<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Casos de prueba: JUnit</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Experto en Desarrollo de Aplicaciones y Servicios con Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Lenguaje Java Avanzado" src="images/baner_j2ee_der.gif" title="Lenguaje Java Avanzado"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Java y Herramientas de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Java y Herramientas de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 4</div>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion04-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Casos de prueba: JUnit</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n+a+JUnit">Introducci&oacute;n a JUnit</a>
</li>
<li>
<a href="#Integraci%C3%B3n+de+JUnit+en+Eclipse">Integraci&oacute;n de JUnit en Eclipse</a>
</li>
<li>
<a href="#Un+ejemplo+sencillo">Un ejemplo sencillo</a>
<ul class="minitoc">
<li>
<a href="#Implementaci%C3%B3n+de+los+casos+de+prueba">Implementaci&oacute;n de los casos de prueba</a>
</li>
<li>
<a href="#Pruebas+con+lanzamiento+de+excepciones">Pruebas con lanzamiento de excepciones</a>
</li>
<li>
<a href="#Ejecuci%C3%B3n+de+pruebas">Ejecuci&oacute;n de pruebas</a>
</li>
<li>
<a href="#Desarrollo+guiado+por+pruebas">Desarrollo guiado por pruebas</a>
</li>
</ul>
</li>
<li>
<a href="#Fixtures">Fixtures</a>
</li>
<li>
<a href="#Objetos+mock">Objetos mock</a>
<ul class="minitoc">
<li>
<a href="#Pruebas+con+base+de+datos">Pruebas con base de datos</a>
</li>
</ul>
</li>
<li>
<a href="#Suites+de+pruebas">Suites de pruebas</a>
</li>
</ul>
</div>


<p>En este tema veremos <strong>JUnit</strong>, una librer&iacute;a desarrollada para poder probar el funcionamiento de las clases y m&eacute;todos que componen nuestra aplicaci&oacute;n, y asegurarnos de que se comportan como deben ante distintas situaciones de entrada.</p>


<a name="N10014"></a><a name="Introducci%C3%B3n+a+JUnit"></a>
<h2 class="underlined_10">Introducci&oacute;n a JUnit</h2>
<div class="section">
<p>Cuando probamos un programa, lo ejecutamos con unos datos de entrada (casos de prueba) para verificar que el funcionamiento cumple los requisitos esperados. Definimos <strong>prueba unitaria</strong> como la prueba de uno de los m&oacute;dulos que componen un programa.</p>
<p>En los &uacute;ltimos a&ntilde;os se han desarrollado un conjunto de herramientas que facilitan la elaboraci&oacute;n de pruebas unitarias en diferentes lenguajes. Dicho conjunto se denomina <em>XUnit</em>. De entre dicho conjunto, <strong>JUnit</strong> es la herramienta utilizada para realizar pruebas unitarias en Java.</p>
<p>El concepto fundamental en estas herramientas es el <strong>caso de prueba</strong> (<em>test case</em>), y la <strong>suite</strong> de prueba (<em>test suite</em>). Los casos de prueba son clases o m&oacute;dulos que disponen de m&eacute;todos para probar los m&eacute;todos de una clase o m&oacute;dulo concreta/o. As&iacute;, para cada clase que quisi&eacute;ramos probar definir&iacute;amos su correspondiente clase de caso de prueba. Mediante las suites podemos organizar los casos de prueba, de forma que cada suite agrupa los casos de prueba de m&oacute;dulos que est&aacute;n funcionalmente relacionados.</p>
<p>Las pruebas que se van construyendo se estructuran as&iacute; en forma de &aacute;rbol, de modo que las hojas son los casos de prueba, y podemos ejecutar cualquier sub&aacute;rbol (suite).</p>
<p>De esta forma, construimos programas que sirven para probar nuestros m&oacute;dulos, y que podremos ejecutar de forma autom&aacute;tica. A medida que la aplicaci&oacute;n vaya avanzando, se dispondr&aacute; de un conjunto importante de casos de prueba, que servir&aacute; para hacer pruebas de regresi&oacute;n. Eso es importante, puesto que cuando cambiamos un m&oacute;dulo que ya ha sido probado, el cambio puede haber afectado a otros m&oacute;dulos, y ser&iacute;a necesario volver a ejecutar las pruebas para verificar que todo sigue funcionando.</p>
<p>Aplicando lo anterior a Java, JUnit es un conjunto de clases opensource que nos permiten probar nuestras aplicaciones Java. Podemos encontrar informaci&oacute;n actualizada de JUnit en <a href="http://www.junit.org">http://www.junit.org</a>
</p>
<p>Encontraremos una distribuci&oacute;n de JUnit, en la que habr&aacute; un fichero JAR, <strong>junit.jar</strong>, que contendr&aacute; las clases que deberemos tener en el CLASSPATH a la hora de implementar y ejecutar los casos de prueba.</p>
</div>


<a name="N1004B"></a><a name="Integraci%C3%B3n+de+JUnit+en+Eclipse"></a>
<h2 class="underlined_10">Integraci&oacute;n de JUnit en Eclipse</h2>
<div class="section">
<p>Eclipse incorpora opciones para poder trabajar con JUnit desde &eacute;l. Antes de nada, debemos tener nuestro proyecto 
	Java ya creado, o bien crearlo nuevo. Una vez hecho esto, deberemos a&ntilde;adir la librer&iacute;a de JUnit al <em>build path</em> 
	del proyecto. La forma m&aacute;s r&aacute;pida de hacer esto es pulsar con el bot&oacute;n derecho sobre nuestro proyecto y seleccionar
	<em>Java Build Path &gt; Add Libraries ...</em>, de forma que nos aparecer&aacute; una ventana en la que podremos elegir la
	librer&iacute;a a a&ntilde;adir, siendo una de ellas JUnit:</p>
<p>
<img alt="A&ntilde;adir la librer&iacute;a JUnit a nuestro proyecto Eclipse" content-width="9cm" height="382" src="imagenes/herramientas/junit_eclipse.gif" width="434"></p>
<p>Una vez seleccionada la librer&iacute;a JUnit, nos aparecer&aacute; otra ventana en la que podremos elegir tanto JUnit 3 como 
	JUnit 4.</p>
<p>
<img alt="Seleccionar versi&oacute;n de la librer&iacute;a" content-width="10cm" height="382" src="imagenes/herramientas/junit_eclipse1.gif" width="493"></p>
<p>La principal diferencia entre ambas versiones es que en JUnit 3 los casos de prueba se crean mediante herencia, y 
	sobrescribiendo una serie de m&eacute;todos, mientras que en la nueva versi&oacute;n se hace mediante anotaciones, por lo que es necesario
	utilizar Java 5 o posterior. Tambi&eacute;n ser&iacute;a posible tener ambas librer&iacute;as en un mismo proyecto.</p>
<p>Vamos a centrarnos en el estudio de JUnit 4. Una vez a&ntilde;adida la librer&iacute;a, ya podemos crear los casos de prueba de 
	nuestro proyecto proyecto. Si creamos un caso de prueba sin tener todav&iacute;a a&ntilde;adida la librer&iacute;a JUnit, veremos que Eclipse
	nos preguntar&aacute; si queremos a&ntilde;adirla y si respondemos afirmativamente la librer&iacute;a se a&ntilde;adir&aacute; autom&aacute;ticamente.</p>
</div>


<a name="N10074"></a><a name="Un+ejemplo+sencillo"></a>
<h2 class="underlined_10">Un ejemplo sencillo</h2>
<div class="section">
<p>Supongamos que tenemos una clase <span class="codefrag">EmpleadoBR</span> con las reglas de negocio
	aplicables a los empleados de una tienda. En esta clase encontramos los siguientes m&eacute;todos
	con sus respectivas especificaciones:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>

<th colspan="1" rowspan="1">M&eacute;todo</th>
<th colspan="1" rowspan="1">Especificaci&oacute;n</th>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">float calculaSalarioBruto(</span>
<br>

<span class="codefrag">&nbsp;&nbsp;TipoEmpleado tipo, </span>
<br>

<span class="codefrag">&nbsp;&nbsp;float ventasMes, </span>
<br>

<span class="codefrag">&nbsp;&nbsp;float horasExtra)</span></td>
<td colspan="1" rowspan="1">El salario base ser&aacute; 1000 euros si el empleado es de tipo <span class="codefrag">TipoEmpleado.vendedor</span>,
y de 1500 euros si es de tipo <span class="codefrag">TipoVendedor.encargado</span>. A esta cantidad se le
sumar&aacute; una prima de 100 euros si <span class="codefrag">ventasMes</span> es mayor o igual que 1000 euros, y de 
200 euros si fuese al menos de 1500 euros. Por &uacute;ltimo, cada hora extra se pagar&aacute; a 20 euros.
Si <span class="codefrag">tipo</span> es <span class="codefrag">null</span>, o <span class="codefrag">ventasMes</span> o <span class="codefrag">horasExtra</span>
toman valores negativos el m&eacute;todo lanzar&aacute; una excepci&oacute;n de tipo <span class="codefrag">BRException</span>.</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">float calculaSalarioNeto(&nbsp;&nbsp;</span>
<br>

<span class="codefrag">&nbsp;&nbsp;float salarioBruto)</span></td>
<td colspan="1" rowspan="1">Si el salario bruto es menor de 1000 euros, no se aplicar&aacute; ninguna retenci&oacute;n. Para salarios
a partir de 1000 euros, y menores de 1500 euros se les aplicar&aacute; un 16%, y a los salarios
a partir de 1500 euros se les aplicar&aacute; un 18%. El m&eacute;todo nos devolver&aacute; 
<span class="codefrag">salarioBruto * (1-retencion)</span>, o <span class="codefrag">BRExcepcion</span> si el salario es menor
que cero.</td>

</tr>

</table>
<p>A partir de dichas especificaciones podemos dise&ntilde;ar un conjunto de casos de prueba
siguiendo m&eacute;todos como el m&eacute;todo de pruebas de particiones, tambi&eacute;n conocido como caja negra. 
Si en lugar de contar con la especificaci&oacute;n, cont&aacute;semos con el c&oacute;digo del m&eacute;todo a probar 
tambi&eacute;n podr&iacute;amos dise&ntilde;ar a partir de &eacute;l un conjunto de casos de prueba utilizando otro tipo
de m&eacute;todos (en este caso se podr&iacute;a utilizar el m&eacute;todo de caja blanca). No vamos a entrar en 
el estudio de estos m&eacute;todos de prueba, sino que nos centraremos en el estudio de la herramienta
JUnit. Por lo tanto, supondremos que despu&eacute;s de aplicar un m&eacute;todo de pruebas hemos obtenido
los siguientes casos de prueba:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>

<th colspan="1" rowspan="1">M&eacute;todo a probar</th>
<th colspan="1" rowspan="1">Entrada</th>
<th colspan="1" rowspan="1">Salida esperada</th>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioNeto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">2000</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">1640</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioNeto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">1500</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">1230</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioNeto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">1499.99</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">1259.9916</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioNeto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">1250</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">1050</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioNeto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">1000</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">840</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioNeto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">999.99</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">999.99</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioNeto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">500</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">500</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioNeto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">0</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">0</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioNeto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">-1</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">BRException</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioBruto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">vendedor</span>, 2000 euros, 8h</td>
<td colspan="1" rowspan="1"><span class="codefrag">1360</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioBruto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">vendedor</span>, 1500 euros, 3h</td>
<td colspan="1" rowspan="1"><span class="codefrag">1260</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioBruto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">vendedor</span>, 1499.99 euros, 0h</td>
<td colspan="1" rowspan="1"><span class="codefrag">1100</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioBruto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">encargado</span>, 1250 euros, 8h</td>
<td colspan="1" rowspan="1"><span class="codefrag">1760</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioBruto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">encargado</span>, 1000 euros, 0h</td>
<td colspan="1" rowspan="1"><span class="codefrag">1600</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioBruto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">encargado</span>, 999.99 euros, 3h</td>
<td colspan="1" rowspan="1"><span class="codefrag">1560</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioBruto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">encargado</span>, 500 euros, 0h</td>
<td colspan="1" rowspan="1"><span class="codefrag">1500</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioBruto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">encargado</span>, 0 euros, 8h</td>
<td colspan="1" rowspan="1"><span class="codefrag">1660</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioBruto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">vendedor</span>, -1 euros, 8h</td>
<td colspan="1" rowspan="1"><span class="codefrag">BRException</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioBruto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">vendedor</span>, 1500 euros, -1h</td>
<td colspan="1" rowspan="1"><span class="codefrag">BRException</span></td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">calculaSalarioBruto</span></td>
<td colspan="1" rowspan="1"><span class="codefrag">null</span>, 1500 euros, 8h</td>
<td colspan="1" rowspan="1"><span class="codefrag">BRException</span></td>

</tr>

</table>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Los casos de prueba se pueden dise&ntilde;ar e implementar antes de haber implementado el m&eacute;todo a probar. De hecho, es
recomendable hacerlo as&iacute;, ya que de esta forma las pruebas comprobar&aacute;n si el m&eacute;todo implementado se ajusta a las especificaciones
que se dieron en un principio. Evidentemente, esto no se podr&aacute; hacer en las pruebas que dise&ntilde;emos siguiendo el m&eacute;todo de caja blanca.
Tambi&eacute;n resulta conveniente que sean personas distintas las que se encargan de las pruebas y de la implementaci&oacute;n del m&eacute;todo, por el
mismo motivo comentado anteriormente.</div>
</div>
<p>A continuaci&oacute;n veremos como implementar estas pruebas utilizando JUnit 4.</p>
<a name="N102A8"></a><a name="Implementaci%C3%B3n+de+los+casos+de+prueba"></a>
<h3 class="underlined_5">Implementaci&oacute;n de los casos de prueba</h3>
<p>Vamos a utilizar JUnit para probar los m&eacute;todos anteriores. Para ello deberemos crear una serie de clases en las que implementaremos
		las pruebas dise&ntilde;adas. Esta implementaci&oacute;n consistir&aacute; b&aacute;sicamente en invocar el m&eacute;todo que est&aacute; siendo probado pas&aacute;ndole los par&aacute;metros
		de entrada establecidos para cada caso de prueba, y comprobar si la salida real coincide con la salida esperada. Esto en principio lo 
		podr&iacute;amos hacer sin necesidad de utilizar JUnit, pero el utilizar esta herramienta nos va a ser de gran utilidad ya que nos proporciona
		un <em>framework</em> que nos obligar&aacute; a implementar las pruebas en un formato est&aacute;ndar que podr&aacute; ser reutilizable y entendible por
		cualquiera que conozca la librer&iacute;a. El aplicar este <em>framework</em> tambi&eacute;n nos ayudar&aacute; a tener una bater&iacute;a de pruebas ordenada, 
		que pueda ser ejecutada f&aacute;cilmente y que nos muestre los resultados de forma clara mediante una interfaz gr&aacute;fica que proporciona la
		herramienta. Esto nos ayudar&aacute; a realizar pruebas de regresi&oacute;n, es decir, ejecutar la misma bater&iacute;a de pruebas en varios momentos del 
		desarollo, para as&iacute; asegurarnos de que lo que nos hab&iacute;a funcionado antes siga funcionando bien.</p>
<p>Para implementar las pruebas en JUnit utilizaremos dos elementos b&aacute;sicos:</p>
<ul>
		
<li>Por un lado, marcaremos con la anotaci&oacute;n <span class="codefrag">@Test</span> los m&eacute;todos que queramos que JUnit ejecute. Estos ser&aacute;n los 
		m&eacute;todos en los que implementemos nuestras pruebas. En estos m&eacute;todos llamaremos al m&eacute;todo probado y comprobaremos si el resultado
		obtenido es igual al esperado.</li>
		
<li>Para comprobar si el resultado obtenido coincide con el esperado utilizaremos los m&eacute;todos <span class="codefrag">assert</span> de la librer&iacute;a
		JUnit. Estos son una serie de m&eacute;todos est&aacute;ticos de la clase <span class="codefrag">Assert</span> (para simplificar el c&oacute;digo podr&iacute;amos hacer un <em>
		import</em> est&aacute;tico de dicha clase), todos ellos con el prefijo <span class="codefrag">assert-</span>. Existen multitud de variantes de estos 
		m&eacute;todos, seg&uacute;n el tipo de datos que estemos comprobando (<span class="codefrag">assertTrue</span>, <span class="codefrag">assertFalse</span>, <span class="codefrag">assertEquals</span>, 
		<span class="codefrag">assertNull</span>, etc). Las llamadas a estos m&eacute;todos servir&aacute;n para que JUnit sepa qu&eacute; pruebas han tenido &eacute;xito y cu&aacute;les no.</li>
		
</ul>
<p>Cuando ejecutemos nuestras pruebas con JUnit, se nos mostrar&aacute; un informe con el n&uacute;mero de pruebas &eacute;xitosas y fallidas, y un detalle
		desglosado por casos de prueba. Para los casos de prueba que hayan fallado, nos indicar&aacute; adem&aacute;s el valor que se ha obtenido y el
		que se esperaba.</p>
<p>Adem&aacute;s de estos elementos b&aacute;sicos anteriores, a la hora de implementar las pruebas con JUnit deberemos seguir una serie de buenas
		pr&aacute;cticas que se detallan a continuaci&oacute;n:</p>
<ul>
		
<li>La clase de pruebas se llamar&aacute; igual que la clase a probar, pero con el sufijo <span class="codefrag">-Test</span>. Por ejemplo, si queremos
		probar la clase <span class="codefrag">MiClase</span>, la clase de pruebas se llamar&aacute; <span class="codefrag">MiClaseTest</span>.</li>
		
<li>La clase de pruebas se ubicar&aacute; en el mismo paquete en el que estaba la clase probada. Si <span class="codefrag">MiClase</span> est&aacute; en el paquete
		<span class="codefrag">es.ua.jtech.lja</span>, <span class="codefrag">MiClaseTest</span> pertenecer&aacute; e ese mismo paquete. De esta forma nos aseguramos tener acceso a
		todos los miembros de tipo protegido y paquete de la clase a probar.</li>
		
<li>Mezclar clases reales de la aplicaci&oacute;n con clases que s&oacute;lo nos servir&aacute;n para realizar las pruebas durante el desarrollo no es
		nada recomendable, pero no queremos renunciar a poner la clase de pruebas en el mismo paquete que la clase probada. Para solucionar
		este problema lo que se har&aacute; es crear las clases de prueba en un directorio de fuentes diferente. Si los fuentes de la aplicaci&oacute;n
		se encuentran normalmente en un directorio llamado <span class="codefrag">src</span>, los fuentes de pruebas ir&iacute;an en un directorio llamado 
		<span class="codefrag">test</span>. </li>
		
<li>Los m&eacute;todos de prueba (los que est&aacute;n anotados con <span class="codefrag">@Test</span>), tendr&aacute;n como nombre el mismo nombre que el del m&eacute;todo
		probado, pero con prefijo <span class="codefrag">test-</span>. Por ejemplo, para probar <span class="codefrag">miMetodo</span> tendr&iacute;amos un m&eacute;todo de prueba llamado
		<span class="codefrag">testMiMetodo</span>. </li>
		
<li>Aunque dentro de un m&eacute;todo de prueba podemos poner tantos <span class="codefrag">assert</span> como queramos, es recomendable crear un m&eacute;todo
		de prueba diferente por cada caso de prueba que tengamos. Por ejemplo, si para <span class="codefrag">miMetodo</span> hemos dise&ntilde;ado tres casos
		de prueba, podr&iacute;amos tener tres m&eacute;todos de prueba distintos: <span class="codefrag">testMiMetodo1</span>, <span class="codefrag">testMiMetodo2</span>, y 
		<span class="codefrag">testMiMetodo3</span>. De esta forma, cuando se presenten los resultados de las pruebas podremos ver exactamente qu&eacute; caso de
		prueba es el que ha fallado.</li>
		
</ul>
<p>Vamos a ver ahora c&oacute;mo hacer esto desde Eclipse. Lo primero que deberemos hacer es crear un nuevo directorio de fuentes en nuestro
		proyecto, para tener separados en &eacute;l los fuentes de prueba. Por ejemplo, podemos llamar a este directorio <span class="codefrag">test</span>. Una vez hayamos hecho
		esto, pincharemos con el bot&oacute;n derecho sobre la clase que queramos probar y seleccionaremos <em>New &gt; JUnit Test Case</em>. Nos aparecer&aacute;
		un asitente para crear nuestro caso de prueba JUnit, en el que muchos campos estar&aacute;n ya rellenos:</p>
<p>
<img alt="Asistente de JUnit" content-width="10cm" height="561" src="imagenes/herramientas/junit_asistente.gif" width="470"></p>
<p>Como podemos observar, tanto el nombre de la nueva clase como el paquete ya lo indica correctamente, pero deberemos cambiar el directorio
		de fuentes a <span class="codefrag">test</span> en lugar de <span class="codefrag">src</span>, y la liber&iacute;a utilizada ser&aacute; JUnit 4 en lugar de JUnit 3. Una vez hemos introducido
		esta informaci&oacute;n pulsaremos sobre <em>Next</em>. Veremos una pantalla en la que podremos seleccionar los m&eacute;todos que queremos probar:</p>
<p>
<img alt="Selecci&oacute;n de m&eacute;todos a probar" content-width="10cm" height="561" src="imagenes/herramientas/junit_metodos.gif" width="470"></p>
<p>Una vez seleccionados los m&eacute;todos que nos interesen podremos pulsar el bot&oacute;n <span class="codefrag">Finish</span> y nos crear&aacute; el esqueleto de nuestra
		clase JUnit. En &eacute;l deberemos rellenar los m&eacute;todos de pruebas, o crear nuevos m&eacute;todos si lo consideramos oportuno. Por ejemplo, la implementaci&oacute;n
		de alguno de los casos de prueba dise&ntilde;ados anteriormente podr&iacute;a quedar como se muestra a continuaci&oacute;n:</p>
<pre class="brush:java;">public class EmpleadoBRTest {
  @Test
  public void testCalculaSalarioBruto1() {
    float resultadoReal = EmpleadoBR.calculaSalarioBruto(
                           TipoEmpleado.vendedor, 2000.0f, 8.0f);
    float resultadoEsperado = 1360.0f;
    assertEquals(resultadoEsperado, resultadoReal, 0.01);
  }
	
  @Test
  public void testCalculaSalarioBruto2() {
    float resultadoReal = EmpleadoBR.calculaSalarioBruto(
                           TipoEmpleado.vendedor, 1500.0f, 3.0f);
    float resultadoEsperado = 1260.0f;
    assertEquals(resultadoEsperado, resultadoReal, 0.01);
  }

  @Test
  public void testCalculaSalarioNeto1() {
    float resultadoReal = EmpleadoBR.calculaSalarioNeto(2000.0f);
    float resultadoEsperado = 1640.0f;
    assertEquals(resultadoEsperado, resultadoReal, 0.01);
  }

  @Test
  public void testCalculaSalarioNeto2() {
    float resultadoReal = EmpleadoBR.calculaSalarioNeto(1500.0f);
    float resultadoEsperado = 1230.0f;
    assertEquals(resultadoEsperado, resultadoReal, 0.01);
  }
}</pre>
<p>En general la construcci&oacute;n de pruebas sigue siempre estos mismos patrones: llamar al m&eacute;todo probado y comprobar si la salida real 
		coincide con la esperada utilizando los m&eacute;todos <span class="codefrag">assert</span>.</p>
<a name="N10360"></a><a name="Pruebas+con+lanzamiento+de+excepciones"></a>
<h3 class="underlined_5">Pruebas con lanzamiento de excepciones</h3>
<p>En algunos casos de prueba, lo que se espera como salida no es que el m&eacute;todo nos devuelva un determinado valor, sino que se produzca una
		excepci&oacute;n. Para comprobar con JUnit que la excepci&oacute;n se ha lanzado podemos optar por dos m&eacute;todos diferentes. El m&aacute;s sencillo de ellos es
		indicar la excepci&oacute;n esperada en la anotaci&oacute;n <span class="codefrag">@Test</span>:</p>
<pre class="brush:java;">@Test(expected=BRException.class)
public void testCalculaSalarioNeto9() {
  EmpleadoBR.calculaSalarioNeto(-1.0f);
}</pre>
<p>Otra posibilidad es utilizar el m&eacute;todo <span class="codefrag">fail</span> de JUnit, que nos permite indicar que hay un fallo en la prueba. En este caso
		lo que har&iacute;amos ser&iacute;a llamar al m&eacute;todo probado dentro de un bloque <span class="codefrag">try-catch</span> que capture la excepci&oacute;n esperada. Si al 
		llamar al m&eacute;todo no saltase la excepci&oacute;n, llamar&iacute;amos a <span class="codefrag">fail</span> para indicar que no se ha comportado como deber&iacute;a seg&uacute;n
		su especificaci&oacute;n.</p>
<pre class="brush:java;">@Test
public void testCalculaSalarioNeto9() {
  try {
    EmpleadoBR.calculaSalarioNeto(-1.0f);
    fail("Se esperaba excepcion BRException");
  } catch(BRException e) {}
}</pre>
<p>Cuando el m&eacute;todo que estemos probando pueda lanzar una excepci&oacute;n de tipo <em>checked</em> que debamos capturar de forma obligatoria
		en JUnit, tambi&eacute;n podemos utilizar <span class="codefrag">fail</span> dentro del bloque <span class="codefrag">catch</span> para notificar del fallo en caso de que se
		lance la excepci&oacute;n de forma no esperada:</p>
<pre class="brush:java;">public void testCalculaSalarioBruto1() {
  float resultadoReal;
  try {
    resultadoReal = EmpleadoBR.calculaSalarioBruto(
                           TipoEmpleado.vendedor, 2000.0f, 8.0f);
    float resultadoEsperado = 1360.0f;
    assertEquals(resultadoEsperado, resultadoReal, 0.01);
  } catch (BRException e) {
    fail("Lanzada excepcion no esperada BRException");
  }
}</pre>
<p>Si el m&eacute;todo probado lanzase una excepci&oacute;n de tipo <em>unchecked</em> no esperada, y no la captur&aacute;semos, JUnit en lugar de marcarlo
		como fallo lo marcar&aacute; como error.</p>
<a name="N1039A"></a><a name="Ejecuci%C3%B3n+de+pruebas"></a>
<h3 class="underlined_5">Ejecuci&oacute;n de pruebas</h3>
<p>Cuando tengamos definida la clase de prueba que queramos ejecutar, y la clase a probar, pulsamos con el bot&oacute;n derecho sobre la clase de prueba 
		y selecionamos <em>Run As &gt; JUnit test</em>. Nos aparecer&aacute; la ventana de JUnit en Eclipse con los resultados:</p>
<p>
<img alt="Resultados de las pruebas" content-width="8cm" height="448" src="imagenes/herramientas/junit_resultados.gif" width="417"></p>
<p>Arriba tendremos una barra roja o verde (seg&uacute;n si ha habido fallos o no), y el n&uacute;mero de pruebas fallidas, y de errores 
		producidos durante la ejecuci&oacute;n de las pruebas. En la parte central vemos la jerarqu&iacute;a de todas las pruebas ejecutadas, con un icono
		que nos indicar&aacute; si ha tenido &eacute;xito o no, y si seleccionamos alguna de las fallidas abajo vemos los detalles del error (resultado
		obtenido, resultado esperado, y l&iacute;nea de c&oacute;digo en la que se ha producido). Haciendo doble click en los errores iremos a la l&iacute;nea de 
		c&oacute;digo que los provoc&oacute;. Se puede relanzar un test pulsando <em>Ctrl + F11</em>, o pulsando sobre el bot&oacute;n "<em>play</em>".</p>
<p>
<strong>Ejecutar pruebas fuera de Eclipse</strong>
</p>
<p>Para ejecutar pruebas por s&iacute; solas, debemos utilizar un ejecutor de pruebas (<em>test runner</em>). JUnit proporciona algunos de 
		ellos, como <span class="codefrag">junit.textui.TestRunner</span> (para mostrar los resultados en modo texto), o <span class="codefrag">junit.swingui.TestRunner</span> 
		(para mostrar los resultados gr&aacute;ficamente). Para ejecutarlos podemos incluir el jar <em>junit.jar</em> en el CLASSPATH al ejecutar:</p>
<pre class="code">java -cp ./junit.jar junit.swingui.TestRunner</pre>
<p>Nos aparecer&iacute;a una ventana donde indicamos el nombre del caso de prueba que queremos ejecutar (o lo elegimos de una lista), y 
		luego pulsando <em>Run</em> nos mostrar&aacute; los resultados. La barra verde aparece si las pruebas han ido bien, y si no aparecer&aacute; en rojo. En la pesta&ntilde;a <em>Failures </em>podemos ver qu&eacute; pruebas 
		han fallado, y en <em>Test Hierarchy </em>podemos ver todas las pruebas que se han realizado, y los resultados para cada una. En el cuadro 
		inferior nos aparecen los errores que se han producido en las pruebas err&oacute;neas.</p>
<p>Para ejecutar el <em>TestRunner</em> u otro ejecutor de pruebas, podemos tambi&eacute;n definirnos un m&eacute;todo <span class="codefrag">main</span> en nuestra clase 
		de prueba que lance el ejecutor, en nuestro caso:</p>
<pre class="brush:java;">public static void main (String[] args)
{
	String[] nombresTest = {EmpleadoBRTest.class.getName()};
	junit.swingui.TestRunner.main(nombresTest);
}</pre>
<p>Vemos que al <span class="codefrag">main</span> del <em>TestRunner</em> se le pueden pasar como par&aacute;metros los nombres de las clases de prueba que 
		queremos probar.</p>
<a name="N103F2"></a><a name="Desarrollo+guiado+por+pruebas"></a>
<h3 class="underlined_5">Desarrollo guiado por pruebas</h3>
<p>Anteriormente se ha comentado que puede resultar recomendable implementar las pruebas antes que el m&eacute;todo a probar. Existe una metodolog&iacute;a de 
desarrollo denominada desarrollo guiado por pruebas (<em>Test Driven Development, TDD</em>) que se basa precisamente en implementar primero las
pruebas y a partir de ellas implementar las funcionalidades de nuestra aplicaci&oacute;n. Esta metodolog&iacute;a consiste en los siguientes pasos:</p>
<ul>

<li>Seleccionar una funcionalidad de la aplicaci&oacute;n a implementar.</li>

<li>Dise&ntilde;ar e implementar una serie de casos de prueba a partir de la especificaci&oacute;n de dicha funcionalidad. Evidentemente, en un principio 
la prueba ni siquiera compilar&aacute;, ya que no existir&aacute; ni la clase ni el m&eacute;todo a probar. Con Eclipse podemos hacer que genere autom&aacute;ticamente
los componentes que necesitamos. Podemos ver que al utilizar una clase que no existe en Eclipse nos mostrar&aacute; un icono de error en la 
l&iacute;nea correspondiente. Pinchando sobre dicho icono podremos hacer que se cree autom&aacute;ticamente la clase necesaria:

<img alt="Crear una clase a partir de la prueba" content-width="11cm" height="281" src="imagenes/herramientas/junit_tdd.gif" width="541">

</li>

<li>Una vez compile, se deber&aacute; ejecutar la prueba para comprobar que falla. De esta forma nos aseguramos de que realmente las pruebas est&aacute;n
comprobando algo.</li>

<li>El siguiente paso consiste en hacer el m&iacute;nimo c&oacute;digo necesario para que se pasen los <em>tests</em>. Aqu&iacute; se deber&aacute; implementar el c&oacute;digo
m&aacute;s sencillo posible, y no hacer nada que no sea necesario para pasar las pruebas, aunque nosotros veamos que pudiese ser conveniente. Si
creemos que se deber&iacute;a a&ntilde;adir algo, la forma de proceder ser&iacute;a anotar la mejora, para m&aacute;s adelante a&ntilde;adirla a la especificaci&oacute;n, y cuando
las pruebas reflejen esa mejora se implementar&aacute;, pero no antes. De esta forma nos aseguramos de que siempre todas las funcionalidades implementadas
est&aacute;n siendo verificadas por alguna de las pruebas.</li>

<li>Una vez las pruebas funcionan, refactorizaremos el c&oacute;digo escrito para conseguir un c&oacute;digo m&aacute;s limpio (por ejemplo para eliminar 
segmentos de c&oacute;digo duplicados). Volviendo a ejecutar las pruebas escritas podremos comprobar que la refactorizaci&oacute;n no ha hecho que nada
deje de funcionar.</li>

<li>Por &uacute;ltimo, si todav&iacute;a nos quedan funcionalidades por implementar, repetiremos el proceso seleccionando una nueva funcionalidad.</li>

</ul>
<p>Estas pruebas tambi&eacute;n se denominan pruebas <em>red-green-refactor</em>, debido a que primero deberemos comprobar que las pruebas fallan
(luz roja), y de esta forma tener confianza en que nuestras pruebas est&aacute;n comprobando algo. Despu&eacute;s implementamos el c&oacute;digo para conseguir
que el test funcione (luz verde), y por &uacute;ltimo refactorizamos el c&oacute;digo.</p>
<p>Una de las ventajas de esta tecnolog&iacute;a es que se consigue un c&oacute;digo de gran calidad, en el que vamos a tener una gran confianza, ya que va
a estar probado desde el primer momento. Adem&aacute;s, nos asegura que las pruebas verifican todos los requerimientos de la aplicaci&oacute;n. Al 
eliminar los errores de forma temprana, con esta metodolog&iacute;a se evita tener que depurar un c&oacute;digo m&aacute;s complejo.</p>
</div>


<a name="N10428"></a><a name="Fixtures"></a>
<h2 class="underlined_10">Fixtures</h2>
<div class="section">
<p>Es probable que en varias de las pruebas implementadas se utilicen los mismos datos de entrada o de salida esperada, o
		que se requieran los mismos recursos. Para evitar tener c&oacute;digo repetido en los diferentes m&eacute;todos de <em>test</em>, podemos
		utilizar los llamados <em>fixtures</em>, que son elementos fijos que se crear&aacute;n antes de ejecutar cada prueba. Para inicializar
		estos elementos fijos utilizaremos m&eacute;todos marcados con las siguientes anotaciones:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
		
<tr>
		
<th colspan="1" rowspan="1"><em>Anotaci&oacute;n</em></th>
		<th colspan="1" rowspan="1"><em>Comportamiento</em></th>
		
</tr>
		
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">@Before</span></td>
		<td colspan="1" rowspan="1">El m&eacute;todo se ejecutar&aacute; antes de cada prueba (antes de ejecutar cada uno de los m&eacute;todos marcados con <span class="codefrag">@Test</span>). 
		Ser&aacute; &uacute;til para inicializar los datos de entrada y de salida esperada que se vayan a utilizar en las pruebas.</td>
		
</tr>
		
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">@After</span></td>
		<td colspan="1" rowspan="1">Se ejecuta despu&eacute;s de cada <em>test</em>. Nos servir&aacute; para liberar recursos que se hubiesen inicializado en el m&eacute;todo marcado
		con <span class="codefrag">@Before</span>.</td>
		
</tr>
		
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">@BeforeClass</span></td>
		<td colspan="1" rowspan="1">Se ejecuta una sola vez antes de ejecutar todos los <em>tests</em> de la clase. Se utilizar&aacute;n para crear estructuras
		de datos y componentes que vayan a ser necesarios para todas las pruebas. Los m&eacute;todos marcados con esta anotaci&oacute;n deben ser est&aacute;ticos.</td>
		
</tr>
		
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">@AfterClass</span></td>
		<td colspan="1" rowspan="1">Se ejecuta una &uacute;nica vez despu&eacute;s de todos los <em>tests</em> de la clase. Nos servir&aacute; para liberar los recursos inicializados
		en el m&eacute;todo marcado con <span class="codefrag">@BeforeClass</span>, y al igual que este &uacute;ltimo, s&oacute;lo se puede aplicar a m&eacute;todos est&aacute;ticos.</td>
		
</tr>
		
</table>
<p>Imaginemos que tenemos una clase <span class="codefrag">ColaMensajes</span> a la que se pueden a&ntilde;adir una serie de mensajes de texto hasta llegar
		a un l&iacute;mite de capacidad. Cuando se rebase dicho l&iacute;mite, el mensaje m&aacute;s antiguo ser&aacute; eliminado. Para probar los m&eacute;todos de esta clase
		en muchos casos nos interesar&aacute; tener como entrada una cola llena. Para evitar repetir el c&oacute;digo en el que se inicializa dicha cola, 
		podemos hacer uso de <em>fixtures</em>:</p>
<pre class="brush:java;">public class ColaMensajesTest {

  ColaMensajes colaLlena3;
	
  @Before
  public void setUp() throws Exception {
    colaLlena3 = new ColaMensajes(3);
    colaLlena3.insertarMensaje("1");
    colaLlena3.insertarMensaje("2");
    colaLlena3.insertarMensaje("3");
  }

  @Test
  public void testInsertarMensaje() {
    List&lt;String&gt; listaEsperada = new ArrayList&lt;String&gt;();
    listaEsperada.add("2");
    listaEsperada.add("3");
    listaEsperada.add("4");
		
    colaLlena3.insertarMensaje("4");
    assertEquals(listaEsperada, colaLlena3.obtenerMensajes());
  }

  @Test
  public void testNumMensajes() {
    assertEquals(3, colaLlena3.numMensajes());
  }

  @Test
  public void testExtraerMensaje() {
    assertEquals("1", colaLlena3.extraerMensaje());
  }
}</pre>
</div>

	
<a name="N104A2"></a><a name="Objetos+mock"></a>
<h2 class="underlined_10">Objetos mock</h2>
<div class="section">
<p>Hasta ahora hemos visto ejemplos muy sencillos, en los que el m&eacute;todo a probar recibe todos los datos de entrada necesarios mediante par&aacute;metros.
	Sin embargo, en una aplicaci&oacute;n real en la mayor&iacute;a de los casos el comportamiento de los m&eacute;todos no depender&aacute; &uacute;nicamente de los par&aacute;metros
	de entrada, sino que tambi&eacute;n depender&aacute; de otros datos, como por ejemplo datos almacenados en una base de datos, o datos a los que se
	accede a trav&eacute;s de la red. Estos datos tambi&eacute;n son una entrada del m&eacute;todo de probar, pues el resultado del mismo depende de ellos, por lo 
	que en nuestras pruebas de JUnit deber&iacute;amos ser capaces de fijarlos para poder predecir de forma determinista el resultado del
	m&eacute;todo a probar.</p>
<p>Sin embargo, dado que muchas veces dependen de factores externos al c&oacute;digo de nuestra aplicaci&oacute;n, es imposible establecer su valor
	en el c&oacute;digo de JUnit. Por ejemplo, imaginemos que el m&eacute;todo <span class="codefrag">calculaSalarioNeto</span> visto como ejemplo anteriormente, dado que
	los tramos de las retenciones var&iacute;an cada a&ntilde;o, en lugar de utilizar unos valores fijos se conecta a una aplicaci&oacute;n de la Agencia Tributaria
	a trav&eacute;s de Internet para obtener los tramos actuales. En ese caso el resultado que devolver&aacute; depender&aacute; de la informaci&oacute;n almacenada en
	un servidor remoto que no controlamos. Es m&aacute;s, imaginemos que la especificaci&oacute;n del m&eacute;todo nos dice que nos devolver&aacute; <span class="codefrag">BRException</span>
	si no puede conectar al servidor para obtener la informaci&oacute;n. Deber&iacute;amos implementar dicho caso de prueba, pero en principio nos es
	imposible especificar como entrada en JUnit que se produzca un fallo en la red. Tampoco nos vale cortar la red manualmente, ya que nos
	interesa tener una bater&iacute;a de pruebas automatizadas.</p>
<p>La soluci&oacute;n para este problema es utilizar objetos <em>mock</em>. &Eacute;stos son objetos "impostores" que implementaremos nosotros y
	que se har&aacute;n pasar por componentes utilizados en nuestra aplicaci&oacute;n, permiti&eacute;ndonos establecer su comportamiento seg&uacute;n nuestros
	intereses. Por ejemplo, supongamos que el m&eacute;todo <span class="codefrag">calculaSalarioNeto</span> est&aacute; accediendo al servidor remoto mediante un
	objeto <span class="codefrag">ProxyAeat</span> que es quien se encarga de conectarse al servidor remoto y obtener la informaci&oacute;n necesaria de &eacute;l. Podr&iacute;amos
	crearnos un objeto <span class="codefrag">MockProxyAeat</span>, que se hiciese pasar por el objeto original, pero que nos permitiese establecer
	el resultado que queremos que nos devuelva, e incluso si queremos que produzca alguna excepci&oacute;n. A continuaci&oacute;n mostramos el c&oacute;digo
	que tendr&iacute;a el m&eacute;todo a probar dentro de la clase <span class="codefrag">EmpleadoBR</span>:</p>
<pre class="brush:java;">public float calculaSalarioNeto(float salarioBruto) {
  float retencion = 0.0f;
		
  if(salarioBruto &lt; 0) {
    throw new BRException("El salario bruto debe ser positivo");
  }
		
  ProxyAeat proxy = getProxyAeat();
  List&lt;TramoRetencion&gt; tramos;
  try {
    tramos = proxy.getTramosRetencion();
  } catch (IOException e) {
    throw new BRException(
                  "Error al conectar al servidor de la AEAT", e);
  } 
		
  for(TramoRetencion tr: tramos) {
    if(salarioBruto &lt; tr.getLimiteSalario()) {
      retencion = tr.getRetencion();
      break;
    }
  }
		
  return salarioBruto * (1 - retencion); 
}

ProxyAeat getProxyAeat() {
  ProxyAeat proxy = new ProxyAeat();
  return proxy;
}</pre>
<p>Ahora necesitamos crear un objeto <span class="codefrag">MockProxyAeat</span> que pueda hacerse pasar por el objeto original. Para ello haremos
	que <span class="codefrag">MockProxyAeat</span> herede de <span class="codefrag">ProxyAeat</span>, sobrescribiendo los m&eacute;todos para los que queramos cambiar el
	comportamiento, y a&ntilde;adiendo los constructores y m&eacute;todos auxiliares que necesitemos. Debido al polimorfismo, este nuevo objeto 
	podr&aacute; utilizarse en todos los lugares en los que se utilizaba el objeto original:</p>
<pre class="brush:java;">public class MockProxyAeat extends ProxyAeat {

  boolean lanzarExcepcion;
	
  public MockProxyAeat(boolean lanzarExcepcion) {
    this.lanzarExcepcion = lanzarExcepcion;		
  }
	
  @Override
  public List&lt;TramoRetencion&gt; getTramosRetencion() 
                                             throws IOException {
    if(lanzarExcepcion) {
      throw new IOException("Error al conectar al servidor");
    }

    List&lt;TramoRetencion&gt; tramos = new ArrayList&lt;TramoRetencion&gt;();
    tramos.add(new TramoRetencion(1000.0f, 0.0f));
    tramos.add(new TramoRetencion(1500.0f, 0.16f));
    tramos.add(new TramoRetencion(Float.POSITIVE_INFINITY, 0.18f));
		
    return tramos;
  }
}</pre>
<p>Ahora debemos conseguir que dentro del m&eacute;todo a probar se utilice el objeto <em>mock</em> en lugar del aut&eacute;ntico, pero deber&iacute;amos
	hacerlo sin modificar ni el m&eacute;todo ni la clase a probar. Podremos hacer esto de forma sencilla si hemos utilizado m&eacute;todos de 
	<em>factor&iacute;a</em> para tener acceso a estos componentes. Podemos crear una subclase de <span class="codefrag">EmpleadoBR</span>
	en la que se sobrescriba el m&eacute;todo de factor&iacute;a que se encarga de obtener el objeto <span class="codefrag">ProxyAeat</span>, para que en su lugar nos
	instancie el <em>mock</em>:</p>
<pre class="brush:java;">class TestableEmpleadoBR extends EmpleadoBR {

  ProxyAeat proxy;
	
  public void setProxyAeat(ProxyAeat proxy) {
    this.proxy = proxy;
  }
	
  @Override
  ProxyAeat getProxyAeat() {
    return proxy;
  }
}</pre>
<p>Si nuestra clase a probar no tuviese un m&eacute;todo de factor&iacute;a, siempre podr&iacute;amos refactorizarla para extraer la creaci&oacute;n del
	componente que queramos sustituir a un m&eacute;todo independiente y as&iacute; permitir introducir el <em>mock</em> de forma limpia.</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Tanto los objetos <em>mock</em> como cualquier clase auxiliar que hayamos creado para las pruebas, deber&aacute;
	estar contenida en el directorio de c&oacute;digo de pruebas (<span class="codefrag">test</span>). En el directorio de c&oacute;digo de la aplicaci&oacute;n (<span class="codefrag">src</span>)
	s&oacute;lo deber&aacute;n quedar los componentes que sean necesarios para que la aplicaci&oacute;n funcione cuando sea puesta en producci&oacute;n.</div>
</div>
<p>El c&oacute;digo de JUnit para probar nuestro m&eacute;todo podr&iacute;a quedar como se muestra a continuaci&oacute;n:</p>
<pre class="brush:java;">TestableEmpleadoBR ebr;
TestableEmpleadoBR ebrFail;
	
@Before
public void setUpClass() {
  ebr = new TestableEmpleadoBR();
  ebr.setProxyAeat(new MockProxyAeat(false));

  ebrFail = new TestableEmpleadoBR();
  ebrFail.setProxyAeat(new MockProxyAeat(true));
}
	
@Test
public void testCalculaSalarioNeto1() {
  float resultadoReal = ebr.calculaSalarioNeto(2000.0f);
  float resultadoEsperado = 1640.0f;
  assertEquals(resultadoEsperado, resultadoReal, 0.01);
}
	
@Test(expected=BRException.class)
public void testCalculaSalarioNeto10() {
  ebrFail.calculaSalarioNeto(1000.0f);
}</pre>
<p>Podremos utilizar <em>mocks</em> para cualquier otro tipo de componente del que dependa nuestro m&eacute;todo. Por ejemplo, si en nuestro
	m&eacute;todo se utiliza un generador de n&uacute;meros aleatorios, y el comportamiento var&iacute;a seg&uacute;n el n&uacute;mero obtenido, podr&iacute;amos sustituir dicho
	generador por un <em>mock</em>, para as&iacute; poder predecir en nuestro c&oacute;digo el resultado que dar&aacute;. De especial inter&eacute;s son las pruebas
	de m&eacute;todos que dependen de los datos almacenados en una base de datos, ya que son los que nos encontraremos con m&aacute;s frecuencia, y en los
	que los <em>mocks</em> tambi&eacute;n nos pueden resultar de ayuda. Por este motivo, pasamos a tratarlos de forma especial a continuaci&oacute;n.</p>
<a name="N1051A"></a><a name="Pruebas+con+base+de+datos"></a>
<h3 class="underlined_5">Pruebas con base de datos</h3>
<p>Normalmente en nuestra aplicaci&oacute;n tendremos una serie de objetos que se encargan del acceso a datos (<em>Data Access Objects</em>, DAO).
	El resto de componentes de la aplicaci&oacute;n, como pueden ser nuestros componentes de negocio, utilizar&aacute;n los DAO para acceder a los datos. 
	Por lo tanto, dichos componentes de negocio podr&iacute;an ser probados sustituyendo los DAO por objetos <em>mock</em> en los que podamos
	establecer de forma sencilla el estado de la base de datos que queremos simular en las pruebas.</p>
<p>Supongamos que tenemos una clase <span class="codefrag">EmpleadoBO</span> que contiene un m&eacute;todo <span class="codefrag">getSalarioBruto(int idEmpleado)</span>. Dicho 
	m&eacute;todo toma como entrada el identificador de un empleado en la base de datos, y nos devolver&aacute; su salario bruto. En caso de que el
	empleado no exista en la base de datos, lanzar&aacute; una excepci&oacute;n de tipo <span class="codefrag">BOException</span>. Lo mismo ocurrir&aacute; si no puede 
	acceder a la base de datos. La implementaci&oacute;n ser&aacute; como se muestra a continuaci&oacute;n:</p>
<pre class="brush:java;">public class EmpleadoBO {
  public float getSalarioBruto(int idEmpleado) throws BOException {

    IEmpleadoDAO edao = getEmpleadoDAO();
    EmpleadoBR ebr = new EmpleadoBR();
		
    try {
      EmpleadoTO empleado = edao.getEmpleado(idEmpleado);
      if(empleado==null) {
        throw new BOException("El usuario no existe");
      }
			
      return ebr.calculaSalarioBruto(empleado.getTipo(), 
              empleado.getVentasMes(), empleado.getHorasExtra());
    } catch (DAOException e) {
      throw new BOException("Error al obtener el salario bruto", 
                            e);
    } catch(BRException e) {
      throw new BOException("Error al calcular el salario bruto", 
                            e);			
    }
  }

  IEmpleadoDAO getEmpleadoDAO() {
    IEmpleadoDAO edao = new JDBCEmpleadoDAO();
    return edao;
  }
}</pre>
<p>En este caso ser&aacute; sencillo crear un <em>mock</em> de nuestro DAO de empleados y sustuir el DAO original por el impostor. Nos ser&aacute; de ayuda
	el haber definido una interfaz para el DAO (<span class="codefrag">IEmpleadoDAO</span>), ya que de esta forma implementaremos el <em>mock</em> como otra versi&oacute;n 
	del DAO que implemente la misma interfaz que la original:</p>
<pre class="brush:java;">public class MockEmpleadoDAO implements IEmpleadoDAO {

  List&lt;EmpleadoTO&gt; listaEmpleados;
  boolean falloConexion;
	
  public MockEmpleadoDAO(boolean falloConexion) {
    listaEmpleados = new ArrayList&lt;EmpleadoTO&gt;();
    this.falloConexion = falloConexion;
  }
	
  private void compruebaConexion() throws DAOException {
    if(falloConexion) {
      throw new DAOException("Fallo al conectar a la BD");
    }		
  }
	
  public void addEmpleado(EmpleadoTO empleado) 
                                            throws DAOException {
    this.compruebaConexion();
    if(this.getEmpleado(empleado.getId()) == null) {
      listaEmpleados.add(empleado);
    } else {
      throw new DAOException("El empleado la existe en la BD");
    }
  }

  public void delEmpleado(int idEmpleado) throws DAOException {
    this.compruebaConexion();
    EmpleadoTO empleado = this.getEmpleado(idEmpleado); 
    if(empleado != null) {
      listaEmpleados.remove(empleado);
    } else {
      throw new DAOException("El empleado no existe en la BD");
    }
  }

  public EmpleadoTO getEmpleado(int idEmpleado) 
                                            throws DAOException {
    this.compruebaConexion();
    for(EmpleadoTO empleado: listaEmpleados) {
      if(empleado.getId() == idEmpleado) {
        return empleado;
      }
    }
		
    return null;
  }

  public List&lt;EmpleadoTO&gt; getEmpleados() throws DAOException {
    this.compruebaConexion();
    return listaEmpleados;
  }
}</pre>
<p>De esta forma podr&iacute;amos implementar algunas de nuestras pruebas en JUnit como sigue a continuaci&oacute;n:</p>
<pre class="brush:java;">public class EmpleadoBOTest {

  TestableEmpleadoBO ebo;
	
  @Before
  public void setUp() {
    EmpleadoDAO edao = new MockEmpleadoDAO(false);
    try {
      edao.addEmpleado(new EmpleadoTO(1,"12345678X", 
             "Paco Garcia", TipoEmpleado.vendedor, 1250, 8));
      edao.addEmpleado(new EmpleadoTO(2,"65645342B", 
             "Maria Gomez", TipoEmpleado.encargado, 1600, 2));
      edao.addEmpleado(new EmpleadoTO(3,"45452343F", 
             "Manolo Gutierrez", TipoEmpleado.vendedor, 800, 0));
    } catch (DAOException e) {
      e.printStackTrace();
    }
		
    ebo = new TestableEmpleadoBO();
    ebo.setEmpleadoDAO(edao);
  }
	
  @Test
  public void testGetSalarioBruto() {
    try {
      float resultadoReal = ebo.getSalarioBruto(3);
      float resultadoEsperado = 1000.0f;
			
      assertEquals(resultadoEsperado, resultadoReal, 0.01);
    } catch (BOException e) {
      fail("Lanzada excepcion no esperada BOException");
    }
  }
}

class TestableEmpleadoBO extends EmpleadoBO {

  EmpleadoDAO edao;
	
  public void setEmpleadoDAO(EmpleadoDAO edao) {
    this.edao = edao;
  }
	
  @Override
  EmpleadoDAO getEmpleadoDAO() {
    return edao;
  }	
}</pre>
<p>Destacamos aqu&iacute; que los <em>fixtures</em> han sido de gran ayuda para crear los objetos <em>mock</em> necesarios.</p>
<p>Sin embargo, si lo que nos interesa es probar nuestro DAO, ya no tiene sentido utilizar <em>mocks</em>, ya que estos estar&iacute;an sustituyendo
	a las propias clases a probar. En estos casos ser&aacute; necesario probar la base de datos real. Para ello tenemos herramientas especializadas
	como DBUnit, que nos permiten establecer de forma sencilla el estado en el que queremos dejar la base de datos antes de cada prueba.</p>
<p>Otra opci&oacute;n ser&iacute;a utilizar los propios <em>fixtures</em> de JUnit para establecer el estado de la base de datos antes 
	de cada prueba. Podr&iacute;amos utilizar el m&eacute;todo marcado con <span class="codefrag">@Before</span> para vaciar la tabla que estemos probando e insertar
	en ella los datos de prueba.</p>
<div class="frame warning">
<div class="label">Importante</div>
<div class="content">Nunca deberemos modificar ni una l&iacute;nea de c&oacute;digo del m&eacute;todo a probar, ya que nuestro objetivo es comprobar que
	dicho m&eacute;todo se comporta como es debido tal como est&aacute; implementado en la aplicaci&oacute;n. S&oacute;lo podremos cambiar componentes de los que
	depende, pero sin afectar al c&oacute;digo de propio m&eacute;todo probado.</div>
</div>
</div>

	
<a name="N10571"></a><a name="Suites+de+pruebas"></a>
<h2 class="underlined_10">Suites de pruebas</h2>
<div class="section">
<p>A medida que vamos acumulando m&eacute;todos de prueba, nos podr&iacute;a interesar organizarlos o agruparlos de determinada forma. Mediante las 
		<strong>suites</strong> podemos asignar m&eacute;todos de prueba a grupos, y as&iacute; poder ejecutar todas nuestras pruebas (o un grupo de ellas) 
		de forma conjunta.</p>
<p>Para crear la <span class="codefrag">suite</span> con JUnit 4 simplemente deberemos crear una nueva clase Java, y anotarla como se muestra a continuaci&oacute;n:</p>
<pre class="brush:java;">import org.junit.*;
import org.junit.runner.*;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;

@RunWith(Suite.class)
@SuiteClasses( { EmpleadoBRTest.class, EmpleadoBOTest.class })
public class MiSuite {}</pre>
<p>La anotaci&oacute;n <span class="codefrag">@RunWith</span> simplemente hace referencia a la clase de JUnit 4 que se encarga de ejecutar las suites. 
	Por otro lado, la anotaci&oacute;n <span class="codefrag">SuiteClasses</span> sirve para poner entre llaves, y separadas por comas, todas las 
	clases de prueba que queramos incorporar a la suite. De esta forma, la clase, como se ve, puede quedar vac&iacute;a perfectamente. 
	Luego el compilador, al procesar las anotaciones, ya se encarga de construir la suite correspondiente con las clases de prueba.
	Utilizando este m&eacute;todo, todas las clases de prueba que agrupemos en la suite deber&aacute;n estar implementadas en JUnit 4.</p>
<p>Para ejecutar la suite, la ejecutamos (<em>Run As</em>) como un <em>JUnit Test</em>. Aparecer&aacute; la ventana de JUnit con los tests 
	realizados, agrupados por las clases a las que pertenece cada uno.</p>
<p>Para crear suites de pruebas en Eclipse, podemos ir a <em>File &gt; New &gt; JUnit Test Suite</em>. Ah&iacute; le indicamos el nombre de la suite, 
	y las clases de prueba que queremos incluir en ella. Sin embargo, esto s&oacute;lo funciona cuando utilizamos JUnit 3. Existe una peque&ntilde;a 
	"laguna" a&uacute;n en la adaptaci&oacute;n de las suites a JUnit 4, que Eclipse no ha cubierto a&uacute;n. Sin embargo, existe una 
	forma de hacer que las pruebas hechas en JUnit 4 funcionen en una suite creada por Eclipse.</p>
<p>Deberemos modificar el m&eacute;todo <span class="codefrag">suite</span> creado autom&aacute;ticamente, a&ntilde;adiendo una nueva clase, que compatibiliza las pruebas de JUnit 4 
	para que funcionen en entornos de ejecuci&oacute;n de JUnit 3 (como el <em>runner</em> que lanza el m&eacute;todo <span class="codefrag">suite</span>). Esta clase 
	se llama <strong><span class="codefrag">JUnit4TestAdapter</span></strong>, y bastar&iacute;a con sustituir las dos l&iacute;neas anteriores en negrita por estas dos:</p>
<pre class="brush:java;">public static Test suite() {
  ...
  suite.addTest(
    new junit.framework.JUnit4TestAdapter(EmpleadoBOTest.class));
  suite.addTest(
    new junit.framework.JUnit4TestAdapter(EmpleadoBRTest.class));
  ...
}</pre>
<p>Esta forma de crear la suite tiene la ventaja de que nos permitir&aacute; agrupar pruebas de JUnit 3 y 4.</p>
</div>

<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
