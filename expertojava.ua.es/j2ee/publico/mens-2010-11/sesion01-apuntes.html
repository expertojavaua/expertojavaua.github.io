<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title> Introducci&oacute;n a JMS (Java Message Service)</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servicios de Mensajes con JMS" src="images/baner_j2ee_der.gif" title="Servicios de Mensajes con JMS"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servicios de Mensajes con JMS</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servicios de Mensajes con JMS</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servicios de Mensajes con JMS">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 1</div>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="2. Mensajes. Robustez en JMS">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html" title="3. Durable Subscribers y Transacciones. JMS y JavaEE">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html" title="4. Message Driven Beans">Sesi&oacute;n 4</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html" title="1. Introducci&oacute;n a JMS">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html" title="2. Mensajes. Robustez en JMS">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html" title="3. Durable Subscribers y Transacciones. JMS y JavaEE">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html" title="4. Message Driven Beans">Sesi&oacute;n 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion01-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1> Introducci&oacute;n a JMS (Java Message Service)</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Un+Poco+de+Historia">Un Poco de Historia</a>
<ul class="minitoc">
<li>
<a href="#Mensajer%C3%ADa">Mensajer&iacute;a</a>
</li>
<li>
<a href="#MOM">MOM</a>
</li>
</ul>
</li>
<li>
<a href="#Dominios+de+Mensajer%C3%ADa">Dominios de Mensajer&iacute;a</a>
<ul class="minitoc">
<li>
<a href="#Punto+a+Punto">Punto a Punto</a>
</li>
<li>
<a href="#Publicaci%C3%B3n%2FSubscripci%C3%B3n">Publicaci&oacute;n/Subscripci&oacute;n</a>
</li>
</ul>
</li>
<li>
<a href="#Java+Message+Service">Java Message Service</a>
<ul class="minitoc">
<li>
<a href="#JMS+y+JavaEE">JMS y JavaEE</a>
</li>
<li>
<a href="#Arquitectura+JMS">Arquitectura JMS</a>
</li>
<li>
<a href="#El+Modelo+de+Programaci%C3%B3n+JMS">El Modelo de Programaci&oacute;n JMS</a>
<ul class="minitoc">
<li>
<a href="#Objetos+Administrados">Objetos Administrados</a>
</li>
<li>
<a href="#Conexiones">Conexiones</a>
</li>
<li>
<a href="#Sesiones">Sesiones</a>
</li>
<li>
<a href="#Productores+de+Mensajes">Productores de Mensajes</a>
</li>
<li>
<a href="#Consumidores+de+Mensajes">Consumidores de Mensajes</a>
</li>
<li>
<a href="#Mensajes">Mensajes</a>
</li>
</ul>
</li>
<li>
<a href="#Modelos+Espec%C3%ADficos">Modelos Espec&iacute;ficos</a>
<ul class="minitoc">
<li>
<a href="#API+Punto+a+Punto">API Punto a Punto</a>
</li>
<li>
<a href="#API+Publicaci%C3%B3n%2FSubscripci%C3%B3n">API Publicaci&oacute;n/Subscripci&oacute;n</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Recursos+JMS+en+Glassfish">Recursos JMS en Glassfish</a>
<ul class="minitoc">
<li>
<a href="#Factor%C3%ADas+de+Conexi%C3%B3n-N1042D">Factor&iacute;as de Conexi&oacute;n</a>
</li>
<li>
<a href="#Destinos-N10455">Destinos</a>
</li>
</ul>
</li>
<li>
<a href="#Una+Aplicaci%C3%B3n+JMS">Una Aplicaci&oacute;n JMS</a>
<ul class="minitoc">
<li>
<a href="#Ejemplo+de+PTP">Ejemplo de PTP</a>
<ul class="minitoc">
<li>
<a href="#Productor">Productor</a>
</li>
<li>
<a href="#Consumidor">Consumidor</a>
</li>
</ul>
</li>
<li>
<a href="#Ejemplo+de+Pub%2FSub">Ejemplo de Pub/Sub</a>
<ul class="minitoc">
<li>
<a href="#Publicador">Publicador</a>
</li>
<li>
<a href="#Subscriptor">Subscriptor</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>


<p>Tarde o temprano llega el momento en el que todo desarrollador tiene la necesidad de intercomunicar aplicaciones. Existen m&uacute;ltiples soluciones para este tipo de problemas, pero dependiendo de las restricciones y requerimientos, el hecho de decidir como resolver esta situaci&oacute;n puede ser otro problema en s&iacute;. Los requerimientos de negocio normalmente restringen el n&uacute;mero de elementos que tienen un impacto directo como puede ser el rendimiento, escalabilidad, confiabilidad, etc...</p>


<a name="N1000F"></a><a name="Un+Poco+de+Historia"></a>
<h2 class="underlined_10">Un Poco de Historia</h2>
<div class="section">
<p>A partir de los a&ntilde;os 60, las grandes empresas invirtieron grandes cantidad de dinero en <em>mainframes</em> para las aplicaciones cr&iacute;ticas, tales como procesamiento de datos, procesos financieros, an&aacute;lisis estad&iacute;sticos, etc... La arquitectura <em>mainframe</em> ofrece muchos beneficios, como pueden ser la alta disponibilidad, redundancia, gran confiabilidad y escalabilidad, etc... Aunque estos sistemas eran extremadamente potentes (y caros), el acceso a estos sistemas se restringe a unas pocas opciones de entrada. Adem&aacute;s, la interconectividad entre estos sistemas todav&iacute;a no existe, lo que imposibilidad el procesamiento paralelo.</p>
<p>En los 70, los usuarios empezaron a acceder a los mainframes a trav&eacute;s de terminales los cuales expandieron el uso de estos sistemas permitiendo el acceso concurrente de miles de usuarios. Durante esta &eacute;poca, se inventaron las redes de ordenadores, y se hizo posible la conectividad entre mainframes. En los 80, adem&aacute;s de los terminales gr&aacute;ficos disponibles, los PCs llegaron al mercado y la emulaci&oacute;n de terminales se convirti&oacute; en algo com&uacute;n. La interconectividad se convirti&oacute; en un aspecto muy importante ya que las aplicaciones desarrolladas para ejecutarse sobre PCs necesitaban acceder a los mainframes. Esta diversidad de plataformas y protocolos introdujo nuevos problemas que hab&iacute;a que resolver.</p>
<p>

<img alt="Evoluci&oacute;n de la arquitectura Mainframe" content-width="14cm" src="imagenes/sesion1/antecedentes.jpg" width="693">
</p>
<p>La conexi&oacute;n de un sistema fuente con un destino no era nada sencillo ya que cada hardware, protocolo y formato de datos requer&iacute;a un tipo diferente de adaptador. Conforme creci&oacute; esta lista de adaptadores, tambi&eacute;n lo hizo las diferentes versiones de estos, lo que provoco que se convirtiera en dif&iacute;cil de mantener, hasta que el mantenimiento de los adaptadores llevaba m&aacute;s tiempo que el de los propios sistemas. Esto dio pie a la mensajer&iacute;a empresarial.</p>
<p>El objetivo de la <strong>mensajer&iacute;a empresarial</strong> era transferir informaci&oacute;n entre sistemas heterog&eacute;neos mediante el env&iacute;o de mensajes de un sistema a otro. Ha habido diversas tecnolog&iacute;as con diferentes formas de mensajer&iacute;a a lo largo de los a&ntilde;os, incluyendo:</p>
<ul>
	
<li>Soluciones para llamadas a procedimientos remotos que hacen funciones de middleware mediante una cola de mensajes, tales como <em>COM</em> y <em>CORBA</em>
</li>
	
<li>Soluciones para la notificaci&oacute;n de eventos, comunicaci&oacute;n entre procesos y colas de mensajes los cuales se incluyen en los sistemas operativos, como buffers FIFO, colas de mensajes, tubos (<em>pipes</em>), se&ntilde;ales, sockets, ...</li>
	
<li>Soluciones para una categor&iacute;a de middleware que ofrece un mecanismo de mensajer&iacute;a fiable y as&iacute;ncrono tales como <em>WebShpereMQ</em>, <em>SonicMQ</em>, <em>TIBCO</em>, <em>Apache ActiveMQ</em>, etc...</li>

</ul>
<p>As&iacute; pues, existen muchos productos que ofrecen un mecanismo de mensajer&iacute;a, pero la que nos interesa a nosotros es la &uacute;ltima categor&iacute;a. La necesidad es la madre de la invenci&oacute;n, y por eso apareci&oacute; el middleware de mensajer&iacute;a. Se necesitaba un software para comunicar y transferir datos entre diferentes aplicaciones, sistemas operativos, protocolos e incluso diferentes lenguajes de programaci&oacute;n. Adem&aacute;s, el enrutamiento y la transformaci&oacute;n de mensajes emerg&iacute;an como una parte importante de estas soluciones. Esto es lo que hoy d&iacute;a se conoce como <strong>MOM</strong> (<em>Message-Oriente Middleware</em>)</p>
<a name="N1005C"></a><a name="Mensajer%C3%ADa"></a>
<h3 class="underlined_5">Mensajer&iacute;a</h3>
<p>La mensajer&iacute;a es un m&eacute;todo de comunicaci&oacute;n entre componentes software o aplicaciones. Un sistema de mensajes es una facilidad <em>peer-to-peer</em>: un cliente de mensajer&iacute;a puede enviar mensajes a, o recibir mensajes de, otro cliente. Basta con que ambos se conecten a agentes de mensajer&iacute;a (<em>MOMs</em>) que proporcionen facilidades de creaci&oacute;n, env&iacute;o, recepci&oacute;n y lectura de mensajes. Los mensajes permiten una comunicaci&oacute;n distribu&iacute;da <strong>d&eacute;bilmente acoplada</strong>: un componente env&iacute;a un mensaje a un <em>destino</em> y el receptor lo recoge del mismo.</p>
<p>Sin embargo, ni el emisor ni el receptor tienen que estar disponibles al mismo tiempo para comunicarse. De hecho, el emisor no tiene porqu&eacute; saber nada del receptor, y viceversa. Ambos s&oacute;lo deben saber el formato del mensaje y cual es el destino del mensaje. Esto hace que la mensajer&iacute;a difiera de tecnolog&iacute;as fuertemente acopladas, tales como RMI, que requieren que la aplicaci&oacute;n cliente conozca los m&eacute;todos de la aplicaci&oacute;n remota.</p>
<p>Una aplicaci&oacute;n utilizar&aacute; la mensajer&iacute;a cuando queramos que:</p>
<ul>
	
<li>ciertos componentes no dependan del interfaz de otros componentes, de modo que &eacute;stos puedas sustituirse f&aacute;cilmente</li>
	
<li>la aplicaci&oacute;n funcione independientemente de si todos los componentes se est&aacute;n ejecutando de forma simult&aacute;nea</li>
	
<li>el modelo de negocio de la aplicaci&oacute;n permita a un componente enviar informaci&oacute;n a otro componente y que contin&uacute;e su procesamiento sin esperar a una respuesta inmediata.</li>

</ul>
<a name="N10084"></a><a name="MOM"></a>
<h3 class="underlined_5">MOM</h3>
<p>El <strong>M</strong>idleware <strong>O</strong>rientado a <strong>M</strong>ensajes (MOM) es un categor&iacute;a de software para la intercomunicaci&oacute;n de sistemas que ofrece una manera segura, escalable, confiable y con bajo acoplamiento. Los MOMs permiten la comunicaci&oacute;n entre aplicaciones mediante un conjunto de APIs ofrecidas por cada proveedor y lenguaje, as&iacute; pues, tendremos un API propietaria y diferente por cada MOM existente.</p>
<p>La idea principal de un MOM es que act&uacute;a como un mediador entre los emisores y los receptores de mensajes. Esta mediaci&oacute;n ofrece un nuevo nivel de desacoplamiento en la mensajer&iacute;a empresarial. As&iacute; pues, un MOM se utiliza para mediar en la conectividad y la mensajer&iacute;a, no solo entre las aplicaciones y el mainframe, sino de una aplicaci&oacute;n a otra.</p>
<p>

<img alt="Evoluci&oacute;n MOM" content-width="11cm" src="imagenes/sesion1/mom.jpg" width="444">
</p>
<p>A un nivel m&aacute;s alto, los mensajes son unidades de informaci&oacute;n de negocio que se env&iacute;an de una aplicaci&oacute;n a otra a trav&eacute;s de un MOM. Estos mensajes se env&iacute;an y reciben por aquellos clientes que se conectan o subscriben a los mensajes. Este mecanismo es el que permite el acoplamiento d&eacute;bil entre emisores y receptores, ya que no se requiere que ambos est&eacute;n conectados simult&aacute;neamente al MOM para enviar y/o recibir los mensajes. Esto es la <strong>mensajer&iacute;a as&iacute;ncrona</strong>.</p>
<p>Los MOMs a&ntilde;adieron muchas caracter&iacute;sticas a la mensajer&iacute;a empresarial que previamente no eran posibles cuando los sistemas estaban fuertemente acoplados, tales como la persistencia de los mensajes, enrutamientos complejos de mensajes, transformaci&oacute;n de los mensajes, etc... La <em>persistencia de mensajes </em>ayuda a mitigar las conexiones lentas o poco fiables realizadas por lo emisores y receptores o en una situaci&oacute;n donde el fallo de un receptor no afecta al estado del emisor. El <em>enrutamiento complejo</em> de mensajes genera una cantidad de posibilidades que incluyen la entrega de un &uacute;nico mensaje a muchos receptores, enrutamiento de mensajes basados en propiedades del contenido del mensaje, etc... La <em>transformaci&oacute;n de mensajes</em> permite la comunicaci&oacute;n entre dos aplicaciones que no trabajan con el mismo formato de mensajes.</p>
<p>Adem&aacute;s, la mayor&iacute;a de MOMs existentes en el mercado ofrecen soporte para diversos protocolos de conectividad, como pueden ser HTTP/S, SSL, TCP/IP, UDP, etc... Incluso algunos proveedores ofrecen soporte para m&uacute;ltiples lenguajes de programaci&oacute;n, facilitando del uso de MOMs en una amplia variedad de entornos. Este gran abanico de protocolos, lenguajes y APIs provoca la aparici&oacute;n de JMS para estandarizar la mensajer&iacute;a dentro del mundo Java.</p>
</div>


<a name="N100B9"></a><a name="Dominios+de+Mensajer%C3%ADa"></a>
<h2 class="underlined_10">Dominios de Mensajer&iacute;a</h2>
<div class="section">
<p>Existen dos modelos/dominios de mensajer&iacute;a:</p>
<ul>
	
<li>Punto a Punto (<strong>PTP</strong>), en la que un mensaje se consume por un &uacute;nico consumidor.</li>
	
<li>Publicaci&oacute;n/Subscripci&oacute;n (<strong>Pub/Sub</strong>), en la que un mensaje se consume por muchos consumidores.</li>

</ul>
<p>Destacar que no todos los proveedores implementan ambos. Posteriormente veremos como JMS ofrece diferentes APIs para estos dos modelos.</p>
<a name="N100D4"></a><a name="Punto+a+Punto"></a>
<h3 class="underlined_5">Punto a Punto</h3>
<p>Como hemos mencionado, bajo el modelo PTP, <strong>un mensaje se consume por un &uacute;nico consumidor</strong> (1:1), pero pueden haber varios emisores. El destino del mensaje es un <strong>cola</strong> definida y con un nombre (de manera opuesta a un t&oacute;pico bajo el modelo Pub/Sub). Dicho de otra manera, se trata de un modelo FIFO, en el cual el mensaje encolado ser&aacute; el primero en salir de la cola (suponiendo que tienen el mismo nivel de prioridad).</p>
<p>

<img alt="Modelo Punto a Punto" content-width="12cm" src="imagenes/sesion1/ptp.jpg" width="422">
</p>
<p>As&iacute; pues, bajo el modelo punto a punto, el emisor env&iacute;a un mensaje a una cola definida (con nombre) con un nivel de prioridad, y el receptor extrae el mensaje de la cola. Al extraer el mensaje, el receptor env&iacute;a un acuse de recibo a la cola para confirmar su correcta recepci&oacute;n (ACK).</p>
<p>Una aplicaci&oacute;n PTP se construye bajo el concepto de colas de mensajes, productores y consumidores. A los emisores se les conoce como <strong>productores</strong>, y a los receptores como <strong>consumidores</strong>. Cada mensaje se env&iacute;a a una cola espec&iacute;fica, y los consumidores  extraen los mensajes de la(s) cola(s) definidas. Estas colas retienen todos los mensajes enviados hasta que son consumidos o hasta que expiren.</p>
<a name="N100F9"></a><a name="Publicaci%C3%B3n%2FSubscripci%C3%B3n"></a>
<h3 class="underlined_5">Publicaci&oacute;n/Subscripci&oacute;n</h3>
<p>En este modelo, <strong>un mensaje puede consumirse por m&uacute;ltiples consumidores</strong> (1:N). El destino de un mensaje se conoce como <strong>t&oacute;pico</strong>. Un t&oacute;pico no funciona como un pila, ya que los mensajes en los t&oacute;picos no se encolan. De hecho, un nuevo mensaje en el t&oacute;pico sobrescribir&aacute; cualquier mensaje existente. As&iacute; pues, bajo este modelo de difusi&oacute;n, los productores/emisores/publicadores publican el mensaje en un t&oacute;pico, y los consumidores se subscriben al t&oacute;pico.</p>
<p>

<img alt="Modelo Publicaci&oacute;n/Subscripcui&oacute;n" content-width="12cm" src="imagenes/sesion1/pubsub.jpg" width="437">
</p>
<p>En este modelo, los publicadores (emisores) y los subscriptores (receptores) normalmente son an&oacute;nimos y pueden, de forma din&aacute;mica, publicar o subscribirse a la jerarqu&iacute;a de contenidos. El sistema de mensajer&iacute;a se encarga de distribuir los mensajes que llegan al t&oacute;pico de los m&uacute;ltiples publicadores a sus respectivos subscriptores, mediante un mecanismo push, de modo que los mensajes se env&iacute;an autom&aacute;ticamente a los subscriptores.</p>
<p>La mensaria Pub/Sub tiene las siguientes caracter&iacute;sticas:</p>
<ul>
	
<li>Cada mensaje puede tener m&uacute;ltiples consumidores</li>
	
<li>Existe un dependencia temporal entre los publicadores y los subscritores perecederos (<em>non-durable</em>) ya que un cliente que se subscribe a un t&oacute;pico puede consumir los mensajes publicados despu&eacute;s de la subscripci&oacute;n, y el subscriptor debe continuar conectado para consumir los posteriores mensajes.</li>

</ul>
<p>El API JMS disminuye esta dependencia temporal permitiendo a los clientes crear subscripciones duraderas (<em>durable</em>). Las subscripciones duraderas permiten recibir mensajes que fueron enviados cuando los subscriptores no estaban conectados. De este modo, las subscripciones duraderas ofrecen flexibilidad y fiabilidad a las colas pero aun as&iacute; permiten a los clientes enviar mensajes a m&uacute;ltiples recipientes.</p>
<p>Al poder haber m&uacute;ltiples publicadores y m&uacute;ltiples consumidores en el mismo t&oacute;pico, el modelo Pub/Sub es especialmente &uacute;til en situaciones donde un grupo de aplicaciones quiere notificar a otras de un evento particular. Por ejemplo, una aplicaci&oacute;n de CRM, al crear un cliente, puede necesitar comunicar a otras aplicaciones la creaci&oacute;n de este cliente.</p>
</div>


<a name="N1012E"></a><a name="Java+Message+Service"></a>
<h2 class="underlined_10">Java Message Service</h2>
<div class="section">
<p>JMS se separa de las APIs propietarias de cada proveedor para ofrece un API est&aacute;ndar (mediante un conjunto de interfaces) para la mensajer&iacute;a empresarial, de modo que mediante Java podamos enviar y recibir mensajes sin atarnos a ning&uacute;n proveedor. JMS adem&aacute;s minimiza el conocimiento de mensajer&iacute;a empresarial que debe tener un programador Java para desarrollar complejas aplicaciones de mensajer&iacute;a, mientras mantiene la portabilidad entre las diferentes implementaciones de proveedores JMS.</p>
<p>Cuidado, JMS no es un MOM. Se trata de una especificaci&oacute;n que abstrae la interacci&oacute;n entre los clientes de mensajer&iacute;a y los MOMs del mismo modo que JDBC abstrae la comunicaci&oacute;n con las BBDD relacionales. El siguiente gr&aacute;fico muestra como JMS ofrece un API que utilizan los clientes de mensajer&iacute;a para interactuar con MOMs espec&iacute;ficos via proveedores JMS que manejan la interacci&oacute;n con el MOM espec&iacute;fico. De este modo, JMS reduce la barrera para la creaci&oacute;n de aplicaciones de mensajer&iacute;a, facilitando la portabilidad a otros proveedores JMS.</p>
<p>

<img alt="JMS de un cliente a multiples proveedores" content-width="13cm" src="imagenes/sesion1/jms.jpg" width="587">
</p>
<p>JMS permite que la comunicaci&oacute;n entre componentes sea <strong>d&eacute;bilmente acoplada</strong>, <strong>as&iacute;ncrona</strong> (el proveedor JMS entrega los mensajes al destino conforme llegan, y el cliente no tiene que solicitar los mensajes para recibirlos) y <strong>fiable</strong> (JMS asegura que cada mensaje se entrega una y solo una vez, y mediante inferiores niveles de fiabilidad permite la p&eacute;rdida o el duplicado de mensajes en aquellas aplicaciones que requieran menos control).</p>
<p>Originalmente creada por <em>Sun</em> conjunto a un grupo de compa&ntilde;&iacute;as de la industria de la mensajer&iacute;a empresarial, la primera versi&oacute;n de la especificaci&oacute;n JMS data de 1998. La &uacute;ltima <em>release</em> fue en 2002 con mejoras necesarias y desde entonces se trata de una tecnolog&iacute;a estable y madura. La <em>release</em> JMS 1.1 unific&oacute; los dos conjuntos de APIs para trabajar con los dos dominios de mensajer&iacute;a, de modo que ahora s&oacute;lo necesitamos una API para trabajar con ambos dominios.</p>
<a name="N1015B"></a><a name="JMS+y+JavaEE"></a>
<h3 class="underlined_5">JMS y JavaEE</h3>
<p>A partir de la versi&oacute;n 1.3 de JavaEE, el API JMS forma parte de la especificaci&oacute;n <em>enterprise</em>, y los desarrolladores la pueden utilizar dentro de componentes JavaEE.</p>
<p>El API JMS dentro de la plataforma JavaEE aporta:</p>
<ul>
	
<li>Aplicaciones cliente, componentes EJB y componentes web que pueden enviar o recibir de forma as&iacute;ncrona mensajes JMS. Los clientes pueden recibir incluso los mensajes tambi&eacute;n de forma as&iacute;ncrona.</li>
	
<li>Beans de mensajes (<em>Message-driven Beans</em> - MDBs) que son un tipo de EJB que puede consumir mensajes de forma as&iacute;ncrona. Un proveedor JMS (t&iacute;picamente el servidor de aplicaciones) puede implementar de forma opcional el procesamiento concurrente de mensajes con MDBs.</li>
	
<li>El env&iacute;o y recepci&oacute;n de mensajes puede participar en transacciones distribuidas lo cual permite que las operaciones JMS y el acceso a BD ocurra dentro de una misma transacci&oacute;n.</li>

</ul>
<p>Todo esto provoca que JMS mejore JavaEE simplificando el desarrollo de aplicaciones empresariales, mediante interacciones as&iacute;ncronas, de confianza y con bajo acoplamiento entre los componentes JavaEE y los sistemas legacy que soportan la mensajer&iacute;a. A su vez, JavaEE mejora JMS mediante el soporte de transacciones distribuidas, y el procesamiento de mensajes de manera concurrente.</p>
<div class="frame note">
<div class="label">Arquitectura de Conectores JavaEE</div>
<div class="content">El servidor de aplicaciones integra a diferentes proveedores JMS mediante la arquitectura de conectores. De este modo, accedemos a un proveedor a trav&eacute;s de un adaptador de recursos. Esto permite que los propietarios de MOMs creen proveedores JMS que puedan enchufarse en m&uacute;ltiples servidores de aplicaciones, y permite a un servidor de aplicaciones disponer de m&uacute;ltiples proveedores JMS.
</div>
</div>
<a name="N10181"></a><a name="Arquitectura+JMS"></a>
<h3 class="underlined_5">Arquitectura JMS</h3>
<p>Para estandarizar el API, JMS define de un modo formal muchos conceptos y elementos del mundo de la mensajer&iacute;a:</p>
<ul>
	
<li>
<em>Cliente JMS</em>: Una aplicaci&oacute;n 100% Java que env&iacute;a y recibe mensajes. Cualquier componente JavaEE puede actuar como un cliente JMS.
		<ul>
			
<li>
<em>Clientes No-JMS</em>: una aplicaci&oacute;n escrita en un lenguaje que no es Java que env&iacute;a y recibe mensajes.</li>
			
<li>
<em>Productor JMS</em>: una aplicaci&oacute;n cliente que crea y env&iacute;a mensajes JMS.</li>
			
<li>
<em>Consumidor JMS</em>: una aplicaci&oacute;n cliente que recibe y procesa mensajes JMS.</li>			
			
</ul>
	
</li>
	
<li>
<em>Proveedor JMS</em>: implementaci&oacute;n de los interfaces JMS el cual est&aacute; idealmente escrito 100% en Java. El proveedor debe ofrecer prestaciones tanto de administraci&oacute;n como de control de los recursos JMS. Toda implementaci&oacute;n de la plataforma Java incluye un proveedor JMS.</li>
	
<li>
<em>Mensaje JMS</em>: elemento principal de JMS; objeto (cabecera + propiedades + cuerpo) que contiene la informaci&oacute;n y que es enviado y recibido por clientes JMS.</li>
	
<li>
<em>Dominio JMS</em>: Los dos estilos de mensajer&iacute;a: PTP y Pub/Sub.</li>
	
<li>
<em>Objetos Administrados</em>: objetos JMS preconfigurados que contienen datos de configuraci&oacute;n espec&iacute;ficos del proveedor, los cuales utilizar&aacute;n los clientes. Los clientes acceden a estos objetos mediante JNDI.
	<ul>
		
<li>
<em>Factor&iacute;a de Conexi&oacute;n</em>: los clientes utilizan una factor&iacute;a para crear conexiones al proveedor JMS.</li>
		
<li>
<em>Destino</em>: objeto (cola/t&oacute;pico) al cual se direccionan y env&iacute;an los mensajes, y desde donde se reciben los mensajes.</li>
	
</ul>
	
</li>

</ul>
<p>Estos elementos interaccionan del siguiente modo:</p>
<p>

<img alt="Arquitectura JMS" content-width="10cm" src="imagenes/sesion1/arqJMS.jpg" width="389">
</p>
<p>Las herramientas de administraci&oacute;n permiten vincular destinos y factor&iacute;as de conexi&oacute;n a trav&eacute;s de un espacio de nombres JNDI. Entonces un cliente JMS puede consultar los objetos administrados en dicho espacio v&iacute;a inyecci&oacute;n de recursos y establecer conexiones l&oacute;gicas con ellos a trav&eacute;s del proveedor JMS.</p>
<a name="N101D5"></a><a name="El+Modelo+de+Programaci%C3%B3n+JMS"></a>
<h3 class="underlined_5">El Modelo de Programaci&oacute;n JMS</h3>
<p>El esquema de trabajo con las <strong>interfaces</strong> JMS queda claramente definido en el siguiente gr&aacute;fico:</p>
<p>

<img alt="Modelo Programaci&oacute;n JMS" content-width="13cm" src="imagenes/sesion1/modeloProgramacion.jpg" width="506">
</p>
<p>A continuaci&oacute;n veremos en detalle cada uno de estos elementos con trozos de c&oacute;digo que muestran como instanciarlos.</p>
<a name="N101ED"></a><a name="Objetos+Administrados"></a>
<h4>Objetos Administrados</h4>
<p>Es m&aacute;s c&oacute;modo que los dos extremos de las aplicaci&oacute;n JMS, la factor&iacute;a de conexiones y los destinos, sean mantenidos mediante administraci&oacute;n que de forma programativa. Esto se debe a que la tecnolog&iacute;a que hay bajo estos objetos va a ser diferente dependiendo del proveedor JMS, y por tanto, su administraci&oacute;n var&iacute;a de un proveedor a otro.</p>
<p>Los clientes JMS acceden a estos objetos v&iacute;a interfaces que son portables, de modo que un cliente pueda cambiar de implementaci&oacute;n JMS sin necesidad de ninguna modificaci&oacute;n. La administraci&oacute;n de estos objetos (en nuestro caso a trav&eacute;s de la consola de administraci&oacute;n de <em>Glassfish</em>) se realiza dentro de un espacio de nombre JNDI, y los clientes acceden a &eacute;l mediante la inyecci&oacute;n de recursos v&iacute;a anotaciones.</p>
<a name="N101FC"></a><a name="Factor%C3%ADas+de+Conexi%C3%B3n"></a>
<h5>Factor&iacute;as de Conexi&oacute;n</h5>
<p>La factor&iacute;a de conexi&oacute;n es el objeto que utiliza el cliente para crear una conexi&oacute;n con el proveedor, encapsulando un conjunto de par&aacute;metros de configuraci&oacute;n de la conexi&oacute;n que han sido previamente definidos por el administrador del servidor de mensajes. Cada factor&iacute;a de conexi&oacute;n es una instancia de <span class="codefrag">ConnectionFactory</span>, ya sea <span class="codefrag">QueueConnectionFactory</span> o <span class="codefrag">TopicConnectionFactory</span>.</p>
<p>Al inicio de un cliente JMS, normalmente se inyecta un recurso de factor&iacute;a de conexi&oacute;n en un objeto <span class="codefrag">ConnectionFactory</span>. Por ejemplo, el siguiente fragmento de c&oacute;digo muestra como se inyecta el recurso cuyo nombre JNDI es <span class="codefrag">jms/ConnectionFactory</span> y se asigna a un objeto <span class="codefrag">ConnectionFactory</span>:</p>
<pre class="code">@Resource(mappedName="jms/ConnectionFactory")
private static ConnectionFactory connectionFactory;
</pre>
<a name="N10221"></a><a name="Destinos"></a>
<h5>Destinos</h5>
<p>Un destino (<span class="codefrag">javax.jms.Destination</span>) es el objeto que utiliza el cliente para especificar el destino de los mensajes que produce y el origen de los mensajes que consume. En PTP los destinos son las colas (<span class="codefrag">javax.jms.Queue</span>), mientras que en Pub/Sub son los t&oacute;picos (<span class="codefrag">javax.jms.Topic</span>). Una aplicaci&oacute;n JMS puede utilizar m&uacute;ltiples colas o t&oacute;picos (o ambos).</p>
<p>Para crear un destino mediante el servidor de aplicaciones, hay que crear un recurso JMS que especifique un nombre JNDI para el destino. Dentro de la implementaci&oacute;n del servidor de aplicaciones, cada destino referencia a un destino f&iacute;sico.</p>
<p>Del mismo modo que con la factor&iacute;a de conexiones, los destinos tambi&eacute;n se inyectan, pero en este caso, son espec&iacute;ficos a un dominio u otro. Si quisi&eacute;ramos crear una aplicaci&oacute;n que con el mismo c&oacute;digo fuente trabajase tanto con t&oacute;picos como con colas deber&iacute;amos asignar el destino a un objeto <span class="codefrag">Destination</span>.</p>
<p>El siguiente fragmento espec&iacute;fica dos recursos, una cola y un t&oacute;pico. Los nombres de los recursos se mapean con destinos creados via JNDI.</p>
<pre class="code">@Resource(mappedName="jms/Queue")
private static Queue queue;

@Resource(mappedName="jms/Topic")
private static Topic topic;
</pre>
<div class="frame note">
<div class="label">Mezclando Interfaces</div>
<div class="content">
El uso de interfaces comunes permite mezclar factor&iacute;as de conexiones y destinos. Por poder, se puede crear una <span class="codefrag">QueueConnectionFactory</span> y utilizarla con un <span class="codefrag">Topic</span>, y viceversa.<br>

<strong>El comportamiento de la aplicaci&oacute;n depender&aacute; del tipo de destino</strong>, no del tipo de factor&iacute;a de conexi&oacute;n.
</div>
</div>
<a name="N10254"></a><a name="Conexiones"></a>
<h4>Conexiones</h4>
<p>Una conexi&oacute;n encapsula una conexi&oacute;n virtual con el proveedor JMS, y puede representar un socket TCP/IP entre el cliente y un demonio del proveedor. Al crear una conexi&oacute;n, se crean objetos, tanto en la parte del cliente como en la del servidor, que gestionan el trasiego de mensajes entre el cliente y el sistema de mensajes. Mediante una conexi&oacute;n crearemos una o m&aacute;s sesiones en las que se producen y se consumen mensajes. Las conexiones implementan el interfaz <span class="codefrag">javax.jms.Connection</span>. A partir de una <span class="codefrag">ConnectionFactory</span>, podemos crear una conexi&oacute;n del siguiente modo:</p>
<pre class="code">Connection connection = connectionFactory.createConnection();</pre>
<p>Al finalizar la aplicaci&oacute;n, tenemos que cerrar toda conexi&oacute;n. Es muy importante cerrar las conexiones porque sino podemos provocar la sobrecarga del proveedor JMS. Al cerrar una conexi&oacute;n tambi&eacute;n cerramos sus sesiones y sus productores y consumidores de mensajes.</p>
<pre class="code">connection.close();</pre>
<p>Antes de que nuestras aplicaciones puedan consumir mensajes, debemos llamar al m&eacute;todo <span class="codefrag">start</span> de la conexi&oacute;n. Si queremos parar el env&iacute;o de mensajes de forma temporal sin cerrar la conexi&oacute;n, podemos utilizar el m&eacute;todo <span class="codefrag">stop</span>.</p>
<a name="N1027A"></a><a name="Sesiones"></a>
<h4>Sesiones</h4>
<p>Una sesi&oacute;n es un contexto monohilo para producir y consumir mensajes. Mediante las sesiones crearemos:</p>
<ul>
	
<li>Productores de mensajes.</li>
	
<li>Consumidores de mensajes.</li>
	
<li>Mensajes.</li>
	
<li>Navegadores de colas (<em>Queue Browser</em>).</li>
	
<li>Colas y t&oacute;picos temporales.</li>

</ul>
<p>Existen dos tipos de sesiones: las transaccionales y las no-transaccionales. Las transaccionales se caracterizan porque todos los mensajes enviados y recibidos se tratan como una unidad at&oacute;mica que est&aacute; sujeta al protocolo commit/rollback (confirmar o deshacer). En estas sesiones no es necesario realizar acuses de recibo o <em>acknowledgements</em>. En las no-transaccionales hay que seleccionar un tipo de acuse de recibo. En este caso, el tipo Session.AUTO_ACKNOWLEDGE indica que la sesi&oacute;n acusa el recibo de un mensaje una vez que la aplicaci&oacute;n receptora lo ha procesado.</p>
<p>Las sesiones implementan el interfaz <span class="codefrag">javax.jms.Session</span>. Tras crear una conexi&oacute;n, la utilizaremos para crear una sesi&oacute;n:</p>
<pre class="code">Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</pre>
<p>El primer par&aacute;metro indica que la sesi&oacute;n no es transaccional, y el segundo que la sesi&oacute;n confirmar&aacute; la recepci&oacute;n exitosa de los mensajes de forma autom&aacute;tica mediante un acuse de recibo.</p>
<p>Para crear una sesi&oacute;n transaccional, utilizaremos el siguiente fragmento:</p>
<pre class="code">Session session = connection.createSession(true, 0);</pre>
<p>En este caso, hemos creado una sesi&oacute;n transaccional pero que no especifica la confirmaci&oacute;n de los mensajes.</p>
<a name="N102B8"></a><a name="Productores+de+Mensajes"></a>
<h4>Productores de Mensajes</h4>
<p>Un productor de mensajes es un objeto creado por una sesi&oacute;n y que se utiliza para enviar mensajes a un destino. Implementa el interfaz <span class="codefrag">javax.jms.MessageProducer</span>. A partir de la sesi&oacute;n y un destino, podemos crear diferentes tipos de productores:</p>
<pre class="code">MessageProducer producer = session.createProducer(dest);
MessageProducer producer = session.createProducer(queue);
MessageProducer producer = session.createProducer(topic);</pre>
<p>Una vez creado un productor y el mensaje, para enviar mensajes utilizaremos el m&eacute;todo <span class="codefrag">send</span>:</p>
<pre class="code">producer.send(message);</pre>
<p>Se puede crear un productor sin identificar mediante un <span class="codefrag">null</span> como par&aacute;metro en el m&eacute;todo <span class="codefrag">createProducer</span>. Mediante este tipo de productores, el destino no se especifica hasta que se env&iacute;a un mensaje, especific&aacute;ndolo como primer par&aacute;metro.</p>
<pre class="code">MessageProducer anonProd = session.createProducer(null);
anonProd.send(dest, message);</pre>
<a name="N102E2"></a><a name="Consumidores+de+Mensajes"></a>
<h4>Consumidores de Mensajes</h4>
<p>Un consumidor de mensajes es un objeto creado por una sesi&oacute;n y que se utiliza para recibir mensajes enviados desde un destino. Implementa el interfaz <span class="codefrag">javax.jms.MessageConsumer</span>. A partir de la sesi&oacute;n y un destino, podemos crear diferentes tipos de productores:</p>
<pre class="code">MessageConsumer consumer = session.createConsumer(dest);
MessageConsumer consumer = session.createConsumer(queue);
MessageConsumer consumer = session.createConsumer(topic);</pre>
<p>Un consumidor de mensajes permite a un cliente JMS registrar su inter&eacute;s en un destino con un proveedor JMS. El proveedor gestiona la entrega de mensajes desde un destino a los consumidores registrados en dicho destino.</p>
<p>Tras crear un consumidor, &eacute;ste queda activo y lo podemos utilizar para recibir mensajes. Para desactivar al consumidor, utilizaremos el m&eacute;todo <span class="codefrag">close</span>. La entrega de mensajes no comienza hasta que no se inicia la conexi&oacute;n creada mediante el m&eacute;todo <span class="codefrag">start</span>.</p>
<div class="frame note">
<div class="label">Recuerda</div>
<div class="content">
Recuerda siempre llamar al m&eacute;todo <span class="codefrag">start</span>, es uno de los errores m&aacute;s comunes dentro de la programaci&oacute;n JMS
</div>
</div>
<p>Para consumir un mensaje de forma s&iacute;ncrona utilizaremos el m&eacute;todo <span class="codefrag">receive</span>. Esta operaci&oacute;n se puede realizar en cualquier momento siempre y cuando previamente hayamos iniciado la conexi&oacute;n (mediante el m&eacute;todo <span class="codefrag">start</span>):</p>
<pre class="code">connection.start();
Message m = consumer.receive();
connection.start();
Message m = consumer.receive(1000); // timeout tras un segundo</pre>
<p>Para consumir un mensaje de forma as&iacute;ncrona necesitamos un <em>listener</em> de mensajes.</p>
<a name="N1031A"></a><a name="Listener+de+Mensajes"></a>
<h5>Listener de Mensajes</h5>
<p>Un listener de mensajes es un objeto que act&uacute;a como un manejador de eventos as&iacute;ncronos para mensajes. Este objeto implementa el interfaz <span class="codefrag">javax.jms.MessageListener</span>, el cual &uacute;nicamente contiene el m&eacute;todo <span class="codefrag">onMessage</span>. En este m&eacute;todo definiremos las acciones a realizar con el mensaje recibido.</p>
<p>Para registrar el listener utilizaremos el m&eacute;todo <span class="codefrag">setMessageListener</span> del interfaz <span class="codefrag">MessageConsumer</span>. Por ejemplo, si tenemos una clase <span class="codefrag">Listener</span> que implementa el interfaz <span class="codefrag">MessageListener</span>, podemos registrar el listener del siguiente modo:</p>
<pre class="code">Listener myListener = new Listener();
consumer.setMessageListener(myListener);</pre>
<p>Tras registrar el listener, podemos llamar al m&eacute;todo <span class="codefrag">start</span> de la conexi&oacute;n para empezar la entrega de mensajes. Si lo hacemos antes, perderemos mensajes. Cuando comienza el env&iacute;o de los mensajes, cada vez que se recibe un mensaje, el proveedor JMS llama al m&eacute;todo <span class="codefrag">onMessage</span> del listener de mensajes. El m&eacute;todo <span class="codefrag">onMessage</span> recibe como par&aacute;metro un objeto de tipo <span class="codefrag">Message</span>, con los datos recibidos. Nuestro m&eacute;todo <span class="codefrag">onMessage</span> deber&iacute;a capturar todas las excepciones. No debe lanzar excepciones <em>checked</em>, y relanzar excepciones <em>unchecked</em> (<span class="codefrag">RuntimeException</span>) se considera un error de programaci&oacute;n.</p>
<p>Un listener de mensajes no es espec&iacute;fico para un tipo de destino en particular. El mismo listener puede obtener mensajes  tanto de una cola como de un t&oacute;pico, dependiendo del tipo de destino para el cual se cre&oacute; el consumidor de mensajes. Sin embargo, un listener normalmente espera un tipo y formato espec&iacute;fico de mensaje.</p>
<p>La sesi&oacute;n utilizada para crear el consumidor de mensajes serializa la ejecuci&oacute;n de todos los listener de mensajes registrados con la sesi&oacute;n. En un instante cualquiera, uno y solo uno de los listener de mensajes de la sesi&oacute;n est&aacute; en ejecuci&oacute;n.</p>
<a name="N1035F"></a><a name="Mensajes"></a>
<h4>Mensajes</h4>
<p>Los mensajes tambi&eacute;n se crean a partir de objetos de sesi&oacute;n. Por ejemplo, para crear un mensaje de tipo texto:</p>
<pre class="code">TextMessage message = session.createTextMessage();</pre>
<p>Los mensajes encapsulan informaci&oacute;n a intercambiar entre aplicaciones. Un mensaje contiene tres componentes: los campos de la <em>cabecera</em>, las <em>propiedades</em> espec&iacute;ficas de la aplicaci&oacute;n y el <em>cuerpo</em> del mensaje.</p>
<p>Los partes de cada mensaje as&iacute; como los diferentes tipos de mensajes los estudiaremos en la siguiente sesi&oacute;n.</p>
<a name="N1037F"></a><a name="Modelos+Espec%C3%ADficos"></a>
<h3 class="underlined_5">Modelos Espec&iacute;ficos</h3>
<p>Hasta ahora nos hemos centrado en el API JMS, el cual es com&uacute;n para ambos dominios de mensajer&iacute;a. A continuaci&oacute;n veremos cada uno de ellos en detalle.</p>
<a name="N10388"></a><a name="API+Punto+a+Punto"></a>
<h4>API Punto a Punto</h4>
<p>El API punto a punto se refiere de manera espec&iacute;fica a los interfaces basados en el uso de colas, de modo que los interfaces de este API son:</p>
<ul>
	
<li>
<span class="codefrag">QueueConnectionFactory</span>
</li>
	
<li>
<span class="codefrag">Queue</span>
</li>
	
<li>
<span class="codefrag">QueueConnection</span>
</li>
	
<li>
<span class="codefrag">QueueSession</span>
</li>
	
<li>
<span class="codefrag">QueueSender</span>
</li>
	
<li>
<span class="codefrag">QueueReceiver</span>
</li>

</ul>
<p>Igual que en modelo general JMS, obtendremos tanto los objetos <span class="codefrag">QueueConnectionFactory</span> como <span class="codefrag">Queue</span> del proveedor JMS via JNDI (mediante la inyecci&oacute;n de c&oacute;digo v&iacute;a anotaciones). Como puede observarse, la mayoria de los interfaces a&ntilde;aden el sufijo <span class="codefrag">Queue</span> al nombre del interfaz JMS. Las excepciones son el interfaz <span class="codefrag">Destination</span>, que se llama <span class="codefrag">Queue</span>, y los interfaces <span class="codefrag">MessageProducer</span> y <span class="codefrag">MessageConsumer</span> que pasan a ser <span class="codefrag">QueueSender</span> y <span class="codefrag">QueueReceiver</span>, respectivamente.</p>
<p>A continuaci&oacute;n podemos ver el mismo gr&aacute;fico de antes pero ahora respecto al modelo punto a punto.</p>
<p>

<img alt="Modelo Programaci&oacute;n Punto a Punto" content-width="13cm" src="imagenes/sesion1/modeloProgramacionQueue.jpg" width="506">
</p>
<p>Las aplicaciones que usan un modelo de mensajer&iacute;a punto a punto normalmente utilizan este API espec&iacute;fico en vez del API general.</p>
<a name="N103DA"></a><a name="API+Publicaci%C3%B3n%2FSubscripci%C3%B3n"></a>
<h4>API Publicaci&oacute;n/Subscripci&oacute;n</h4>
<p>Cada elemento espec&iacute;fico para las colas, tiene su correspondencia con el uso de t&oacute;picos. As&iacute; pues, tendremos los siguientes interfaces:</p>
<ul>
	
<li>
<span class="codefrag">TopicConnectionFactory</span>
</li>
	
<li>
<span class="codefrag">Topic</span>
</li>
	
<li>
<span class="codefrag">TopicConnection</span>
</li>
	
<li>
<span class="codefrag">TopicSession</span>
</li>
	
<li>
<span class="codefrag">TopicPublisher</span>
</li>
	
<li>
<span class="codefrag">TopicSubscriber</span>
</li>

</ul>
<p>A continuaci&oacute;n podemos ver el mismo gr&aacute;fico de antes pero ahora respecto al modelo <em>publish-subscribe</em>.</p>
<p>

<img alt="Modelo Programaci&oacute;n Publicaci&oacute;n-Subscripci&oacute;n" content-width="13cm" src="imagenes/sesion1/modeloProgramacionTopic.jpg" width="506">
</p>
</div> 



<a name="N10412"></a><a name="Recursos+JMS+en+Glassfish"></a>
<h2 class="underlined_10">Recursos JMS en Glassfish</h2>
<div class="section">
<p>Para una comunicaci&oacute;n necesitamos dos tipos de objetos administrados: una factor&iacute;a de conexiones y una cola (o un t&oacute;pico). Estos objetos administrados est&aacute;n, como su nombre indica, gestionados por Glassfish. En Glassfish, como en otros servidores de aplicaciones, el administrador puede a&ntilde;adir o actualizar estos recursos. Para ver como se hace entremos en la consola de administraci&oacute;n.</p>
<p>Una vez estemos en la consola, consultaremos el panel izquierdo y seleccionaremos <strong>Recursos</strong> y a su vez <strong>Recursos JMS</strong>:</p>
<p>

<img alt="Acceso a los recursos JMS en Glassfish" content-width="12cm" src="imagenes/sesion1/glassfishRecursosJMS.jpg" width="556">
</p>
<a name="N1042D"></a><a name="Factor%C3%ADas+de+Conexi%C3%B3n-N1042D"></a>
<h3 class="underlined_5">Factor&iacute;as de Conexi&oacute;n</h3>
<p>Entonces, si pinchamos en el panel de la derecha, tenemos acceso a <strong>F&aacute;bricas de conexi&oacute;n</strong> y <strong>Recursos de destino</strong>. Al pinchar en la f&aacute;bricas de conexi&oacute;n podemos crear una nueva o bien editar las que est&eacute;n creadas.</p>
<p>

<img alt="Acceso a las f&aacute;bricas de conexi&oacute;n" content-width="12cm" src="imagenes/sesion1/glassfishFabricasConexion.jpg" width="713">
</p>
<p>En el ejemplo anterior, hay creada una de ellas cuyo nombre JNDI es <strong>jms/ConnectionFactory</strong> y aparece como habilitada. Si queremos ver sus par&aacute;metros hacemos click y vemos lo siguiente:</p>
<p>

<img alt="Algunos par&aacute;metros de las f&aacute;bricas de conexi&oacute;n" content-width="12cm" src="imagenes/sesion1/glassfishJMSConnectionFactory.jpg" width="712">
</p>
<a name="N10455"></a><a name="Destinos-N10455"></a>
<h3 class="underlined_5">Destinos</h3>
<p>De la misma forma, si consultamos <strong>Recursos de destino</strong> podemos ver los nombres JNDI de las colas y t&oacute;picos que est&aacute;n habilitados o, en su defecto, crearlos.</p>
<p>

<img alt="Recursos de destino" content-width="12cm" src="imagenes/sesion1/glassfishRecursosDestino.jpg" width="686">
</p>
<p>
Desde el panel de destinos se pueden activar, desactivar, crear, borrar. 
</p>
<p>Pero en cualquier caso, ya sea a trav&eacute;s de <em>Ant</em> o del acceso a la consola, la factor&iacute;a y los destinos a usar deber&aacute;n estar creados antes de que el cliente se ejecute.</p>
</div>





<a name="N10475"></a><a name="Una+Aplicaci%C3%B3n+JMS"></a>
<h2 class="underlined_10">Una Aplicaci&oacute;n JMS</h2>
<div class="section">
<p>Una aplicaci&oacute;n JMS ser&aacute; tan simple o compleja como sean sus requisitos de negocio. Igual que con JDBC, es com&uacute;n aislar el c&oacute;digo JMS mediante componentes o en su propia capa.</p>
<p>Los pasos que seguir&aacute; todo componente JMS ser&aacute;n:</p>
<ol>
	
<li>Adquirir una factor&iacute;a de conexi&oacute;n.</li>
	
<li>Crear una conexi&oacute;n mediante la factor&iacute;a de conexi&oacute;n.</li>
	
<li>Comenzar la conexi&oacute;n.</li>
	
<li>Crear una sesi&oacute;n a partir de la conexi&oacute;n.</li>
	
<li>Adquirir un destino.</li>
	
<li>Dependiendo de si enviamos o recibimos
	<ul>
		
<li>Crear un productor.
			<ol>
				
<li>Crear un productor.</li>
				
<li>Crear un mensaje y adjuntarlo a su destino.</li>
			
</ol>
		
</li>
		
<li>Crear un consumidor.
			<ol>
				
<li>Crear un consumidor.</li>
				
<li>Opcionalmente registrar un listener de mensajes</li>
			
</ol>
		
</li>
	
</ul>
</li>
	
<li>Enviar/Recibir el/los mensaje/s</li>
	
<li>Cerrar los objetos (consumidor, productor, sesi&oacute;n, conexi&oacute;n)</li>

</ol>
<p>A continuaci&oacute;n, veremos un ejemplo por cada tipo de dominio de JMS. Ambos ejemplos se basan </p>
<a name="N104B9"></a><a name="Ejemplo+de+PTP"></a>
<h3 class="underlined_5">Ejemplo de PTP</h3>
<p>A continuaci&oacute;n vamos a ver un ejemplo de dos clientes PTP, uno que produce mensajes a una cola, y otro que consume dichos mensajes de la misma cola.</p>
<p>Lo primero que tenemos que hacer es crear un proyecto de cliente empresarial <em><span class="codefrag">(File -&gt; New Project -&gt; Java EE -&gt; Enterprise Application Client)</span></em>.</p>
<a name="N104C9"></a><a name="Productor"></a>
<h4>Productor</h4>
<pre class="code">package org.especialistajee.jms;

// imports

public class Productor {

    <em>@Resource(mappedName = "jms/ConnectionFactory")</em>
    private static ConnectionFactory connectionFactory;
    <em>@Resource(mappedName = "jms/Queue")</em>
    private static Queue queue;

    public void enviaMensajeCola(String mundo) throws JMSException {

        Connection connection = null;
        Session session = null;

        MessageProducer producer = null;
        Message message = null;
        boolean esTransaccional = false;

        try {
            connection = connectionFactory.createConnection();
            <em>// Recordar llamar a start() para permitir el envio de mensajes</em>
            connection.start();
            <em>// Creamos una sesion sin transaccionalidad y con envio de acuse automatico</em>
            session = connection.createSession(esTransaccional, Session.AUTO_ACKNOWLEDGE);
            <em>// Creamos el productor a partir de una cola</em>
            producer = session.createProducer(queue);
            <em>// Creamos un mensaje sencillo de texto</em>
            message = session.createTextMessage(mundo);
            <em>// Mediante le productor, enviamos el mensaje</em>
            producer.send(message);
			
            System.out.println("Enviado mensaje [" + mundo + "]");
        } finally {
            <em>// Cerramos los recursos</em>
            producer.close();
            session.close();
            connection.close();
        }
    }

    public static void main(String[] args) throws Exception {
        Productor p = new Productor();
        p.enviaMensajeCola("Hola Mundo");
        p.enviaMensajeCola("Adios Mundo");
    }
}
</pre>
<p>Este ejemplo demuestra los pasos necesarios para crear un producto JMS y enviar un mensaje a un destino. Destacar que este cliente no se preocupa de que haya un consumidor JMS al otro lado esperando un mensaje. La mediaci&oacute;n de los mensajes entre los productores y los consumidores es tarea del MOM, y de ah&iacute; una de las grandes virtudes de las aplicaciones JMS.</p>
<p>Una vez que el mensaje se ha enviado al destino, un consumidor recibir&aacute; el mensaje.</p>
<a name="N104F2"></a><a name="Consumidor"></a>
<h4>Consumidor</h4>
<p>El consumidor lo hemos separado en dos clases distintas para diferenciar el tratamiento s&iacute;ncrono del as&iacute;crono.</p>
<a name="N104FB"></a><a name="Consumidor+S%C3%ADncrono"></a>
<h5>Consumidor S&iacute;ncrono</h5>
<pre class="code">package org.especialistajee.jms;

// imports

public class ConsumidorSincrono {

    @Resource(mappedName = "jms/ConnectionFactory")
    private static ConnectionFactory connectionFactory;
    @Resource(mappedName = "jms/Queue")
    private static Queue queue;

    public void recibeMensajeSincronoCola() throws JMSException {

        Connection connection = null;
        Session session = null;

        MessageConsumer consumer = null;
        TextMessage message = null;
        boolean esTransaccional = false;

        try {
            connection = connectionFactory.createConnection();
            <em>// Recordar llamar a start() para permitir la recepci&oacute;n de mensajes</em>
            connection.start();
            <em>// Creamos una sesion sin transaccionalidad y con envio de acuse automatico</em>
            session = connection.createSession(esTransaccional, Session.AUTO_ACKNOWLEDGE);
            <em>// Creamos el consumidor a partir de una cola</em>
            consumer = session.createConsumer(queue);
            <em>// Recibimos un mensaje de texto</em>
            <strong>message = (TextMessage) consumer.receive();</strong>

            <em>// Sacamos el mensaje por consola</em>
            System.out.println("Recibido sincrono [" + message.getText() + "]");
            System.out.println("Fin sincrono");
        } finally {
            <em>// Cerramos los recursos</em>
            consumer.close();
            session.close();
            connection.close();
        }
    }

    public static void main(String[] args) throws Exception {
        ConsumidorSincrono p = new ConsumidorSincrono();
        p.recibeMensajeSincronoCola();
    }
}
</pre>
<p>En el m&eacute;todo de tratamiento s&iacute;ncrono, el m&eacute;todo <span class="codefrag">receive</span> bloquea la ejecuci&oacute;n hasta que no recibe el mensaje.</p>
<p>Una llamada como &eacute;sta, sin argumentos, o con un argumento <span class="codefrag">0</span>, bloquea al receptor indefinidamente hasta que se produce un mensaje o se cierra la aplicaci&oacute;n. Si queremos esperar solo por un tiempo limitado podemos pasarle un argumento <span class="codefrag">long</span> que indica un <em>timeout</em>. Si no queremos esperar nada, llamaremos al m&eacute;todo <span class="codefrag">receiveNoWait()</span> (sin argumentos) que recibe el siguiente mensaje si hay alguno disponible, y devuelve <span class="codefrag">null</span> en otro caso.</p>
<a name="N10533"></a><a name="Consumidor+As%C3%ADncrono"></a>
<h5>Consumidor As&iacute;ncrono</h5>
<pre class="code">package org.especialistajee.jms;

// imports

public class ConsumidorAsincrono {

    @Resource(mappedName = "jms/ConnectionFactory")
    private static ConnectionFactory connectionFactory;
    @Resource(mappedName = "jms/Queue")
    private static Queue queue;

    public void recibeMensajeAsincronoCola() throws JMSException {
        Connection connection = null;
        Session session = null;

        MessageConsumer consumer = null;
        TextoListener listener = null;
        boolean esTransaccional = false;

        try {
            connection = connectionFactory.createConnection();
            <em>// Creamos una sesion sin transaccionalidad y con envio de acuse automatico</em>
            session = connection.createSession(esTransaccional, Session.AUTO_ACKNOWLEDGE);
            <em>// Creamos el consumidor a partir de una cola</em>
            consumer = session.createConsumer(queue);
            <em>// Creamos el listener, y lo vinculamos al consumidor -&gt; asincrono</em>
            <strong>listener = new TextoListener();
            consumer.setMessageListener(listener);</strong>
            <em>// Llamamos a start() para empezar a consumir</em>
            connection.start();
			
            <em>// Sacamos el mensaje por consola</em>
            System.out.println("Fin asincrono");
        } finally {
            <em>// Cerramos los recursos</em>
            consumer.close();
            session.close();
            connection.close();
        }
    }

    public static void main(String[] args) throws Exception {
        ConsumidorAsincrono p = new ConsumidorAsincrono();
        p.recibeMensajeAsincronoCola();
    }
}
</pre>
<p>De la parte as&iacute;ncrona, destacar la necesidad de crear un <span class="codefrag">MessageListener</span> que ser&aacute; el encargado de recibir el mensaje y realizar las acciones oportunas. Por ello, una vez creado el listener, se le adjunta al consumidor.</p>
<p>A continuaci&oacute;n podemos ver el listener de mensajes para la recepci&oacute;n as&iacute;ncrona, el cual implementa el m&eacute;todo <span class="codefrag">onMessage</span>:</p>
<pre class="code">package org.especialistajee.jms;

// imports

public class TextoListener implements MessageListener {

    <em>/**
    * Casts del mensaje a un mensaje de texto y se muestra por consola
    * @param message mensaje de entrada
    */</em>
    @Override
    <strong>public void onMessage(Message message)</strong> {
        TextMessage msg = null;
	
        try {
            if (message instanceof TextMessage) {
                msg = (TextMessage) message;
                System.out.println("Recibido asincrono [" + msg.getText() + "]");
            } else {
                System.err.println("El mensaje no es de tipo texto");
            }
        } catch (JMSException e) {
            System.err.println("JMSException en onMessage(): " + e.toString());
        } catch (Throwable t) {
            System.err.println("Exception en onMessage():" + t.getMessage());
        }
    }
}
</pre>
<p>Si lanzamos el consumidor antes del productor entonces &eacute;ste estar&aacute; esperando hasta que el productor los env&iacute;e y obtendremos la misma salida. Esto sucede si usamos colas, cuando usamos t&oacute;picos como destinos las cosas 
cambian, como veremos en la siguiente secci&oacute;n.</p>
<p>Si lanzamos el consumidor despu&eacute;s del productor, el primero recibir&aacute; los mensajes dependiendo del tiempo de vida de los mismos (que por defecto es 0).</p>
<a name="N10571"></a><a name="Ejemplo+de+Pub%2FSub"></a>
<h3 class="underlined_5">Ejemplo de Pub/Sub</h3>
<p>De igual modo, con el modelo <em>publish/subscribe</em> tenemos los siguientes ejemplos:</p>
<a name="N1057D"></a><a name="Publicador"></a>
<h4>Publicador</h4>
<pre class="code">package org.especialistajee.jms;

// imports

public class Publicador {

    @Resource(mappedName = "jms/ConnectionFactory")
    private static ConnectionFactory connectionFactory;
    @Resource(mappedName = "jms/Topic")
    private static Topic topic;

    public void enviaMensajeTopico(String mundo) throws JMSException {

        Connection connection = null;
        Session session = null;

        MessageProducer publisher = null;
        Message message = null;
        boolean esTransaccional = false;

        try {
            connection = connectionFactory.createConnection();
            // Recordar llamar a start() para permitir el envio de mensajes
            connection.start();
            // Creamos una sesion sin transaccionalidad y con envio de acuse automatico
            session = connection.createSession(esTransaccional, Session.AUTO_ACKNOWLEDGE);
            // Creamos el publicador a partir de un topico
            publisher = session.createProducer(topic);
            // Creamos un mensaje sencillo de texto
            message = session.createTextMessage(mundo);
            // Mediante el publicador, enviamos el mensaje
            publisher.send(message);
			
            System.out.println("Enviado mensaje [" + mundo + "]");
        } finally {
            // Cerramos los recursos
            publisher.close();
            session.close();
            connection.close();
        }
    }

    /**
     * Creamos y lanzamos el publicador
     */
    public static void main(String[] args) throws Exception {
        Publicador p = new Publicador();
        p.enviaMensajeTopico("Hola Mundo");
        p.enviaMensajeTopico("Adios Mundo");
    }
}
</pre>
<p>Si comparamos el c&oacute;digo del productor con el del publicador podemos ver que es el mismo excepto a la hora de crear el <span class="codefrag">MessageProducer</span>. En el caso de <em>PTP</em> se utiliza una cola, y para <em>Pub/Sub</em> un t&oacute;pico.</p>
<a name="N10594"></a><a name="Subscriptor"></a>
<h4>Subscriptor</h4>
<p>Del mismo modo que con los consumidores, hemos separado los subscriptores en dos:</p>
<a name="N1059D"></a><a name="Subscriptor+S%C3%ADncrono"></a>
<h5>Subscriptor S&iacute;ncrono</h5>
<pre class="code">package org.especialistajee.jms;

// imports

public class SubscriptorSincrono {

    @Resource(mappedName = "jms/ConnectionFactory")
    private static ConnectionFactory connectionFactory;
    @Resource(mappedName = "jms/Topic")
    private static Topic topic;

    public void recibeMensajeSincronoTopico() throws JMSException {

        Connection connection = null;
        Session session = null;

        MessageConsumer subscriber = null;
        TextMessage message = null;
        boolean esTransaccional = false;

        try {
            connection = connectionFactory.createConnection();
            // Recordar llamar a start() para permitir el envio de mensajes
            connection.start();
            // Creamos una sesion sin transaccionalidad y con envio de acuse automatico
            session = connection.createSession(esTransaccional, Session.AUTO_ACKNOWLEDGE);
            // Creamos el subscriptor a partir de un topico
            subscriber = session.createConsumer(topic);
            // Recibimos un mensaje de texto
            message = (TextMessage) subscriber.receive();
			
            // Sacamos el mensaje por consola
            System.out.println("Recibido sincrono [" + message.getText() + "]");
            System.out.println("Fin sincrono");
        } finally {
            // Cerramos los recursos
            subscriber.close();
            session.close();
            connection.close();
        }
    }

    public static void main(String[] args) throws Exception {
        SubscriptorSincrono p = new SubscriptorSincrono();
        p.recibeMensajeSincronoTopico();
    }
}
</pre>
<p>Al comparar con el consumidor, este subscriptor tambi&eacute;n es id&eacute;ntico excepto a la hora de crear el <span class="codefrag">MessageConsumer</span> (&eacute;ste se basa en un t&oacute;pico).</p>
<a name="N105AE"></a><a name="Subscriptor+As%C3%ADncrono"></a>
<h5>Subscriptor As&iacute;ncrono</h5>
<pre class="code">package org.especialistajee.jms;

// imports

public class SubscriptorAsincrono {

    @Resource(mappedName = "jms/ConnectionFactory")
    private static ConnectionFactory connectionFactory;
    @Resource(mappedName = "jms/Topic")
    private static Topic topic;

    public void recibeMensajeAsincronoTopico() throws JMSException {

        Connection connection = null;
        Session session = null;

        MessageConsumer subscriber = null;
        TextoListener listener = null;
        boolean esTransaccional = false;

        try {
            connection = connectionFactory.createConnection();
            // Creamos una sesion sin transaccionalidad y con envio de acuse automatico
            session = connection.createSession(esTransaccional, Session.AUTO_ACKNOWLEDGE);
            // Creamos el subscriptor a partir de un topico
            subscriber = session.createConsumer(topic);
            // Creamos el listener, y lo vinculamos al subscriptor -&gt; asincrono
            listener = new TextoListener();
            subscriber.setMessageListener(listener);
            // Llamamos a start() para empezar a consumir
            connection.start();
			
            // Sacamos el mensaje por consola
            System.out.println("Fin asincrono");
        } finally {
            // Cerramos los recursos
            subscriber.close();
            session.close();
            connection.close();
        }
    }

    public static void main(String[] args) throws Exception {
        SubscriptorAsincrono p = new SubscriptorAsincrono();
        p.recibeMensajeAsincronoTopico();
    }
}
</pre>
<p>Y el as&iacute;ncrono tambi&eacute;n es similar, tanto que el listener que utilizamos es semejante al utilizado en el ejemplo del consumidor as&iacute;ncrono.</p>
</div>


<p>Si ejecutamos el subscriptor antes que el publicador, veremos que el subscriptor s&iacute;ncrono se <em>cuelga</em> puesto que los mensajes que hab&iacute;an sido enviados antes de lanzar el subscriptor no pueden ser recibidos. Esto se debe al modelo Pub/sub, ya que un cliente subscrito a un t&oacute;pico puede leer mensajes de &eacute;l solo <em>despu&eacute;s</em> de haber realizado la subscripci&oacute;n, y en este caso sucede al contrario. Ocurre lo mismo en el caso as&iacute;ncrono.</p>


<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2010-2011 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
</body>
</html>
