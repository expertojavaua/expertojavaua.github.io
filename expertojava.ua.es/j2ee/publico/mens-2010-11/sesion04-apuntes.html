<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Message Driven Beans (MDBs)</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servicios de Mensajes con JMS" src="images/baner_j2ee_der.gif" title="Servicios de Mensajes con JMS"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servicios de Mensajes con JMS</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servicios de Mensajes con JMS</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servicios de Mensajes con JMS">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html" title="1. Introducci&oacute;n a JMS">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="2. Mensajes. Robustez en JMS">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html" title="3. Durable Subscribers y Transacciones. JMS y JavaEE">Sesi&oacute;n 3</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 4</div>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html" title="1. Introducci&oacute;n a JMS">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html" title="2. Mensajes. Robustez en JMS">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html" title="3. Durable Subscribers y Transacciones. JMS y JavaEE">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html" title="4. Message Driven Beans">Sesi&oacute;n 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion04-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Message Driven Beans (MDBs)</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n">Introducci&oacute;n</a>
</li>
<li>
<a href="#Por+Qu%C3%A9+Utilizar+MDBs">Por Qu&eacute; Utilizar MDBs</a>
<ul class="minitoc">
<li>
<a href="#Multihilo">Multihilo</a>
</li>
<li>
<a href="#C%C3%B3digo+de+Mensajer%C3%ADa+Simplicado">C&oacute;digo de Mensajer&iacute;a Simplicado</a>
</li>
<li>
<a href="#Inicio+de+Consumo+de+Mensajes">Inicio de Consumo de Mensajes</a>
</li>
</ul>
</li>
<li>
<a href="#Reglas+de+Programaci%C3%B3n">Reglas de Programaci&oacute;n</a>
</li>
<li>
<a href="#Ejemplo+de+un+Consumidor+con+MDBs">Ejemplo de un Consumidor con MDBs</a>
</li>
<li>
<a href="#Anotaciones+de+un+MDB">Anotaciones de un MDB</a>
<ul class="minitoc">
<li>
<a href="#Uso+de+la+Anotaci%C3%B3n+con+%40MessageDriven">Uso de la Anotaci&oacute;n con @MessageDriven</a>
</li>
<li>
<a href="#Implementado+el+MessageListener">Implementado el MessageListener</a>
</li>
<li>
<a href="#Uso+de+ActivationConfigProperty">Uso de ActivationConfigProperty</a>
<ul class="minitoc">
<li>
<a href="#acknowledgeMode">acknowledgeMode</a>
</li>
<li>
<a href="#subscriptionDurability">subscriptionDurability</a>
</li>
<li>
<a href="#messageSelector">messageSelector</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Uso+de+los+Callbacks+del+Ciclo+de+Vida+del+Bean">Uso de los Callbacks del Ciclo de Vida del Bean</a>
</li>
<li>
<a href="#Env%C3%ADo+de+Mensajes+JMS+desde+MDBs">Env&iacute;o de Mensajes JMS desde MDBs</a>
</li>
<li>
<a href="#Gestionando+las+Transacciones+Distribuidas">Gestionando las Transacciones Distribuidas</a>
<ul class="minitoc">
<li>
<a href="#Transacciones+CMT+y+BMT+dentro+de+un+MDB">Transacciones CMT y BMT dentro de un MDB</a>
</li>
</ul>
</li>
<li>
<a href="#Mejores+Pr%C3%A1cticas">Mejores Pr&aacute;cticas</a>
<ul class="minitoc">
<li>
<a href="#Elige+con+Cuidado+el+Modelo+de+Mensajer%C3%ADa">Elige con Cuidado el Modelo de Mensajer&iacute;a</a>
</li>
<li>
<a href="#Modulariza">Modulariza</a>
</li>
<li>
<a href="#Bueno+Uso+de+los+Filtros+de+Mensajes">Bueno Uso de los Filtros de Mensajes</a>
</li>
<li>
<a href="#Elige+el+Tipo+de+Mensajes+con+Cuidado">Elige el Tipo de Mensajes con Cuidado</a>
</li>
<li>
<a href="#Cuidado+con+los+Mensajes+Venenosos">Cuidado con los Mensajes Venenosos</a>
</li>
<li>
<a href="#Configura+el+Tama%C3%B1o+del+Pool+MDB">Configura el Tama&ntilde;o del Pool MDB</a>
</li>
</ul>
</li>
</ul>
</div>

<a name="N1000E"></a><a name="Introducci%C3%B3n"></a>
<h2 class="underlined_10">Introducci&oacute;n</h2>
<div class="section">
<p>Un <em>Message-Driven Bean</em> o MDB (EJB dirigido por mensajes) es un oyente de mensajes que puede consumir mensajes de una cola o de una <em>durable subscription</em>. Dichos mensajes pueden ser enviados por cualquier componente JavaEE (cliente, otro EJB o una componente Web como un servlet). Incluso desde una aplicaci&oacute;n o sistema que no use tecnolog&iacute;a JavaEE.</p>
<p>Conceptualmente se dise&ntilde;aron para que el servidor de aplicaciones proporcionase facilidades de <em>multi-threading</em>, esto es que m&uacute;ltiples consumidores procesen mensajes concurrentemente sin necesidad de desarrollar c&oacute;digo adicional. As&iacute;, los MDBs proporcionan dicha facilidad al manejar los mensajes entrantes mediante m&uacute;ltiples instancias de beans alojados en el <em>pool</em> del servidor de aplicaciones.</p>
<p>Al igual que en el caso de los clientes JMS <em>standalone</em> que se basan en el m&eacute;todo <span class="codefrag">onMessage()</span>, un MDB tambi&eacute;n contiene este m&eacute;todo que se invoca autom&aacute;ticamente a la llegada de un mensaje. Sin embargo, los MDBs difieren de estos clientes en que el contenedor EJB realiza autom&aacute;ticamente varias tareas de inicializaci&oacute;n que implementamos a mano en el cliente, como:</p>
<ul>
	
<li>Crear un consumidor as&iacute;ncrono (<span class="codefrag">MessageConsumer</span>/<span class="codefrag">QueueReceiver</span>/<span class="codefrag">TopicSubscriber</span>) para recibir el mensaje. En vez de crear el consumidor en el c&oacute;digo fuente, con un MDB asociamos el destino y la factor&iacute;a de conexiones durante el despliegue. Si se quiere especificar una subscripci&oacute;n duradera o un selector de mensajes tambi&eacute;n se puede hacer en tiempo de despliegue.</li>
	
<li>Registrar el listener de mensajes. El MDB registra el listener autom&aacute;ticamente sin que haya que codificar una llamada a <span class="codefrag">setMessageListener</span>.</li>
	
<li>Especificar el modo de acuse de recibo. El modo de acuse de recibo por defecto es <span class="codefrag">AUTO_ACKNOWLEDGE</span>, y se utiliza a no ser que se cambien mediante una propiedad de configuraci&oacute;n.</li>

</ul>
<p>Para ello el MDB usa la anotaci&oacute;n <span class="codefrag">@MessageDriven</span> para especificar las propiedades del bean o de la factor&iacute;a de conexi&oacute;n, tales como el tipo de destino, la subscripci&oacute;n duradera, el selector de mensajes, o el modo de acuse de recibo.</p>
<p>Por defecto, el contenedor iniciar&aacute; una transacci&oacute;n justo ANTES de llamar al m&eacute;todo <span class="codefrag">onMessage()</span> y har&aacute; un commit de esta transacci&oacute;n cuando dicho m&eacute;todo haga el return, a menos que la transacci&oacute;n est&eacute; marcada como rollback en el contexto del MDB.</p>
<p>Con respecto a otros EJBs, la diferencia fundamental con cualquier otro EJB es que el MDB no tiene interface local o remota. Solo la clase bean. Se parece a un <em>Stateless Session Bean</em> (SSB) porque sus instancias son short-lived y no retienen estado para un cliente espec&iacute;fico. Pero sus variables pueden contener informaci&oacute;n de estado entre los diferentes mensajes de cliente: por ejemplo, un conexi&oacute;n a una base de datos, o una referencia a un EJB, etc...</p>
<p>Como un SSB, un MDB puede tener varias instancias intercambiables ejecut&aacute;ndose al mismo tiempo. El contenedor puede hacer un pooling de instancias para permitir que los mensajes se procesen concurrentemente, lo cual puede afectar al orden en que se reciben los mensajes. Por lo tanto, como la concurrencia puede afectar el orden en que se entregan los mensajes, nuestras aplicaciones deber&aacute;n gestionar los mensajes que llegan en cadena, por ejemplo, mediante un control conversacional a nivel de aplicaci&oacute;n que vaya cacheando los mensajes hasta que se reciban todos.</p>
</div>


<a name="N10060"></a><a name="Por+Qu%C3%A9+Utilizar+MDBs"></a>
<h2 class="underlined_10">Por Qu&eacute; Utilizar MDBs</h2>
<div class="section">
<p>Frente a la mala fama, en t&eacute;rminos de escalabilidad, que ha acompa&ntilde;ado hasta ahora a los EJBs (antes de EJB3 claro!) los MDBs siempre han <em>mantenido el tipo</em>. Esto se debe a una serie de caracter&iacute;sticas que tienen los MDBs.</p>
<a name="N1006C"></a><a name="Multihilo"></a>
<h3 class="underlined_5">Multihilo</h3>
<p>Las aplicaciones de negocio pueden necesitar consumidores de mensajes multihilo que puedan procesar los mensajes de modo concurrente. Los MDBs evitan esta complejidad ya que soporta el multihilo sin necesidad de c&oacute;digo adicional. Los MDBs gestionan los mensajes entrantes mediante m&uacute;ltiples instancias de beans (dentro de un pool), y tan pronto como un nuevo mensaje llega al destino, una instancia MDB sale del pool para manejar el mensaje.</p>
<p>
	
<img alt="MDBs y Multihilo" content-width="14cm" src="imagenes/sesion4/multihilo.jpg" width="712">
</p>
<a name="N1007F"></a><a name="C%C3%B3digo+de+Mensajer%C3%ADa+Simplicado"></a>
<h3 class="underlined_5">C&oacute;digo de Mensajer&iacute;a Simplicado</h3>
<p>Los MDBs evitan la necesidad de codificar los aspectos mec&aacute;nicos asociados al procesamiento de mensajes (como buscar las factor&iacute;as de conexiones o los destinos, crear las conexiones, abrir sesiones, crear consumidores y adjuntar <em>listeners</em>). Mediante EJB 3, el uso de situaciones por defecto para las circunstancias m&aacute;s comunes elimina gran parte de la configuraci&oacute;n. En el peor caso, tendremos que ofrecer la informaci&oacute;n de configuraci&oacute;n via anotaciones o mediante el descriptor de despliegue.</p>
<a name="N1008C"></a><a name="Inicio+de+Consumo+de+Mensajes"></a>
<h3 class="underlined_5">Inicio de Consumo de Mensajes</h3>
<p>Para comenzar a recoger mensajes de la cola de peticiones, alguien necesita invocar el m&eacute;todo apropiado dentro del c&oacute;digo. En un entorno de producci&oacute;n, no queda claro quien y donde recae esta responsabilidad. El inicio de consumo de mensajes mediante un proceso manual claramente no es deseable. En un entorno de servidor, casi cualquier manera de ejecutar el m&eacute;todo al inicio del servidor es altamente dependiente del sistema; del mismo modo ocurre para detener la recepci&oacute;n de mensajes de manera manual.</p>
<p>Mediante los MDBs registrados, podremos iniciar o detener estos componentes de una manera sencilla cuando se arranque o detenga el servidor.</p>
</div>


<a name="N1009A"></a><a name="Reglas+de+Programaci%C3%B3n"></a>
<h2 class="underlined_10">Reglas de Programaci&oacute;n</h2>
<div class="section">
<p>Igual que los EJBs, los MDBs son POJOs que siguen un sencillo conjunto de reglas y que en ocasiones tienen anotaciones:</p>
<ol>
	
<li>La clase MDB debe directamente (mediante la palabra clave <span class="codefrag">implements</span> en la declaraci&oacute;n de la clase) o indirectamente (mediante anotaciones o descriptores) implementar un interfaz de <em>listener</em> de mensajes.</li>
	
<li>La clase MDB debe ser concreta, ni abstracta ni final.</li>
	
<li>La clase MDB debe ser un POJO y no una subclase de otro MDB.</li>
	
<li>La clase MDB debe declararse p&uacute;blica.</li>
	
<li>El constructor de la clase MDB no debe tener argumentos. Si no se tiene un constructor, el compilador implementar&aacute; un constructor por defecto. El contenedor usa ese constructor para crear instancias de MDBs.</li>
	
<li>No se puede definir un m&eacute;todo <span class="codefrag">finalize</span>. Si es necesario alguno c&oacute;digo de limpieza, se deber&iacute;a definir un m&eacute;todo designado como <span class="codefrag">PreDestroy</span>.</li>
	
<li>Los MDBs deben implementar los m&eacute;todos de la interfaz <span class="codefrag">MessageListener</span> y esos m&eacute;todos deben ser p&uacute;blicos, nunca est&aacute;ticos o finales.</li>
	
<li>Esta prohibido lanzar <span class="codefrag">javax.rmi.RemoteException</span> o cualquier excepci&oacute;n de ejecuci&oacute;n. Si se lanza un <span class="codefrag">RuntimeException</span>, la instancia MDB finalizar&aacute;.</li>

</ol>
</div>


<a name="N100D4"></a><a name="Ejemplo+de+un+Consumidor+con+MDBs"></a>
<h2 class="underlined_10">Ejemplo de un Consumidor con MDBs</h2>
<div class="section">
<p>A continuaci&oacute;n vamos a realizar el mismo consumidor que hicimos en la primera sesi&oacute;n, pero &uacute;nicamente de forma as&iacute;ncrona via MDBs.</p>
<pre class="code">
<strong>@MessageDriven(mappedName = "jms/Queue", activationConfig = {
    @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue")
})</strong>
public class ConsumidorMDBBean implements <strong>MessageListener</strong> {

    public ConsumidorMDBBean() {
        System.out.println("Constructor del MDB");
    }

    public void onMessage(Message message) {
        TextMessage msg = null;

        try {
            if (message instanceof TextMessage) {
                msg = (TextMessage) message;
                System.out.println("Recibido MDB [" + msg.getText() + "]");
            } else {
                System.err.println("El mensaje no es de tipo texto");
            }
        } catch (JMSException e) {
            System.err.println("JMSException en onMessage(): " + e.toString());
        } catch (Throwable t) {
            System.err.println("Exception en onMessage():" + t.getMessage());
        }
    }
}
</pre>
</div>


<a name="N100E7"></a><a name="Anotaciones+de+un+MDB"></a>
<h2 class="underlined_10">Anotaciones de un MDB</h2>
<div class="section">
<a name="N100ED"></a><a name="Uso+de+la+Anotaci%C3%B3n+con+%40MessageDriven"></a>
<h3 class="underlined_5">Uso de la Anotaci&oacute;n con @MessageDriven</h3>
<p>Los MDBS son sin duda los EJBs m&aacute;s sencillos de desarrollar, y por tanto soportan muy pocas anotaciones. De hecho, la anotaci&oacute;n <span class="codefrag">@MessageDriven</span> y su anidada <span class="codefrag">@ActivationConfigProperty</span> con las &uacute;nicas anotaciones espec&iacute;ficas de los MDBs.</p>
<p>La anotacion <span class="codefrag">@MessageDriven</span> utilizada en el ejemplo representa el caso t&iacute;pico que se utilizar&aacute; la mayor&iacute;a de las veces. La anotaci&oacute;n se define as&iacute;:</p>
<pre class="code">@Target(TYPE)
@Retention(RUNTIME)
public @interface MessageDriven {
    String name() default "";
    Class messageListenerInterface default Object.class;
    ActivationConfigProperty[] activationConfig() default {};
    String mappedName();
    String description();
}
</pre>
<p>Destacar que todos los argumentos son opcionales, de modo, que en su uso m&aacute;s minimalista la anotaci&oacute;n quedar&aacute; as&iacute;:</p>
<pre class="code">@MessageDriven
public class GestorPeticionesCompraMDB
</pre>
<p>dejando todo los detalles para el descriptor de despliegue.</p>
<p>El primer elemento, <span class="codefrag">name</span>, especifica el nombre del MDB (en nuestro caso <span class="codefrag">GestorPeticionesCompraMDB</span>). Si el nombre del elemento se omite, el c&oacute;digo utiliza el nombre de la clase como nombre del MDB. El segundo par&aacute;metro, <span class="codefrag">messageListenerInterface</span>, especifica que listener de mensajes implementa el MDB. El par&aacute;metro <span class="codefrag">actionConfig</span> se utiliza para especificar propiedades de configuraci&oacute;n espec&iacute;ficas del listener. Finalmente, mediante <span class="codefrag">mappedName</span> indicaremos la ruta JNDI del destino.</p>
<a name="N10123"></a><a name="Implementado+el+MessageListener"></a>
<h3 class="underlined_5">Implementado el MessageListener</h3>
<p>Un MDB implementa un interfaz de listener de mensaje por la misma raz&oacute;n que los consumidores JMS implementan el interfaz <span class="codefrag">javax.jms.MessageListener</span>. El contenedor utiliza el listener para registrar el MDB en el proveedor de mensajes y pasar los mensajes de entrada a los m&eacute;todos implementados en el listener.</p>
<p>Utilizar el par&aacute;metro <span class="codefrag">messageListenerInterface</span> de la anotaci&oacute;n <span class="codefrag">@MessageDriven</span> es solo una manera de especificar un listener de mensajes. Podr&iacute;amos hacer lo mismo de este otro modo:</p>
<pre class="code">@MessageDriven(
    name="MiGestorPeticionesCompra",
    <strong>messageListenerInterface="javax.jms.MessageListener"</strong>)
public class GestorPeticionesCompraMDB {
</pre>
<p>Sin embargo, es m&aacute;s c&oacute;modo omitir el par&aacute;metro y especificar el interfaz con la palabra clave <span class="codefrag">implements</span>:</p>
<pre class="code">public class GestorPeticionesCompraMDB implements MessageListener {</pre>
<p>Otra opci&oacute;n es especificar el interfaz del listener mediante el descriptor de despliegue, y dejar los detalles fuera del c&oacute;digo. La elecci&oacute;n entre un modo u otro suele ser cuesti&oacute;n de gustos, aunque algunas herramientas se sienten m&aacute;s c&oacute;modas con el segundo enfoque, ya que facilita la generaci&oacute;n de los m&eacute;todos del bean a partir del interfaz.</p>
<a name="N1014D"></a><a name="Uso+de+ActivationConfigProperty"></a>
<h3 class="underlined_5">Uso de ActivationConfigProperty</h3>
<p>La propiedad <span class="codefrag">activationConfig</span> de la anotacion <span class="codefrag">@MessageDriven</span> nos permite especificar la configuraci&oacute;n espec&iacute;fica de nuestro sistema de mensajer&iacute;a mediante un array de instancia de <span class="codefrag">ActivationConfigProperty</span>. La definici&oacute;n de <span class="codefrag">ActivationConfigProperty</span> es:</p>
<pre class="code">public @interface ActivationConfigProperty {
    String propertyName();
    String propertyValue();
}
</pre>
<p>Cada propiedad de activaci&oacute;n es un par (nombre, valor) que el proveedor conoce, entiende y utiliza para iniciar el MDB. El mejor modo de ver como funcionan estas propiedades es mediante ejemplo. En el siguiente ejemplo podemos ver como configuramos tres de las propiedades m&aacute;s comunes:</p>
<pre class="code">@MessageDriven(
    name="MiGestorPeticionesCompra",
    activationConfig = {
        @ActivationConfigProperty(
            propertyName="<strong>destinationType</strong>",
            propertyValue="javax.jms.Queue"),
        @ActivationConfigProperty(
            propertyName="<strong>connectionFactoryJndiName</strong>",
            propertyValue="jms/QueueConnectionFactory"),
        @ActivationConfigProperty(
            propertyName="<strong>destinationName</strong>",
            propertyValue="jms/PeticionesCompraQueue")
    }
)
</pre>
<p>La propiedad <span class="codefrag">destinationType</span> le indica al contenedor que este MDB est&aacute; escuchando de una cola. A continuaci&oacute;n, <span class="codefrag">connectionFactoryJndiName</span> le indica el nombre JNDI de la factor&iacute;a de conexiones que debe utilizarse para crear las conexiones JMS para el MDB. Y el <span class="codefrag">destinationName</span> indica que estamos escuchando mensajes que llegan a un destino cuyo nombre JNDI es <span class="codefrag">jms/PeticionesCompraQueue</span>.</p>
<p>A continuaci&oacute;n veremos otras propiedades JMS que ya hemos estudiado en las sesiones anteriores.</p>
<a name="N10188"></a><a name="acknowledgeMode"></a>
<h4>acknowledgeMode</h4>
<p>Ya sabemos que los mensajes no se eliminan de la cola hasta que el consumidor no env&iacute;a el acuse de recibo. Para sesiones no transaccionales, hay que elegir el modo m&aacute;s apropiado para el proyecto. El m&aacute;s com&uacute;n y conveniente es <span class="codefrag">AUTO_ACKNOWLEDGE</span>. El otro modo soportado por los MDBs es <span class="codefrag">DUPS_OK_ACKNOWLEDGE</span>.</p>
<p>Para cambiar el modo de acuse de recibo lo har&iacute;amos del siguiente modo:</p>
<pre class="code">@ActivationConfigProperty(
    propertyName="<strong>acknowledgeMode</strong>",
    propertyValue="DUPS_OK_ACKNOWLEDGE")
</pre>
<p>El tratamiento del acuse de recibo por parte de JMS ya lo vimos en la segunda sesi&oacute;n: <a href="sesion02-apuntes.html#Controlar+el+Acuse+de+Recibo+de+los+Mensajes">sesion02-apuntes.html#Controlar+el+Acuse+de+Recibo+de+los+Mensajes</a>
</p>
<a name="N101A8"></a><a name="subscriptionDurability"></a>
<h4>subscriptionDurability</h4>
<p>Si queremos que un MDB sea un subscritor duradero, tendremos algo as&iacute;:</p>
<pre class="code">@ActivationConfigProperty(
	propertyName="destinationType",
	propertyValue="javax.jms.Topic"),
@ActivationConfigProperty(
	propertyName="<strong>subscriptionDurability</strong>",
	propertyValue="Durable")</pre>
<p>Para subscripciones no duraderas, podemos fijar el valor de la propiedad <span class="codefrag">subscriptionDurability</span> a <span class="codefrag">NonDurable</span>, aunque este es el valor por defecto.</p>
<a name="N101C2"></a><a name="messageSelector"></a>
<h4>messageSelector</h4>
<p>La propiedad messageSelector es el homonimo MDB a aplicar un selector a un consumidor JMS. Si queremos hacer un selector con MDBs el cual obtenga aquellos mensajes del a&ntilde;o 2008 har&iacute;amos:</p>
<pre class="code">@ActivationConfigProperty(
	propertyName="<strong>messageSelector</strong>",
	propertyValue="Anyo = 2008")</pre>
<p>Los selectores de mensajes ya lo vimos en la segunda sesi&oacute;n: <a href="sesion02-apuntes.html#Selector+de+Mensajes">sesion02-apuntes.html#Selector+de+Mensajes</a>
</p>
</div> 



<a name="N101DD"></a><a name="Uso+de+los+Callbacks+del+Ciclo+de+Vida+del+Bean"></a>
<h2 class="underlined_10">Uso de los Callbacks del Ciclo de Vida del Bean</h2>
<div class="section">
<p>El contenedor es responsable de:</p>
<ul>
	
<li>Crear instancias MDBs y configurarlas.</li>
	
<li>Inyectar recursos, incluyendo el contexto 'message-driven'.</li>
	
<li>Colocar las instancias en un pool gestionado.</li>
	
<li>Cuando llega un mensaje, sacar un bean inactivo del pool (en este punto, el contenedor puede que tenga que incrementar el tama&ntilde;o del pool.</li>
	
<li>Ejecutar el m&eacute;todo de listener de mensajes (m&eacute;todo <span class="codefrag">onMessage</span>)</li>
	
<li>Al finalizar la ejecuci&oacute;n del m&eacute;todo <span class="codefrag">onMessage</span>, devolver al pool el bean.</li>
	
<li>Conforme sea necesario, retirar (o destruir) beans del pool.</li>

</ul>
<p>Un MDB es un EJB, y como tal, tiene un ciclo de vida, el cual tiene 3 estados: no existe, disponible y ocupado.</p>
<p>

<img alt="Ciclo de vida de un MDB" content-width="12cm" src="imagenes/sesion4/cicloVida.jpg" width="604">
</p>
<p>Los dos <em>callbacks</em> de ciclo de vida de un MDBs son (1) <span class="codefrag">PostContruct</span>, el cual se llama inmediatamente un vez el MDB se ha creado, iniciado y se le han inyectado todo los recursos, y (2) <span class="codefrag">PreDestroy</span>, que se llama antes de quitar y eliminar las instancias bean del pool. Estos <em>callbacks</em> se suelen utilizan para reservar y liberar recursos inyectados que se usan en el m&eacute;todo <span class="codefrag">onMessage</span>, que es lo que hemos hecho en nuestro ejemplo.</p>
<p>

<img alt="Callbacks de un MDB" content-width="8cm" src="imagenes/sesion4/ciclo.gif" width="400">
</p>
<div class="frame note">
<div class="label">M&eacute;todo Callback</div>
<div class="content">Para poder marcar un m&eacute;todo como <em>callback</em> &eacute;ste debe ser p&uacute;blico, no puede ser ni final ni est&aacute;tico, debe devolver <span class="codefrag">void</span> y puede recibir 0 o 1 argumento.</div>
</div>
<p>Para demostrar el uso de los <em>callbacks</em>, vamos a modificar el MDB de modo que cuando le llegue un mensaje, realice un acceso a la base de datos.</p>
<pre class="code">@MessageDriven(mappedName = "jms/Queue", activationConfig = {
    @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue")
})
public class ConsumidorMDBJDBCBean implements MessageListener {

    private java.sql.Connection connection;
    private DataSource dataSource;
    <strong>@Resource
    private MessageDrivenContext context;</strong>

    public ConsumidorMDBJDBCBean() {
        System.out.println("Constructor del MDB");
    }

    <strong>@Resource(name = "jdbc/biblioteca")</strong>
    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @<strong>PostConstruct
    public void initialize()</strong> {
        try {
            connection = dataSource.getConnection();
        } catch (SQLException sqle) {
            sqle.printStackTrace();
        }
    }

    <strong>@PreDestroy
    public void cleanup()</strong> {
        try {
            connection.close();
            connection = null;
        } catch (SQLException sqle) {
            sqle.printStackTrace();
        }
    }

    public void onMessage(Message message) {
        TextMessage msg = null;

        try {
            if (message instanceof TextMessage) {
                msg = (TextMessage) message;
                System.out.println("Recibido MDB [" + msg.getText() + "]");
            } else {
                System.err.println("El mensaje no es de tipo texto");
            }
            <em>// Accedemos a la base de datos;</em>
            this.preguntaBBDD("Total de Libros");
        } catch (JMSException jmse) {
            jmse.printStackTrace();
            <strong>context.setRollbackOnly();</strong>
        } catch (SQLException sqle) {
            sqle.printStackTrace();
            <strong>context.setRollbackOnly();</strong>
        } catch (Throwable t) {
            System.err.println("Exception en onMessage():" + t.getMessage());
            <strong>context.setRollbackOnly();</strong>
        }
    }

    private int preguntaBBDD(String mensaje) throws SQLException {
        int result = -1;

        Statement stmt = <strong>connection</strong>.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT COUNT(*) FROM LIBRO");
        if (rs.next()) {
            result = rs.getInt(0);
            System.out.println(mensaje + " " + result);
        }

        if (stmt != null) {
            stmt.close();
            stmt = null;
        }
        if (rs != null) {
            rs.close();
            rs = null;
        }

        return result;
    }
}
</pre>
<div class="frame note">
<div class="label">Ejemplo con JDBC</div>
<div class="content">Aunque en el ejemplo hayamos utilizado JDBC, es recomendable considerar JPA para acceder a la base de datos</div>
</div>
<p>En el ejemplo vamos a utilizar el datasource del proyecto web (<span class="codefrag">jdbc/biblioteca</span>), el cual se supone que ya ten&eacute;is creado, as&iacute; como la cola <span class="codefrag">jms/Queue</span> creada en la primera sesi&oacute;n.</p>
<p>Para evitar crear y destruir sesiones por cada llegada de un mensaje, utilizamos los m&eacute;todos callbacks y la inyecci&oacute;n de recursos. Primero inyectamos el <em>datasource</em> mediante la anotaci&oacute;n <span class="codefrag">@Resource</span> en el m&eacute;todo <span class="codefrag">setDataSource</span>. Esta anotaci&oacute;n le indica al contenedor EJB que deber&iacute;a buscar el datasource <span class="codefrag">jdbc/biblioteca</span> v&iacute;a <em>JNDI</em> y pas&aacute;rsela al m&eacute;todo <em>set</em>. Tras inyectar los recursos, el contenedor comprueba si hay alg&uacute;n m&eacute;todo anotado con <span class="codefrag">@PostConstruct</span> que deba invocarse antes de colocar el MDB en el pool. En nuestro caso, el m&eacute;todo <span class="codefrag">initialize</span>, el cual se encarga de crear un conexi&oacute;n a partir de la fuente de datos.</p>
<p>En alg&uacute;n punto, el contenedor decir que nuestro bean debe salir del pool y ser destruido (puede que al para el servidor). El callback <span class="codefrag">@PreDestroy</span> ofrece esta posibilidad para limpiar los recursos de un bean. Nosotros lo hemos utilizado en nuestro m&eacute;todo <span class="codefrag">cleanup</span>, que se encarga de cerrar la conexi&oacute;n con la base de datos.</p>
</div>


<a name="N1028C"></a><a name="Env%C3%ADo+de+Mensajes+JMS+desde+MDBs"></a>
<h2 class="underlined_10">Env&iacute;o de Mensajes JMS desde MDBs</h2>
<div class="section">
<p>Adem&aacute;s de los recursos de base de datos, los <em>callbacks</em> tambi&eacute;n se utilizan para gestionar los objetos administrados de JMS (los destinos y la factor&iacute;a de conexiones). Y aunque parezca un poco ir&oacute;nico, la tarea que m&aacute;s se realiza dentro de un MDB es enviar mensajes JMS. Por ejemplo, cuando un MDB recibe una petici&oacute;n puede que algo funcione mal o que la petici&oacute;n sea incompleta, y por tanto, la mejor manera de notificar esto es v&iacute;a JMS a una cola de error sobre la que estar&aacute; escuchando el productor del mensaje.</p>
<p>Vamos a modificar el primer ejemplo para que si el mensaje que recibe no es de tipo texto escriba en una cola de error. Para ello, aprovecharemos las ventajas que ofrece el MDB para inyectar las recursos y el uso de los <em>callbacks</em> para la creaci&oacute;n y destrucci&oacute;n de los recursos.</p>
<pre class="code">@MessageDriven(mappedName = "jms/Queue", activationConfig = {
    @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue")
})
public class ConsumidorMDBJMSBean implements MessageListener {

    private javax.jms.Connection jmsConnection;
    <strong>@Resource(name = "jms/ErrorQueue")
    private javax.jms.Destination errorQueue;
    @Resource(name = "jms/QueueConnectionFactory")
    private javax.jms.ConnectionFactory connectionFactory;</strong>
    @Resource
    private MessageDrivenContext context;

    <strong>@PostConstruct</strong>
    public void initialize() {
        try {
            <strong>jmsConnection = connectionFactory.createConnection();</strong>
        } catch (JMSException jmse) {
            jmse.printStackTrace();
        }
    }

    <strong>@PreDestroy</strong>
    public void cleanup() {
        try {
            <strong>jmsConnection.close();</strong>
        } catch (JMSException jmse) {
            jmse.printStackTrace();
        }
    }

    public void onMessage(Message message) {
        TextMessage msg = null;

        try {
            if (message instanceof TextMessage) {
                msg = (TextMessage) message;
                System.out.println("Recibido JMS-MDB [" + msg.getText() + "]");
            } else {
                System.err.println("El mensaje no es de tipo texto. Enviando mensaje a cola de error");
                <strong>this.enviaMensajeError();</strong>
            }
        } catch (JMSException jmse) {
            jmse.printStackTrace();
            context.setRollbackOnly();
        } catch (Throwable t) {
            System.err.println("Exception en onMessage():" + t.getMessage());
            context.setRollbackOnly();
        }
    }

    private void enviaMensajeError() throws JMSException {
        Session session = jmsConnection.createSession(true,
                Session.AUTO_ACKNOWLEDGE);
        MessageProducer producer = session.createProducer(errorQueue);
        TextMessage message = session.createTextMessage("El mensaje recibido deb&iacute;a ser de tipo texto");
        producer.send(message);
        session.close();
    }
}
</pre>
<p>Siguiendo el esquema del ejemplo anterior, hemos creado variables de instancia para almacenar la factor&iacute;a de conexiones y la cola para los mensajes de error. Tambi&eacute;n hemos utilizado los callbacks para crear y destruir la conexi&oacute;n con la cola.</p>
</div>


<a name="N102B8"></a><a name="Gestionando+las+Transacciones+Distribuidas"></a>
<h2 class="underlined_10">Gestionando las Transacciones Distribuidas</h2>
<div class="section">
<p>En los ejemplos JMS de las primeras sesiones, indic&aacute;bamos si la sesi&oacute;n JMS era o no transaccional. Por otro lado, si revisamos los ejemplos MDB no indicamos en ning&uacute;n sitio nada sobre la transaccionalidad. De hecho, le cedemos la decisi&oacute;n al contenedor para que utilice el comportamiento por defecto para los MDBs.</p>
<p>En concreto, por defecto, el contenedor comenzar&aacute; una transacci&oacute;n antes de iniciar el m&eacute;todo <span class="codefrag">onMessage</span> y realizar&aacute; el <em>commit</em> tras el <em>return</em> del m&eacute;todo, a no ser que se marque como <em>rollback</em> mediante el contexto <em>message-driven</em>.</p>
<p>Una aplicaci&oacute;n JavaEE que utiliza JMS puede utilizar transacciones para combinar el env&iacute;o o recepci&oacute;n de mensajes con modificaciones a una base de datos y cualquier otra operaci&oacute;n con un gestor de recursos. Las transacciones distribuidas nos permiten acceder a m&uacute;ltiples componentes de una aplicaci&oacute;n dentro de una &uacute;nica transacci&oacute;n. Por ejemplo, un Servlet puede empezar una transacci&oacute;n, acceder a varias bases de datos, invocar a un EJB que env&iacute;a un mensaje JMS y realizar un commit de la transacci&oacute;n. Sin embargo, persiste la restricci&oacute;n vista en la sesi&oacute;n anterior respecto a que la aplicaci&oacute;n no puede enviar un mensaje JMS y recibir una respuesta dentro de la misma transacci&oacute;n.</p>
<a name="N102D6"></a><a name="Transacciones+CMT+y+BMT+dentro+de+un+MDB"></a>
<h3 class="underlined_5">Transacciones CMT y BMT dentro de un MDB</h3>
<p>Con los MDBs, podemos utilizar transacciones tanto CMT como BMT. Para asegurar que todos los mensajes son recibidos y manejados dentro del contexto de una transacci&oacute;n, utilizaremos transacciones CMT, anotando el m&eacute;todo <span class="codefrag">onMessage</span> con el atributo transaccional a <span class="codefrag">Required</span> (es el atributo por defecto). Esto significa que si no hay ninguna transacci&oacute;n en progreso, se comenzar&aacute; una nueva antes de la llamada al m&eacute;todo y se realizar&aacute; el commit al finalizar el mismo.</p>
<p>Al utilizar transacciones CMT podemos emplear los siguientes m&eacute;todos del <span class="codefrag">MessageDrivenContext</span>:</p>
<ul>
	
<li>
<span class="codefrag">setRollbackOnly</span>: utiliza este m&eacute;todo para el manejo de los errores. Si salta una excepci&oacute;n, <span class="codefrag">setRollbackOnly</span> marca la transacci&oacute;n actual para que la &uacute;nica salida de la transacci&oacute;n sea un <em>rollback</em>.</li>
	
<li>
<span class="codefrag">getRollbackOnly</span>: utiliza este m&eacute;todo para comprobar si la transacci&oacute;n actual est&aacute; marcada para hacer <em>rollback</em>.</li>

</ul>
<p>Si utilizamos BMT, la entrega de un mensaje en el m&eacute;todo <span class="codefrag">onMessage</span> tiene lugar fuera del contexto de la transacci&oacute;n distribuida. La transacci&oacute;n comienza cuando se llama al m&eacute;todo <span class="codefrag">UserTransaction.begin</span> dentro del m&eacute;todo <span class="codefrag">onMessage</span>, y finaliza al llamar a <span class="codefrag">UserTransaction.commit</span> o <span class="codefrag">UserTransaction.rollback</span>. Cualquier llamada al m&eacute;todo <span class="codefrag">Connection.createSession</span> debe tener lugar dentro de la transacci&oacute;n. Tambi&eacute;n hay que destacar que si en un BMT llamamos a <span class="codefrag">UserTransaction.rollback</span>, no se realiza la re-entrega del mensaje, mientras que si en una transacci&oacute;n CMT llamamos a <span class="codefrag">setRollbackOnly</span>, si que provoca la re-entrega del mensaje.</p>
</div>


<a name="N1031E"></a><a name="Mejores+Pr%C3%A1cticas"></a>
<h2 class="underlined_10">Mejores Pr&aacute;cticas</h2>
<div class="section">
<p>Igual que todas las tecnolog&iacute;as, los MDB tienen algunos escollos que hay que evitar, y algunas mejores pr&aacute;cticas que debemos tener en mente.</p>
<a name="N10327"></a><a name="Elige+con+Cuidado+el+Modelo+de+Mensajer%C3%ADa"></a>
<h3 class="underlined_5">Elige con Cuidado el Modelo de Mensajer&iacute;a</h3>
<p>Antes de empezar a codificar c&oacute;digo como un loco, considera la elecci&oacute;n del modelo de mensaje de un modo cuidadoso. Lo m&aacute;s normal es que el modelo PTP resuelva tus problemas m&aacute;s del 90% de los casos. En ocasiones, aunque contadas, el enfoque Pub/Sub es mejor, sobretodo si env&iacute;as el mismo mensaje a m&aacute;s de un receptor.</p>
<p>Por suerte, la mayor&iacute;a del c&oacute;digo es independiente del dominio, y deber&iacute;as codificar as&iacute;, mediante los interfaces de m&aacute;s alto nivel. De este modo, cambiar el dominio deber&iacute;a ser una cuesti&oacute;n de configuraci&oacute;n.</p>
<a name="N10334"></a><a name="Modulariza"></a>
<h3 class="underlined_5">Modulariza</h3>
<p>Debido a que los MDBs son muy similares a los beans de sesi&oacute;n, es natural empezar a colocar l&oacute;gica de negocio dentro de los m&eacute;todos del listener de mensajes. La l&oacute;gica de negocio debe esta modularizada y desacoplada de los aspectos espec&iacute;ficos de la mensajer&iacute;a.</p>
<p>En el ejemplos hemos creado un m&eacute;todo privado para realizar la l&oacute;gica de negocio, aunque mejor habr&iacute;a sido colocarlo en una clase aparte, en concreto, dentro de nuestros objetos de negocio, y desde el <span class="codefrag">onMessage</span> del MDB invocar al m&eacute;todo de negocio adecuado.</p>
<a name="N10344"></a><a name="Bueno+Uso+de+los+Filtros+de+Mensajes"></a>
<h3 class="underlined_5">Bueno Uso de los Filtros de Mensajes</h3>
<p>Existen pocas razones para utilizar un &uacute;nico destino de mensaje para m&uacute;ltiples prop&oacute;sitos. Los selectores de mensajes son muy &uacute;tiles en estas circunstancias. Por ejemplo, si utilizamos la misma cola tanto para enviar peticiones de compra como notificar las cancelaciones de los pedidos, podemos hacer que el cliente utilice una propiedad de mensaje para identificar el tipo de petici&oacute;n. En el MDB utilizaremos un selector de mensaje para separar y manejar cada tipo de petici&oacute;n.</p>
<p>A la inversa, mejoraremos de forma dram&aacute;tica el rendimiento y mantendremos el c&oacute;digo m&aacute;s sencillo mediante destinos separados (en contra de los <em>selectors</em>). As&iacute;, utilizar&iacute;amos una cola para realizar las peticiones y otra para las cancelaciones de pedidos, siendo el cliente el que decide a que cola env&iacute;a el mensaje.</p>
<a name="N10354"></a><a name="Elige+el+Tipo+de+Mensajes+con+Cuidado"></a>
<h3 class="underlined_5">Elige el Tipo de Mensajes con Cuidado</h3>
<p>La elecci&oacute;n del tipo de mensaje no siempre es tan obvia como pueda parecer. Por ejemplo, una idea atractiva es utilizar cadenas de texto XML; esto hace que el acoplamiento entre sistemas sea d&eacute;bil. Si hubi&eacute;semos utilizado un objeto, estaremos obligando que al otro lado conozcan dicho objeto.</p>
<p>El problema de XML es que hincha el tama&ntilde;o de los mensajes de un modo significativo, degradando el rendimiento del MOM. En algunas ocasiones, la elecci&oacute;n correcta ser&aacute; utilizar flujos binarios dentro del cuerpo, ya que &eacute;ste tipo implica la mejor demanda de procesamiento MOM y consumo de memoria.</p>
<a name="N10361"></a><a name="Cuidado+con+los+Mensajes+Venenosos"></a>
<h3 class="underlined_5">Cuidado con los Mensajes Venenosos</h3>
<p>Un mensaje venenoso es un mensaje que recibe el MDB para el cual no est&aacute; preparado. Imagina que uno de nuestros MDBs no puede manejar uno de los mensajes recibidos, por ejemplo, porque esperamos un mensaje tipo <span class="codefrag">ObjectMessage</span> y recibimos uno de texto. La recepci&oacute;n, sin control, de este tipo de mensajes causa que la transacci&oacute;n en la que est&aacute; inmerso el MDB haga un <em>rollback</em>. En nuestros ejemplos hemos protegido al MDB de los mensajes venenosos ya que la recepci&oacute;n se realiza dentro de un <em>try/catch</em> y se invoca al <em>rollback</em> si se detecta la situaci&oacute;n. Sin embargo esto implica que como el MDB sigue escuchando, el mensaje venenoso se le enviar&aacute; una y otra vez y entraremos en un bucle infinito.</p>
<p>

<img alt="Mensajes Venenosos" content-width="12cm" src="imagenes/sesion4/poison.jpg" width="554">
</p>
<p>Afortunadamente muchos MOMs y contenedores EJB ofrecen mecanismos para tratar estos mensajes venenosos, incluyendo que: (a) no se intente el reenv&iacute;o m&aacute;s de un determinado n&uacute;mero de veces y (b) se habilite una cola de <em>dead messages</em>. Una vez un mensaje se ha intentado enviar el n&uacute;mero de veces que hemos fijado en la configuraci&oacute;n de la cola, &eacute;ste pasa a almacenar en la cola de <em>dead messages</em>. Esto se puede controlar configurando el destino adecuadamente.</p>
<p>Las malas noticias es que estos mecanismos no est&aacute;n estandarizados, y dependen del proveedor de mensajer&iacute;a.</p>
<div class="frame note">
<div class="label">Mensajes Venenosos en Glassfish</div>
<div class="content">

<em>Glassfish</em> utiliza las propiedades <span class="codefrag">endpointExceptionRedeliveryAttempts</span> y <span class="codefrag">sendUndeliverableMsgsToDMQ</span>. M&aacute;s informaci&oacute;n en 
<a href="http://docs.sun.com/app/docs/doc/820-6740/aeoon">docs.sun.com/app/docs/doc/820-6740/aeoon</a>.
</div>
</div>
<a name="N1039D"></a><a name="Configura+el+Tama%C3%B1o+del+Pool+MDB"></a>
<h3 class="underlined_5">Configura el Tama&ntilde;o del Pool MDB</h3>
<p>La mayor&iacute;a de contenedores EJB permiten especificar el n&uacute;mero m&aacute;ximo de instancias de un determinado MDB que puede crear el contenedor. De hecho, esto controla el nivel de concurrencia. Si hay 5 mensajes concurrentes a procesar y el tama&ntilde;o del pool es 3, el contenedor esperar&aacute; hasta que los 3 primeros mensajes hayan sido procesados para asignar m&aacute;s instancias.</p>
<p>Esta es una espada de doble filo y requiere mucho cuidado en su manejo. Si el tama&ntilde;o del pool es muy peque&ntilde;o, los mensajes se procesar&aacute;n lentamente. Al mismo tiempo, es deseable fijar un l&iacute;mite razonable al tama&ntilde;o del pool para que muchas instancias MDB concurrentes no ahoguen la m&aacute;quina.</p>
<p>Para la configuraci&oacute;n del pool mediante <em>Glassfish</em>, pod&eacute;is acceder a la siguiente informaci&oacute;n: <a href="http://docs.sun.com/app/docs/doc/820-4336/beaiu">docs.sun.com/app/docs/doc/820-4336/beaiu</a>
</p>
</div> 


<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2010-2011 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
</body>
</html>
