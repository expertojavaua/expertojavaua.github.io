<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Introducci&oacute;n a los Servicios Web. Invocaci&oacute;n de servicios web SOAP.</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servicios Web y SOA" src="images/baner_j2ee_der.gif" title="Servicios Web y SOA"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servicios Web</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servicios Web</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servicios Web">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menupage">
<div class="menupagetitle">Sesion 1</div>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion01-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Introducci&oacute;n a los Servicios Web. Invocaci&oacute;n de servicios web SOAP.</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#%C2%BFQu%C3%A9+es+un+Servicio+Web%3F">&iquest;Qu&eacute; es un Servicio Web?</a>
</li>
<li>
<a href="#Caracter%C3%ADsticas+de+los+Servicios+Web">Caracter&iacute;sticas de los Servicios Web</a>
</li>
<li>
<a href="#Tipos+de+servicios+Web">Tipos de servicios Web</a>
</li>
<li>
<a href="#Arquitectura+de+los+Servicios+Web">Arquitectura de los Servicios Web</a>
</li>
<li>
<a href="#Servicios+Web+SOAP+y+Java+EE">Servicios Web SOAP y Java EE</a>
</li>
<li>
<a href="#Tecnolog%C3%ADas+b%C3%A1sicas+para+Servicios+Web">Tecnolog&iacute;as b&aacute;sicas para Servicios Web</a>
<ul class="minitoc">
<li>
<a href="#SOAP">SOAP</a>
</li>
<li>
<a href="#WSDL">WSDL</a>
</li>
<li>
<a href="#UDDI">UDDI</a>
</li>
</ul>
</li>
<li>
<a href="#Interoperabilidad+de+los+WS%3A+Metro+y+JAX-WS">Interoperabilidad de los WS: Metro y JAX-WS</a>
</li>
<li>
<a href="#Los+servicios+Web+desde+la+vista+del+Cliente">Los servicios Web desde la vista del Cliente</a>
</li>
<li>
<a href="#Ficheros+WSDL+y+de+esquema+con+Netbeans">Ficheros WSDL y de esquema con Netbeans</a>
</li>
<li>
<a href="#Tipos+de+acceso+para+invocar+servicios+Web+JAX-WS">Tipos de acceso para invocar servicios Web JAX-WS</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+de+servicios+web+JAX-WS+con+JDK+1.6">Invocaci&oacute;n de servicios web JAX-WS con JDK 1.6</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+de+servicios+web+JAX-WS+desde+una+clase+Java+con+Maven">Invocaci&oacute;n de servicios web JAX-WS desde una clase Java con Maven</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+de+servicios+web+JAX-WS+desde+una+aplicaci%C3%B3n+Web+con+Maven">Invocaci&oacute;n de servicios web JAX-WS desde una aplicaci&oacute;n Web con Maven</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+de+servicios+web+con+Netbeans">Invocaci&oacute;n de servicios web con Netbeans</a>
</li>
<li>
<a href="#Gestor+de+servicios+web+de+Netbeans">Gestor de servicios web de Netbeans</a>
</li>
<li>
<a href="#Interfaz+de+invocaci%C3%B3n+din%C3%A1mica+%28DII%29">Interfaz de invocaci&oacute;n din&aacute;mica (DII)</a>
<ul class="minitoc">
<li>
<a href="#A+partir+de+un+documento+WSDL">A partir de un documento WSDL</a>
</li>
<li>
<a href="#Sin+un+documento+WSDL">Sin un documento WSDL</a>
</li>
</ul>
</li>
</ul>
</div>


<p>El dise&ntilde;o del software tiende a ser cada vez m&aacute;s modular. Las 
  aplicaciones se componen de una serie de componentes (servicios) reutilizables, 
  que pueden encontrarse distribuidos a lo largo de una serie de m&aacute;quinas 
  conectadas en red.</p>

<p>Los Servicios Web nos permitir&aacute;n distribuir nuestra aplicaci&oacute;n 
  a trav&eacute;s de Internet, pudiendo una aplicaci&oacute;n utilizar los servicios 
  ofrecidos por cualquier servidor conectado a Internet. La cuesti&oacute;n clave cuando hablamos de
  servicios Web es la interoperabilidad entre las aplicaciones.</p>


<a name="N10012"></a><a name="%C2%BFQu%C3%A9+es+un+Servicio+Web%3F"></a>
<h2 class="underlined_10">&iquest;Qu&eacute; es un Servicio Web?</h2>
<div class="section">
<p>Un Servicio Web es un componente al que podemos acceder mediante protocolos 
  Web est&aacute;ndar, utilizando XML para el intercambio de informaci&oacute;n.</p>
<p>Normalmente nos referimos con Servicio Web a una colecci&oacute;n de procedimientos 
  (m&eacute;todos) a los que podemos llamar desde cualquier lugar de Internet 
  o de nuestra intranet, siendo este mecanismo de invocaci&oacute;n totalmente 
  independiente de la plataforma que utilicemos y del lenguaje de programaci&oacute;n 
  en el que se haya implementado internamente el servicio.</p>
<p>Cuando conectamos con un servidor web desde nuestro navegador, el servidor nos 
  devuelve la p&aacute;gina web solicitada, que es un documento que se mostrar&aacute; 
  en el navegador para que lo visualice el usuario, pero es dif&iacute;cilmente 
  entendible por una m&aacute;quina. Podemos ver esto como web para humanos. En 
  contraposici&oacute;n, los Servicios Web ofrecen informaci&oacute;n con un formato 
  est&aacute;ndar que puede ser entendido f&aacute;cilmente por una aplicaci&oacute;n. 
  En este caso estar&iacute;amos ante una web para m&aacute;quinas. </p>
<p>Los servicios Web son componentes de aplicaciones distribuidas que est&aacute;n disponibles de
   forma externa. Se pueden utilizar para integrar aplicaciones escritas en diferentes lenguajes
   y que se ejecutan en plataformas diferentes. Los servicios Web son independientes de lenguaje
   y de la plataforma gracias a que los vendedores han admitido est&aacute;ndares comunes de Servicios
   Web.</p>
<p>El WC3 (<em>World Wide Web Consortium</em>) define un servicio Web como un sistema software dise&ntilde;ado
   para soportar interacciones m&aacute;quina a m&aacute;quina a trav&eacute;s de la red. Dicho de otro modo, los servicios Web
   proporcionan una forma estandar de interoperar entre aplicaciones software que se ejecutan en
   diferentes plataformas. Por lo tanto, su principal caracter&iacute;stica su gran <strong>interoperabilidad</strong> y
   extensibilidad as&iacute; como por proporcionar informaci&oacute;n f&aacute;cilmente procesable por las m&aacute;quinas gracias
   al uso de XML. Los servicios Web pueden combinarse con muy bajo acoplamiento para conseguir la
   realizaci&oacute;n de operaciones complejas. De esta forma, las aplicaciones que proporcionan servicios simples pueden 
   interactuar con otras para "entregar" servicios sofisticados a&ntilde;adidos.</p>
<div class="frame note">
<div class="label">Historia de los servicios Web</div>
<div class="content">
Los servicios Web fueron "inventados" para solucionar el problema de la <strong>interoperabilidad</strong> entre
las aplicaciones. Al principio de los 90, con el desarrollo de Internet/LAN/WAN, apareci&oacute; el gran problema de
integrar aplicaciones diferentes. Una aplicaci&oacute;n pod&iacute;a haber sido desarrollada en C++ o Java, y ejecutarse bajo
Unix, un PC, o un computador <em>mainframe</em>. No hab&iacute;a una forma f&aacute;cil de intercomunicar dichas aplicaciones.
Fu&eacute; el desarrollo de XML el que hizo posible compartir datos entre aplicaciones con diferentes plataformas 
hardware a trav&eacute;s de la red, o incluso a trav&eacute;s de Internet.
La raz&oacute;n de que se llamasen servicios Web es que fueron dise&ntilde;ados para residir en un servidor Web, y ser llamados
a trav&eacute;s de Internet, t&iacute;picamente via protocolos HTTP, o HTTPS. De esta forma se asegura que un servicio puede ser
llamado por cualquier aplicaci&oacute;n, usando cualquier lenguaje de programaci&oacute;n, y bajo cualquier sistema operativo, siempre
y cu&aacute;ndo, por supuesto, la conexi&oacute;n a Internet est&eacute; activa, y tenga
un puerto abierto HTTP/HTTPS, lo cual es cierto para casi cualquier computador que disponga de acceso a Internet. 
</div>
</div>
</div>

<a name="N10038"></a><a name="Caracter%C3%ADsticas+de+los+Servicios+Web"></a>
<h2 class="underlined_10">Caracter&iacute;sticas de los Servicios Web</h2>
<div class="section">
<p>Las caracter&iacute;sticas deseables de un Servicio Web son:</p>
<ul>
  
<li>Un servicio debe poder ser <strong>accesible a trav&eacute;s de la Web</strong>. 
    Para ello debe utilizar protocolos de transporte est&aacute;ndares como HTTP, 
    y codificar los mensajes en un lenguaje est&aacute;ndar que pueda conocer 
    cualquier cliente que quiera utilizar el servicio.</li>
  
<li>Un servicio debe contener una <strong>descripci&oacute;n de s&iacute; mismo</strong>. 
    De esta forma, una aplicaci&oacute;n podr&aacute; saber cu&aacute;l es la 
    funci&oacute;n de un determinado Servicio Web, y cu&aacute;l es su interfaz, 
    de manera que pueda ser utilizado de forma autom&aacute;tica por cualquier 
    aplicaci&oacute;n, sin la intervenci&oacute;n del usuario.</li>
  
<li>Debe poder <strong>ser localizado</strong>. Deberemos tener alg&uacute;n 
    mecanismo que nos permita encontrar un Servicio Web que realice una determinada 
    funci&oacute;n. De esta forma tendremos la posibilidad de que una aplicaci&oacute;n 
    localice el servicio que necesite de forma autom&aacute;tica, sin tener que 
    conocerlo previamente el usuario.</li>

</ul>
</div>


<a name="N10057"></a><a name="Tipos+de+servicios+Web"></a>
<h2 class="underlined_10">Tipos de servicios Web</h2>
<div class="section">
<p>A nivel conceptual, un servicio es un componente software proporcionado a trav&eacute;s de un <em>endpoint</em>
   accesible a trav&eacute;s de la red. Los servicios productores y consumidores utilizan mensajes para intercambiar
   informaci&oacute;n de invocaciones de petici&oacute;n y respuesta en forma de documentos auto-contenidos que hacen muy 
   pocas asunciones sobre las capacidades tecnol&oacute;gicas de cada uno de los receptores.</p>
<div class="frame note">
<div class="label">Definici&oacute;n de endpoint</div>
<div class="content">
Los servicios pueden interconectarse a trav&eacute;s de la red. En una arquitectura orientada a servicios, cualquier
interacci&oacute;n punto a punto implica dos <em>endpoints</em>: uno que proporciona un servicio, y otro de lo consume.
Es decir, que un <em>endpoint</em> es cada uno de los "elementos", en nuestro caso nos referimos a servicios, 
que se sit&uacute;an en ambos "extremos" de la red que sirve de canal de comunicaci&oacute;n entre ellos.
Cuando hablamos de servicios Web, un <em>endpoint</em> se especifica mediante una URI.
</div>
</div>
<p>A nivel t&eacute;cnico, los servicios pueden implementarse de varias formas. En este sentido, podemos distinguir dos tipos de 
   servicios Web: los denominados servicios Web "grandes" (<em>"big" Web Services</em>), los llamaremos servicios Web SOAP, y 
   servicios Web RESTful.</p>
<p>
<strong>Servicios Web SOAP</strong>
</p>
<p>Los servicios Web SOAP, o servicios Web <em>"big"</em>, utilizan mensajes XML para intercomunicarse que siguen el 
   est&aacute;ndar SOAP (<em>Simple Object Access Protocol</em>), un lenguaje XML que define la arquitectura y formato de los mensajes.
   Dichos sistemas normalmente contienen una descripci&oacute;n legible por la m&aacute;quina de la descripci&oacute;n de las operaciones
   ofrecidas por el servicio, escrita en WSDL (<em>Web Services Description Language</em>), que es un lenguaje basado en XML
   para definir las interfaces sint&aacute;cticamente.</p>
<p>El formato de mensaje SOAP y el lenguaje de definici&oacute;n de interfaces WSDL se ha extendido bastante, y muchas herramientas
   de desarrollo, por ejemplo Netbeans, pueden reducir la complejidad de desarrollar aplicaciones de servicios Web.</p>
<p>El dise&ntilde;o de un servicio basado en SOAP debe establecer un contrato formal para describir la interfaz que ofrece el servicio 
   Web. WSDL puede utilizarse para describir los detalles del contrato, que pueden incluir mensajes, operaciones, <em>bindings</em>, 
   y la localizaci&oacute;n del servicio Web. Tambi&eacute;n deben tenerse en cuenta los requermientos no funcionales, como por ejemplo
   las transacciones, necesidad de mantener el estado (<em>addressing</em>), seguridad y coordinaci&oacute;n</p>
<p>En este m&oacute;dulo vamos a hablar &uacute;nicamente en los Servicios Web SOAP.</p>
<p>
<strong>Servicios Web RESTful</strong>
</p>
<p>Los servicios Web RESTful (<em>Representational State Transfer Web Services</em>) son adecuados para escenarios de integraci&oacute;n
   b&aacute;sicos <em>ad-hoc</em>. Dichos servicios Web se suelen integrar mejor con HTTP que los servicios basado en SOAP, ya que no 
   requieren mensajes XML o definciones del servicio en forma de fichero WSDL</p>
<p>Los servicios Web REST utilizan est&aacute;ndares muy conocidos como HTTP, SML, URI, MIME, y tienen una infraestructura "ligera" que
   permite que los servicios se construyan utilizando herramientas de forma m&iacute;nima. Gracias a ello, el desarrollo de servicios RESTful
   es barato y tiene muy pocas "barreras" para su adopci&oacute;n. </p>
</div>



<a name="N100A6"></a><a name="Arquitectura+de+los+Servicios+Web"></a>
<h2 class="underlined_10">Arquitectura de los Servicios Web</h2>
<div class="section">
<p>Los servicios Web presentan una arquitectura orientada a servicios que permite crear una definici&oacute;n abstracta de un servicio,
   proporcionar una implementaci&oacute;n concreta de dicho servicio, publicar y localizar un servicio, seleccionar un instancia de un servicio,
   y utilizar dicho servicio con una elevada interoperabilidad. Es posible desacoplar la implementaci&oacute;n del servicio Web y su uso 
   por parte de un cliente. Tambi&eacute;n es posible desacoplar la implementaci&oacute;n del servicio y de cliente. Las implementaciones concretas del
   servicio pueden desacoplarse a nivel de l&oacute;gica y transporte. La siguiente figura muestra el diagrama de una arquitectura orientada a servicios.
</p>
<p>
<img alt="Arquitectura orientada a Servicios" content-width="8cm" src="imagenes/sesion1/arq_ws.png" width="500"></p>
<p>El proveedor del servicio define la descripci&oacute;n abstracta de dicho servicio utilizando un lenguaje de descripci&oacute;n de Servicios Web (<em>WSDL: Web
   Services Description Language: </em>). A continuaci&oacute;n se crea un Servicio concreto a partir de la descripci&oacute;n abstracta del servicio, produciendo
   as&iacute; una descripci&oacute;n concreta del servicio en WSDL. Dicha descripci&oacute;n concreta puede entonces publicarse en un servicio de registro como por 
   ejemplo UDDI (<em>Universal Description, Descovery and Integration</em>). Un cliente de un servicio puede utilizar un servicio de registro para
   localizar una descripci&oacute;n de un servicio, a partir de la cual podr&aacute; seleccionar y utilizar una implementaci&oacute;n concreta de dicho servicio.
</p>
<p>La descripci&oacute;n abstracta se define en un documento WSDL como un <strong><em>PortType</em></strong>. Una instancia concreta de un Servicio se define 
   mediante un elemento <strong><em>port</em></strong> de un WSDL (consistente a su vez en una combinaci&oacute;n de un PortType, un <em>binding</em> de codificaci&oacute;n y transporte, 
   m&aacute;s una direcci&oacute;n). Un conjunto de <strong><em>ports</em></strong> definen un elemento <strong><em>service</em></strong> de un WSDL. 
</p>
</div>


<a name="N100D8"></a><a name="Servicios+Web+SOAP+y+Java+EE"></a>
<h2 class="underlined_10">Servicios Web SOAP y Java EE</h2>
<div class="section">
<p>Como ya se ha dicho, en este m&oacute;dulo vamos a centrarnos en los servicios Web SOAP. Aunque no existe una definici&oacute;n com&uacute;nmente aceptada para este tipo
   de servicios, utilizaremos la siguiente extraida de la especificaci&oacute;n JSR-109 (<em>Implementing Web Services</em>), que define el modelo de programaci&oacute;n y 
   arquitectura del soporte de ejecuci&oacute;n (<em>run-time</em>) para implementar servicios Web en Java.
</p>
<p>
<strong>Definici&oacute;n de Servicio Web</strong>:</p>
<p>Un servicio Web es un componente con las siguientes caracter&iacute;sticas: </p>
<ul>
  
<li>Implementa los m&eacute;todos de una interfaz descrita mediante un WSDL. Dichos m&eacute;todos
      se implementan utilizando un EJB de sesi&oacute;n de tipo <em>Stateless/Singleton</em> o bien un componente web JAX-WS</li>
  
<li>Un servicio Web puede tener publicada su interfaz en uno o m&aacute;s "registros" durante su despliegue  </li>
  
<li>La implementaci&oacute;n de un Servicio Web, la cual utiliza solamente la funcionalidad descrita por su especificaci&oacute;n, 
      puede desplegarse en cualquier servidor de aplicaciones que cumple con las especificaciones Java EE</li>
  
<li>Los servicios requeridos en tiempo de ejecuci&oacute;n (<em>run-time</em>), tales como atributos de seguridad, se separan
      de la implementaci&oacute;n del servicio. Se utilizar&aacute;n herramientas adicionales que pueden definir dichos requerimientos durante el 
      ensamblado o despliegue</li>
  
<li>Un contenedor act&uacute;a como mediador para acceder al servicio</li>

</ul>
<p>La especificaci&oacute;n de Java EE para servicios Web define una serie de relaciones arquitect&oacute;nicas requeridas para dichos servicios, que
   mostramos en la siguiente figura. Se trata de <strong>relaciones l&oacute;gicas</strong> que no imponen requerimiento alguno para el 
   proveedor del contenedor sobre c&oacute;mo estructurar los contenedores y los procesos. Como a&ntilde;adido para la plataforma Java EE se incluye
   un componente <strong>port</strong> que depende de la funcionalidad de contenedor proporcionada por los contenedores web y EJB, y del
   transporte SOAP/HTTP.   
</p>
<p>
<img alt="Arquitectura Java EE" content-width="8cm" src="imagenes/sesion1/javaEE-arq-ws.png" width="414"></p>
<p>Los servicios Web para Java EE requieren que un componente <strong>Port</strong> pueda ser referenciado desde un cliente, as&iacute; como
   desde los contenedores web y EJB. No se requiere que haya un <em>Port</em> accesible desde un contenedor de <em>applets</em>.
</p>
<p>Los servicios Web para Java EE pueden implementarse de dos formas: como una clase Java que se ejecuta en un contenedor Web (seg&uacute;n el modelo
   de programaci&oacute; definido en JAX-WS, y que veremos m&aacute;s adelante), o como un EJB de sesi&oacute;n <em>stateless</em> o <em>singleton</em> en un contenedor EJB.</p>
<p>El contenedor del servicio Web debe proporcionar la gesti&oacute;n del ciclo de vida de la implementaci&oacute;n del servicio, adem&aacute;s de proporcionar
   soporte adicional para la gesti&oacute;n de concurrencia de la invocaci&oacute;n de los m&eacute;todos del servicio, y soporte para la seguridad. 
</p>
</div>


<a name="N10130"></a><a name="Tecnolog%C3%ADas+b%C3%A1sicas+para+Servicios+Web"></a>
<h2 class="underlined_10">Tecnolog&iacute;as b&aacute;sicas para Servicios Web</h2>
<div class="section">
<p>Tenemos una serie de tecnolog&iacute;as, todas ellas basadas en XML, que son 
  fundamentales para el desarrollo de Servicios Web. Estas tecnolog&iacute;as 
  son independientes tanto del SO como del lenguaje de programaci&oacute;n utilizado 
  para implementar dichos servicios. Por lo tanto, ser&aacute;n utilizadas para 
  cualquier Servicio Web, independientemente de la plataforma sobre la que construyamos 
  dichos servicios (como puede ser J2EE o .NET). </p>
<p>Los protocolos utilizados en los Servicios Web se organizan en una serie de 
  capas:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Capa</strong></td>
    <td colspan="2" rowspan="1"><strong>Descripci&oacute;n</strong></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Transporte de servicios</em></td>
    <td colspan="2" rowspan="1">Es la capa que se encarga de transportar los mensajes entre aplicaciones. 
      Normalmente se utiliza el protocolo <strong>HTTP</strong> para este transporte, 
      aunque los servicios web pueden viajar mediante otros protocolos de transferencia 
      de hipertexto como SMTP, FTP o BEEP.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Mensajer&iacute;a XML</em></td>
    <td colspan="2" rowspan="1">Es la capa responsable de codificar los mensajes en XML de forma que puedan 
      ser entendidos por cualquier aplicaci&oacute;n. Puede implementar los protocolos 
      XML-RPC o<strong> SOAP</strong>.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Descripci&oacute;n de servicios</em></td>
    <td colspan="2" rowspan="1">Se encarga de definir la interfaz p&uacute;blica de un determinado servicio. 
      Est&aacute; definici&oacute;n se realiza mediante <strong>WSDL</strong>.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Localizaci&oacute;n de servicios</em></td>
    <td colspan="2" rowspan="1">Se encarga del registro centralizado de servicios, permitiendo que estos 
      sean anunciados y localizados. Para ello se utiliza el protocolo <strong>UDDI</strong>.</td>
  
</tr>

</table>
<p>A continuaci&oacute;n vamos a hablar con un poco m&aacute;s de detalle sobre las tecnolog&iacute;as de mensajer&iacute;a,
   descripci&oacute;n de servicios y localizaci&oacute;n. M&aacute;s concretamente nos referimos a SOAP, WSDL y UDDI.</p>
<a name="N101A0"></a><a name="SOAP"></a>
<h3 class="underlined_5">SOAP</h3>
<p>Se trata de un protocolo derivado de XML que nos sirve para intercambiar informaci&oacute;n 
  entre aplicaciones.</p>
<p>Normalmente utilizaremos SOAP para conectarnos a un servicio e invocar m&eacute;todos 
  remotos, aunque puede ser utilizado de forma m&aacute;s gen&eacute;rica para 
  enviar cualquier tipo de contenido. Podemos distinguir dos tipos de mensajes 
  seg&uacute;n su contenido:</p>
<ul>
  
<li>
<strong>Mensajes orientados al documento</strong>: Contienen cualquier tipo 
    de contenido que queramos enviar entre aplicaciones.</li>
  
<li>
<strong>Mensajes orientados a RPC</strong>: Este tipo de mensajes servir&aacute; 
    para invocar procedimientos de forma remota (<em>Remote Procedure Calls</em>). 
    Podemos verlo como un tipo m&aacute;s concreto dentro del tipo anterior, ya 
    que en este caso como contenido del mensaje especificaremos el m&eacute;todo 
    que queremos invocar junto a los par&aacute;metros que le pasamos, y el servidor 
    nos deber&aacute; devolver como respuesta un mensaje SOAP con el resultado 
    de invocar el m&eacute;todo.</li>

</ul>
<p>Puede ser utilizado sobre varios protocolos de transporte, aunque est&aacute; 
  especialmente dise&ntilde;ado para trabajar sobre HTTP.</p>
<p>Dentro del mensaje SOAP podemos distinguir los siguientes elementos:</p>
<p>
<img alt="Elementos de un mensaje SOAP" content-width="4cm" height="225" src="imagenes/sesion1/soap.gif" width="203"></p>
<ul>
  
<li>Un sobre (<span class="codefrag">Envelope</span>), que describe el mensaje, a quien va 
    dirigido, y c&oacute;mo debe ser procesado. El sobre incluye las definiciones 
    de tipos que se usar&aacute;n en el documento. Contiene una cabecera de forma 
    opcional, y el cuerpo del mensaje.</li>
  
<li>Una cabecera (<span class="codefrag">Header</span>) opcional, donde podemos incluir informaci&oacute;n 
    sobre el mensaje. Por ejemplo, podemos especificar si el mensaje es obligatorio 
    (debe ser entendido de forma obligatoria por el destinatario), e indicar los 
    actores (lugares por donde ha pasado el mensaje).</li>
  
<li>El cuerpo del mensaje (<span class="codefrag">Body</span>), que contiene el mensaje en 
    si. En el caso de los mensajes RPC se define una convenci&oacute;n sobre como 
    debe ser este contenido, en el que se especificar&aacute; el m&eacute;todo 
    al que se invoca y los valores que se pasan como par&aacute;metros. Puede 
    contener un error de forma opcional.</li>
  
<li>Un error (<span class="codefrag">Fault</span>) en el cuerpo del mensaje de forma opcional. 
    Nos servir&aacute; para indicar en una respuesta SOAP que ha habido un error 
    en el procesamiento del mensaje de petici&oacute;n que mandamos.</li>

</ul>
<p>Hemos visto como los mensajes SOAP nos sirven para intercambiar cualquier documento 
  XML entre aplicaciones. Pero puede ocurrir que necesitemos enviar en el mensaje 
  datos que no son XML, como puede ser una imagen. En ese caso tendremos que recurrir 
  a la especificaci&oacute;n de mensajes SOAP con anexos.</p>
<p>Los mensajes SOAP con anexos a&ntilde;aden un elemento m&aacute;s al mensaje:</p>
<p>
<img alt="Elementos de un mensaje SOAP con Anexos" content-width="4cm" height="269" src="imagenes/sesion1/swa.gif" width="203"></p>
<ul>
  
<li>El anexo (<span class="codefrag">Attachment</span>), puede contener cualquier tipo de 
    contenido (incluido el XML). De esta forma podremos enviar cualquier tipo 
    de contenido junto a un mensaje SOAP.</li>

</ul>
<p>Nuestro mensaje podr&aacute; contener tantos anexos como queramos.</p>
<p>Un ejemplo de mensaje SOAP es el siguiente:</p>
<pre class="brush:xml;">&lt;SOAP-ENV:Envelope 
 xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"    
 SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;    
    &lt;SOAP-ENV:Body&gt; 
        &lt;ns:getTemperatura xmlns:ns="http://j2ee.ua.es/ns"&gt;    
            &lt;area&gt;Alicante&lt;/area&gt; 
        &lt;/ns:getTemperatura&gt; 
    &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;</pre>
<p>En &eacute;l estamos llamando a nuestro m&eacute;todo <span class="codefrag">getTemperatura</span> 
  para obtener informaci&oacute;n meteorol&oacute;gica, proporcionando como par&aacute;metro 
  el &aacute;rea de la que queremos obtener la temperatura.</p>
<p>Podemos encontrar la especificaci&oacute;n de SOAP y SOAP con anexos publicada 
  en la p&aacute;gina del W3C, en las direcciones <span class="codefrag">http://www.w3.org/TR/SOAP/</span> 
  y <span class="codefrag">http://www.w3.org/TR/SOAP-attachments</span> respectivamente.</p>
<p></p>
<a name="N10219"></a><a name="WSDL"></a>
<h3 class="underlined_5">WSDL</h3>
<p>WSDL (<strong>Web Services Description Language</strong>) es un lenguaje basado en XML utilizado para describir la funcionalidad que
   proporciona un servicio Web. Una descripci&oacute;n WSDL (fichero WSDL) de un servicio web proporciona una descripci&oacute;n entendible por la m&aacute;quina (<em>machine
   readable</em>) de la interfaz del servicio Web, indicando c&oacute;mo se debe llamar al servicio, qu&eacute; par&aacute;metros espera, y qu&eacute; estructuras de datos 
   devuelve. </p>
<p>La versi&oacute;n actual de WSDL es la 2.0, en la que se ha cambiado el significado de la <strong>D</strong> por <strong>Definition</strong>. 
   La nueva versi&oacute;n plantea cambios de nomenclatura y estructura del fichero xml que contiene la descripci&oacute;n del servicio. En este m&oacute;dulo
   vamos a utilizar la versi&oacute;n anterior, la 1.1, puesto que es la que est&aacute; soportada actualmente por Netbeans, as&iacute; como por BPEL, que estudiaremos
   m&aacute;s adelante. En la figura siguiente mostramos la estructura que siguen los ficheros WSDL en ambas versiones, en donde podemos observar
   el cambio de nomenclatura en la versi&oacute;n 2.0.
</p>
<p>
<img alt="Estructura de un documento WSDL" content-width="6cm" src="imagenes/sesion1/wsdl.png" width="400"></p>
<p>WSDL describe un servicio utilizando varios elementos (etiquetas xml). Dichos elementos podemos clasificarlos
   como abstractos o concretos.La <strong>parte WSDL abstracta</strong> describe las operaciones y mensajes con detalle. En otras palabras,
   la parte abstracta de un WSDL especifica <strong>QU&Eacute;</strong> hace el servicio:</p>
<ul>
  
<li>Qu&eacute; operaciones est&aacute;n disponibles</li>
  
<li>Qu&eacute; entradas, salidas, y mensajes de error tienen las operaciones</li>
  
<li>Cu&aacute;les son las definiciones de los tipos para los mensajes de entrada, salida y error</li>

</ul>
<p>En el mundo Java, podemos pensar en la parte abstracta de un WSDL como en la definici&oacute;n de una interfaz o una clase abstracta, con la definici&oacute;n
   de sus m&eacute;todos, pero no sus implementaciones. La parte abstracta de un WSDL contiene dos componentes principales:</p>
<ul>
   
<li>Las operaciones que forman la definici&oacute;n de la interfaz</li>
   
<li>Los tipos de datos para los par&aacute;metros de entrada, salida y error, de las operaciones</li>

</ul>
<p>
<strong>La parte WSDL concreta</strong> describe el c&oacute;mo y d&oacute;nde del servicio:</p>
<ul>
  
<li>C&oacute;mo tiene que llamar un cliente al servicio</li>
  
<li>Qu&eacute; protocolo deber&iacute;a usar</li>
  
<li>D&oacute;nde est&aacute; disponible el servicio</li>

</ul>
<p>En el mundo Java podemos pensar en la parte concreta de un WSDL como en la implementaci&oacute;n de la parte abstracta, aunque en t&eacute;rminos
   de servicios Web, solamente describe d&oacute;nde se encuentra dicha implementaci&oacute;n para utilizarse. La parte concreta de un WSDL contiene
   dos componentes principales:</p>
<ul>
   
<li>Informaci&oacute;n de <em>enlazado</em> (<em>binding</em>) sobre el protocolo a utilizar</li>
   
<li>La direcci&oacute;n en donde localizar el servicio</li>

</ul>
<p>Vamos a ver con un poco m&aacute;s de detalle los elementos WSDL (tanto la parte abstracta como la concreta):</p>
<ul>
  
<li>
<strong><span class="codefrag">definitions</span></strong>: Es el elemento raiz y permite especificar el espacio de nombres del documento
     <em>target namespace</em>, el nombre, y otros prefijos utilizados en el documento WSDL. Un ejemplo de definici&oacute;n de prefijo es:
     <em>xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"</em>. Este prefijo especifica que todos los elementos dentro del documento de
     esquemas con el <em>target namespace</em> <em>"http://schemas.xmlsoap.org/wsdl/"</em> tendr&aacute;n el prefijo <em>wsdl</em>.
  </li>
  
<li>
<strong><span class="codefrag">types</span></strong>: Se utiliza para definir los tipos de datos que se 
    intercambiar&aacute;n en el mensaje. Podemos definir dichos tipos directamente dentro de este elemento,
    o importar la definici&oacute;n de un fichero de esquema (fichero xsd). La definici&oacute;n de tipos puede verse como las definiciones Java de
    clase, con variables que pueden ser tipos primitivos o referencias a otras clases u objetos. Los tipos primitivos se definen en los
    espacios de nombres del <em>Schema</em> y normalmente nos referimos a ellos como <em>built-in types</em>. &Eacute;stos incluyen tipos simples
    tales como <em>string</em>, <em>int</em>, <em>double</em>,...</li>
  
<li>
<strong><span class="codefrag">message</span></strong>: Define los distintos mensajes que se intercambiaran 
    durante el proceso de invocaci&oacute;n del servicio. Se deber&aacute;n definir 
    los mensajes de entrada y salida para cada operaci&oacute;n que ofrezca el 
    servicio. Los mensajes muestran descripciones abstractas de los datos que se van a intercambiar.</li>
  
<li>
<strong><span class="codefrag">portType</span></strong>: Contiene una colecci&oacute;n de una o m&aacute;s operaciones.  
    Para cada operaci&oacute;n indica cu&aacute;les son los mensajes de entrada y salida, 
    utilizando para ello los mensajes definidos en el apartado anterior. Los <em>portTypes</em> son, por 
    lo tanto, colecciones abstractas de operaciones soportadas por un servicio</li>
  
<li>
<strong><span class="codefrag">binding</span></strong>: Indica el protocolo de red y el formato de los datos 
    para las operaciones de un <em>portType</em>. Los <em>bindings</em> son definiciones concretas de los
    <em>portTypes</em>. Un <em>portType</em> puede tener m&uacute;ltiples <em>bindings</em> asociados. El formato 
    de datos utilizado para los mensaje de las operaciones del <em>portType</em> puede ser orientado 
    al documento u orientado a RPC. Si es orientado al documento tanto el mensaje 
    de entrada como el de salida contendr&aacute;n un documento XML. Si es orientado 
    a RPC el mensaje de entrada contendr&aacute; el m&eacute;todo invocado y sus 
    par&aacute;metros, y el de salida el resultado de invocar dicho m&eacute;todo, 
    siguiendo una estructura m&aacute;s restrictiva.</li>
  
<li>
<strong><span class="codefrag">service</span></strong>: Define el servicio como una colecci&oacute;n de 
    elementos <strong><em>port</em></strong> a los que se puede acceder. Un <em>port</em> se define asociando
    una direcci&oacute;n de red con un <em>binding</em>, de los definidos en el documento. Dicha direcci&oacute;n de red
    es la direcci&oacute;n (URL) 
    donde el servicio act&uacute;a, y por lo tanto, ser&aacute; la direcci&oacute;n a la que 
    las aplicaciones deber&aacute;n conectarse para acceder al servicio. </li>

</ul>
<p>Un documento WSDL de ejemplo es el siguiente:</p>
<pre class="brush:xml;">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;definitions targetNamespace="http://jaxwsHelloServer/" name="HelloService"&gt;
  &lt;types&gt;
    &lt;xsd:schema&gt;
    &lt;xsd:import namespace="http://jaxwsHelloServer/" 
         schemaLocation=
         "http://localhost:8080/JAXWSHelloAppServer/jaxwsHello?xsd=1"/&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;

  &lt;message name="sayHello"&gt;
     &lt;part name="parameters" element="tns:sayHello"/&gt;
  &lt;/message&gt;

  &lt;message name="sayHelloResponse"&gt;
     &lt;part name="parameters" element="tns:sayHelloResponse"/&gt;
  &lt;/message&gt;

  &lt;portType name="Hello"&gt;
     &lt;operation name="sayHello"&gt;
        &lt;input wsam:Action="http://jaxwsHelloServer/Hello/sayHelloRequest" 
            message="tns:sayHello"/&gt;
        &lt;output wsam:Action=
                  "http://jaxwsHelloServer/Hello/sayHelloResponse" 
            message="tns:sayHelloResponse"/&gt;
     &lt;/operation&gt;
  &lt;/portType&gt;

  &lt;binding name="HelloPortBinding" type="tns:Hello"&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" 
                  style="document"/&gt;
      &lt;operation name="sayHello"&gt;
       &lt;soap:operation soapAction=""/&gt;
         &lt;input&gt;
            &lt;soap:body use="literal"/&gt;
         &lt;/input&gt;
         &lt;output&gt;
            &lt;soap:body use="literal"/&gt;
         &lt;/output&gt;
     &lt;/operation&gt;
  &lt;/binding&gt;

  &lt;service name="HelloService"&gt;
    &lt;port name="HelloPort" binding="tns:HelloPortBinding"&gt;
      &lt;soap:address location=
            "http://localhost:8080/JAXWSHelloAppServer/jaxwsHello"/&gt;
    &lt;/port&gt;
  &lt;/service&gt;
&lt;/definitions&gt; 
</pre>
<p>En este ejemplo se define un <strong>servicio</strong>, denominado <span class="codefrag">HelloService</span>. 
   Dicho servicio est&aacute; formado por el <strong>port</strong> <span class="codefrag">HelloPort</span>, al cual se
   accede con protocolo <em>http</em> (<span class="codefrag">binding transport=http</span>) y con mensajer&iacute;a <em>soap</em>
   con estilo <em>document</em>
   (<span class="codefrag">binding style=document</span>). Dicho <strong>port</strong> proporciona la operaci&oacute;n (funcionalidad) <span class="codefrag">sayHello</span>
   (<span class="codefrag">operation name= "sayHello"</span>). Dicha operaci&oacute;n utiliza la codificaci&oacute;n <em>literal</em> en los mensajes de
   entrada y salida (<span class="codefrag">body use= "literal"</span>). Esto es lo que se conoce como operaci&oacute;n de tipo <strong>document/literal</strong>.
  </p>
<p>El elemento <span class="codefrag">portType</span> define la operaci&oacute;n <span class="codefrag">sayHello</span> 
  a partir de los mensajes de entrada y salida que la componen.</p>
<p>En los elementos <span class="codefrag">message</span> vemos la descripci&oacute;n de los mensajes de entrada y salida de
   la operaci&oacute;n <span class="codefrag">sayHello</span>. El mensaje de entrada contiene un dato de tipo <span class="codefrag">"tns:sayHello"</span>, y el de salida es de tipo <span class="codefrag">"tns:sayHelloResponse"</span> 
  (la cadena de saludo devuelta por el servicio). La definici&oacute;n de los tipos se encuentra en
  el fichero de esquema referenciado por la propiedad <em>schemaLocation</em> en una sub-etiqueta
  de <span class="codefrag">&lt;types&gt;</span>
</p>
<p>Podemos encontrar la especificaci&oacute;n de WSDL 1.1 publicada en la p&aacute;gina 
  del W3C, en la direcci&oacute;n <span class="codefrag">http://www.w3.org/TR/wsdl</span>.</p>
<a name="N1033F"></a><a name="UDDI"></a>
<h3 class="underlined_5">UDDI</h3>
<p>UDDI nos permite localizar Servicios Web. Para ello define la especificaci&oacute;n 
  para construir un directorio distribuido de Servicios Web, donde los datos se 
  almacenan en XML. En este registro no s&oacute;lo se almacena informaci&oacute;n sobre 
  servicios, sino tambi&eacute;n sobre las organizaciones que los proporcionan, la 
  categor&iacute;a en la que se encuentran, y sus instrucciones de uso (normalmente 
  WSDL). Tenemos por lo tanto 3 tipos de informaci&oacute;n relacionados entre s&iacute;:</p>
<ul>
  
<li>
<em>P&aacute;ginas blancas</em>: Datos de las organizaciones (direcci&oacute;n, informaci&oacute;n de contacto, etc).</li>
  
<li>
<em>P&aacute;ginas amarillas</em>: Clasificaci&oacute;n de las organizaciones (seg&uacute;n tipo de industria, zona geogr&aacute;fica, etc).</li>
  
<li>
<em>P&aacute;ginas verdes</em>: Informaci&oacute;n t&eacute;cnica sobre los servicios que se ofrecen. Aqu&iacute; se dan las instrucciones
  para utilizar los servicios. Es recomendable que estas instrucciones se especifiquen de forma est&aacute;ndar mediante
  un documento WSDL.</li>
  
</ul>
<p>Adem&aacute;s, UDDI define una API para trabajar con dicho registro, que nos 
  permitir&aacute; buscar datos almacenados en &eacute;l, y publicar datos nuevos. 
</p>
<p>De esta forma, una aplicaci&oacute;n podr&aacute; anunciar sus servicios en 
  un registro UDDI, o bien localizar servicios que necesitemos mediante este registro.</p>
<p>Esta capacidad de localizar servicios en tiempo de ejecuci&oacute;n, y de que 
  una aplicaci&oacute;n pueda saber c&oacute;mo utilizarlo inmediatamente gracias 
  a la descripci&oacute;n del servicio, nos permitir&aacute; realizar una integraci&oacute;n 
  d&eacute;bilmente acoplada de nuestra aplicaci&oacute;n.</p>
<p>La interfaz de UDDI est&aacute; basada en SOAP. Para acceder al registro se 
  utilizar&aacute;n mensajes SOAP, que son transportados mediante protocolo HTTP.</p>
<p>Podemos encontrar la especificaci&oacute;n de UDDI, documentaci&oacute;n, y 
  m&aacute;s informaci&oacute;n en la direcci&oacute;n <span class="codefrag">http://uddi.xml.org/</span>.</p>
<p>Estos registros se utilizan normalmente de forma interna en organizaciones para tener
un directorio organizado de servicios. Podemos encontrar varios registros proporcionados
por diferentes proveedores. Destacamos <strong>jUDDI</strong>, un registro <em>open-source</em> 
de Apache. Este registro consiste en una aplicaci&oacute;n web Java que puede instalarse en cualquier servidor
con soporte para este tipo de aplicaciones, como puede ser Tomcat, y una base de datos, que 
podr&aacute; ser instalada en diferentes SGBD (MySQL, Postgres, Oracle, etc).</p>
</div>

<a name="N10377"></a><a name="Interoperabilidad+de+los+WS%3A+Metro+y+JAX-WS"></a>
<h2 class="underlined_10">Interoperabilidad de los WS: Metro y JAX-WS</h2>
<div class="section">
<p>La interoperabilidad de los servicios Web constituye una iniciativa de Sun y Microsoft. El principal objetivo es proporcionar
   productos que sean capaces de interoperar a trav&eacute;s de diferentes plataformas.
</p>
<p>Metro (http://metro.java.net) es el producto resultante de la iniciativa de Sun para la interoperabilidad de los servicios Web utilizando la plataforma Java. De igual forma WCF (<em>Windows
   Communication Foundation</em>) es la aportaci&oacute;n de Microsoft para la plataforma .NET.  
</p>
<p>Metro, por lo tanto, constituye la implementaci&oacute;n por parte de Sun, de la pila (colecci&oacute;n de tecnolog&iacute;as) de servicios Web (<em>web service stack</em>).
   La versi&oacute;n actual es la 2.1.1 y est&aacute; formada por tres componentes principales, que podemos ver en la figura que se adjunta:
</p>
<ul>
  
<li>Metro/WSIT 2.1.1: WSIT es un conjunto de tecnolog&iacute;as (Web Services Interoperabe Technologies)  que permiten la interoperabilidad con .NET.
      A nivel de transporte, Metro permite utilizar HTTP, MTOM, SOAP/TCP. Tambi&eacute;n proporciona fiabilidad en el env&iacute;o de mensajes (<em>Reliability</em>),
      implementando las especificaciones WS-ReliableMessaging. As&iacute;mismo Metro permite habilitar el uso de transacciones at&oacute;micas, para lo cual
      proporciona una implementaci&oacute;n de las especificaciones WS-Coordination y WS-Atomic Transaction. La seguridad tambi&eacute;n est&aacute; contemplada en 
      Metro mediante la implementaci&oacute;n de las especificaciones WS-Security y WS-Trust.
Bootstrapping: WSDL; WS-Policy; WS-MetadataExange
  </li>
  
<li>JAX-WS RI 2.2.5: Es la implementaci&oacute;n de referencia del est&aacute;ndar JAX-WS (especificaci&oacute;n JSR 224: <em>Java API for XML-Based Web Services</em>). 
      Proporciona las caracter&iacute;sticas b&aacute;sicas para la interoperabilidad de los servicios Web (<em>WS-I Basic Profile</em>: mensajer&iacute;a SOAP, WSDL,
      publicaci&oacute;n de servicios en UDDI; <em>WS-I Attachment Profile</em>: utilizaci&oacute;n de SOAP con anexos; <em>WS-I Addressing</em>: utilizaci&oacute;n de espacios
      de nombres y ficheros de esquema)</li>
  
<li>JAXB RI 2.2.4-1: Implementaci&oacute;n de referencia del API para la capa de enlazado de datos (<strong>JAXB:</strong> <em>Java Architecture for XML binding</em>)</li>

</ul>
<p>
<img alt="Componentes de Metro" content-width="8cm" src="imagenes/sesion1/metro.png" width="529"></p>
<p>Con JAX-WS, una invocaci&oacute;n de una operaci&oacute;n a un servicio web se representa con un protocolo basado en
   XML, como por ejemplo SOAP. La especificaci&oacute;n SOAP define la estructura del "envoltorio" (<em>envelope</em>)
   del mensaje, reglas de codificaci&oacute;n, y convenciones para representar invocaciones y respuestas del servicio
   web. Estas llamadas y respuestas son transmitidas como mensajes SOAP (ficheros XML) a trav&eacute;s de HTTP.
</p>
<p>Si bien los mensajes SOAP son complejos, la API JAX-WS oculta esta complejidad al desarrollador de la
   aplicaci&oacute;n. En la parte del servidor, el desarrollador especifica las operaciones del servicio web definiendo
   m&eacute;todos en una interfaz escrita en lenguaje Java. El desarrollador tambi&eacute;n codifica una o m&aacute;s clases
   que implementan dichos m&eacute;todos. Los programas cliente tambi&eacute;n son f&aacute;ciles de codificar. Un cliente crea un
   <em>proxy</em> (un objeto local que representa el servicio) y a continuaci&oacute;n simplemente invoca los m&eacute;todos
   sobre el <em>proxy</em>. Con JAX-WS, el desarrollador no necesita generar o "parsear" mensajes SOAP.
   El <em>runtime</em> de JAX-WS convierte las llamadas y respuestas del API en y desde los mensajes SOAP.
</p>
<p>La siguiente figura muestra la interacci&oacute;n entre un cliente y un servicio web a trav&eacute;s de JAX-WS.</p>
<p>
<img alt="Comunicaci&oacute;n entre un servicio Web y un cliente a trav&eacute;s de JAX-WS" content-width="8cm" src="imagenes/sesion1/jaxws.jpg" width="479"></p>
<p>Metro (y consecuentemente, JAX-WS)est&aacute; incluido en Glassfish 3.x por defecto, por lo que haremos uso de &eacute;l para implementar nuestros Servicios Web y clientes correspondientes.</p>
</div>


<a name="N103D4"></a><a name="Los+servicios+Web+desde+la+vista+del+Cliente"></a>
<h2 class="underlined_10">Los servicios Web desde la vista del Cliente</h2>
<div class="section">
<p>La vista del cliente de un servicio Web es bastante similar a la de un <em>Enterprise JavaBean</em>. Un cliente de un
   servicio Web puede ser otro servicio Web, un componente Java EE (componente web,componente EJB), incluyendo una aplicacion cliente Java EE, 
   o una aplicaci&oacute;n Java arbitraria. Una aplicaci&oacute;n no Java o un servicio Web para una aplicaci&oacute;n no Java EE tambi&eacute;n podr&iacute;an ser clientes de un
   Servicio Web, pero vamos a ce&ntilde;irnos a la plataforma Java EE.</p>
<p>El cliente de un servicio Web puede ser remoto (no se requiere que resida en la misma m&aacute;quina que el servicio Web) y se 
   proporciona una total transparencia al respecto (el cliente no puede distinguir si est&aacute; accediendo a un servidor local o remoto).</p>
<p>La siguiente figura ilustra la vista del cliente de un servicio Web, proporcionada por el proveedor del componente <em>Port</em> y el
   contenedor en el que &eacute;ste reside. Adem&aacute;s se incluye la clase/interfaz Service (<strong>SI:</strong> Service Interface), y la interfaz del <em>Endpoint</em>
   del servicio (<strong>SEI:</strong> Service Endpoint Interface).</p>
<p>
<img alt="Vista de un cliente de un servicio Web" content-width="7cm" src="imagenes/sesion1/client-view.png" width="355"></p>
<p>La clase/interfaz <strong>Service</strong> (SI) define los m&eacute;todos que un cliente puede utilizar para acceder a un <strong>Port</strong>
   de un servicio Web. Un cliente NO crea o destruye un Port. Utiliza la clase/interfaz Service para obtener el acceso a un Port. La
   clase/interfaz Service se define en la especificaci&oacute;n JAX-WS, pero su comportamiento viene definido en el documento WSDL proporcionado 
   por el proveedor del servicio Web. Las herramientas de despliegue del contenedor proporcionan una implementaci&oacute;n de los m&eacute;todos
   de la clase/interfaz Service generada por JAX-WS.
</p>
<p>El cliente accede a una implementaci&oacute;n de un servicio Web utilizando el SEI. Dicho SEI es especificado por el proveedor del servicio. Las
   herramientas del despliegue y el <em>run-time</em> del contenedor proporciona las clases en la parte del servidor que van a atender
   las peticiones SOAP sobre la implementaci&oacute;n de dicho servicio de los m&eacute;todos especificados en el SEI.</p>
<p>Un Port no tiene identidad para el cliente, que lo debe considerar como un objeto sin estado.</p>
<p>JAX-WS define un modelo de programaci&oacute;n en el que se realiza un mapeado de un documento WSDL a Java. Dicho mapaeado proporciona una factor&iacute;a (<em>Service</em>)
   para seleccionar qu&eacute; <em>Port</em> (agregado en el servicio) desea usar el cliente. Como veremos m&aacute;s adelante, la herramienta
   JAX-WS que porporciona las clases necesarias en la parte del cliente para poder acceder a un servicio web se denomina <strong>wsimport</strong>. 
   En general, el transporte, codificaci&oacute;n, y direcci&oacute;n del <em>Port</em> son transparentes para el cliente. El cliente s&oacute;lamente
   necesita realizar llamadas sobre la interfaz del <em>endpoint</em> del servicio (<em>Service Endpoint Interface</em>), utilizando
   el <em>PortType</em> correspondiente para acceder a dicho servicio.</p>
<p>En esta sesi&oacute;n vamos a explicar el modelo de programaci&oacute;n del cliente de un servicio Web utilizando JAX-WS, pero antes vamos a 
   ver c&oacute;mo trabajar con ficheros wsdl y ficheros de esquema con Netbeans.</p>
</div>


<a name="N1042D"></a><a name="Ficheros+WSDL+y+de+esquema+con+Netbeans"></a>
<h2 class="underlined_10">Ficheros WSDL y de esquema con Netbeans</h2>
<div class="section">
<p>Saber "leer" y/o crear un fichero WSDL es importante para trabajar con servicios Web SOAP. Por ello vamos a ver c&oacute;mo, de forma sencilla,
   se puede trabajar con ficheros WSDL y de esquema utilizando Netbeans</p>
<div class="frame note">
<div class="label">Importante</div>
<div class="content">
Para poder editar ficheros WSDL y de esquema aprovechando las ventajas de edici&oacute;n que nos proporciona NetBeans, tenemos que
instalar el plugin correspondiente.  
</div>
</div>
<p>
<strong>C&oacute;mo instalar el plugin en Netbeans para editar ficheros WSDL y xsd</strong>
</p>
<p>Para instalar el plugin, lo haremos desde el men&uacute; de NetBeans. Para ello iremos a <em>Tools-&gt;Plugins-&gt;Settings-&gt;Add</em>.
A continuaci&oacute;n tenemos que proporcionar un nombre (para identificar el sitio que contiene los plugins, y a&ntilde;adirlo a la
lista de sitios en donde NetBeans buscar&aacute; actualizaciones de los plugins), y la URL del sitio desde el cual nos
podemos descargar e instalar el plugin.</p>
<ul>
  
<li>Name: Deadlock.Netbeans.org</li>
  
<li>URL: http://deadlock.netbeans.org/hudson/job/xml/lastSuccessfulBuild/
  artifact/build/updates/updates.xml</li>

</ul>
<p>A continuaci&oacute;n pulsamos OK.</p>
<p>
<img alt="URL de descarga del plugin XML" content-width="11cm" src="imagenes/sesion2/wsdl-plugin-3.png" width="600"></p>
<p>En la pesta&ntilde;a "Available Plugins", marcaremos "XML Tools", y procedemos a su instalaci&oacute;n:</p>
<p>
<img alt="Instalaci&oacute;n del plugin XML" content-width="9cm" src="imagenes/sesion2/wsdl-plugin-4.png" width="600"></p>
<p>
<strong>FICHEROS DE ESQUEMA</strong>
</p>
<p>
<strong><em>XML Schema</em></strong> es una recomendaci&oacute;n del W3C, que proporciona mecanismos para definir la estructra, contenido y sem&aacute;ntica de un documento XML.
 Un fichero WSDL utiliza el "lenguaje de esquemas" (<em>XML Schema</em>) para definir los tipos de datos y/o elementos utilizados por las operaciones de un servicio Web.</p>
<p>El bloque de construcci&oacute;n principal de un documento XML es <strong>element</strong>. La definici&oacute;n de un elemento <em>element</em> debe contener una propiedad
   <span class="codefrag">name</span>, que representa su nombre, y una propiedad <span class="codefrag">type</span> para indicar el tipo de elemento. Podemos utilizar alguno de los tipos predefinidos
   (<em>built-in types</em>), por ejemplo <em>xs:string</em>, <em>xs:integer</em>, o bien podemos definir nuevos tipos utilizando etiquetas
   <em>simpleType</em> o <em>complexType</em>.
</p>
<p>Por ejemplo, podemos crear la siguiente definici&oacute;n del elemento <em>Customer_Addres</em> que representa la direcci&oacute;n de un cliente: </p>
<pre class="brush:xml;">
&lt;xs:element name="CustomerAddress" type="xs:string"/&gt;     
 
</pre>
<p>Ahora podemos utilizar la definici&oacute;n anterior para expresar la estructura del siguiente mensaje de respuesta de nuestro servicio Web</p>
<pre class="brush:xml;">
&lt;message name="msgResponse"&gt;
     &lt;part name="parameters" element="tns:CustomerAddress"/&gt;
  &lt;/message&gt;
 
</pre>
<p>Seg&uacute;n esto, un ejemplo de mensaje de respuesta por parte de nuestro servicio Web podr&iacute;a ser &eacute;ste:</p>
<pre class="brush:xml;">
&lt;Customer_address&gt;Calle de los Pinos, 37&lt;/Customer_address&gt;
 
</pre>
<p>En lugar de utilizar tipos primitivos, podemos definir nuevos tipos utilizando la etiqueta <em>ComplexType</em> (es un contenedor
   de elementos). Por ejemplo vamos a definir los tipos <em>CustomerType</em> y <em>AddressType</em> y el elemento <em>Customer</em>,
   la siguiente forma:</p>
<pre class="brush:xml;">
    &lt;xsd:element name="Customer" type="tns:CustomerType"/&gt;
    &lt;xsd:complexType name="CustomerType"&gt;
        &lt;xsd:sequence&gt;
            &lt;xsd:element name="Phone" type="xsd:integer"/&gt;
            &lt;xsd:element name="Addresses" type="tns:AddressType"/&gt;
        &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
    &lt;xsd:complexType name="AddressType"&gt;
        &lt;xsd:sequence&gt;
            &lt;xsd:element name="Address1" type="xsd:string"/&gt;
            &lt;xsd:element name="Address2" type="xsd:string"/&gt;
        &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
 
</pre>
<p>Ahora podemos crear un segundo mensaje de respuesta en nuestro WSDL que haga uso del nuevo tipo <em>CustomerInfo</em>:</p>
<pre class="brush:xml;">
&lt;message name="msgResponse2"&gt;
     &lt;part name="parameters" element="tns:Customer"/&gt;
  &lt;/message&gt;
 
</pre>
<p>Un ejemplo de mensaje de respuesta con esta definici&oacute;n podr&iacute;a ser:</p>
<pre class="brush:xml;">
&lt;Customer&gt;
   &lt;Phone&gt;12345678&lt;/Phone&gt;
   &lt;Address1&gt;Calle de los Pinos, 37&lt;/Address1&gt;
   &lt;Address2&gt;Calle de los Manzanos, 25&lt;/Address2&gt;
&lt;/Customer&gt;
 
</pre>
<p>Para crear ficheros de esquema desde Netbeans, tenemos que crear un nuevo fichero con extensi&oacute;n xsd. Con bot&oacute;n derecho, seleccionamos 
   <em>New-&gt;Other-&gt;XML-&gt;XML Schema</em>. Debemos proporcionar un nombre para nuestro fichero .xsd, por ejemplo <em>MiEsquema</em>.
   Vamos explicar como crear, de forma visual, el esquema anterior.</p>
<p>El editor de ficheros de esquemas de Netbeans nos permite trabajar con tres vistas: la vista de fuentes
  (<em>Source</em>), en la que podemos trabajar directamente con xml, la vista de esquema (<em>Schema</em>): que nos muestra el contenido
  del fichero en forma de &aacute;rbol, o en forma de "columnas", y la vista de dise&ntilde;o (<em>Design</em>). Esta &uacute;ltima vista nos permite
  editar un fichero de esquema de forma visual, arrastrando componentes desde una paleta y editando sus propiedades, de forma que con
  unos cuantos "clicks" de rat&oacute;n Netbeans genera el correspondiente c&oacute;digo xml, que podemos ver en la vista de fuentes. Las tres vistas est&aacute;n
  sincronizadas en todo momento, de forma que los cambios en cualquiera de ellas, se reflejar&aacute;n autom&aacute;ticamente en las otras dos.</p>
<p>Vamos a crear el tipo <em>CustomerType</em>. Para ello tendremos que "arrastrar" con el bot&oacute;n izquierdo del rat&oacute;n el componente
   <em>ComplexType</em> desde la paleta de componentes de la derecha, y situarlo justo debajo de <em>Complex Types</em>, en el editor de dise&ntilde;o.
   Cuando nos situemos con el rat&oacute;n en el lugar correcto, nos aparecer&aacute; una l&iacute;nea en negro y s&oacute;lo entonces podremos "soltar" el dedo del
   rat&oacute;n, y nos crear&aacute; un nuevo elemento <em>ComplexType</em> en la vista de dise&ntilde;o. Vamos a ponerle el nombre <em>CustomerType</em>. 
   Si seleccionamos el componente, haciendo doble "click" sobre el mismo podemos cambiar el nombre del componente.
   Si seleccionamos el componente y pulsamos bot&oacute;n derecho, nos aparece un men&uacute;, con la opci&oacute;n "Properties" con el que podemos borrar, a&ntilde;adir
   elementos,..., y editar las propiedades del componente en cualquier momento.</p>
<p>
<img alt="Arrastramos el componente ComplexType a la vista de dise&ntilde;o" content-width="11cm" src="imagenes/sesion1/xsdNewComplexType.jpg" width="750"></p>
<p>A continuaci&oacute;n a&ntilde;adiremos un componente <em>element</em> a <em>CustomerType</em>, arrastrando dicho componente desde la paleta hasta
   situarnos sobre <em>CustomerType</em> antes de soltar el dedo del rat&oacute;n. Llamaremos al nuevo elemento "Phone". Seguidamente, con el bot&oacute;n
   derecho, elegimos la opci&oacute;n "Properties" del men&uacute; contextual, y pinchamos sobre el bot&oacute;n con tres puntos correspondiente al &iacute;tem
   "Definition", y seleccionamos el tipo predefinido integer (dentro del grupo <em>Built-In Types</em>)</p>
<p>
<img alt="A&ntilde;adimos el elemento Phone a AddressType" content-width="9cm" src="imagenes/sesion1/xsdProperties.jpg" width="600"></p>
<p>Repetimos los pasos anteriores para a&ntilde;adir un nuevo componente <em>ComplexType</em> al que llamaremos "AddressType", con los
   sub-elementos "Address1", y "Address2", ambas de tipo "string".</p>
<p>Para finalizar, crearemos un nuevo sub-elemento de "CustomerType", al que llamaremos "Addresses". En este caso, el tipo que asociaremos
   a dicho elemento ser&aacute; el tipo "AddressType", dentro del grupo "Complex Types"</p>
<p>
<img alt="Seleccionamos el tipo AddressType" content-width="5cm" src="imagenes/sesion1/xsdAddresses.png" width="343"></p>
<p>El resultado final en la vista de dise&ntilde;o debe ser &eacute;ste:</p>
<p>
<img alt="Vista de dise&ntilde;o del esquema MiEsquema.xsd" content-width="5cm" src="imagenes/sesion1/xsdFinal.png" width="340"></p>
<p>Si cambiamos a la vista de fuentes (<em>Source</em>) veremos lo siguiente:</p>
<p>
<img alt="Vista de fuentes del esquema MiEsquema.xsd" content-width="9cm" src="imagenes/sesion1/xsdSource.png" width="550"></p>
<p>
<strong>FICHEROS WSDL</strong>
</p>
<p>Ya hemos explicado el contenido de un fichero WSDL. Netbeans nos permite crear ficheros WSDL de forma "visual", simplificando
   de forma significativa el proceso de edici&oacute;n de la especificaci&oacute;n WSDL de nuestro servicio web.</p>
<p>Para crear un fichero wsdl con NetBeans, activamos el men&uacute; contextual con el con bot&oacute;n derecho y seleccionamos 
   <em>New-&gt;Other-&gt;XML-&gt;WSDL Document</em>. Podemos elegir entre crear un documento WSDL abstracto o concreto. En el primer caso solamente proporcionamos el
   <em>portType</em> y las operaciones que ofrece nuestro servicio. En el segundo caso, adem&aacute;s, proporcionaremos la informaci&oacute;n 
   de <em>binding</em> y tipo de codificaci&oacute;n del servicio. La siguiente figura muestra la creaci&oacute;n de un fichero wsdl concreto con nombre
   "conversion", y con un enlazado "SOAP", con codificaci&oacute;n "Document/Literal". 
</p>
<p>
<img alt="Documento WSDL concreto con codificaci&oacute;n Document/Literal" content-width="9cm" src="imagenes/sesion2/wsdl-plugin-6.png" width="550"></p>
<p>El siguiente paso es determinar la <strong>configuraci&oacute;n abstracta</strong> de nuestro WSDL. Tal y como se aprecia en la
   siguiente figura, se trata de indicar el nombre del <em>portType</em>, la operaci&oacute;n que proporciona, as&iacute; como el tipo de operaci&oacute;n
   (elegiremos una operaci&oacute;n s&iacute;ncrona, es decir, de tipo petici&oacute;n-respuesta (<em>Request-Response</em>)), y los mensajes de
   entrada, salida y situaciones excepcionales (<em>Fault</em>).</p>
<p>
<img alt="Configuraci&oacute;n abstracta del documento WSDL" content-width="10cm" src="imagenes/sesion2/wsdl-plugin-7.png" width="630"></p>
<p>En un documento WSDL de tipo <em>document/literal</em>, utilizaremos un tipo XML predefinido, o bien de tipo <em>&lt;element&gt;</em> para
   las diferentes "partes" de los mensajes de entrada/salida/excepciones. En este &uacute;ltimo caso, tendremos que disponer de la definici&oacute;n del
   tipo en el fichero de esquema (fichero <em>xsd</em>) que asociaremos al documento WSDL. La siguiente figura muestra que los tipos "eurosType" 
   y "ptasType" se encuentran definidos en el fichero "conversion.xsd"</p>
<p>
<img alt="Selecci&oacute;n del tipo de las partes de los mensajes" content-width="6cm" src="imagenes/sesion2/wsdl-plugin-11.png" width="400"></p>
<p>Finalmente especificaremos la <strong>configuraci&oacute;n concreta</strong> del WSDL, indicando el nombre de <em>binding</em>,
   as&iacute; como el nombre del servicio y del <em>port</em> asociado.</p>
<p>
<img alt="Configuraci&oacute;n concreta del documento WSDL" content-width="8cm" src="imagenes/sesion2/wsdl-plugin-12.png" width="500"></p>
<p>En la siguiente sesi&oacute;n veremos que, a partir de un wsdl, podemos generar un servcio web.</p>
</div>


<a name="N10597"></a><a name="Tipos+de+acceso+para+invocar+servicios+Web+JAX-WS"></a>
<h2 class="underlined_10">Tipos de acceso para invocar servicios Web JAX-WS</h2>
<div class="section">
<p>Tenemos dos formas diferentes de invocar un Servicio Web utilizando JAX-WS (llamaremos servicios web
   JAX-WS a aquellos servicios que utilizan la librer&iacute;a JAX-WS):</p>
<ul>
  
<li>
<strong>Creaci&oacute;n de un stub est&aacute;tico</strong>: Consiste en 
    generar una capa de <em>stub</em> por debajo del cliente de forma autom&aacute;tica. 
    Dicho <em>stub</em> implementar&aacute; la misma interfaz que el servicio, 
    lo cu&aacute;l nos permitir&aacute; desde nuestro cliente acceder al Servicio 
    Web a trav&eacute;s del <em>stub</em> tal y como si estuvi&eacute;ramos accediendo 
    directamente al servicio. 
    <p>Para utilizar este mecanismo es recomendable contar con alguna herramienta 
      dentro de nuestra plataforma que nos permita generar dicho <em>stub</em>, 
      para no tener que encargarnos nosotros de realizar esta tarea manualmente.</p>
  
</li>
  
<li>
<strong>Utilizaci&oacute;n de la Interfaz de Invocaci&oacute;n Din&aacute;mica 
    (DII)</strong>: Esta forma de acceso nos permitir&aacute; hacer llamadas a 
    procedimientos de nuestro Servicio Web de forma din&aacute;mica, sin crear 
    un <em>stub</em> para ello. Utilizaremos este tipo de invocaci&oacute;n cuando 
    no conozcamos la interfaz del servicio <em>a priori</em>, en cuyo caso para invocar
    a dicho servicio deberemos 
    proporcionar &uacute;nicamente los nombres de los m&eacute;todos a utilizar 
    mediante una cadena de texto. 
    <p>Podremos utilizar esta interfaz din&aacute;mica aunque no contemos con 
      un documento WSDL que nos indique la interfaz y datos de nuestro servicio. 
      En este caso, deberemos proporcionar manualmente esta informaci&oacute;n, 
      para as&iacute; poder acceder al servicio correctamente.</p>
  
</li>

</ul>
<p>Vamos a ver c&oacute;mo invocar servicios web JAX-WS (crear un cliente web) utilizando
   un <em>stub</em> est&aacute;tico con jdk 1.6, con Maven, y con Netbeans. Y despu&eacute;s comentaremos
   c&oacute;mo utilizar la Interfaz de Invocaci&oacute;n Din&aacute;mica.</p>
<p>Cuando utilizamos un <em>stub</em> est&aacute;tico, los pasos generales para crear un cliente
   son:</p>
<ol>
  
<li>Codificar la clase cliente, implementando el acceso al servicio Web utilizando las interfaces
      de los stubs que se generar&aacute;n con <em>wsimport</em>
</li>
  
<li>Generar los artefactos necesarios del servicio web para poder conectar con dicho servicio Web
      desde el cliente (mediante la utilidad <em>wsimport</em>)</li>
  
<li>Compilar la clase cliente (empaquetar y desplegar si es necesario)</li>
  
<li>Ejecutar el cliente</li>    

</ol>
</div>



<a name="N105E6"></a><a name="Invocaci%C3%B3n+de+servicios+web+JAX-WS+con+JDK+1.6"></a>
<h2 class="underlined_10">Invocaci&oacute;n de servicios web JAX-WS con JDK 1.6</h2>
<div class="section">
<p>A partir de JDK 1.6 se incluye en Java SE la librer&iacute;a JAX-WS y las herramientas necesarias para crear e
   invocar servicios. Podemos encontrar las clases de la API de JAX-WS dentro del paquete <span class="codefrag">javax.xml.ws</span> y
   en subpaquetes de &eacute;ste.</p>
<p>Para crear un cliente en JDK 1.6 (o con JAX-WS en versiones anteriores de JDK) utilizaremos la herramienta
<span class="codefrag">wsimport</span>, que tomar&aacute; como entrada el documento WSDL del servicio al que queremos acceder y producir&aacute;
un conjunto de clases Java que nos permitir&aacute;n acceder al servicio. Esta herramienta se puede invocar desde l&iacute;nea
de comando:</p>
<pre class="code">
<strong>wsimport -s</strong> <em>&lt;src.dir&gt;</em> <strong>-d</strong> <em>&lt;dest.dir&gt;</em> <strong>-p</strong> <em>&lt;pkg&gt;</em> <em>&lt;wsdl.uri&gt;</em>
</pre>
<p>El documento WSDL (<span class="codefrag">&lt;wsdl.url&gt;</span>) se especificar&aacute; mediante su ruta en el disco o mediante su URL. Podemos proporcionar otros 
par&aacute;metros para indicar la forma en la que se debe generar el <em>stub</em>, como el directorio donde
queremos que guarde los fuentes de las clases generadas (<span class="codefrag">&lt;src.dir&gt;</span>), el directorio donde guardar&aacute; estas clases compiladas (<span class="codefrag">&lt;dest.dir&gt;</span>),
y el paquete en el que se generar&aacute; este conjunto de clases (<span class="codefrag">&lt;pkg&gt;</span>). </p>
<p>Por ejemplo podr&iacute;amos utilizar el siguiente comando para crear el cliente de un servicio <span class="codefrag">HolaMundo</span>
que se encuentra definido en <span class="codefrag">http://jtech.ua.es/HolaMundo/wsdl/HolaMundoSW.wsdl</span>, 
separando los fuentes en el directorio <span class="codefrag">src</span> y las clases compiladas en <span class="codefrag">bin</span>, y generando 
todas estas clases dentro de un paquete <span class="codefrag">es.ua.jtech.servcweb.hola.stub</span>:</p>
<pre class="code">
<strong>wsimport -s</strong> src <strong>-d</strong> bin <strong>-p</strong> es.ua.jtech.servcweb.hola.stub 
         http://jtech.ua.es/HolaMundo/wsdl/HolaMundoSW.wsdl</pre>
<p>Con esto se generar&aacute;n una serie de clases que nos permitir&aacute;n acceder al servicio web e invocar sus operaciones
desde nuestro cliente. Dentro de estas clases tendremos una que recibir&aacute; el mismo nombre que el servicio, y que 
heredar&aacute; de la clase <span class="codefrag">Service</span>. Deberemos instanciar esta clase, y a partir de ella obtendremos el
<em>stub</em> para acceder a un puerto del servicio. Este <em>stub</em> tendr&aacute; la misma interfaz que el servicio web,
y a partir de &eacute;l podremos invocar sus operaciones. En el ejemplo del servicio <span class="codefrag">HolaMundo</span> acceder&iacute;amos
al servicio de la siguiente forma:</p>
<pre class="code">
<strong>HolaMundoSWService</strong> service = new <strong>HolaMundoSWService</strong>();
<strong>HolaMundoSW</strong> port = service.<strong>getHolaMundoSW</strong>();

System.out.println("Resultado: " + port.<strong>saluda</strong>("Miguel"));</pre>
<p>El servicio ofrece una operaci&oacute;n <span class="codefrag">saluda</span> que recibe un nombre, y genera un saludo incluyendo
dicho nombre. En este ejemplo vemos como podemos invocar la operaci&oacute;n <span class="codefrag">saluda</span> del servicio a partir del <em>stub</em> (<span class="codefrag">port</span>) como 
si se tratase de un m&eacute;todo de un objeto local.</p>
</div> 


<a name="N10670"></a><a name="Invocaci%C3%B3n+de+servicios+web+JAX-WS+desde+una+clase+Java+con+Maven"></a>
<h2 class="underlined_10">Invocaci&oacute;n de servicios web JAX-WS desde una clase Java con Maven</h2>
<div class="section">
<p>Ahora vamos a ver paso a paso c&oacute;mo crear nuestro cliente de un servicio web JAX-WS utilizando Maven.
   Para ello necesitamos conocer la direcci&oacute;n del WSDL del servicio web al que vamos a acceder. Para este 
   ejemplo, supongamos que dicha direcci&oacute;n es: <span class="codefrag">http://localhost:8080/holaMundo/hola?WSDL</span>

</p>
<p>El contenido del fichero wsdl es el siguiente:</p>
<pre class="brush:xml;">

&lt;definitions 
   xmlns:wsu=
      "http://docs.oasis-open.org/wss/2004/01/
             oasis-200401-wss-wssecurity-utility-1.0.xsd" 
             xmlns:wsp="http://www.w3.org/ns/ws-policy" 
             xmlns:wsp1_2="http://schemas.xmlsoap.org/ws/2004/09/policy" 
             xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata" 
             xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" 
             xmlns:tns="http://sw/" 
             xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
             xmlns="http://schemas.xmlsoap.org/wsdl/" 
             targetNamespace="http://sw/" 
             name="hola"&gt;
  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://sw/" 
          schemaLocation="http://localhost:8080/HolaMundo/hola?xsd=1"/&gt;
      &lt;/xsd:schema&gt;
  &lt;/types&gt;
  
  &lt;message name="hello"&gt;
     &lt;part name="parameters" element="tns:hello"/&gt;
  &lt;/message&gt;
  
  &lt;message name="helloResponse"&gt;
     &lt;part name="parameters" element="tns:helloResponse"/&gt;
  &lt;/message&gt;

  &lt;portType name="Hola"&gt;
    &lt;operation name="hello"&gt;
      &lt;input wsam:Action="http://sw/hola/helloRequest" 
             message="tns:hello"/&gt;
      &lt;output wsam:Action="http://sw/hola/helloResponse" 
              message="tns:helloResponse"/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;

  &lt;binding name="HolaPortBinding" type="tns:Hola"&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;
    &lt;operation name="hello"&gt;
       &lt;soap:operation soapAction=""/&gt;
       &lt;input&gt;
         &lt;soap:body use="literal"/&gt;
       &lt;/input&gt;
       &lt;output&gt;
         &lt;soap:body use="literal"/&gt;
       &lt;/output&gt;
    &lt;/operation&gt;
   &lt;/binding&gt;

   &lt;service name="hola"&gt;
     &lt;port name="HolaPort" binding="tns:HolaPortBinding"&gt;
        &lt;soap:address location="http://localhost:8080/HolaMundo/hola"/&gt;
     &lt;/port&gt;
   &lt;/service&gt;
&lt;/definitions&gt;

</pre>
<p>Analizando la definici&oacute;n <strong>ABSTRACTA</strong> del servicio Web en el wsdl anterior, podemos ver que en la 
   etiqueta <span class="codefrag">&lt;portType&gt;</span> (interfaz del servicio) se indica que el servicio ofrece la operaci&oacute;n con nombre <em>hello</em>, 
   que tiene asociado un mensaje de entrada de tipo <em>hello</em> y un mensaje de salida de tipo <em>helloResponse</em>.
   Los tipos de los mensajes de entrada y salida est&aacute;n definidos en un fichero de esquema importado
   en <span class="codefrag">&lt;types&gt;</span>, en el atributo <em>schemaLocation</em>, y cuyo valor podemos observar que es   
   <span class="codefrag">http://localhost:8080/HolaMundo/hola?xsd=1"</span> (en muchas ocasiones, y por comodidad,
   en lugar de importar el fichero de esquema, podemos incluir la definici&oacute;n de dicho esquema en el propio fichero wsdl). 
   Si accedemos a dicha direcci&oacute;n podemos ver que
   el fichero de esquema contiene lo siguiente:
</p>
<pre class="code">

&lt;xs:schema xmlns:tns="http://sw/" xmlns:xs="http://www.w3.org/2001/XMLSchema" 
           version="1.0" targetNamespace="http://sw/"&gt;
   &lt;xs:element name="hello" type="tns:hello"/&gt;
   &lt;xs:element name="helloResponse" type="tns:helloResponse"/&gt;
   
   &lt;xs:complexType name="hello"&gt;
     &lt;xs:sequence&gt;
        &lt;xs:element name="name" type="xs:string" minOccurs="0"/&gt;
     &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
   
   &lt;xs:complexType name="helloResponse"&gt;
     &lt;xs:sequence&gt;
        &lt;xs:element name="return" type="xs:string" minOccurs="0"/&gt;
     &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
</pre>
<p>En el fichero de esquema (con extensi&oacute;n .xsd), podemos observar que los mensajes
   <em>hello</em> y <em>helloResponse</em> contienen cadenas de caracteres. Por lo tanto, nuestro
   servicio acepta un mensaje con una cadena de caracteres como entrada y como resultado tambi&eacute;n nos devuelve otra cadena de
   caracteres.</p>
<p>Analizando la definici&oacute;n <strong>CONCRETA</strong> del servicio Web en el wsdl anterior, podemos ver en la 
   etiqueta <span class="codefrag">&lt;port&gt;</span> se indica que la direcci&oacute;n para acceder al componente <em>Port</em> de nuestro servicio Web es: 
   <em>http://localhost:8080/HolaMundo/hola</em>. El nombre del componente es <strong>HolaPort</strong>, y se deber&aacute; acceder
   al componente <em>HolaPort</em> a trav&eacute;s de una instancia de la clase <strong>Hola</strong>. 
</p>
<p>Ahora vamos a comenzar a desarrollar nuestro cliente para el servicio web anterior. 
   En primer lugar crearemos un proyecto java con maven, por ejemplo utilizando el arquetipo por defecto 
   <em>maven-archetype-quickstart</em> mediante:</p>
<pre class="brush:plain;">
   mvn archetype:generate -DgroupId=expertoJava 
                          -DartifactId=HolaMundoJavaClient 
                          -Dversion=1.0-SNAPSHOT 
                          -DarchetypeArtifactId=maven-archetype-quickstart 
                          -DinteractiveMode=false</pre>
<p>En el <em>pom.xml</em> generado tenemos que incluir, dentro de la etiqueta <strong>&lt;build&gt;</strong> (y subetiqueta
     <strong>&lt;plugins&gt;</strong>), los siguientes
     <em>plugins</em>
</p>
<ul>
  
<li>
<strong><em>jaxws-maven-plugin</em></strong>: para ejecutar la utilidad <strong>wsimport</strong> de JAX-WS y generar los stubs del servicio web.
     Vamos a configurar la ejecuci&oacute;n de la <em>goal</em> <em>wsimport</em> de forma que, a partir del wsdl situado en:  
     <span class="codefrag">http://localhost:8080/HolaMundo/hola?WSDL</span>, genere los stubs necesarios, que por defecto se almacenan en el 
     directorio <span class="codefrag">target/jaxws/wsimport/java</span>. Por defecto est&aacute; asociado a la fase <span class="codefrag">generate-sources</span> del ciclo de
     vida de Maven. Wsimport se ejecutar&aacute;, por tanto, antes de compilar los fuentes del proyecto.
  </li>
  
<li>
<strong><em>exec-maven-plugin</em></strong>: para ejecutar la aplicaci&oacute;n java desde maven</li>

</ul>
<p>El c&oacute;digo para el plugin <em>jaxws-maven-plugin</em> quedar&iacute;a como: </p>
<pre class="brush:xml;">
      &lt;plugin&gt;
        &lt;groupId&gt;org.jvnet.jax-ws-commons&lt;/groupId&gt;
        &lt;artifactId&gt;jaxws-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;wsimport&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
        &lt;configuration&gt;
          &lt;!-- opcionalmente podr&iacute;amos indicar el paquete en el que 
               queremos que se generen los ficheros
          &lt;packageName&gt;wsClient&lt;/packageName&gt;
          --&gt;
          &lt;wsdlUrls&gt;
              &lt;wsdlUrl&gt;
                   http://localhost:8080/HolaMundo/hola?WSDL
              &lt;/wsdlUrl&gt;
          &lt;/wsdlUrls&gt;
          &lt;verbose&gt;true&lt;/verbose&gt;
        &lt;/configuration&gt;
        
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;javax.xml&lt;/groupId&gt;
            &lt;artifactId&gt;webservices-api&lt;/artifactId&gt;
            &lt;version&gt;1.4&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;
     &lt;/plugin&gt;   

</pre>
<p>El c&oacute;digo para el plugin <em>exec-maven-plugin</em> ser&iacute;a el siguiente: </p>
<pre class="brush:xml;">
        &lt;plugin&gt;
          &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
          &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;
          &lt;version&gt;1.2.1&lt;/version&gt;
          &lt;executions&gt;
             &lt;execution&gt;
                 &lt;goals&gt;
                   &lt;goal&gt;java&lt;/goal&gt;
                 &lt;/goals&gt;
             &lt;/execution&gt;
          &lt;/executions&gt;
          &lt;configuration&gt;
            &lt;mainClass&gt;expertoJava.App&lt;/mainClass&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;

</pre>
<p>Adicionalmente necesitamos incluir en nuestro <em>pom.xml</em> la dependencia con la librer&iacute;a <em>webservices-rt</em>
</p>
<pre class="brush:xml;">
&lt;dependency&gt;
    &lt;groupId&gt;com.sun.xml.ws&lt;/groupId&gt;
    &lt;artifactId&gt;webservices-rt&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;

</pre>
<p>Tambi&eacute;n nos aseguraremos de incluir la codificaci&oacute;n del c&oacute;digo fuente como una propiedad en nuestro fichero pom:</p>
<pre class="brush:xml;">
  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;/properties&gt;

</pre>
<p>A continuaci&oacute;n, compilaremos nuestro proyecto para generar los <em>stubs</em> necesarios con <em>wsimport</em>, y poder
   realizar llamadas al servicio web.</p>
<pre class="brush:plain;">mvn compile</pre>
<p>Podemos ver en pantalla que, al compilar, se ejecuta wsimport, se parsea el WSDL, y a continuaci&oacute;n se genera el c&oacute;dgio (stubs).
   Tambi&eacute;n se muestran los nombres de los ficheros generados (ya que hemos incluido la etiqueta 
   <span class="codefrag">&lt;verbose&gt;true&lt;/true&gt;</span>
   en la configuraci&oacute;n de <em>wsimport</em> en nuestro <em>pom</em>).</p>
<pre class="brush:plain;">
[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building HolaMundoJavaClient 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- jaxws-maven-plugin:1.10:wsimport (default) @ HolaMundoJavaClient ---
[INFO] Processing: http://localhost:8080/HolaMundo/hola?WSDL 
[INFO] jaxws:wsimport args: [-s, ..., -d, ..., -verbose, -catalog, 
   (omitimos los detalles de la ejecuci&oacute;n de wsimport)
parsing WSDL...

generating code...

sw/Hello.java
sw/HelloResponse.java
sw/Hola.java
sw/Hola_Service.java
sw/ObjectFactory.java
sw/package-info.java

compiling code...

javac -d ... (omitimos el comando de compilaci&oacute;n)
[INFO] 
[INFO] --- maven-resources-plugin:2.5:resources (default-resources) @ HolaMundoJavaClient ---
...
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /home/especialista/MavenProjects/
        HolaMundoJavaClient/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:2.3.2:compile (default-compile) @ HolaMundoJavaClient ---
[INFO] Compiling 1 source files to 
         /home/especialista/MavenProjects/HolaMundoJavaClient/target/classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
...
</pre>
<p>Podemos ver que <em>wsimport</em> genera en <strong><span class="codefrag">target/generated-sources/sw</span></strong>
   los siguientes ficheros:
</p>
<ul>
  
<li>
<strong><span class="codefrag">Hola.java</span></strong>: contiene la Interfaz del servicio (SEI del servicio)</li>
  
<li>
<strong><span class="codefrag">Hola_Service.java</span></strong>: contiene la Clase heredada de Service, que utilizaremos para acceder al 
      componente Port de nuestro servicio web a trav&eacute;s del SEI. Para ello debemos utilizar el m&eacute;todo "Hola getHolaPort()"
      de la clase Hola_Service</li>
  
<li>
<strong><span class="codefrag">ObjectFactory.java</span></strong>: Contiene una factoria de m&eacute;todos para recuperar representaciones java a 
      partir de definiciones XML </li> 
  
<li>
<strong><span class="codefrag">Hello.java, HelloResponse.java</span></strong>: son las clases que representan mensajes de
      nuestro WSDL</li>
  
<li>
<strong><span class="codefrag">package-info.java</span></strong>: fichero con informaci&oacute;n sobre las clases generadas</li>           

</ul>
<p>Ahora vamos a codificar la llamada al servicio web desde nuestra clase Java <span class="codefrag">App</span>:</p>
<pre class="brush:java;">
package jtech;

public class App 
{
    public static void main( String[] args )
    {      
        try { 
            //Primero accedemos a un objeto Service
            sw.Hola_Service service = new sw.Hola_Service();
            //a trav&eacute;s de &eacute;l accedemos al Port
            sw.Hola port = service.getHolaPort();
            java.lang.String name = "amigos de los Servicios Web";
            //utilizamos el Port para llamar al WS a trav&eacute;s del SEI
            java.lang.String result = port.hello(name);
            System.out.println("Result = "+result);
        } catch (Exception ex) {
        // TODO handle custom exceptions here
        }        
    }
}
  
</pre>
<p>Podemos comprobar en el c&oacute;digo que nuestro cliente no es incapaz de distinguir si los m&eacute;todos a los que est&aacute; llamando se est&aacute;n ejecutando en
   local o en remoto, ni tampoco puede saber c&oacute;mo est&aacute; implementado el servicio (si es una clase java, un 
   servlet, ejb, ...).</p>
<p>De igual forma, en el c&oacute;digo anterior se aprecia que el cliente <strong>NO TIENE CONTROL</strong> sobre el ciclo de vida del servicio Web, 
   de forma que <strong>no puede
   crear o destruir instancias</strong> de un servicio Web (componentes <em>Port</em>). 
   El cliente <strong>S&Oacute;LO ACCEDE</strong> a un componente <em>Port</em>. El ciclo de vida de los <em>Ports</em> o instancias de
   la implementaci&oacute;n de un Servicio web, son generadas por el <em>run-time</em> en el que reside dicho servicio Web (t&iacute;picamente
   en un servidor de aplicaciones). </p>
<p>Una vez creada nuestra clase cliente, vamos a empaquetar:</p>
<pre class="brush:plain;">mvn package</pre>
<p>... y finalmente ejecutar nuestra aplicaci&oacute;n java</p>
<pre class="brush:plain;">mvn exec:java</pre>
<p>El resultado debe ser:</p>
<pre class="code">Hola amigos de los Servicios Web !</pre>
<p>L&oacute;gicamente, siempre y cuando el servicio est&eacute; desplegado en un servidor de aplicaciones que est&eacute; en marcha! :)</p>
</div>


<a name="N107B6"></a><a name="Invocaci%C3%B3n+de+servicios+web+JAX-WS+desde+una+aplicaci%C3%B3n+Web+con+Maven"></a>
<h2 class="underlined_10">Invocaci&oacute;n de servicios web JAX-WS desde una aplicaci&oacute;n Web con Maven</h2>
<div class="section">
<p>Vamos a ver a c&oacute;mo podemos invocar un servicio web JAX-WS desde un Servlet y/o JSP con Maven.
   Utilizaremos el mismo wsdl del ejemplo del apartado anterior.
</p>
<p>En este caso comenzaremos por generar un proyecto Web java EE 6 con Maven:</p>
<pre class="brush:plain;">
mvn archetype:generate -DgroupId=jtech 
                       -DartifactId=HolaMundoWebClient 
                       -Dversion=1.0-SNAPSHOT 
                       -DarchetypeArtifactId=webapp-javaee6
                       -DarchetypeGroupId=org.codehaus.mojo.archetypes 
                       -DinteractiveMode=false
</pre>
<div class="frame note">
<div class="label">Importante</div>
<div class="content">
No olvides incluir el par&aacute;metro <em>-DarchetypeGroupId=org.codehaus.mojo.archetypes</em>, si no lo haces
as&iacute;, Maven no encontrar&aacute; el arquetipo <em>webapp-javaee6</em> en el cat&aacute;logo de arquetipos.

</div>
</div>
<p>Vamos a comentar brevemente el contenido del fichero <strong><em>pom.xml</em></strong> que hemos generado. Tenemos
   las siguientes dependencias y <em>plugins</em>.</p>
<ul>
   
<li>librer&iacute;a <strong>javaee-web-api (versi&oacute;n 6.0)</strong>: necesaria para utilizar <em>servlets</em> con anotaciones</li>
   
<li>plugin <strong>maven-compiler (version 2.3.2)</strong>: necesitamos configurar la versi&oacute;n de los fuentes y ejecutables java
       (1.6), y para compilar las librer&iacute;as del directorio "endorsed". Dicho directorio se contendr&aacute; versiones actualizadas de librer&iacute;as de anotaciones de
       servicios Web. </li>
   
<li>plugin <strong>maven-war (version 2.1.1)</strong>: utilizado para empquetar nuestro proyecto ignorando el fichero <em>web.xml</em>
       a la hora de hacer el <em>build</em> de nuestro proyecto</li>
   
<li>plugin <strong>maven-dependency (version 2.1)</strong>: lo utilizaremos para copiar en el directorio "endorsed" (target/endorsed) la librer&iacute;a 
       javaee-endorsed-api-6.0.jar. Esta librer&iacute;a permite utilizar anotaciones de servicios Web y se utilizar&aacute; en la librer&iacute;a correspondiente
       de jax-ws que viene incluida por defecto en jdk 6</li>
 
</ul>
<p>Para poder compilar y desplegar nuestro cliente de servicio Web en glassfish, vamos a a&ntilde;adir dos <em>plugins</em> m&aacute;s:</p>
<ul>
   
<li>plugin <strong>jaxws-maven-plugin (version 2.2)</strong>: con el que ejecutaremos la <em>goal</em> <em>wsimport</em>,
       igual que hicimos para el cliente Java del ejemplo anterior. </li>
   
<li>plugin <strong>glassfish (version 2.1)</strong>: para desplegar el war generado en el servidor de aplicaciones, utilizando
       la goal <em>glassfish:deploy</em>. Para configurar el <em>plugin</em>, vamos a indicar la contrase&ntilde;a utilizando el fichero
       <em>master-password</em>, que contiene la contrase&ntilde;a codificada del administrador del dominio, y que est&aacute; situado en el
       directorio ra&iacute;z de dicho dominio (en nuestro caso <span class="codefrag">glassfish/domains/domain1</span>). Por defecto, la contrase&ntilde;a del
       administrador del dominio es <em>changeit</em>, y esta contrase&ntilde;a NO se guarda (es decir, no se crea el <em>master-password</em>).
       Para crear dicho fichero tendremos que utilizar los siguientes comandos:
       <pre class="code">/opt/glassfish-3.2.2/bin/asadmin stop-domain</pre>
       
<pre class="code">/opt/glassfish-3.2.2/bin/asadmin change-master-password --savemasterpassword=true domain1</pre> 

       
<p>Este comando nos solicitar&aacute; la contrase&ntilde;a actual y la nueva. Introducimos en ambos casos <em>changeit</em>. Como
       resultado se habr&aacute; creado el fichero <span class="codefrag">glassfish/domains/domain1/master-password</span>, que referenciaremos en
       nuestro pom</p>     
   
</li> 

</ul>
<p>La configuraci&oacute;n del <strong>plugin de glassfish</strong> quedar&iacute;a como sigue:</p>
<pre class="brush:xml;">
&lt;plugin&gt;
   &lt;groupId&gt;org.glassfish.maven.plugin&lt;/groupId&gt;
   &lt;artifactId&gt;maven-glassfish-plugin&lt;/artifactId&gt;
   &lt;version&gt;2.1&lt;/version&gt;
   &lt;configuration&gt;
      &lt;user&gt;admin&lt;/user&gt;
      &lt;passwordFile&gt;
            /opt/glassfish-3.2.2/glassfish/domains/domain1/master-password
      &lt;/passwordFile&gt;
      &lt;glassfishDirectory&gt;/opt/glassfish-3.2.2/glassfish&lt;/glassfishDirectory&gt;
      &lt;domain&gt;
         &lt;name&gt;domain1&lt;/name&gt;
         &lt;adminPort&gt;4848&lt;/adminPort&gt;
         &lt;httpPort&gt;8080&lt;/httpPort&gt;
      &lt;/domain&gt;
      &lt;components&gt;
         &lt;component&gt;
            &lt;name&gt;HolaMundoWebClient&lt;/name&gt;
            &lt;artifact&gt;target/HolaMundoWebClient-1.0-SNAPSHOT.war&lt;/artifact&gt;
         &lt;/component&gt;
      &lt;/components&gt;
   &lt;/configuration&gt;
&lt;/plugin&gt;
  
</pre>
<p>Hemos configurado el despliegue de forma que el nombre del componente desplegado en Glassfish es <em>HolaMundoWebClient</em>. Dicho componente
   tendr&aacute; asociado el <em>war</em> de nuestra aplicaci&oacute;n Web. Si desp&uacute;es de desplegar la aplicaci&oacute;n en
   Glassfish, ejecutamos el
   comando <em>asadmin list-applications</em>, veremos que uno de las aplicaciones desplegadas es <em>HolaMundoWebClient</em>.
</p>
<div class="frame note">
<div class="label">Importante</div>
<div class="content">
Antes de realizar el despliegue de nuestra aplicaci&oacute;n tenemos que asegurarnos de que en nuestro directorio HOME no tengamos el fichero
<span class="codefrag">.asadminpass</span>. Si es as&iacute;, procederemos a renombrarlo (por ejemplo lo podemos sustituir por .asadminpass-old). 
</div>
</div>
<p>Ahora vamos a implementar el servlet (por ejemplo lo podemos llamar <em>NewServlet.java</em>). Para ello utilizaremos la anotaci&oacute;n <em>@WebServlet</em>. Especificaremos
   los atributos <em>name</em>, con el nombre del servlet, y el atributo <em>urlPatterns</em>,
   en el que indicaremos la url con la que se accede a dicho servlet.
</p>
<p>Una posible implementaci&oacute;n puede ser la siguiente:</p>
<pre class="brush:java;">
package expertoJava;

import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.ws.WebServiceRef;
import sw.Hola_Service;

@WebServlet(name = "Hola", urlPatterns = {"/Hola"})
public class NewServlet extends HttpServlet {
    @WebServiceRef
    private Hola_Service service;
    
    protected void processRequest(HttpServletRequest request, 
                                  HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        try {
            out.println("&lt;html&gt;");
            out.println("&lt;head&gt;");
            out.println("&lt;title&gt;Servlet HolaMundo&lt;/title&gt;");
            out.println("&lt;/head&gt;");
            out.println("&lt;body&gt;");
            out.println("&lt;h1&gt;Servlet HolaMundo desde " + request.getContextPath() + "&lt;/h1&gt;");

            try { // Obtenemos el Port
                sw.Hola port = service.getHolaPort();
                java.lang.String name = "amigos de los Servicios Web";
                // Llamamos a la operaci&oacute;n correspondiente del SEI
                java.lang.String result = port.hello(name);
                out.println("Result = "+result);
            } catch (Exception ex) {
               // Manejo de excepciones
            }

            out.println("&lt;/body&gt;");
            out.println("&lt;/html&gt;");
        } finally {
            out.close();
        }
    }
    
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }
   
    @Override
    public String getServletInfo() {
        return "Short description";
    }    
}  
</pre>
<p>Maven nos generar&aacute; como ra&iacute;z del contexto por defecto de nuestro servlet el nombre del
   artefacto generado, es decir, <em>HolaMundoWebClient-1.0-SNAPSHOT</em>. Si quisi&eacute;ramos utilizar
   otro nombre, como por ejemplo <em>HolaMundoWebClient</em>, tendremos que a&ntilde;adir el fichero
   <em>glassfish-web.xml</em> (en el directorio src/main/webapp/WEB-INF/) con el siguiente 
   contenido:</p>
<pre class="brush:java;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE glassfish-web-app PUBLIC 
    "-//GlassFish.org//DTD GlassFish Application Server 3.1 Servlet 3.0//EN" 
    "http://glassfish.org/dtds/glassfish-web-app_3_0-1.dtd"&gt;
&lt;glassfish-web-app&gt;
 &lt;context-root&gt;HolaMundoWebClient&lt;/context-root&gt;
&lt;/glassfish-web-app&gt; 
  
</pre>
<p>Ahora ya estamos en disposici&oacute;n de compilar, empaquetar, desplegar y ejecutar nuestro cliente. Los stubs necesarios para
   realizar la llamada al servicio Web se generar&aacute;n durante la compilaci&oacute;n. A continuaci&oacute;n empaquetaremos la aplicaci&oacute;n,
   lo cual generar&aacute; el war <em>target/HolaMundoWebClient-1.0-SNAPSHOT.war</em>. 
</p>
<pre class="code">mvn compile</pre>
<pre class="code">mvn package</pre>
<p>Antes de desplegar la aplicaci&oacute;n nos aseguraremos de que el servidor de aplicaciones est&eacute; en marcha. Podemos arrancarlo
   desde l&iacute;nea de comandos con:</p>
<pre class="code">/opt/glassfish-3.1.2.2/bin/asadmin start-domain</pre>
<p>Utilizando el comando <em>asadmin list-domains</em>, podemos ver qu&eacute; dominios se est&aacute;n ejecutando. A continuaci&oacute;n
  desplegamos nuestra aplicaci&oacute;n. 
</p>
<p>El siguiente paso es desplegar dicho war
   en el servidor de aplicaciones Glassfish. 
   Recordemos que el componente desplegado se llamar&aacute;: <em>HolaMundoWebClient</em>.</p>
<pre class="code">mvn glassfish:deploy</pre>
<p>Para comprobar que nuestra aplicaci&oacute;n web se ha desplegado, podemos usar el comando <em>asadmin list-applications</em>.</p>
<p>Con el <em>plugin</em> de glassfish podemos tambi&eacute;n eliminar el componente desplegado de glassfish: </p>
<pre class="brush:plain;">mvn glassfish:undeploy</pre>
<p>O redesplegar dicho
   componente (ser&iacute;a equivalente a hacer un <em>undeploy</em>, seguido de un <em>deploy</em>):</p>
<pre class="brush:plain;">mvn glassfish:redeploy</pre>
<p>Finalmente, podemos ver la ejecuci&oacute;n de nuestro servlet, accediendo a la siguiente 
   direcci&oacute;n, y suponiendo que hemos configurado la raiz del contexto como <em>HolaMundoWebClient</em>
   en el fichero <em>glassfish-web.xml</em>:</p>
<pre class="brush:plain;">http://localhost:8080/HolaMundoWebClient/Hola</pre>
<p>Podr&iacute;amos querer pasar el par&aacute;metro de entrada directamente en la llamada desde el navegador, para lo
   que tendremos que incluir en nuestro c&oacute;digo del <em>servlet</em> las siguientes l&iacute;neas: 
</p>
<pre class="brush:java;">
String cadena = request.getParameter("x");
...
out.println("&lt;p&gt;" + port.hello(cadena) + "%lt;/p&gt;");  
</pre>
<p>Ahora podemos pasar los par&aacute;metros de entrada al servlet de la siguiente forma:    
</p>
<pre class="brush:plain;">http://localhost:8080/HolaMundoWebClient/Hola?x=pepe%20de%20Alicante</pre>
<p>Los <span class="codefrag">%20</span> son espacios en blanco. <strong><span class="codefrag">x</span></strong> es el nombre del 
    par&aacute;metro de entrada. 
</p>
<p>Si en vez de un par&aacute;metro, nuestra aplicaci&oacute;n requiere m&aacute;s de uno, se deben pasar las parejas "variable=valor" separadas
   por el car&aacute;cter <span class="codefrag">&amp;</span>.</p>
<p>
<strong>Ficheros de despliegue: web.xml</strong>
</p>
<p>El uso de servlets con anotaciones hace que <strong>NO</strong> sea necesario proporcionar el fichero con la configuraci&oacute;n
   del despliegue (fichero web.xml). A continuaci&oacute;n mostramos el c&oacute;digo de dicha configuraci&oacute;n (<strong>web.xml</strong>), que puede 
   incluirse en el directorio <strong>src/main/webapp/WEB-INF</strong>:</p>
<pre class="brush:xml;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;Hola&lt;/servlet-name&gt;
        &lt;servlet-class&gt;expertoJava.NewServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Hola&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/Hola&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;session-config&gt;
        &lt;session-timeout&gt;
            30
        &lt;/session-timeout&gt;
    &lt;/session-config&gt;
&lt;/web-app&gt;
  
</pre>
<p>
<strong>Uso de la anotaci&oacute;n @WebServiceRef</strong>
</p>
<p>Java EE 6 permite "inyectar" una referencia a un servicio Web remoto, a trav&eacute;s del uso de la anotaci&oacute;n
   <strong>@WebServiceRef</strong>. Utilizando esta anotaci&oacute;n, el contenedor inyectar&aacute; una instancia del WS (un objeto 
   <strong><span class="codefrag">Service</span></strong>) en tiempo de ejecuci&oacute;n. Ya hemos visto que, a partir del WSDL, es posible escribir un <em>proxy</em> 
   (<em>stub</em>) java para invocar a un servicio Web (WS). La herramienta <em>wsimport</em> genera, a partir del
   WSDL, las clases e interfaces java que hacen posible la ejecuci&oacute;n de una llamada a un WS por un cliente. Las
   interfaces generadas representan el SEI (<em>Service Endpoint Interface</em>), a trav&eacute;s del cual podemos realizar
   llamadas locales al WS remoto v&iacute;a HTTP.
</p>
<p>El cliente puede obtener una instancia del <em>proxy</em> del WS utilizando la anotaci&oacute;n <strong>@WebServiceRef</strong>
   de la siguiente forma:</p>
<pre class="brush:java;">
...
@WebServiceRef
private MiServicio myService;
...
MiPuerto myPort=myService.getMiPuertoPort();
...
</pre>
<p>
<strong><span class="codefrag">MyServicio</span></strong> es una clase que hereda de <strong><span class="codefrag">javax.xml.ws.Service</span></strong>, y es generada
   por la herramienta <em>wsimport</em>.</p>
<p>Si nuestro cliente NO reside en un contenedor (NO es gestionado por el contenedor), entonces NO soporta el uso de dicha anotaci&oacute;n.
   Es decir, podemos hacer uso de <em>@WebServiceRef</em> cuando nuestro cliente sea, por ejemplo, un <em>servlet</em> o un <em>EJB</em>, 
   pero no cuando sea una clase java plana. En este &uacute;ltimo caso tendremos que crear la instancia nosotros mismos (tendremos que hacer un <strong><span class="codefrag">new</span></strong>) del
   servicio directamente en nuestro c&oacute;digo):</p>
<pre class="brush:java;">

private MiServicio myService = new MiServicio();
...
MiPuerto myPort=myService.getMiPuertoPort();
...
</pre>
<p>La anotaci&oacute;n <strong>@WebServiceRef</strong> puede soportar, entre otros, los siguientes par&aacute;metros: </p>
<ul>
  
<li>
<strong>name</strong>: identifica la referencia al servicio Web. El valor de <em>name</em> es un nombre local a la aplicaci&oacute;n
      que utiliza dicho recurso (WS). El nombre pude ser un nombre JNDI absoluto o relativo al espacio de nombres JNDI de java:
      <em>java:comp/env</em>. El valor por defecto es la cadena vac&iacute;a</li>
  
<li>
<strong>wsdlLocation</strong>: identifica la URL del documento WSDL del servicio web referenciado. Por defecto contiene la
      cadena vac&iacute;a. Si dicho valor est&aacute; presente, "sobreescribe" (<em>overrides</em>) la localizaci&oacute;n del
      documento WSDL que se haya especificado en la anotaci&oacute;n <em>WebService</em> de la clase del servicio referenciado que ha
      sido generada en el cliente (en nuestro caso la clase Hola_Service generada por wsimport)</li>
  
<li>
<strong>type</strong>: identifica el tipo del recurso como un objeto de una clase Java. Por defecto su valor es <em>Object.class</em>
      
</li>
  
<li>
<strong>value</strong>: identifica el tipo del recurso como un objeto de una clase Java. Por defecto su valor es <em>Service.class</em>
      
</li>    

</ul>
<p>
<strong>Invocaci&oacute;n del servicio Web desde una p&aacute;gina JSP</strong>
</p>
<p>Para ilustrar un ejemplo de una invocaci&oacute;n al servicio Web desde una p&aacute;gina jsp, simplemente
   tendremos que incluir la llamada a dicho WS desde <span class="codefrag">src/main/webapp/index.jsp</span>, por ejemplo, as&iacute;:
</p>
<pre class="brush:xml;">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd"&gt;

&lt;html&gt;
   &lt;head&gt;
     &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
     &lt;title&gt;JSP Page&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;h1&gt;Hola Mundo!&lt;/h1&gt;
&lt;%
      try {
         sw.Hola_Service service = new sw.Hola_Service();
         sw.Hola port = service.getHolaPort();
         String name = "amigos de los Servicios Web";
         String result = port.hello(name);
         out.println("Result = "+result);
      } catch (Exception ex) {
         // TODO handle custom exceptions here
      }
%&gt;
    &lt;/body&gt;
&lt;/html&gt;

  
</pre>
<p>Una vez compilado y re-desplegado nuestro cliente Web, para comprobar que se ejecuta la invocaci&oacute;n al servicio Web desde
   la p&aacute;gina <strong>jsp</strong>, accederemos a la direcci&oacute;n:</p>
<pre class="brush:plain;">http://localhost:8080/HolaMundoWebClient/</pre>
</div>   


<a name="N109A6"></a><a name="Invocaci%C3%B3n+de+servicios+web+con+Netbeans"></a>
<h2 class="underlined_10">Invocaci&oacute;n de servicios web con Netbeans</h2>
<div class="section">
<p>Vamos a ver ahora c&oacute;mo crear un cliente de servicios web de forma visual mediante Netbeans. Este 
entorno utilizar&aacute; internamente las librer&iacute;as y herramientas est&aacute;ndar de Sun para crear <em>stub</em> del cliente.</p>
<p>En primer lugar, deberemos crear un proyecto, o utilizar uno ya existente. Este proyecto podr&aacute; ser de cualquier tipo
(aplicaci&oacute;n Java, aplicaci&oacute;n Web, etc). Para nuestro ejemplo crearemos un proyecto Maven Java.</p>
<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans" content-width="10cm" src="imagenes/sesion1/nb-hello01.jpg" width="400"></p>
<p>El proyecto se llamar&aacute; <span class="codefrag">HelloClient</span> y tendr&aacute; una clase principal <span class="codefrag">App</span> en el 
paquete <span class="codefrag">jtech.helloclient</span>.</p>
<p>
<img alt="Datos de la creaci&oacute;n del proyecto" content-width="8cm" src="imagenes/sesion1/nb-hello02.jpg" width="400"></p>
<p>Por defecto, la versi&oacute;n del c&oacute;digo fuente es la 1.5. Podr&iacute;amos cambiar a otra versi&oacute;n m&aacute;s actual (por ejemplo la 1.6) pulsando
   con bot&oacute;n derecho <strong><em>Properties-&gt;Sources</em></strong> y editando el campo <strong><em>Source/Binary format</em></strong>.</p>
<p>Una vez tengamos el proyecto java creado, podremos a&ntilde;adir el <em>stub</em> para acceder
a un servicio web pulsando con el bot&oacute;n derecho sobre el proyecto y seleccionando la opci&oacute;n <strong><em>New-&gt;Web Service Client ...</em></strong>.
</p>
<p>
<img alt="Creaci&oacute;n de un cliente de servicio Web" content-width="10cm" src="imagenes/sesion1/nb-hello04.jpg" width="400"></p>
<p>Se abrir&aacute; un asistente para crear el <em>stub</em> del cliente. Aqu&iacute; deberemos especificar en primer lugar el documento
WSDL que define el servicio al que vamos a acceder, por ejemplo indicando la URL en la que se encuentra. En segundo lugar 
especificaremos el paquete en el que queremos que se generen las clases del <em>stub</em>.</p>
<p>
<img alt="Datos para la creaci&oacute;n del stub en el cliente" content-width="11cm" src="imagenes/sesion1/nb-hello06.jpg" width="500"></p>
<p>Finalmente, una vez introducidos estos datos pulsaremos el bot&oacute;n <em>Finish</em>, tras lo cual se invocar&aacute; a 
<span class="codefrag">wsimport</span> para generar el <em>stub</em> del servicio. Una vez generado el <em>stub</em> del cliente, podremos ver en 
la carpeta <em>Generated Sources (jaxws-wsimport)</em> del proyecto las clases generadas. En la carpeta <em>Web Service References</em>
veremos la referencia al puerto y operaciones que proporciona el servicio Web referenciado.
</p>
<p>
<img alt="Ficheros generados por wsimport y referencias al WS" content-width="5cm" src="imagenes/sesion1/nb-hello07.jpg" width="321"></p>
<p>Una vez creado el <em>stub</em> del cliente, deberemos utilizarlo en nuestra aplicaci&oacute;n para acceder al servicio. Vamos a suponer
que lo queremos invocar desde la clase principal de nuestra aplicaci&oacute;n (<span class="codefrag">App</span>), aunque lo mismo podr&iacute;a hacerse para invocarlo desde 
cualquier otra clase, o incluso desde un JSP. Para crear el c&oacute;digo que llame al servicio pulsaremos con el bot&oacute;n derecho del rat&oacute;n
en el lugar del fuente de nuestra clase en el que queramos insertar la llamada (en nuestro ejemplo, en el fichero <span class="codefrag">App.java </span> dentro del 
m&eacute;todo <span class="codefrag">main</span>), y con el bot&oacute;n derecho seleccionaremos la opci&oacute;n <strong><em>Insert Code...</em></strong>, y a continuaci&oacute;n <strong><em>Call Web Service Operation</em></strong>.
</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">De forma alternativa podr&iacute;amos a&ntilde;adir el c&oacute;digo que invoca el servicio arrastrando el 
la operaci&oacute;n <em>hola</em> de la carpeta <em>Web Service References</em>, hasta el lugar del c&oacute;digo donde queremos realizar la llamaada.</div>
</div>
<p>Se abrir&aacute; una ventana en la que deberemos seleccionar la operaci&oacute;n que queramos invocar. En nuestro caso seleccionaremos
la operaci&oacute;n <span class="codefrag">hello</span> del servicio <span class="codefrag">hola</span> y pulsamos el bot&oacute;n <em>OK</em>

</p>
<p>
<img alt="Selecci&oacute;n de la operacion del WS a invocar en el cliente" content-width="5cm" src="imagenes/sesion1/nb-hello10.jpg" width="311"></p>
<p>Una vez hecho esto, Netbeans generar&aacute; en nuestra clase el c&oacute;digo que hace la llamada al servicio. Deberemos editar este c&oacute;digo
para especificar los par&aacute;metros que vamos a proporcionar en la llamada.</p>
<p>
<img alt="Edici&oacute;n de la llamada al servicio web" content-width="9cm" src="imagenes/sesion1/nb-hello11.jpg" width="400"></p>
<p>Con esto ya podremos ejecutar nuestra aplicaci&oacute;n cliente (con el bot&oacute;n derecho sobre nuestro proyecto, pulsando <em>Run</em> ),
que se conectar&aacute; al servicio web <span class="codefrag">hola</span>. El resultado se mostrar&aacute; en el panel de salida de Netbeans. </p>
<p>
<img alt="Ejecuci&oacute;n del cliente java del servicio Web hola" content-width="9cm" src="imagenes/sesion1/nb-hello11.png" width="500"></p>
</div>


<a name="N10A66"></a><a name="Gestor+de+servicios+web+de+Netbeans"></a>
<h2 class="underlined_10">Gestor de servicios web de Netbeans</h2>
<div class="section">
<p>En Netbeans tambi&eacute;n encontramos un gestor de servicios web, en el que tenemos disponibles algunos servicios
web externos proporcionados por terceros (Google, StrikeIron), y al que podemos a&ntilde;adir otros servicios, propios
o ajenos. De esta forma podemos tener un cat&aacute;logo de servicios que podremos incorporar de forma r&aacute;pida a
nuestras aplicaciones, e incluso probarlos desde el propio entorno.</p>
<p>Podemos acceder a este gestor de servicios a trav&eacute;s de la secci&oacute;n <em>Web Services</em> de la ventana 
<em>Services</em> de Netbeans. Aqu&iacute; veremos una lista de servicios que ya vienen incluidos en Netbeans y que 
podremos probar o incorporar en nuestras aplicaciones. Vamos a a&ntilde;adir un nuevo servicio. Para ello antes 
creamos un grupo en el que incluirlo. Pulsamos con el bot&oacute;n derecho sobre <em>Web Services</em> y 
seleccionamos <em>Create Group</em> para crear el nuevo grupo.
</p>
<p>
<img alt="Gestor de servicios web de Netbeans" content-width="7cm" height="151" src="imagenes/sesion1/nbtest_1.gif" width="331"></p>
<p>Vamos a a&ntilde;adir un servicio <em>HelloService</em>. Vamos a crear un 
grupo de nombre <em>jTech</em> en el que incluiremos los servicios proporcionados por dicha entidad.
</p>
<p>
<img alt="Creaci&oacute;n de un nuevo grupo de servicios" content-width="6cm" height="123" src="imagenes/sesion1/nbtest_2.gif" width="288"></p>
<p>Pulsamos sobre el grupo con el bot&oacute;n derecho y seleccionamos <em>Add Web Service ...</em> para a&ntilde;adir 
el nuevo servicio.
</p>
<p>
<img alt="A&ntilde;adimos un nuevo servicio en el grupo creado" content-width="6cm" src="imagenes/sesion1/nb-hello12.jpg" width="313"></p>
<p>Como datos del servicio proporcionamos la direcci&oacute;n del documento WSDL que lo define. Adem&aacute;s podemos tambi&eacute;n
especificar el paquete en el cual generar&aacute; la librer&iacute;a con el <em>stub</em> necesario para acceder al servicio. 
Cuando terminemos de introducir los datos pulsamos <em>Add</em> para a&ntilde;adir el nuevo servicio.
</p>
<p>
<img alt="Datos del servicio web para el gestor de servicios" content-width="10cm" src="imagenes/sesion1/nb-hello13.jpg" width="400"></p>
<p>Una vez tenemos el servicio a&ntilde;adido, podemos desplegarlo para ver las operaciones que ofrece y probarlas
pulsando sobre ellas con el bot&oacute;n derecho y seleccionando <em>Test Method</em>

</p>
<p>
<img alt="Prueba de un servicio desde el gestor de servicios" content-width="7cm" src="imagenes/sesion1/nb-hello14.jpg" width="306"></p>
<p>Nos aparecer&aacute; una ventana en la que deberemos introducir los par&aacute;metros necesarios para invocar el servicio,
y tras ello pulsar sobre el bot&oacute;n <em>Submit</em> para invocarlo y ver el resultado obtenido.
</p>
<p>
<img alt="Datos para la prueba del servicio y resultado obtenido" content-width="7cm" src="imagenes/sesion1/nb-hello15.jpg" width="438"></p>
<p>Tambi&eacute;n podemos utilizar los servicios del gestor en nuestras aplicaciones de forma sencilla. Simplemente
tendremos que arrastrar la operaci&oacute;n que queramos invocar sobre el lugar del c&oacute;digo fuente en el que queramos
hacer la llamada. Al hacer esto se a&ntilde;adir&aacute; a nuestro proyecto una librer&iacute;a (JAR) con el <em>stub</em> necesario
para acceder al servicio.</p>
</div>


<a name="N10AD5"></a><a name="Interfaz+de+invocaci%C3%B3n+din%C3%A1mica+%28DII%29"></a>
<h2 class="underlined_10">Interfaz de invocaci&oacute;n din&aacute;mica (DII)</h2>
<div class="section">
<p>Mediante esta interfaz ya no utilizaremos un <em>stub</em> para invocar los 
  m&eacute;todos del servicio, sino que nos permitir&aacute; invocar los m&eacute;todos 
  de forma din&aacute;mica, indicando simplemente el nombre del m&eacute;todo 
  que queremos invocar como una cadena de texto, y sus par&aacute;metros como 
  un <em>array</em> de objetos.</p>
<p>Esto nos permitir&aacute; utilizar servicios que no conocemos previamente. 
  De esta forma podremos implementar por ejemplo un <em>broker</em> de servicios. 
  Un <em>broker</em> es un servicio intermediario, al que podemos solicitar alguna 
  tarea que necesitemos. Entonces el <em>broker</em> intentar&aacute; localizar 
  el servicio m&aacute;s apropiado para dicha tarea en un registro de servicios, 
  y lo invocar&aacute; por nosotros. Una vez haya conseguido la informaci&oacute;n 
  que requerimos, nos la devolver&aacute;. De esta forma la localizaci&oacute;n 
  de servicios se hace totalmente transparente para nosotros.</p>
<p>Podremos acceder con esta interfaz tanto si contamos con un documento WSDL 
  como si no contamos con &eacute;l, pero en el caso de que no tengamos el WSDL 
  deberemos especificar en el c&oacute;digo todos los datos incluidos en estos 
  documentos que necesitemos y de los que en este caso no disponemos (<em>endpoint</em>, 
  par&aacute;metros y tipos, etc).</p>
<a name="N10AF6"></a><a name="A+partir+de+un+documento+WSDL"></a>
<h3 class="underlined_5">A partir de un documento WSDL</h3>
<p>Vamos a ver el caso en el que contamos con el documento WSDL que describe el 
  servicio. El primer paso ser&aacute; conseguir el objeto <span class="codefrag">Service</span> 
  igual que hicimos en el caso anterior. La clase <strong>javax.xml.ws.Service</strong> es una
  abstracci&oacute;n que representa un servicio WSDL (etiqueta <em>service</em>). </p>
<p>  La clase
  <strong>Service</strong> act&uacute;a como una factor&iacute;a que proporciona tanto <em>proxies</em> para
  el <em>enpoint</em> de un servicio (de forma est&aacute;tica utilizando los stubs generados), como instancias para llamadas a operaciones remotas de
  forma din&aacute;mica.
  </p>
<p>Un ejemplo de uso din&aacute;mico de <strong>Service</strong> es el siguiente:</p>
<pre class="brush:java;">
ServiceFactory sf = ServiceFactory.newInstance();
Service serv = sf.createService(
   new URL("http://localhost:8080/HolaMundo/hola?WSDL"),
   new QName("http://localhost:8080/HolaMundo", "hello"));
</pre>
<p>Utilizaremos el objeto <span class="codefrag">Call</span> para hacer las llamadas din&aacute;micas 
  a los m&eacute;todos del servicio. Deberemos crear un objeto <span class="codefrag">Call</span> 
  correspondiente a un determinado puerto y operaci&oacute;n de nuestro servicio:</p>
<pre class="brush:java;">
  Call call = serv.createCall(
  new QName("http://localhost:8080/HolaMundo", "holaPort"),
  new QName("http://localhost:8080/HolaMundo", "hello"));
</pre>
<p>El &uacute;ltimo paso ser&aacute; invocar la llamada que hemos creado:</p>
<pre class="brush:java;">
    String result = (String) call.invoke(
    new Object[] { "Miguel" });
</pre>
<p>A este m&eacute;todo le debemos proporcionar un <em>array</em> de objetos como 
  par&aacute;metro, ya que debe poder utilizarse para cualquier operaci&oacute;n, 
  con diferente n&uacute;mero y tipo de par&aacute;metros. Como tampoco se conoce<em> 
  a priori</em> el valor devuelto por la llamada, deberemos hacer una conversi&oacute;n 
  <em>cast</em> al tipo que corresponda, ya que nos devuelve un <span class="codefrag">Object</span> 
  gen&eacute;rico.</p>
<a name="N10B45"></a><a name="Sin+un+documento+WSDL"></a>
<h3 class="underlined_5">Sin un documento WSDL</h3>
<p>Si no contamos con el WSDL del servicio, crearemos un objeto <span class="codefrag">Service</span> 
  proporcionando &uacute;nicamente el nombre del servicio:</p>
<pre class="brush:java;">
   ServiceFactory sf = ServiceFactory.newInstance(); 
   Service serv = sf.createService( 
   new QName("http://jtech.ua.es", "hola"));</pre>
<p>A partir de este objeto podremos obtener un objeto <span class="codefrag">Call</span> para 
  realizar una llamada al servicio de la misma forma que vimos en el caso anterior:</p>
<pre class="brush:java;">
  Call call = serv.createCall(
  new QName("http://localhost:8080/HolaMundo", "holaPort"),
  new QName("http://localhost:8080/HolaMundo", "hello"));</pre>
<p>En este caso el objeto <span class="codefrag">Call</span> no tendr&aacute; ninguna informaci&oacute;n 
  sobre las caracter&iacute;sticas del servicio, ya que no tiene acceso al documento 
  WSDL que lo describe, por lo que deberemos proporcion&aacute;rselas nosotros 
  expl&iacute;citamente.</p>
<p>En primer lugar, deberemos especificar el <em>endpoint</em> del servicio, para 
  que sepa a qu&eacute; direcci&oacute;n debe conectarse para acceder a dicho 
  servicio:</p>
<pre class="brush:java;">call.<strong>setTargetEndpointAddress</strong>(endpoint);</pre>
<p>Una vez especificada esta informaci&oacute;n, deberemos indicar el tipo de 
  datos que nos devuelve la llamada a la operaci&oacute;n que vamos a invocar 
  (en nuestro ejemplo <span class="codefrag">saluda</span>):</p>
<pre class="brush:java;">
  QName t_string = 
  new QName("http://www.w3.org/2001/XMLSchema", "string");
  call.setReturnType(t_string);</pre>
<p>Por &uacute;ltimo, indicaremos los par&aacute;metros de entrada que toma la 
  operaci&oacute;n y sus tipos:</p>
<pre class="brush:java;">
  QName t_string = 
  new QName("http://www.w3.org/2001/XMLSchema", "string");
  call.addParameter("string_1", t_string, ParameterMode.IN);</pre>
<p>Una vez hecho esto, podremos invocar dicha operaci&oacute;n igual que en el 
  caso anterior:</p>
<pre class="brush:java;">
    String result = (String) call.<strong>invoke</strong>(
    new Object[] { "Miguel" });</pre>
</div>


<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
