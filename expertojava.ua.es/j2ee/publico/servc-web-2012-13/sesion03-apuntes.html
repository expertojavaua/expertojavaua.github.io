<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Orquestaci&oacute;n de Servicios: BPEL</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servicios Web y SOA" src="images/baner_j2ee_der.gif" title="Servicios Web y SOA"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servicios Web</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servicios Web</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servicios Web">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 3</div>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion03-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Orquestaci&oacute;n de Servicios: BPEL</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Orquestaci%C3%B3n+frente+a+Coreograf%C3%ADa">Orquestaci&oacute;n frente a Coreograf&iacute;a</a>
<ul class="minitoc">
<li>
<a href="#%C2%BFPor+qu%C3%A9+orquestar+Servicios+Web%3F">&iquest;Por qu&eacute; orquestar Servicios Web?</a>
</li>
<li>
<a href="#%C2%BFPor+qu%C3%A9+orquestar+servicios+Web+con+BPEL%3F">&iquest;Por qu&eacute; orquestar servicios Web con BPEL?</a>
</li>
</ul>
</li>
<li>
<a href="#El+lenguaje+BPEL">El lenguaje BPEL</a>
</li>
<li>
<a href="#Estructura+de+un+proceso+BPEL">Estructura de un proceso BPEL</a>
<ul class="minitoc">
<li>
<a href="#">Partner Links</a>
</li>
<li>
<a href="#Variables">Variables</a>
</li>
<li>
<a href="#Actividades">Actividades</a>
</li>
</ul>
</li>
<li>
<a href="#Relaci%C3%B3n+de+BPEL+con+BPMN">Relaci&oacute;n de BPEL con BPMN</a>
</li>
<li>
<a href="#Pasos+para+desarrollar+un+proceso+de+negocio+con+BPEL">Pasos para desarrollar un proceso de negocio con BPEL</a>
</li>
<li>
<a href="#Despliegue+y+pruebas+del+proceso+BPEL">Despliegue y pruebas del proceso BPEL</a>
<ul class="minitoc">
<li>
<a href="#Entorno+de+ejecuci%C3%B3n+JBI">Entorno de ejecuci&oacute;n JBI (JBI Runtime Environment)</a>
</li>
<li>
<a href="#BPEL">BPEL Service Engine</a>
</li>
<li>
<a href="#Proyecto+de+aplicaciones+compuestas">Proyecto de aplicaciones compuestas</a>
</li>
</ul>
</li>
<li>
<a href="#Creaci%C3%B3n+y+ejecuci%C3%B3n+de+casos+de+prueba">Creaci&oacute;n y ejecuci&oacute;n de casos de prueba</a>
</li>
</ul>
</div>


<p>La respuesta m&aacute;s reciente al reto de la integraci&oacute;n de aplicaciones es la arquitectura
   orientada a servicios (SOA) y las tecnolog&iacute;as de servicios web. El enfoque <em>bottom-up</em>
   de SOA considera que las diferentes aplicaciones de la empresa exponen sus funcionalidades
   a trav&eacute;s de servicios web. De esta forma se puede acceder a diferentes funcionalidades de
   diferentes aplicaciones (tanto <em>legacy</em> como de nueva creaci&oacute;n) de una forma com&uacute;n a trav&eacute;s
   de servicios web. 
   </p>

<p>Pero el desarrollar servicios web y exponer las funcionalidades no es suficiente.
   Necesitamos tambi&eacute;n alguna forma de componer dichas funcionalidades en el orden correcto.
   En esta sesi&oacute;n hablaremos de c&oacute;mo realizar dicha secuenciaci&oacute;n, concretamente nos centraremos
   en una de las aproximaciones posibles: la orquestaci&oacute;n de servicios. Para ello haremos uso de
   un lenguaje denominado BPEL, que permite la composici&oacute;n de servicios seg&uacute;n el paradigma de
   orquestaci&oacute;n de servicios. El uso de BPEL har&aacute; posible una aproximaci&oacute;n <em>top-down</em> 
   (o aproximaci&oacute;n orientada a los procesos) de SOA. 
   </p>


<a name="N1001B"></a><a name="Orquestaci%C3%B3n+frente+a+Coreograf%C3%ADa"></a>
<h2 class="underlined_10">Orquestaci&oacute;n frente a Coreograf&iacute;a</h2>
<div class="section">
<p>Los servicios Web "exponen" las operaciones de ciertas aplicaciones o sistemas de informaci&oacute;n.
   Consecuentemente, la combinaci&oacute;n (composici&oacute;n) de varios servicios Web realmente implica la integraci&oacute;n de las
   aplicaciones subyacentes y sus funcionalidades</p>
<p>Los servicios Web pueden combinarse de dos formas:</p>
<ul>
  
<li>Orquestaci&oacute;n</li>
  
<li>Correograf&iacute;a</li>

</ul>
<p>Cuando se hace uso de <strong>orquestaci&oacute;n</strong>, un proceso central (que puede ser otro servicio Web) 
   lleva el control de los servicios Web implicados en la realizaci&oacute;n de una tarea y 
   coordina la ejecuci&oacute;n de las diferentes operaciones sobre dichos servicios Web.
   Los servicios Web orquestados no "conocen" (y no necesitan conocer) que est&aacute;n implicados en un proceso de composici&oacute;n
   y que forman parte de un proceso de negocio de nivel m&aacute;s alto. Solamente el coordinador central de la orquestaci&oacute;n
   es "consciente" de la meta a conseguir, por lo que la orquestaci&oacute;n se centraliza mediante definiciones expl&iacute;citas
   de las operaciones y del orden en el que se deben invocar los servicios Web, tal y como se muestra en la siguiente
   figura. La orquestaci&oacute;n se utiliza
   normalmente en procesos de negocio privados.
</p>
<p>
	
<img alt="Orquestaci&oacute;n de servicios." content-width="9cm" src="imagenes/sesion5/orquestacion.gif" width="318"> 
</p>
<p>Cuando se hace uso de <strong>coreograf&iacute;a</strong>, no hay un coordinador central. En su lugar, cada servicio
   Web implicado en dicha coreograf&iacute;a "conoce" exactamente cuando ejecutar sus operaciones y con qui&eacute;n debe interactuar.
   La coreograf&iacute;a es un esfuerzo colaborativo centrado en el intercambio de mensajes en procesos de negocio p&uacute;blicos.
   Todos los participantes en la coreograf&iacute;a ncesitan estar "informados" del proceso de negocio, las operaciones a 
   ejectuar, los mensajes a intercambiar, y el tiempo a invertir en dicho intercambio de mensajes. Mostramos 
   este esquema a continuaci&oacute;n.
</p>
<p>
	
<img alt="Coreograf&iacute;a de servicios." content-width="9cm" src="imagenes/sesion5/coreografia.gif" width="337"> 
</p>
<p>Desde la perspectiva de la composici&oacute;n de servicios Web para ejecutar procesos de negocio, la orquestaci&oacute;n es un paradigma
   m&aacute;s flexible y tiene las siguientes ventajas sobre la coreograf&iacute;a:
</p>
<ul>
  
<li>La coordinaci&oacute;n de los procesos componentes est&aacute; gestionada de forma centralizada por un coordinador conocido.</li>
  
<li>Los servicios Web puden incorporarse sin que sean "conscientes" de que est&aacute;n formando parte de un proceso de
      negocio mayor.</li>
  
<li>Pueden crearse escenarios alternativos en caso de que ocurra alg&uacute;n fallo.</li>    

</ul>
<a name="N1005F"></a><a name="%C2%BFPor+qu%C3%A9+orquestar+Servicios+Web%3F"></a>
<h3 class="underlined_5">&iquest;Por qu&eacute; orquestar Servicios Web?</h3>
<p>Los servicios Web se utilizan actualmente tanto dentro como fuera de los l&iacute;mites de una organizaci&oacute;n. Los servicios Web se est&aacute;n
   convirtiendo en la tecnolog&iacute;a com&uacute;n para proporcionar puntos de integraci&oacute;n entre las aplicaciones (tanto por vendedores de
   grandes aplicaciones de empresa, como por negocios tradicionales de internet, como la tienda electr&oacute;nica Amazon.com o la
   m&aacute;quina de b&uacute;squeda Google, que exponen interfaces en forma de servicios Web para que dichas aplicaciones sean tambi&eacute;n
   "integrables").
</p>
<p>El siguiente paso l&oacute;gico en el salto a un modelo centrado en servicios (Web) es la orquestaci&oacute;n de dichos servicios en
   nuevos procesos de negocio y servicios de m&aacute;s alto nivel. Los servicios Web proporcionan una tecnolog&iacute;a de interfaces com&uacute;n
   que unifica el modelo de integraci&oacute;n para todos los servicios independientemente de su origen. Los beneficios de los servicios
   Web, tales como su descubrimiento en tiempo de ejecuci&oacute;n y su bajo acoplamiento, contribuyen a la orquestaci&oacute;n de
   servicios Web proporcionando un acercamiento al modelado y ejecuci&oacute;n de procesos de negocio en tiempo real. La idea es construir
   orquestaciones sin utilizar herramientas de programaci&oacute;n tradicionales, tales como C# o Java, con el objetivo de reducir
   el esfuerzo total de producir nuevos servicios y aplicaciones basadas en servicios.
</p>
<div class="frame note">
<div class="label">Recuerda</div>
<div class="content"> La orquestaci&oacute;n de servicios Web pretende proporcionar una aproximaci&oacute;n abierta, basada en estandares, para
  conectar servicios Web de forma conjunta con el objetivo de crear procesos de negocio de m&aacute;s alto nivel.
</div>
</div>
<a name="N10070"></a><a name="%C2%BFPor+qu%C3%A9+orquestar+servicios+Web+con+BPEL%3F"></a>
<h3 class="underlined_5">&iquest;Por qu&eacute; orquestar servicios Web con BPEL?</h3>
<p>Dentro de la orquestaci&oacute;n de servicios, BPEL constituye un <strong>lenguaje est&aacute;ndar</strong> para la integraci&oacute;n y automatizaci&oacute;n de procesos.
   Los procesos de negocio programados con BPEL ser&aacute;n capaces de  ejecutarse en diferentes plataformas 
   que cumplan dicho est&aacute;ndar, ofreciendo a los clientes una mayor libertad de elecci&oacute;n.
</p>
<p>Otras razones para utilizar orquestaci&oacute;n de servicios y BPEL son: </p>
<ul>
  
<li>
<strong>Menores costes de mantenimiento:</strong> con la utilizaci&oacute;n de un lenguaje de programaci&oacute;n como C o Java, el mantenimiento puede resultar
    m&aacute;s dif&iacute;cil, especialmente si la l&oacute;gica de negocio sufre cambios frecuentes. Adem&aacute;s, no en todos los lenguajes
    de programaci&oacute;n resulta f&aacute;cil la manipulaci&oacute;n de mensajes XML. </li>
  
<li>
<strong>Menores costes de soporte: </strong>Si una organizaci&oacute;n tiene la capacidad de integrar servicios Web, tambi&eacute;n ser&aacute; capaz de crear e invocar procesos BPEL utilizando la
    infraestructura de servicios Web existente. Adem&aacute;s, BPEL tiene muchas construcciones relacionadas con la invocaci&oacute;n de
    servicios Web, incluyendo el manejo de fallos, la correlaci&oacute;n, y soporte para l&oacute;gica condicional. BPEL tiene un soporte
    muy bueno para manejar mensajes XML a trav&eacute;s de XPath (XPath se utiliza para referenciar partes de un mensaje XML y para 
    realizar manipulaciones b&aacute;sicas de cadenas de carateres y de n&uacute;meros).</li>
  
<li>Finalmente, BPEL hace que sea posible <strong>ampliar el grupo de desarrolladores</strong> para 
    realizar tareas de integraci&oacute;n de procesos de negocio y automatizaci&oacute;n de procesos, que requer&iacute;an habilidades altamente
    especializadas. Utilizando herramientas gr&aacute;ficas de dise&ntilde;o, incluso los no desarrolladores, tales como los analistas del
    negocio pueden dise&ntilde;ar y modificar de forma sencilla las aplicaciones a medida que el negocio requiere cambios</li>

</ul>
<div class="frame note">
<div class="label">Recuerda</div>
<div class="content">El est&aacute;ndar BPEL ha sido dise&ntilde;ado para reducir la complejidad requerida para orquestar servicios Web, 
  reduciendo as&iacute; tiempo y costes de desarrollo, e incrementar la eficiencia y exactitud de los procesos de negocio. Sin un est&aacute;ndar
  cada organizaci&oacute;n tiene que construir su propio conjunto de protocolos de negocio propietarios, dejando poca flexibilidad para
  una verdadera colaboraci&oacute;n de los servicios Web.
</div>
</div>
<p>Adem&aacute;s, el lenguaje BPEL proporciona soporte para:</p>
<ul>
  
<li>
<strong>Elevados tiempos de ejecuci&oacute;n</strong>. Normalmente, los procesos de negocio tardan bastante tiempo en completar su
     ejecuci&oacute;n, particularmente si &eacute;stos implican interacciones con <em>partners</em> a trav&eacute;s de Internet. Puede ocurrir
     que dichos procesos requeran minutos, horas, e incluso d&iacute;as antes de su finalizaci&oacute;n. Puede ocurrir que invoquen a un
     servicio Web y necesiten esperar la respuesta durante un periodo relativamente largo de tiempo. Si utiliz&aacute;semos una
     aplicaci&oacute;n Java, por ejemplo, en lugar de un proceso BPEL tendr&iacute;amos que dedicar mucho tiempo a monitorizar qu&eacute; procesos
     han terminado, y cu&aacute;les siguen todav&iacute;a en ejecuci&oacute;n. Tambi&eacute;n necesitar&iacute;amos hacer un seguimiento de qu&eacute; aplicaciones Java
     (procesos) podemos "cerrar" y cu&aacute;les tenemos que seguir manteniendo en ejecuci&oacute;n debido a que est&aacute;n a la espera de recibir
     una respuesta.</li>
  
<li>
<strong>Compensaci&oacute;n</strong>. Llamamos compensaci&oacute;n al proceso de deshacer pasos realizados en un proceso de negocio que ya se han completado
     con &eacute;xito. Este concepto es uno de los m&aacute;s importantes en los procesos de negocio. El objetivo de la
     compensaci&oacute;n es dar marcha atr&aacute;s a los efectos de actividades previas que ya se han llevado a cabo como parte de un proceso
     de negocio que est&aacute; siendo abandonado. 
     <p>La compensaci&oacute;n est&aacute; relacionada con la naturaleza de la mayor&iacute;a de procesos de negocio
       que se ejecutan durante largos periodos de tiempo y utilizan comunicaci&oacute;n as&iacute;ncrona con servicios Web <em>partner</em> 
       d&eacute;bilmente acoplados. Este concepto es similar al de transacciones <em>ACID</em> (<em>Atomic, Consistent, Isolation, Durable </em>
       utilizadas en sistemas de informaci&oacute;n de
       empresas. BPEL soporta el concepto de compensaci&oacute;n con la posibilidad de definir manejadores de compensaci&oacute;n, que tienen
       un &aacute;mbito de acci&oacute;n espec&iacute;fico. A esta caracter&iacute;stica la denomina <em>Long-Running Transactions (LRT)</em>.
     </p>
  
</li>
  
<li>
<strong>Reacci&oacute;n ante eventos</strong>. Dichos eventos pueden ser mensajes o alarmas. Los eventos de tipo mensaje son generados por mensajes
     de entrada a trav&eacute;s de la invocaci&oacute;n de operaciones sobre los <em>port types</em>. Los eventos de tipo alarma est&aacute;n relacionados
     con el tiempo y se generan despu&eacute;s de un tiempo especificado.
  </li>
  
<li>
<strong>Modelado de actividades concurrentes</strong>. La concurrencia se modela mediante la actividad  &lt;flow&gt;. &Eacute;sta permite
     especificar escenarios concurrentes complejos, como por ejemplo el expresar dependencias de sincronizaci&oacute;n entre actividades.
     Es decir, podemos especificar qu&eacute; actividades pueden comenzar y cuando (dependiendo de otras actividades), definiendo as&iacute; 
     dependencias complejas. Por ejemplo, podemos especificar que una cierta actividad, o varias actividades no pueden comenzar
     antes de que otra actividad o varias activdades hayan terminado.
  </li>
  
<li>
<strong>Modelos con estado</strong>. A diferencia de los servicios Web, que presentan un modelo sin estado, los procesos de negocio requieren
     el uso de un modelo con estado. Cuando un cliente comienza un proceso de negocio, se crea una nueva instancia. Esta instancia 
     "vive" mientras no termine el proceso de negocio. Los mensajes enviados al proceso necesitan ser entregados a las instancias
     correctas del proceso de negocio. BPEL proporciona un mecanismo para utilizar datos de negocio espec&iacute;ficos para mantener 
     referencias a instancias espec&iacute;ficas del proceso de negocio. A este mecanismo lo denomina <em>correlaci&oacute;n</em>.
  </li>   

</ul>
<p>Por todo ello, BPEL resulta la opci&oacute;n m&aacute;s adecuada para orquestar procesos frente a otros lenguajes de programaci&oacute;n, como por ejemplo Java.</p>
</div> 


<a name="N100D2"></a><a name="El+lenguaje+BPEL"></a>
<h2 class="underlined_10">El lenguaje BPEL</h2>
<div class="section">
<p>La aproximaci&oacute;n orientada a procesos de SOA requiere un lenguaje para realizar una descripci&oacute;n relativamente simple de c&oacute;mo
   pueden componerse los servicios Web convirti&eacute;ndose en procesos de negocio. Ser&iacute;a estupendo que tales descripciones pudiesen
   tambi&eacute;n ejecutarse, lo cual permitir&iacute;a no s&oacute;lo proporcionar definiciones de procesos abstractos, sino escribir especificaciones
   ejecutables de dichos procesos. BPEL es dicho lenguaje. Un proceso abstracto BPEL representa, de forma est&aacute;ndar, un conjunto 
   de comportamientos observables.
</p>
<p>BPEL (<em>Business Process Execution Language</em>) es un lenguaje de orquestaci&oacute;n de servicios. Es un lenguaje basado en XML
   que soporta las tecnolog&iacute;as de servicios Web (incluyendo SOAP, WSDL, UDDI, WS-Reliable Messaging, WS-Addressing, WS-Coordination, 
   y WS-Transaction).
</p>
<p>BPEL representa una convergencia entre dos lenguajes <em>workflow</em>: WSFL (<em>Web Services Flow Language</em>) y XLANG. WSFL fue
   dise&ntilde;ado por IBM y est&aacute; basado en el concepto de grafos dirigidos. XLANG fue dise&ntilde;ado por Microsoft y es un lenguaje estructurado
   en bloques. BPEL, que inicialmente recibi&oacute; el nombre de BPEL4WS, combina ambas aproximaciones proporcionando un vocabulario rico para 
   la descripci&oacute;n de procesos de negocio. En Abril de 2003, BEA Systems, IBM, Microsoft, SAP y Siebel Systems decidieron someter BEL4WS
   1.1 al comit&eacute; t&eacute;cnico de OASIS para su estadarizaci&oacute;n, recibiendo el nombre de WS-BPEL 2.0 (en Septiembre de 2004). En esta sesi&oacute;n hablaremos simplemente
   de BPEL (aunque nos refereremos a WS-BPEL 2.0). La siguiente figura muestra la evoluci&oacute;n de BPEL:
</p>
<p>
	
<img alt="Evoluci&oacute;n del lenguaje BPEL." content-width="10cm" src="imagenes/sesion5/bpel-evolution.png" width="450"> 
</p>
<p>BPEL puede utilizarse dentro de una empresa y entre empresas. Dentro de una empresa, el papel de BPEL es el de estandarizar la
   integraci&oacute;n de aplicaciones y extender la integraci&oacute;n de sistemas previamente aislados. Entre empresas, BPEL permite una integraci&oacute;n
   m&aacute;s f&aacute;cil y efectiva con <em>partners</em> del negocio. BPEL es una tecnolog&iacute;a clave en entornos en donde las funcionalidades ya est&aacute;n
   o ser&aacute;n expuestas via servicios Web.
</p>
<p>BPEL ha sido dise&ntilde;ado espec&iacute;ficamente como un lenguaje para la definici&oacute;n de procesos de negocio. BPEL 
   soporta dos tipos diferentes de procesos de negocio:
</p>
<ul>
     
<li>
<strong>Procesos de negocio ejecutables</strong>: especifican los detalles exactos de los procesos
         del negocio y pueden ser ejecutados en una m&aacute;quina de orquestaci&oacute;n (<em>orchestration engine</em>).
         En la mayor&iacute;a de los casos BPEL se utiliza para procesos
         ejecutables</li>
     
<li>
<strong>Procesos abstractos de negocio</strong>:  
         especifican solamente el intercambio de mensajes p&uacute;blicos entre las partes implicadas, sin
         incluir detalles espec&iacute;ficos de los flujos de los procesos. No son ejecutables y raramente
         se utilizan.</li>    
   
</ul>
<div class="frame note">
<div class="label">Recuerda</div>
<div class="content">
   BPEL es un lenguaje de ejecuci&oacute;n de procesos de negocio. 
   Un <strong>proceso de negocio</strong> (<em>Business Process</em>) es un flujo de trabajo, formado por una serie de pasos o actividades, que
   son requeridas para completar una transacci&oacute;n de negocio. Las actividades del proceso de negocio pueden requerir la invocaci&oacute;n de aplicaciones
   y/o intervenci&oacute;n humana para su consecuci&oacute;n. Un proceso de negocio t&iacute;picamente tiene una duraci&oacute;n larga, implicando a m&uacute;ltiples partes y/o
   aplicaciones tanto dentro de una empresa como entre empresas.
</div>
</div>
</div>   


<a name="N10119"></a><a name="Estructura+de+un+proceso+BPEL"></a>
<h2 class="underlined_10">Estructura de un proceso BPEL</h2>
<div class="section">
<p>Un proceso BPEL especifica el orden exacto en el que deben invocarse los servicios Web participantes, tanto de 
   forma secuencial como en paralelo. Con BPEL podemos expresar un comportamiento condicional, por ejemplo la invocaci&oacute;n de un servicio
   Web puede depender del valor de una invocaci&oacute;n previa. Tambi&eacute;n podemos construir bucles, declarar variables, copiar y asignar valores,
   y definir manejadores de fallos, entre otras cosas. Combinando todas estas construcciones podemos definir procesos de negocio 
   complejos de una forma algor&iacute;tmica. De hecho, debido a que los procesos de negocio son esencialmente grafos de actividades, 
   podr&iacute;a ser &uacute;til expresarlos utilizando diagramas de actividad UML.
</p>
<p>En un escenario t&iacute;pico, el proceso de negocio BPEL recibe una petici&oacute;n de un cliente (que puede ser una aplicaci&oacute;n cliente,
   u otro servicio Web, entre otros). Para servir dicha petici&oacute;n, el proceso invoca a diversos servicios Web y finalmente responde al 
   cliente que ha realizado la llamada. Debido a que el proceso BPEL se comunica con otros servicios Web, tiene que tener en cuenta
   la descripci&oacute;n WSDL de los servicios Web a los que llama.
</p>
<div class="frame note">
<div class="label">Recuerda</div>
<div class="content">
  Un <strong>proceso BPEL</strong> es un servicio con estado de grano "grueso" (<em>large-grained</em>), que ejecuta unos pasos
  para completar una meta de negocio. Dicha meta puede ser la ejecuci&oacute;n de una transacci&oacute;n de negocio, o la
  consecuci&oacute;n del trabajo requerido por un servicio. Los pasos en el proceso BPEL ejecutan actividades (representadas por
  elementos del lenguaje BPEL) para lleva a cabo su cometido. Dichas actividades se centran en la invocaci&oacute;n de servicios
  participantes para realizar las diferentes tareas y devolver los correspondientes resultados al proceso. El trabajo resultante
  de la colaboraci&oacute;n de todos los servicios implicados es una <strong>orquestaci&oacute;n de servicios</strong>.
</div>
</div>
<p>Para los clientes de un proceso BPEL, &eacute;ste es como cualquier otro servicio Web. 
   Cuando definimos un proceso BPEL, esencialmente definimos un servicio Web que es una composici&oacute;n de otros servicios Web
   existentes. La interfaz del nuevo servicio Web BPEL utiliza un conjunto de <strong><em>port types</em></strong> a trav&eacute;s 
   de los cuales
   ofrece operaciones igual que cualquier otro servicio Web. Cada <em>port type</em> puede contener varias operaciones. 
   Para invocar un proceso de negocio descrito con BPEL, tenemos
   que invocar al servicio Web resultante de la composici&oacute;n, tal y como mostramos en la siguiente figura.
</p>
<p>
	
<img alt="Vista esquem&aacute;tica de un proceso BPEL." content-width="12cm" src="imagenes/sesion5/esquemaBPEL.gif" width="482"> 
</p>
<p>Un proceso BPEL puede ser s&iacute;ncrono o as&iacute;ncrono. Un <strong>proceso BPEL s&iacute;ncrono</strong> bloquea al cliente (aqu&eacute;l que usa el
   proceso BPEL) hasta que finaliza y devuelve el resultado a dicho cliente. Un <strong>proceso as&iacute;ncrono</strong> no bloquea al al cliente.
   Para ello utiliza una llamada <em>callback</em> que devuelve un resultado (si es que lo hay). Normalmente utilizaremos
   procesos as&iacute;ncronos para procesos que consumen mucho tiempo, y procesos s&iacute;ncronos para aquellos que devuelven un resultado
   en relativamente poco tiempo. Si un proceso BPEL utiliza servicios Web as&iacute;ncronos, entonces el propio proceso BPEL 
   normalmente tambi&eacute;n lo es. Hablaremos de los procesos as&iacute;ncronos en la siguiente sesi&oacute;n.
</p>
<p>La estructura b&aacute;sica de un documento (fichero con extensi&oacute;n <strong>.bpel</strong>) 
   que define un proceso BPEL es la siguiente:</p>
<pre class="code"> 
&lt;process name="nameProcess" ... &gt;

  &lt;partnerLinks&gt;
    &lt;!-- Declaraci&oacute;n de partner links --&gt;
  &lt;/partnerLinks&gt;
  
  &lt;variables&gt;
    &lt;!-- Declaraci&oacute;n de variables --&gt;
  &lt;/variables&gt;
  
  &lt;sequence&gt;
      &lt;!-- Cuerpo principal de la definici&oacute;n del proceso BPEL --&gt;
  &lt;/sequence&gt;

&lt;/process&gt;

</pre>
<p>En la etiqueta <strong><span class="codefrag">&lt;process&gt;</span></strong> se a&ntilde;aden los espacios de nombres. 
   Aqu&iacute; tenemos que definir tanto el espacio de nombres objetivo (
   <strong><span class="codefrag">targetNameSpace</span></strong>), como los <em>namespaces</em> para acceder a los
   WSDL de los servicios Web a los que invoca, y al WSDL del proceso BPEL. Tenemos que declarar
   tambi&eacute;n el <em>namespace</em> para todas las etiquetas y actividades BPEL (que
   puede ser el espacio de nombres por defecto, para as&iacute; no tener que incluirlo en cada nombre de
   etiqueta BPEL). El <em>namespace</em> para actividades BPEL debe ser: <em>http://schemas.xmlsoap.org/ws/2003/03/business-process/</em>:
</p>
<pre class="code"> 
&lt;process name="nameProcess" 
         targetNamespace= "http://..."
         xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
         xmlns:sw1="http://..." &lt;!-- namespace del servicio Web sw1 --&gt;
         xmlns:sw2="http://..." &lt;!-- namespace del servicio Web sw2 --&gt;
         ... &gt;  

...

&lt;/process&gt;

</pre>
<p>Un proceso BPEL est&aacute; formado por una serie de pasos. Cada uno de los pasos se denomina
   <strong>actividad</strong>. La etiqueta <strong><span class="codefrag">&lt;sequence&gt;</span></strong> contiene
   el conjunto de pasos o actividades que conforman el servicio que proporciona el proceso BPEL. 
   Hablaremos de las actividades un poco m&aacute;s adelante.
</p>
<p>La etiqueta (o elemento) <strong><span class="codefrag">&lt;process&gt;</span></strong> est&aacute; siempre
  presente en un proceso BPEL, es decir, es el m&iacute;nimo requerimiento en un fichero BPEL.</p>
<a name="N10187"></a>
<h3 class="underlined_5">Partner Links</h3>
<p>Lo siguiente que ha de hacerse es definir los enlaces con las diferentes "partes" que
   interact&uacute;an con el proceso BPEL, es lo que denominamos como <em>partner links</em>.
   Cada <em>partner link</em> tiene asociado un <em>partnerLinkType</em> espec&iacute;fico, y que
   se definir&aacute; en el WSDL correspondiente.
</p>
<p>Vamos a explicar un poco mejor este concepto. Los procesos BPEL
   interactuan con servicios Web externos de dos formas distintas:
</p>
<ul>
  
<li>El proceso BPEL invoca operaciones sobre otros servicios Web.</li>
  
<li>El proceso BPEL recibe invocaciones de clientes. Uno de los clientes es el usuario
      del proceso BPEL, que realiza la invocaci&oacute;n inicial. Otros clientes son, por ejemplo, 
      servicios Web que han sido invocados por el proceso BPEL, pero realizan <em>callbacks</em>
      para devolver las respuestas solicitadas. En este &uacute;ltimo caso, el proceso cliente tiene dos
      <em>roles</em>: es invocado por el proceso BPEL e invoca al proceso BPEL.</li>

</ul>
<p>Cada proceso BPEL tiene al menos un <em>partner link</em> cliente, debido a que tiene que haber
   un cliente que invoque al proceso BPEL. Por otro lado, un proceso BPEL tendr&aacute; (normalmente) al menos 
   un <em>partner link</em> a qui&eacute;n invoque.</p>
<p>BPEL trata a los clientes como <em>partner links</em> por dos razones. La m&aacute;s obvia
   es para proporcionar soporte para interacciones as&iacute;ncronas. En interacciones as&iacute;ncronas (como veremos
   en la siguiente sesi&oacute;n), los procesos necesitan invocar operaciones sobre sus clientes. Dichos procesos
   cliente devuelven el resultado mediante <em>callbacks</em> sobre el proceso que los invoc&oacute;.
</p>
<p>La segunda raz&oacute;n est&aacute; basada en el hecho de que el
   proceso BPEL puede ofrecer servicios. Estos servicios, ofertados a trav&eacute;s de <em>port types</em>, pueden utilizarse
   por m&aacute;s de un cliente. El proceso puede querer distinguir entre diferentes clientes y ofrecerles &uacute;nicamente la
   funcionalidad que &eacute;stos est&aacute;n autorizados a utilizar.</p>
<div class="frame note">
<div class="label">Recuerda</div>
<div class="content">
   Los <strong><em>partner links</em></strong> definen enlaces con los <em>partners</em> (partes
   que interaccionan con nuestro proceso de negocio) del
   proceso BPEL. Dichos <em>partners</em> pueden ser: (a) Servicios invocados por el proceso;
   (b) Servicios que invocan al proceso; (c) Servicios que tienen ambos roles: son invocados por el proceso e invocan 
   al proceso. Ya que un cliente debe llamar al proceso BPEL, &eacute;ste debe contener <strong>al 
   menos una</strong> definici&oacute;n de <em>partnerLink</em>. 
</div>
</div>
<p>A partir de aqu&iacute; utilizaremos <strong><em>ncname</em></strong> y <strong><em>qname</em></strong> para expresar
  el formato que deben seguir ciertos nombres dados a los atributos de las etiquetas BPEL.
</p>
<ul>
  
<li>
<strong><em>ncname</em></strong> es una cadena de caracteres que debe comenzar siempre por una 
      letra o un signo de subrayado.
  </li>
  
<li>
<strong><em>qname</em></strong> es un <em>ncname</em> que tambi&eacute;n debe mostrar de qu&eacute; espacio de nombres XML proviene.
     Por lo tanto, un <em>qname</em> siempre tiene que seguir el formato <em>tns:ncname</em>, en donde <em>tns</em> es el nombre
     del espacio de nombres definido al comienzo del documento correspondiente.
  </li>

</ul>
<p>La sintaxis para especificar los <strong><em>partnerLinks</em></strong> es:</p>
<pre class="code"> 
&lt;partnerLinks&gt;
   &lt;partnerLink name="ncname" partnerLinkType="qname"
             myrole="ncname" partnerRole="ncname"&gt;
   &lt;/partnerLink&gt;
&lt;/partnerLinks&gt;

</pre>
<p>Cada <em>partner link</em> es definido por un <em>partner link type</em> y un nombre de rol (o dos,
como veremos a continuaci&oacute;n).</p>
<p>Cada <em>partner link</em> especifica uno o dos atributos, que tienen que ver con el rol que implementa cada
   uno de los servicios relacionados:</p>
<ul>
  
<li>
<em>myRole</em>: indica el rol del propio proceso BPEL. Cuando solamente se especifica este atributo,
      cualquier cliente o <em>partner</em> puede interaccionar con el proceso BPEL sin ning&uacute;n requerimiento 
      adicional. </li>
  
<li>
<em>partnerRole</em>: indica el rol del partner. Si solamente definimos este atributo, estamos permitiendo
      la interacci&oacute;n con un <em>partner</em> o cliente que no imponga requerimientos sobre el proceso que haga 
      la llamada.</li>

</ul>
<p>Utilizaremos un &uacute;nico rol para una operaci&oacute;n s&iacute;ncrona, ya que los resultados deben devolverse
      utilizando la misma operaci&oacute;n. Utilizaremos dos roles en una operaci&oacute;n as&iacute;ncrona, ya que el rol del
      <em>partner</em> cambia cuando se realiza la llamada <em>callback</em> (hablaremos de las operaciones
      as&iacute;ncronas en la siguiente sesi&oacute;n).</p>
<p>Los roles se definen en el documento WSDL de cada partner, cuando se especifican los <em>partnerLinkTypes</em>.
</p>
<p>
<strong><em>Partner Link Types</em></strong>
</p>
<p>Un <strong><em>partnerLinkType</em></strong> especifica la relaci&oacute;n entre dos servicios, definiendo el rol
   que cada servicio implementa. Es decir, declara <strong>c&oacute;mo</strong> interaccionan las partes y lo que cada
   parte ofrece. Los nombres de los roles son cadenas de caracteres arbitrarias. Cada <strong>rol</strong>
   especifica exactamente un tipo <em>portType</em> WSDL que debe ser implementado por el servicio correspondiente.
</p>
<p>Es f&aacute;cil confundir los <em>partner link</em> y los <em>partner link types</em>, sin embargo: </p>
<ul>
  
<li>Los <strong><em>partner link types</em></strong> y los roles son extensiones especiales de WSDL 
    definidas por la especificaci&oacute;n
    BPEL. Como tales, dichos elementos se definen en los <strong>ficheros WSDL</strong>, 
    <strong>no</strong> en el fichero del proceso BPEL.</li>
  
<li>
<strong><em>Partner link</em></strong> es un elemento BPEL 2.0. Por lo que se define en el 
    <strong>fichero del proceso BPEL</strong>.</li>  

</ul>
<p>El siguiente c&oacute;digo corresponde a la descripci&oacute;n WSDL de un proceso BPEL, al que denominaremos <em>Saludo</em>, en el que declaramos el tipo
   <em>MyPartnerLinkType</em>, con el rol denominado <em>ProveedorServicioSaludo</em>. El servicio que implemente
   el rol <em>ProveedorServicioSaludo</em>, deber&aacute; implementar <em>SaludoPortType</em>. En este caso, <em>MyPartnerLinkType</em>
   describe la relaci&oacute;n entre el cliente del proceso BPEL y el propio proceso BPEL.
</p>
<pre class="code"> 
&lt;!-- Extracto de Saludo.wsdl --&gt;
&lt;partnerLinkType name="MyPartnerLinkType"&gt;
   &lt;role name="ProveedorServicioSaludo"
      portType="SaludoPortType"/&gt;
   &lt;/role&gt;
&lt;/partnerLinkType&gt;

</pre>
<p>A continuaci&oacute;n mostramos un extracto del fichero que describe el proceso BPEL <em>Saludo</em>):
</p>
<pre class="code"> 
&lt;!-- Extracto de Saludo.bpel --&gt;
&lt;partnerLinks&gt;
   &lt;partnerLink name="cliente"
        partnerLinkType="MyPartnerLinkType"
        myRole="ProveedorServicioSaludo"/&gt;
&lt;/partnerLinks&gt;

</pre>
<p>Cuando utilizamos operaciones as&iacute;ncronas, se definen dos roles, pero esto lo veremos en la siguiente
   sesi&oacute;n cuando hablemos de los procesos BPEL as&iacute;ncronos.</p>
<div class="frame note">
<div class="label">Recuerda</div>
<div class="content">
   Cada <em>partnerLink</em> de un proceso BPEL se relaciona con un <strong><em>partnerLinkType</em></strong> que lo 
   caracteriza. Cada <em>partnerLinkType</em> se define en el <strong>fichero WSDL</strong>: (a) del proceso
   BPEL, en el caso de que describa la interacci&oacute;n del cliente con el propio proceso BPEL, o (b) del servicio
   Web al que invoca dicho proceso BPEL.
</div>
</div>
<a name="N102A9"></a><a name="Variables"></a>
<h3 class="underlined_5">Variables</h3>
<p>Las variables se utilizan para almacenar, reformatear, y transformar mensajes que contienen el estado del
   proceso. Normalmente necesitaremos una variable para cada mensaje que enviemos a los <em>partners</em> y cada
   mensaje que recibamos de ellos. Aunque tambi&eacute;n podemos almacenar datos que representen el estado del proceso
   y no se env&iacute;en a los <em>partners</em>.
</p>
<p>Para cada variable tenemos que especificar su tipo, que puede ser: </p>
<ul>
   
<li>de tipo mensaje WSDL: indicado mediante el atributo <em>messageType</em>
</li>
   
<li>de un tipo simple de un esquema XML: indicado mediante el atributo <em>type</em>
</li>
   
<li>de tipo elemento de esquema XML: indicado mediante el atributo <em>element</em>
</li>

</ul>
<p>La sintaxis de una declaraci&oacute;n de variable es:</p>
<pre class="code"> 
&lt;variables&gt;
  &lt;variable name="nombreVar"
        messageType="qname"     //tipo mensaje
        type="qname"            //tipo simple
        element="qname"/&gt;       /tipo elemento
&lt;/variables&gt;

</pre>
<p>El nombre de una variable debe ser &uacute;nico en su &aacute;mbito de aplicaci&oacute;n (<em>scope</em>). 
   Debe utilizarse <strong>uno y s&oacute;lo uno</strong> de los tres atributos <em>messageType</em>,
   <em>type</em>, o <em>element</em>.
</p>
<p>El siguiente ejemplo muestra tres declaraciones de variables. La primera de ellas declara
   una variable con el nombre <em>PeticionArticulo</em>, que almacena mensajes WSDL del tipo
   <em>art:MensajePeticionArticulo</em>. La segunda declaraci&oacute;n define una variable denominada 
   <em>DescripcionParcialArticulo</em> que almacena elementos XML del tipo <em>art:DescripcionArticulo</em>.
   La &uacute;ltima declaraci&oacute;n de variable lleva el nombre <em>Telefono</em> y puede almacenar un
   tipo de dato <em>string</em> de un esquema XML. Las dos primeras declaraciones asumen que los 
   <em>messageType</em> y <em>element</em> correspondientes han sido declarados en el
   fichero WSDL.
</p>
<pre class="code"> 
&lt;variables&gt;
  &lt;variable name="PeticionArticulo" 
            messageType="art:MensajePeticionArticulo"/&gt;
  &lt;variable name="DescripcionParcialArticulo" 
            element="art:DescripcionArticulo"/&gt;
  &lt;variable name="Telefono" 
            type="xs:string"/&gt;
&lt;/variables&gt;

</pre>
<p>Cada variable tiene que declararse en un cierto &aacute;mbito y s&oacute;lamente pertenece a ese &aacute;mbito,
   y a los &aacute;mbitos dentro de &eacute;ste. Podemos declarar variables globalmente en la parte
   inicial de de declaraciones del proceso BPEL. Para declarar variables locales a un cierto
   &aacute;mbito se utiliza la etiqueta <strong><span class="codefrag">&lt;scope&gt;</span></strong>.
</p>
<p>Las variables se utilizan normalmente en condiciones. Podemos utilizar la funci&oacute;n
   <em>getVariableData</em> para extraer valores arbitrarios de las variables. La funci&oacute;n
   tiene tres par&aacute;metros: el nombre de la variable (es un par&aacute;metro obligatorio), nombre
   de la parte del mensaje (opcional), y el <em>path query</em> (opcional). La sintaxis es la siguiente:
</p>
<pre class="code">getVariableData ('variable-name', 'part-name',	&lt;!-- optional --&gt;
                         'location-path')	&lt;!-- optional --/&gt;</pre>
<p>El tercer par&aacute;metro se escribe con un lenguaje de <em>query</em>, como por ejemplo XPath</p>
<p>La siguiente expresi&oacute;n devuelve la parte del mensaje <em>insuredPersonData</em> del mensaje
   almacenado en la variable <em>InsuranceRequest</em>

</p>
<pre class="code">getVariableData ('InsuranceRequest', 'insuredPersonData')
</pre>
<p>La siguiente expresi&oacute;n devuelve el elemento <em>Age</em> de la variable <em>InsuranceRequest</em>
</p>
<pre class="code">bpws:getVariableData ('InsuranceRequest', 'insuredPersonData',
                             '/insuredPersonData/ins:Age')</pre>
<p>
<strong>Asignaci&oacute;n</strong>
</p>
<p>El copiado de datos de una variable a otra es algo que ocurre bastante a menudo en un proceso
  de negocio. Para ello se utiliza la actividad <em>assign</em>. Esta actividad tambi&eacute;n puede
  utilizarse para copiar nuevos datos en una variable.</p>
<pre class="code"> 
&lt;assign&gt;
  &lt;copy&gt;
    &lt;from variable="ncname" part="ncname"/&gt;
    &lt;to variable="ncname" part="ncname"/&gt;
  &lt;/copy&gt;
&lt;/assign&gt;

</pre>
<a name="N1034F"></a><a name="Actividades"></a>
<h3 class="underlined_5">Actividades</h3>
<p>Como ya hemos comentado, un proceso BPEL est&aacute; formado por una serie de pasos. Cada uno de los pasos se denomina
   <strong>actividad</strong>. BPEL soporta dos tipos de actividades: primitivas y estructuradas.</p>
<p>Las <strong>actividades primitivas</strong> representan construcciones b&aacute;sicas, algunas de ellas son:</p>
<ul>
  
<li>
<span class="codefrag">&lt;receive&gt; </span>: bloquea al proceso hasta que se recibe un determinado mensaje.
      T&iacute;picamente se utiliza para recibir un mensaje del cliente o un <em>callback</em> de un servicio Web
      <em>partner</em>.</li>
  
<li>
<span class="codefrag">&lt;reply&gt; </span>: env&iacute;a un mensaje como respuesta a un mensaje recibido mediante
     <em>receive</em>.</li>
  
<li>
<span class="codefrag">&lt;invoque&gt; </span>: realiza una invocaci&oacute;n sobre un sercicio Web. Puede ser s&iacute;ncrona
     (<em>request-response</em>) o as&iacute;ncrona (<em>one-way</em>).</li>
  
<li>
<span class="codefrag">&lt;assign&gt;</span>: asigna un valor a una variable.</li>
  
<li>
<span class="codefrag"> &lt;wait&gt;</span>: para hacer que el proceso espere un cierto tiempo.</li>
  
<li>
<span class="codefrag"> &lt;throw&gt;</span>: para indicar fallos y excepciones.</li>

</ul>
<p>
<strong>Receive</strong>
</p>
<p>Una actividad <em>receive</em> especifica un <em>partnerLink</em>, un <em>portType</em> y una operaci&oacute;n que
  puede ser invocada. Esta actividad juega un papel muy importante en el ciclo de vida de un proceso de negocio,
  ya que permite al proceso BPEL permanecer bloqueado a la espera de la llegada de un mensaje.
  Una de las formas de iniciar un proceso es utilizando una actividad <em>receive</em> con el atributo 
  <em>createInstance</em> con el valor <em>yes</em> (por defecto, el valor de dicho atributo es <em>no</em>). Una
  actividad <em>receive</em> con <em>createInstance</em> con valor de <em>yes</em> debe ser una de las actividades
  iniciales de un proceso. Puede haber m&aacute;s de una de dichas actividades, en cuyo caso la primera de ellas que
  sea llamada iniciar&aacute; el proceso. La sintaxis para <em>receive</em> es:
</p>
<pre class="code"> 
&lt;receive partnerLink="ncname"
     portType="qname"
     operation="ncname"
     variable="ncname"
     createInstance="yes|no"&gt;
&lt;/receive&gt;

</pre>
<p>
<strong>Reply</strong>
</p>
<p>Una actividad <em>reply</em> se utiliza para enviar una respuesta despu&eacute;s de que se haya 
  llamado a una actividad <em>receive</em>. La combinaci&oacute;n de de una actividad <em>receive</em>
  con otra actividad <em>reply</em> crea una operaci&oacute;n de tipo <strong><em>request-response</em></strong>.
  La actividad <em>reply</em> se utiliza en una interacci&oacute;n
  s&iacute;ncrona, y especifica el mismo <em>partner</em>, <em>port type</em> y operaci&oacute;n que la 
  actividad <em>receive</em> que invoc&oacute; al proceso. Con la actividad <em>reply</em>
  es posible transferir datos mediante una variable. La sintaxis de una actividad
  <em>reply</em> es la siguiente:
</p>
<pre class="code"> 
&lt;reply partnerLink="ncname"
     portType="qname"
     operation="ncname"
     variable="ncname"&gt;
&lt;/reply&gt;

</pre>
<p>
<strong>Invoque</strong>
</p>
<p>Mediante una actividad <em>invoque</em> un proceso puede llamar a otro servicio Web que haya sido
  definido como <em>partner</em>. Esta actividad puede ser s&iacute;ncrona (operaci&oacute;n de tipo <em>request-response</em>)
   o as&iacute;ncrona (operaci&oacute;n de tipo <em>one-way</em>).
</p>
<p>Un uso as&iacute;ncrono de esta actividad solamente necesita especificar una variable de entrada, ya que
  no hay una respuesta inmediata y por lo tanto no hay variable de salida. Un uso s&iacute;ncrono de <em>invoque</em>
  necesita tanto la variable de entrada como la de salida. La sintaxis es: 
</p>
<pre class="code"> 
&lt;invoque partnerLink="ncname"
     portType="qname"
     operation="ncname"
     inputVariable="ncname"
     outputVariable="ncname"&gt;
&lt;/invoque&gt;

</pre>
<p>Las <strong>actividades estructuradas</strong> permiten combinar las actividades primitivas para especificar
  exactamente los pasos de los procesos de negocio. Algunas de ellas son:</p>
<ul>
  
<li>
<span class="codefrag"> &lt;sequence&gt;</span>: define un conjunto de actividades que se invocar&aacute;n en forma de
     secuencia ordenada.</li>
  
<li>
<span class="codefrag"> &lt;flow&gt;</span>: define un conjunto de actividades que se invocar&aacute;n en paralelo.</li>
  
<li>
<span class="codefrag"> &lt;if&gt;</span>: para la implementaci&oacute;n acividades que se ejecutan dependiendo de una condici&oacute;n.</li>
  
<li>
<span class="codefrag"> &lt;while&gt;</span>: para definir bucles.</li>
  
<li>
<span class="codefrag"> &lt;pick&gt;</span>: hace que el proceso espere la llegada de alg&uacute;n evento y realice 
      una determinada actividad (o conjunto de actividades), en funci&oacute;n del evento. B&aacute;sicamente se permiten dos
      tipos de eventos: eventos de mensaje (manejados con la etiqueta <span class="codefrag">&lt;onMessage&gt;</span>)
      y eventos de alarma (manejados con la etiqueta <span class="codefrag">&gt;onAlarm</span>).</li>

</ul>
</div>


<a name="N10431"></a><a name="Relaci%C3%B3n+de+BPEL+con+BPMN"></a>
<h2 class="underlined_10">Relaci&oacute;n de BPEL con BPMN</h2>
<div class="section">
<p>No hay una notaci&oacute;n gr&aacute;fica est&aacute;ndar para WS-BPEL. Algunos vendedores han inventado sus propias notaciones. Estas
  notaciones se benefician del hecho de que la mayor&iacute;a de construcciones BPEL est&aacute;n estructuradas en forma de bloques.
  Esta caracter&iacute;stica permite una representaci&oacute;n visual directa de las descripciones de los procesos BPEL en forma de
  <em>estructurogramas</em>, que tienen un estilo con reminiscencias de los diagramas de Nassi-Shneiderman.
</p>
<p>Por otro lado se ha propuesto el uso de un lenguaje de modelado de procesos sustancialmente diferente a BPEL, denominado
  <em>Business Process Modeling Notation</em> (BPMN), como un <em>front-end</em> gr&aacute;fico para capturar las descripciones
  de los procesos BPEL. Se han propuesto numerosas herramientas que implementan el mapeado de BPMN a BPEL, como por ejemplo 
  la herramienta <em>open-source</em> BPMN2BPEL. Sin embargo, el desarrollo de estas herramientas ha expuesto las diferencias
  fundamentales entre BPMN y BPEL, lo que hace muy dif&iacute;cil, y en algunos casos imposible, el generar c&oacute;digo BPEL legible a 
  partir de modelos BPMN. M&aacute;s dif&iacute;cil todav&iacute;a es el problema de generar c&oacute;digo BPEL a partir de diagramas BPMN y mantener el
  BPMN original y el c&oacute;digo BPEL sincronizado, en el sentido de que una modificaci&oacute;n en uno de ellos se propage al otro.
</p>
</div>


<a name="N1044C"></a><a name="Pasos+para+desarrollar+un+proceso+de+negocio+con+BPEL"></a>
<h2 class="underlined_10">Pasos para desarrollar un proceso de negocio con BPEL</h2>
<div class="section">
<p>Para desarrollar un proceso de negocio con BPEL vamos a seguir los siguientes pasos:</p>
<ol>
  
<li>Conocer los servicios Web implicados</li>
  
<li>Definir el WSDL del proceso BPEL</li>
  
<li>Definir los <em>partner link types</em>
</li>
  
<li>Desarrollar el proceso BPEL:
      <p>4.1 Definir los <em>partner links</em>
</p>
      
<p>4.2 Declarar las variables</p>
      
<p>4.3 Escribir la definici&oacute;n de la l&oacute;gica del proceso</p>
  
</li>
  
  
    

</ol>
<p>
<strong>Conocer con los servicios Web implicados</strong>
</p>
<p>Antes de comenzar a definir el proceso BPEL, tenemos que familiarizarnos con los
  servicios Web a los que invoca nuestro proceso de negocio. Estos servicios se denominan 
  <em>servicios Web partners</em>. Para cada uno de ellos deberemos conocer los <em>port types</em>
  que proporcionan, y las operaciones y mensajes de entrada  salida definidas para dichos <em>port types</em>.
</p>
<p>
<strong>Definir el WSDL del proceso BPEL</strong>
</p>
<p>A continuaci&oacute;n tenemos que exponer el proceso BPEL como un servicio Web, es decir, definir su
  WSDL, declarando los <em>port types</em>, sus operaciones y mensajes de entrada y salida.
</p>
<p>
<strong>Definir los <em>partner link types</em></strong>
</p>
<p>Como ya hemos indicado, los <em>partner link types</em> representan la interacci&oacute;n entre el proceso BPEL
  y los <em>partners</em> implicados, que incluyen tanto a los servicios Web a los que invoca dicho proceso
  BPEL, como al cliente que invoca al proceso BPEL.</p>
<p>Idealmente, cada servicio Web debe definir los correspondientes <em>partner link types</em> en sus ficheros
  WSDL. Alternativamente, podr&iacute;amos definir todos los <em>partner links types</em> en el WSDL del proceso BPEL,
  aunque esta aproximaci&oacute;n no es recomendada ya que viola el principio de encapsulaci&oacute;n.  
</p>
<p>Comprender los <em>partner link types</em> es crucial para desarrollar la especificaci&oacute;n del proceso BPEL.
  Algunas veces resulta &uacute;til dibujar un diagrama con todas las interacciones. Una vez que se han definido los
  <em>partner link types</em> y sus roles correspondientes, pasamos a definir el proceso de negocio.</p>
<p>
<strong>Desarrollar el proceso BPEL</strong>
</p>
<p>Ahora ya estamos en disposici&oacute;n de definir el proceso BPEL. T&iacute;picamente, un proceso BPEL espera un mensaje de 
  entrada de un cliente, el cual comienza la ejecuci&oacute;n del proceso de negocio.
</p>
<p>El documento que define el proceso BPEL presenta la estructura que ya hemos indicado en apartados anteriores.
  Recordemos que debemos a&ntilde;adir:</p>
<ul>
  
<li>los espacios de nombres, tanto del proceso BPEL como de los servicios Web a los que &eacute;ste llama, </li>
  
<li>los <em>partner links</em>, </li>
  
<li>las variables del proceso y </li>
  
<li>el cuerpo principal, que especifica el orden en el que se invocan los servicios Web <em>partners</em>.
     Normalmente comienzan con una actividad <span class="codefrag">&lt;sequence&gt;</span>, que permite definir varias 
     actividades que se ejecutar&aacute;n de forma secuencial.</li>

</ul>
</div>  




<a name="N104D7"></a><a name="Despliegue+y+pruebas+del+proceso+BPEL"></a>
<h2 class="underlined_10">Despliegue y pruebas del proceso BPEL</h2>
<div class="section">
<p>Una vez que hemos desarrollado el proceso BPEL, el &uacute;ltimo paso es su despliegue
  en una <em>BPEL engine</em>, seguido, si se desea, de las pruebas correspondientes 
  antes de su utilizaci&oacute;n en producci&oacute;n.
</p>
<p>Nosotros vamos a utilizar <em>NetBeans</em> como herramienta para desarrollar y desplegar
  procesos BPEL, por lo tanto, vamos a explicar c&oacute;mo se realiza el proceso de despliegue
  y pruebas, utilizando <em>NetBeans 7.1</em>

</p>
<a name="N104EC"></a><a name="Entorno+de+ejecuci%C3%B3n+JBI"></a>
<h3 class="underlined_5">Entorno de ejecuci&oacute;n JBI (JBI Runtime Environment)</h3>
<p>
<em>Netbeans</em> utiliza el entorno de ejecuci&oacute;n JBI (<strong>JBI:</strong> <em>Java Business Integration</em>). 
  Dicho entorno de ejecuci&oacute;n incluye varios componentes que interact&uacute;an utilizando un modelo
  de servicios. Dicho modelo est&aacute; basado en el lenguaje de descripci&oacute;n de servicios web WSDL 2.0. 
  Los componentes que suministran o 
  consumen servicios dentro del entorno JBI son referenciados como m&aacute;quinas de servicios 
  (<em>Service Engines</em>). Uno de estos componentes es la m&aacute;quina de servicios BPEL
  (<em>BPEL Service Engine</em>), que proporciona servicios para ejecutar procesos de negocio.
  Los componentes que proporcionan acceso a los servicios que son externos al entorno JBI 
  se denominan <em>Binding Components</em>.
</p>
<p>
	
<img alt="Entorno de ejecuci&oacute;n JBI." content-width="9cm" src="imagenes/sesion5/entornoJBI.gif" width="493"> 
</p>
<p>Los componentes JBI se instalan
  formando parte del servidor de aplicaciones Glassfish.v2x. Concretamente vamos a utilizar la versi&oacute;n
  2.1.1 del servidor de aplicaciones Glassfish, junto con Glasfish ESB versi&oacute;n 2.2.</p>
<p>Glassfish ESB est&aacute; formado por componentes que dan soporte al dise&ntilde;o (<em>design-time components</em>), y que se
   ejecutan dentro del IDE de NetBeans, y componentes que dan soporte a la ejecuci&oacute;n (<em>runtime components</em>), que
   se ejecutan en el servidor de aplicaciones Glassfish.</p>
<p>La instalaci&oacute;n est&aacute;ndar de Glassfish ESB incluye una m&aacute;quina de servicios BPEL y un componente de enlazado Http, que
    se ejecutan en el servidor de aplicaciones, en el meta-contenedor JBI. Entre los componentes de Glassfish ESB que se
    ejecutan com parte del IDE de NetBeans se incluyen el editor WSDL, el editor de ensamblado de servicios (<em>CASA editor:
    Composite Application Service Assembly</em>). &Eacute;ste &uacute;ltimo permite "ensamblar" manualmente los servicios. Esto puede
    ser necesario en el caso de aplicaciones SOA complejas, para las que que la configuraci&oacute;n por defecto que genera autom&aacute;ticamente 
    NetBeans en las correspondientes Composite Applications no sea suficiente. Por ejemplo, podemos utilizar este editor para
    a&ntilde;adir/reemplazar elementos concretos WSDL (como ports, o bindings) que no se han especificado, cambiar la configuraci&oacute;n
    por defecto del despliegue o incluir conexiones con <em>endpoints</em> de servcios externos que se despliegan de forma separada
    en otras aplicaciones.</p>
<p>Para poder ver qu&eacute; componentes JBI tenemos instalados o desplegados, desde la ventana
   <em>Services</em>, expandimos el nodo <em>Servers</em> y el nodo <em>GlassFish v2.x</em>, y
   dentro de &eacute;l, el nodo JBI. Si el nodo JBI no es visible, necesitaremos arrancar el
   servidor de aplicaciones. Para ello pincharemos con el bot&oacute;n derecho sobre el nodo
   <em>GlassFish v2.x</em> y elegimos <em>Start</em> en el men&uacute; emergente.
</p>
<p>
	
<img alt="Componentes JBI en Glassfish v2.x." content-width="10cm" src="imagenes/sesion5/componentesJBI.gif" width="418"> 
</p>
<a name="N10544"></a><a name="BPEL"></a>
<h3 class="underlined_5">BPEL Service Engine</h3>
<p>La m&aacute;quina de servicios BPEL es un componente JBI (que satisface el est&aacute;ndar JSR 208) que
  proporciona servicios para ejecutar procesos de negocio desarrollados con WS-BPEL 2.0. Para
  desplegar un proceso BPEL, necesitamos a&ntilde;adirlo como un m&oacute;dulo JBI en un proyecto de 
  composici&oacute;n de aplicaciones (<em>Composite Application project</em>).
</p>
<p>La m&aacute;quina de servicios BPEL arranca juntamente con el servidor de aplicaciones. Por lo que para desplegar
  y ejecutar procesos BPEL ser&aacute; necesario tener en marcha el servidor de aplicaciones. Cuando el
  servidor est&aacute; en marcha, en la ventanta <em>Services</em> del IDE de <em>NetBeans</em>, observaremos
  un distintivo de color verde al lado del nodo <em>GlassFish v2.x</em>.
</p>
<p>La m&aacute;quina de servicios BPEL est&aacute; representada como el componente JBI <em>sun-bpel-engine</em>
  del servidor de aplicaciones.</p>
<a name="N10565"></a><a name="Proyecto+de+aplicaciones+compuestas"></a>
<h3 class="underlined_5">Proyecto de aplicaciones compuestas</h3>
<p>El t&eacute;rmino <em>composite application</em> se utiliza para 
  refererirse a alicaciones que en lugar de ser desarrolladas desde cero, son "ensambladas" a partir 
  de servicios disponibles en una arquitectura SOA. Un proyecto de aplicaciones compuestas 
  (<em>Composite Application project</em>) se utiliza para 
  crear un ensamblado de servicios (<em>Service Assembly</em>) que puede desplegarse en el servidor 
  de aplicaciones como un componente JBI.</p>
<p>Un proyecto BPEL no es directamente desplegable. Primero debemos a&ntilde;adir dicho proyecto BPEL, como
  un m&oacute;dulo JBI, en un proyecto <em>Composite Application</em>. A continuaci&oacute;n podremos desplegar el
  proyecto <em>Composite Application</em> en la m&aacute;quina de servicios BPEL. Al desplegar el proyecto hacemos
  que el ensamblado de servicios est&eacute; accesible para el servidor de aplicaciones, permitiendo as&iacute; que
  sus unidades de servicios se ejecuten. </p>
<p>Para desplegar un proyecto <em>Composite Application</em>
  elegiremos la opci&oacute;n <em>Deploy Project</em> en el men&uacute; emergente que aparece al pinchar con el
  bot&oacute;n derecho sobre el nodo <em>Composite Application project</em>. La acci&oacute;n de desplegar el
  <em>Composite Application project</em> compila los ficheros de dicho proyecto, empaqueta el
  proceso BPEL compilado y los artefactos de servicios Web relacionados (incluyendo los ficheros
  WSDL y XSD) en un archivo, y lo despliega en el servidor de aplicaciones.
</p>
</div>


<a name="N10591"></a><a name="Creaci%C3%B3n+y+ejecuci%C3%B3n+de+casos+de+prueba"></a>
<h2 class="underlined_10">Creaci&oacute;n y ejecuci&oacute;n de casos de prueba</h2>
<div class="section">
<p>Dentro de un proyecto <em>Composite
  Application</em> que incluya un m&oacute;dulo JBI podemos tambi&eacute;n crear y ejecutar casos de prueba 
  sobre el proceso BPEL, (que habr&aacute; sido previamente desplegado como un componente JBI, concretamente un 
  <em>Service Assembly</em>, en el servidor de aplicaciones).</p>
<p>Los casos de prueba act&uacute;an como servicios <em>partner</em> remotos que env&iacute;an mensajes SOAP al
  <em>runtime</em> de la m&aacute;quina de servicios BPEL (<em>Service Engine BPEL </em>).
</p>
<p>De forma simple, el proceso de interacci&oacute;n para las pruebas es el siguiente: el <em>runtime</em> de la
  m&aacute;quina de servicios BPEL recibe un mensaje SOAP, crea una instancia del proceso BPEL y comienza a ejecutar
  dicha instancia. Un proceso BPEL puede tener muchas instancias en ejecuci&oacute;n. El <em>runtime</em> de la m&aacute;quina
  de servicios BPEL recibe un mensaje y, mediante correlaci&oacute;n, lo enruta a la instancia apropiada del proceso. 
  Si no existe todav&iacute;a ninguna instancia, se crea una nueva.
</p>
<p>Para crear y obtener los resultados de las pruebas, deberemos hacer lo siguiente:</p>
<ul>
  
<li>A&ntilde;adir un caso de prueba y enlazarlo con una operaci&oacute;n BPEL.</li>
  
<li>Determinar las propiedades de la prueba (como por ejemplo el n&uacute;mero de segundos
     que debe durar como m&aacute;ximo la ejecuci&oacute;n de la prueba). </li>
  
<li>Modificar convenientemente las entradas de las pruebas, para ello editaremos el
      fichero <em>Input.xml</em> seg&uacute;n nos interese.</li>
  
<li>Ejecutar las pruebas. El resultado de la ejecuci&oacute;n se comparar&aacute; con el resultado
      esperado almacenado en el fichero <em>Output.xml</em>. Si ambos resultados son
      diferentes, se habr&aacute; detectado un error.</li>

</ul>
<p>En los ejercicios de la sesi&oacute;n veremos un ejemplo pr&aacute;ctico de despliegue y pruebas
  de un proyecto BPEL.</p>
<p>Observaciones sobre los resultados de las pruebas:</p>
<ul>
  
<li>La primera vez que ejecutemos las pruebas obtendremos como resultado la indicaci&oacute;n de que la prueba
     ha fallado (se ha detectado un error). La salida producida no coincidir&aacute; con el
     resultado almacenado en el fichero <em>Output.xml</em> (que inicialmente estar&aacute; vac&iacute;o). Al ejecutar la
     prueba la primera vez, el contenido de <em>Output.xml</em> ser&aacute; reemplazado por la salida generada en
     esta primera ejecuci&oacute;n.</li>
  
<li>Si ejecutamos la prueba de nuevo sin cambiar la entrada, las ejecuciones siguientes informar&aacute;n del &eacute;xito
     de la prueba, ya que la salida ser&aacute; id&eacute;ntica al contenido de <em>Output.xml</em>.</li>
  
<li>Si cambiamos el valor de la entrada en <em>Input.xml</em> y volvemos a ejecutar la prueba, entonces:
     <ul>
       
<li>Si la propiedad <em>feature-status</em> tiene como valor asignado <em>progress</em>, entonces la
         prueba indica &eacute;xito incluso aunque no coincida el resultado con <em>Output.xml</em>.</li>
       
<li>Si la propiedad <em>feature-status</em> tiene como valor asignado <em>done</em>, entonces
         la prueba indica fallo si no coincide el resultado y guarda el resultado obtenido.</li> 
       
<li>Si pinchamos con el bot&oacute;n derecho del rat&oacute;n sobre el caso de prueba y seleccionamos <em>Diff</em>
          sobre el men&uacute; emergente, se muestra la diferencia entre la &uacute;ltima salida y los contenidos de
          <em>Output.xml</em>.</li>
       
<li>En cada ejecuci&oacute;n posterior a la primera, y asumiendo que <em>Output.xml</em> ya no est&aacute;
          nunca vac&iacute;o, se preserva su contenido. Es decir, una salida previa, nunca se sobreescribe
          con nuevos resultados (con la excepci&oacute;n ya comentada de la primera ejecuci&oacute;n).</li>   
       
<li>Para ver los resultados de pruebas anteriores, podemos elegir de la lista desplegable el
          fichero <em>Actual_yymmddhhmmss.xml</em> correspondiente, y pulsar en el bot&oacute;n <em>Refresh</em>.</li>        
     
</ul>
  
</li>     

</ul>
<p>Podemos ver las propiedades asociadas a los tests, situ&aacute;ndonos sobre un nodo de test de la <em>Composite Application</em> y
   pulsando con el bot&oacute;n derecho, elegimos "Properties". Una de las propiedades es <em>feature-status</em>, que acabamos de
   comentar. Otras propiedades son: descripci&oacute;n del caso de prueba, URL del wsdl a probar, nombre de los ficheros de entrada
   y de salida de las pruebas, ... </p>
</div>  



<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
