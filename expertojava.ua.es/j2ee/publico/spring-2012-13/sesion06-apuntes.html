<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Acceso remoto. Pruebas</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Experto Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Spring" src="images/baner_j2ee_der.gif" title="Spring"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li>
<a class="base-not-selected" href="index.html">Spring</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_1.1', 'skin/')" id="menu_1.1Title" class="menutitle">Spring</div>
<div id="menu_1.1" class="menuitemgroup">
<div class="menuitem">
<a href="index.html" title="Spring">Indice</a>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion06-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Acceso remoto. Pruebas</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Acceso+remoto">Acceso remoto</a>
<ul class="minitoc">
<li>
<a href="#Evaluaci%C3%B3n+de+las+alternativas">Evaluaci&oacute;n de las alternativas</a>
</li>
<li>
<a href="#RMI+en+Spring">RMI en Spring</a>
</li>
<li>
<a href="#Hessian+y+Burlap">Hessian y Burlap</a>
<ul class="minitoc">
<li>
<a href="#Uso+de+los+protocolos">Uso de los protocolos</a>
</li>
<li>
<a href="#Autentificaci%C3%B3n+HTTP+con+Hessian+y+Burlap">Autentificaci&oacute;n HTTP con Hessian y Burlap</a>
</li>
</ul>
</li>
<li>
<a href="#HTTP+invoker">HTTP invoker</a>
</li>
</ul>
</li>
<li>
<a href="#Pruebas">Pruebas</a>
<ul class="minitoc">
<li>
<a href="#Pruebas+unitarias">Pruebas unitarias</a>
</li>
<li>
<a href="#Pruebas+de+integraci%C3%B3n.+Uso+de+objetos+mock">Pruebas de integraci&oacute;n. Uso de objetos mock</a>
</li>
<li>
<a href="#Pruebas+de+la+capa+web">Pruebas de la capa web</a>
<ul class="minitoc">
<li>
<a href="#Simular+la+petici%C3%B3n">Simular la petici&oacute;n</a>
</li>
<li>
<a href="#Comprobar+el+resultado">Comprobar el resultado </a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>


<a name="N1000C"></a><a name="Acceso+remoto"></a>
<h2 class="underlined_10">Acceso remoto</h2>
<div class="section">
<p>Uno de los puntos que hacen atractivos a los EJB es que permiten simplificar la programaci&oacute;n distribuida, proporcionando
un acceso a objetos remotos "casi transparente" para el programador. Se puede localizar de manera sencilla un
objeto remoto que reside en otra m&aacute;quina cualquiera y llamar a sus m&eacute;todos como si el objeto estuviera en la m&aacute;quina local. En esta secci&oacute;n veremos alternativas para
conseguir el mismo objetivo, que si bien no son tan sofisticadas, son m&aacute;s ligeras que la implementaci&oacute;n de muchos
contenedores de EJBs.</p>
<a name="N10015"></a><a name="Evaluaci%C3%B3n+de+las+alternativas"></a>
<h3 class="underlined_5">Evaluaci&oacute;n de las alternativas</h3>
<p>Spring no proporciona una &uacute;nica alternativa a EJBs para acceso remoto. Seg&uacute;n los requerimientos de la aplicaci&oacute;n y las 
caracter&iacute;sticas de la implementaci&oacute;n ser&aacute; m&aacute;s apropiada una u otra alternativa. Veamos cu&aacute;les son:</p>
<ul>

<li>
<strong>RMI:</strong> A pesar de que usar RMI directamente pueda parecer algo "primitivo", Spring implementa una serie de clases que proporcionan 
una capa de abstracci&oacute;n sobre el RMI "puro", de modo que por ejemplo no hay que gestionar directamente el servidor de nombres, ni
ejecutar manualmente <span class="codefrag">rmic</span> y el cliente puede abstraerse totalmente de que el servicio es remoto. RMI ser&aacute; la alternativa adecuada
cuando nos interese <strong>buen rendimiento, clientes Java y sepamos que el servidor de nombres no es un problema 
(p.ej. con firewalls)</strong>
</li>

<li>
<strong>HTTP invoker:</strong> Es una opci&oacute;n muy similar a la de RMI, usando serializaci&oacute;n de Java, pero a trav&eacute;s del puerto HTTP est&aacute;ndar, con lo que eliminamos 
los posibles problemas de firewalls. N&oacute;tese que el cliente tambi&eacute;n debe ser Spring, ya que el protocolo
est&aacute; implementado en librer&iacute;as propias del framework (un cliente RMI podr&iacute;a ser no-Spring). Ser&aacute; apropiado cuando nos interese <strong>buen rendimiento, 
clientes Spring y tengamos posibles problemas con los puertos permitidos.</strong> .</li>

<li>
<strong>Protocolos Hessian y Burlap:</strong> son protocolos que funcionan a trav&eacute;s del puerto HTTP est&aacute;ndar. Hessian
es binario y Burlap XML, por lo que el primero es m&aacute;s eficiente. Te&oacute;ricamente pueden funcionar con clientes no-Java, aunque con ciertas
limitaciones. No son protocolos originalmente dise&ntilde;ados en el seno de Spring, sino de una empresa llamada Caucho (aunque son tambi&eacute;n
<em>open source</em>). Ser&aacute; interesante cuando queramos <strong>buen rendimiento, clientes no-Java y
tengamos posibles problemas con los puertos permitidos.</strong>
</li>

<li>
<strong>Servicios web SOAP:</strong> indicados para el acceso a componentes
remotos en plataformas heterog&eacute;neas (con clientes escritos en casi cualquier lenguaje). Su punto d&eacute;bil es b&aacute;sicamente
el rendimiento: la necesidad de transformar los mensajes que intercambian cliente servidor a formato neutro en XML hace que 
sean poco eficientes, pero es lo que al mismo tiempo los hace portables. Ser&aacute;n apropiados cuando <strong>El rendimiento no
sea cr&iacute;tico, y queramos la m&aacute;xima portabilidad en cuanto a clientes.</strong>
</li>

<li>
<strong>Servicios web REST:</strong> Superan la "pesadez" de sus hermanos SOAP gracias al uso de protocolos ligeros como HTTP. Como contrapartida, al carecer en general de una especificaci&oacute;n formal tendremos que programar manualmente el servicio, tanto en la parte cliente como servidor. Ser&aacute;n los indicados si queremos <strong> m&aacute;xima portabilidad en cuanto a clientes y el API del servicio es simple y f&aacute;cil de programar manualmente.</strong>
</li>

</ul>
<div class="frame warning">
<div class="label">Limitaciones del acceso remoto en Spring</div>
<div class="content">N&oacute;tese que en el acceso remoto a componentes los EJBs siguen teniendo ciertas ventajas sobre Spring, en particular la
propagaci&oacute;n remota de transacciones, que no es posible en Spring. Es el precio a pagar por poder usar un contenedor web java convencional como Tomcat en lugar de un servidor de aplicaciones completo.</div>
</div>
<p>Discutiremos a continuaci&oacute;n con m&aacute;s detalle las caracter&iacute;sticas de estas alternativas y c&oacute;mo usarlas y configurarlas dentro de Spring. Obviaremos los servicios web SOAP, que por su complejidad quedan fuera del &aacute;mbito posible para esta sesi&oacute;n.</p>
<p>En todos los casos vamos a usar el siguiente ejemplo, muy sencillo, de componente al que deseamos acceder de forma
remota, con su interfaz: </p>
<pre class="brush:java;">
package servicios;

public interface ServicioSaludo {
   public String getSaludo();
}
</pre>
<pre class="brush:java;highlight:[3]">
package servicios;

@Service("saludador")
public class ServicioSaludoImpl implements ServicioSaludo {
   String[] saludos = {"hola, &iquest;qu&eacute; tal?", "me alegra verte", "yeeeeeey"};
   
   public String getSaludo() {
	 int pos = (int)(Math.random() * saludos.length);
	 return saludos[pos];
   }
}
</pre>
<a name="N10061"></a><a name="RMI+en+Spring"></a>
<h3 class="underlined_5">RMI en Spring</h3>
<p>Aunque el uso directo de RMI puede resultar tedioso, Spring ofrece una capa de abstracci&oacute;n sobre el RMI "puro" que
permite acceder de forma sencilla y casi transparente a objetos remotos.</p>
<p>Usando la clase <span class="codefrag">RmiServiceExporter</span> podemos exponer la interfaz de nuestro servicio como un objeto RMI. 
Se puede acceder desde el cliente usando RMI "puro" o bien, de modo m&aacute;s sencillo con un <span class="codefrag">RmiProxyFactoryBean</span>.
	</p>
<p>La configuraci&oacute;n en el lado del servidor quedar&aacute; como sigue:</p>
<pre class="brush:xml;">
&lt;bean class="org.springframework.remoting.rmi.RmiServiceExporter"&gt;
    &lt;!-- el nombre del servicio es arbitrario.
    Sirve para referenciarlo desde el cliente --&gt;
    &lt;property name="serviceName" value="miSaludador"/&gt;
    &lt;!-- el servicio es el bean que hacemos accesible --&gt;
    &lt;property name="service" ref="saludador"/&gt;
    &lt;!-- el bean debe implementar un interface --&gt;
    &lt;property name="serviceInterface" value="servicios.ServicioSaludo"/&gt;
    &lt;!-- C&oacute;mo cambiar el puerto para RMI (por defecto es el 1099) --&gt;
    &lt;property name="registryPort" value="1199"/&gt;
&lt;/bean&gt;
</pre>
<p>En la configuraci&oacute;n anterior se ha cambiado el puerto del servidor de nombres RMI para evitar posibles conflictos
con el del servidor de aplicaciones. A partir de este momento, el objeto remoto es accesible a trav&eacute;s de la URL
<span class="codefrag"> rmi://localhost:1199/miSaludador</span>.</p>
<p>La configuraci&oacute;n en el cliente quedar&iacute;a como sigue:</p>
<pre class="brush:xml;">

&lt;bean id="saludadorRMI" 
	class="org.springframework.remoting.rmi.RmiProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="rmi://localhost:1199/miSaludador"/&gt;
    &lt;property name="serviceInterface" value="servicios.ServicioSaludo"/&gt;
&lt;/bean&gt;

</pre>
<p>N&oacute;tese que el id del bean es arbitrario, aunque luego habr&aacute; que referenciarlo en el c&oacute;digo del cliente. Los valores de las propiedades
<span class="codefrag">serviceUrl</span> y <span class="codefrag">serviceInterface</span> evidentemente tienen que coincidir con los dados en la configuraci&oacute;n
en el servidor.</p>
<p>Para acceder al objeto de forma remota todo lo que necesitar&iacute;amos es tener en el cliente 
el c&oacute;digo del interfaz <span class="codefrag">ServicioSaludo</span> y usar el siguiente c&oacute;digo Java para conectar:</p>
<pre class="brush:java;">
ClassPathXmlApplicationContext contexto = 
         new ClassPathXmlApplicationContext("clienteRMI.xml");
ServicioSaludo ss =  contexto.getBean(ServicioSaludo.class);
System.out.println(ss.getSaludo());
</pre>
<p>Suponiendo que el fichero de configuraci&oacute;n en el cliente lo hemos llamado <span class="codefrag">clienteRMI.xml</span>
</p>
<a name="N100A3"></a><a name="Hessian+y+Burlap"></a>
<h3 class="underlined_5">Hessian y Burlap</h3>
<p>Hessian y Burlap son dos protocolos dise&ntilde;ados originalmente por la empresa Caucho, desarrolladora de un servidor
de aplicaciones J2EE de c&oacute;digo abierto llamado <span class="codefrag">Resin</span>. Ambos son protocolos para acceso a servicios
remotos usando conexiones HTTP est&aacute;ndar. La diferencia b&aacute;sica entre ambos es que Hessian es binario (y por tanto m&aacute;s eficiente
que Burlap) y este es XML (y por tanto las comunicaciones son m&aacute;s sencillas de depurar). Para ambos tambi&eacute;n
se han desarrollado implementaciones en distintos lenguajes de manera que el cliente de nuestra aplicaci&oacute;n podr&iacute;a
estar escrito en C++, Python, C#, PHP u otros.</p>
<a name="N100AF"></a><a name="Uso+de+los+protocolos"></a>
<h4>Uso de los protocolos</h4>
<p>Usaremos Hessian en el siguiente ejemplo, aunque la configuraci&oacute;n de Burlap es pr&aacute;cticamente id&eacute;ntica. Hessian
se comunica mediante HTTP con un servlet . Por tanto el primer paso ser&aacute; crear dicho servlet en nuestro <span class="codefrag">web.xml</span>.
Nos apoyaremos en la clase <span class="codefrag">DispatcherServlet</span> propia de Spring, ya que se integra de manera autom&aacute;tica
con el resto de elementos de nuestra configuraci&oacute;n. A continuaci&oacute;n se muestra el fragmento significativo del <span class="codefrag">web.xml</span>.</p>
<pre class="brush:xml;">

&lt;servlet&gt;
   &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
   &lt;servlet-class&gt;
      org.springframework.web.servlet.DispatcherServlet
   &lt;/servlet-class&gt;
   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
   &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
   &lt;url-pattern&gt;/remoting/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

</pre>
<p>Esto hace accesible el servlet a trav&eacute;s de la URL <span class="codefrag">http://localhost:8080/remoting</span> (si por ejemplo
usamos Tomcat cuyo puerto por defecto es el 8080). Recordemos del tema de MVC que en Spring, la configuraci&oacute;n de un <span class="codefrag">DispatcherServlet</span>
se debe guardar en un xml con nombre <em>nombreDelServlet</em>-servlet.xml (en nuestro caso 
<span class="codefrag">remoting-servlet.xml</span>). Aclarar que aunque podr&iacute;amos hacer uso del mismo DispatcherServlet para gestionar tanto los controllers MVC como
el acceso remoto, no es necesario, podemos usar una instancia distinta para cada cosa.</p>
<pre class="brush:xml;">

&lt;bean name="/saludador" 
 	class="org.springframework.remoting.caucho.HessianServiceExporter"&gt;
  &lt;property name="service" ref="saludador"/&gt;
  &lt;property name="serviceInterface" value="servicios.ServicioSaludo"/&gt;
&lt;/bean&gt;

</pre>
<p>Aqu&iacute; hacemos uso de la clase <span class="codefrag">HessianServiceExporter</span>, que nos permite exportar de forma sencilla
un servicio Hessian. En nuestro caso estar&aacute; accesible en la URL <span class="codefrag">http://localhost:8080/contexto-web/remoting/saludador</span>.
Nos falta la configuraci&oacute;n del cliente y el c&oacute;digo que llama al servicio:</p>
<pre class="brush:xml;">
&lt;bean id="miSaludador" 
	class="org.springframework.remoting.caucho.HessianProxyFactoryBean"&gt;
        &lt;property name="serviceUrl" 
        	value="http://localhost:8080/<em>contexto-web</em>/remoting/saludador"/&gt;
        &lt;property name="serviceInterface" value="servicios.ServicioSaludo"/&gt;
&lt;/bean&gt;
</pre>
<p>Suponiendo que el c&oacute;digo XML anterior se guarda en un fichero llamado <span class="codefrag">clienteHessian.xml</span>
</p>
<pre class="brush:java;">
ClassPathXmlApplicationContext contexto = 
	new ClassPathXmlApplicationContext("clienteHessian.xml");
ServicioSaludo ss =  (ServicioSaludo) contexto.getBean("miSaludador");
System.out.println(ss.getSaludo());
</pre>
<p>En el ejemplo anterior bastar&iacute;a con escribir <span class="codefrag">Burlap</span> all&iacute; donde aparece <span class="codefrag">Hessian</span>
y todo deber&iacute;a funcionar igual, pero ahora usando este procolo basado en mensajes XML.</p>
<a name="N100FF"></a><a name="Autentificaci%C3%B3n+HTTP+con+Hessian+y+Burlap"></a>
<h4>Autentificaci&oacute;n HTTP con Hessian y Burlap</h4>
<p>Al ser una conexi&oacute;n HTTP est&aacute;ndar podemos usar autentificaci&oacute;n BASIC. De este modo podemos usar la seguridad
declarativa del contenedor web tambi&eacute;n para controlar el acceso a componentes remotos. En la configuraci&oacute;n
del servidor podr&iacute;amos a&ntilde;adir el siguiente c&oacute;digo:</p>
<pre class="brush:xml;">

&lt;!-- cuidado con el copiar/pegar, 
el nombre de la clase est&aacute; partido --&gt;
&lt;bean class="org.springframework.web.servlet.
	handler.BeanNameUrlHandlerMapping"&gt;
   &lt;property name="interceptors"&gt;
      &lt;list&gt;
         &lt;ref bean="authorizationInterceptor"/&gt;
      &lt;/list&gt;
   &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- cuidado con el copiar/pegar, 
el nombre de la clase est&aacute; partido --&gt;
&lt;bean id="authorizationInterceptor" 
   class="org.springframework.web.servlet.
   handler.UserRoleAuthorizationInterceptor"&gt;
   &lt;property name="authorizedRoles"&gt;
    &lt;list&gt;
      &lt;value&gt;admin&lt;/value&gt;
      &lt;value&gt;subadmin&lt;/value&gt;
    &lt;/list&gt;
   &lt;/property&gt;	
&lt;/bean&gt;
		
</pre>
<p>Usando AOP a&ntilde;adimos un interceptor que resulta ser de la clase <span class="codefrag">UserRoleAuthorizationInterceptor</span>.
Dicho interceptor solo permite el acceso al bean si el usuario resulta estar en uno de los roles especificados
en la propiedad <span class="codefrag">authorizedRoles</span>. El <span class="codefrag">BeanNameUrlHandlerMapping</span> es el objeto que "tras las bambalinas" se encarga de asociar los beans
que comienzan con "/" con los servicios en la URL del mismo nombre (en nuestro caso el bean "/saludador").</p>
<a name="N1011B"></a><a name="HTTP+invoker"></a>
<h3 class="underlined_5">HTTP invoker</h3>
<p>Esta es una implementaci&oacute;n propia de Spring, que utiliza la serializaci&oacute;n est&aacute;ndar de Java para transmitir
objetos a trav&eacute;s de una conexi&oacute;n HTTP est&aacute;ndar. Ser&aacute; la opci&oacute;n a elegir cuando los objetos sean demasiado complejos
para que funcionen los mecanismos de serializaci&oacute;n de Hessian y Burlap.</p>
<p>La configuraci&oacute;n es muy similar al apartado anterior, podemos usar el mismo <span class="codefrag">DispatcherServlet</span> pero ahora
para el acceso al servicio se debe emplear la clase
<span class="codefrag">HttpInvokerServiceExporter</span> en lugar de <span class="codefrag">HessianServiceExporter</span>
</p>
<pre class="brush:xml;">

&lt;bean name="/saludadorHTTP" 
   class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"&gt;
  &lt;property name="service" ref="saludador"/&gt;
  &lt;property name="serviceInterface" value="servicios.ServicioSaludo"/&gt;
&lt;/bean&gt;

</pre>
<p>En la parte del cliente la definici&oacute;n del bean ser&iacute;a:</p>
<pre class="brush:xml;">

&lt;bean id="httpProxy" 
 class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"&gt;
  &lt;property name="serviceUrl" 
    	value="http://localhost:8080/MiAplicacion/remoting/saludadorHTTP"/&gt;
  &lt;property name="serviceInterface" value="servicios.ServicioSaludo"/&gt;
&lt;/bean&gt;

</pre>
<p>Por defecto en el cliente se usan las clases est&aacute;ndar de J2SE para abrir la conexi&oacute;n HTTP. Adem&aacute;s Spring
proporciona soporte para el <span class="codefrag">HttpClient</span> de Jakarta Commons. Bastar&iacute;a con poner una propiedad adicional
en el <span class="codefrag">HttpInvokerProxyFactoryBean</span>:</p>
<pre class="brush:xml;">

&lt;bean id="httpProxy" 
   class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"&gt;
  ...
  &lt;property name="httpInvokerRequestExecutor"&gt;
    &lt;!-- cuidado con el copiar/pegar, 
    el nombre de la clase est&aacute; partido --&gt;
    &lt;bean class="org.springframework.remoting.httpinvoker.
    	CommonsHttpInvokerRequestExecutor"/&gt;
  &lt;/property&gt;
  ...
&lt;/bean&gt;

</pre>
</div>


<a name="N1014C"></a><a name="Pruebas"></a>
<h2 class="underlined_10">Pruebas</h2>
<div class="section">
<p>En cualquier metodolog&iacute;a moderna de ingenier&iacute;a de software las pruebas son un elemento fundamental. Reconociendo este hecho, Spring nos da soporte para poder implementar nuestras pruebas del modo m&aacute;s sencillo posible. Otro aspecto importante, sobre todo en prubeas de integraci&oacute;n es trabajar en un entorno lo m&aacute;s parecido posible a c&oacute;mo se ejecutar&aacute; el c&oacute;digo en producci&oacute;n. En Spring podemos hacer que las dependencias entre objetos se satisfagan autom&aacute;ticamente en pruebas del mismo modo que en producci&oacute;n.</p>
<p>Vamos a usar aqu&iacute; el soporte para JUnit 4 y superior, que es la recomendada en la versi&oacute;n actual de Spring. El soporte de Junit 3 est&aacute; <em>deprecated</em> y se eliminar&aacute; en futuras versiones.</p>
<a name="N1015B"></a><a name="Pruebas+unitarias"></a>
<h3 class="underlined_5">Pruebas unitarias</h3>
<p>Supongamos que en la capa de acceso a datos de nuestra aplicaci&oacute;n tenemos un DAO que implementa este interfaz:</p>
<pre class="brush:java;">
public interface IUsuariosDAO {
    public List&lt;Usuario&gt; listar();
    public Usuario getUsuario(String login);
    public void alta(Usuario u);
    ...
}
</pre>
<p>y que queremos escribir c&oacute;digo de prueba para &eacute;l. Lo primero que nos da Spring es la posibilidad de usar un fichero de configuraci&oacute;n de beans para pruebas diferente al fichero de producci&oacute;n. El esqueleto de la clase que prueba el DAO podr&iacute;a ser algo como:
</p>
<pre class="brush:java;">
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:config/daos-test.xml")
public class UsuariosDAOTest  {
  //Spring nos da la instancia del DAO a probar
  @Autowired
  IUsuariosDAO dao;
  
  //Esto ya no tiene nada de particular de Spring
  @Test
  public void testListar() {
    List&lt;Usuario&gt; lista = dao.listar();
    assertEquals(10, lista.size());
  }
}
</pre>
<p>La anotaci&oacute;n <span class="codefrag">@RunWith</span> es la que nos "activa" el soporte de testing de Spring. Con <span class="codefrag">@ContextConfiguration</span> especificamos el fichero o ficheros de configuraci&oacute;n de beans que vamos a usar para las pruebas. Aqu&iacute; podemos configurar lo que queremos que sea distinto de producci&oacute;n, por ejemplo, que los dataSources conecten con bases de datos de prueba, que los objetos de los que dependemos sean <em>mocks</em>, etc.  
</p>
<div class="frame note">
<div class="label">Profiles</div>
<div class="content">A partir de la versi&oacute;n 3.1 de Spring hay una forma alternativa de hacer esto usando lo que se denominan <em>profiles</em>. La idea es que podemos hacer que ciertos beans se definan dentro de un determinado perfil (p.ej. "test") y ciertos otros en uno distinto (p.ej. "produccion"). Usando diferentes mecanismos podemos especificar qu&eacute; perfil queremos usar en un momento dado. Se recomienda consultar la documentaci&oacute;n de Spring para m&aacute;s informaci&oacute;n.</div>
</div>
<p>N&oacute;tese que la referencia al DAO que queremos probar nos la da el propio Spring, lo que es una forma c&oacute;moda de instanciar el objeto, y adem&aacute;s ofrece la ventaja adicional de que si este dependiera de otros dichas dependencias se resolver&iacute;an autom&aacute;ticamente, lo que nos facilita las pruebas de integraci&oacute;n, como veremos despu&eacute;s.</p>
<p>&iquest;Qu&eacute; tendr&iacute;a de especial nuestro fichero de configuraci&oacute;n para pruebas?. Como ya hemos dicho, lo m&aacute;s habitual es definir la conexi&oacute;n con la base de datos de prueba en lugar de con la real. Yendo un paso m&aacute;s all&aacute; y para agilizar las pruebas, podr&iacute;amos usar una base de datos embebida en lugar de usar simplemente otras tablas en el mismo servidor de bases de datos de producci&oacute;n:
</p>
<pre class="brush:xml;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:jee="http://www.springframework.org/schema/jee"
  xmlns:jdbc="http://www.springframework.org/schema/jdbc"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
  http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context 
    http://www.springframework.org/schema/context/spring-context-3.2.xsd
    http://www.springframework.org/schema/jee 
    http://www.springframework.org/schema/jee/spring-jee-3.2.xsd
    http://www.springframework.org/schema/jdbc 
    http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd"&gt;

    &lt;!-- conexi&oacute;n con la BD de pruebas --&gt;
    &lt;jdbc:embedded-database id="miDataSource"&gt;
        &lt;jdbc:script location="classpath:db.sql"/&gt;
        &lt;jdbc:script location="classpath:testdata.sql"/&gt;
    &lt;/jdbc:embedded-database&gt;
    
    &lt;!-- los DAOs est&aacute;n en este package --&gt;
    &lt;context:component-scan base-package="es.ua.jtech.spring.datos"/&gt;

    &lt;!-- soporte de transacciones en las pruebas --&gt;
    &lt;bean id="txManager" 
      class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
      &lt;!-- importante: este "ref" coincide con el "id" del dataSource --&gt;
      &lt;property name="dataSource" ref="miDataSource"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</pre>
<p>En el fichero anterior estar&iacute;amos definiendo un DataSource Spring que conectar&iacute;a con una base de datos embebida, cuyos datos estar&iacute;an en los dos scripts SQL a los que se hace referencia (supuestamente uno para crear las tablas y otro para insertar los datos). Spring usa HSQLDB como base de datos embebida por defecto, aunque podemos cambiar la configuraci&oacute;n para usar otras. Por supuesto necesitaremos incluir la dependencia correspondiente en el pom.xml (suponiendo HSQLDB):
</p>
<pre class="brush:xml;">
&lt;dependency&gt;
  &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;
  &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
  &lt;version&gt;2.0.0&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre>
<p>Por otro lado, vemos que en el fichero se define un "transaction manager". Este se usa como soporte para gestionar la transaccionalidad de las pruebas. Un problema muy t&iacute;pico de las pruebas de acceso a datos es que la ejecuci&oacute;n de una prueba altera el contenido de la base de datos y quiz&aacute;s interfiere con las pruebas siguientes. Esto nos obliga a restablecer los datos iniciales tras cada prueba, por ejemplo ejecutando el script SQL que inserta los datos. Una alternativa es el <strong>soporte de transaccionalidad</strong> que nos da Spring: podemos hacer un <em>rollback</em> autom&aacute;tico de todos los cambios generados durante la prueba, lo que facilita mucho el trabajo.</p>
<p>Para que funcione esta transaccionalidad de las pruebas necesitamos un transaction manager en el fichero de configuraci&oacute;n de pruebas al igual que es necesario para que funcione la transaccionalidad declarativa en producci&oacute;n. Una vez definido el gestor de transacciones, debemos anotar la clase de pruebas con <span class="codefrag">@TransactionConfiguration</span>. El valor del atributo "transactionManager" debe coincidir con el id del transaction manager definido en el fichero de configuraci&oacute;n XML. Finalmente anotaremos con <span class="codefrag">@Transactional</span> los m&eacute;todos de prueba para los que queramos hacer un <em>rollback</em> autom&aacute;tico, o bien anotaremos la propia clase  si queremos hacerlo en todos:</p>
<pre class="brush:java;highlight:[4,5,6]">
//modificaci&oacute;n del test anterior
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:config/daos-test.xml")
@TransactionConfiguration(transactionManager = "txManager",
                           defaultRollback = true)
@Transactional
public class UsuariosDAOTest  {
...
</pre>
<a name="N101B3"></a><a name="Pruebas+de+integraci%C3%B3n.+Uso+de+objetos+mock"></a>
<h3 class="underlined_5">Pruebas de integraci&oacute;n. Uso de objetos mock</h3>
<p>Supongamos que tenemos una capa de negocio en la que hay un "gestor de usuarios" con el siguiente interfaz:</p>
<pre class="brush:java;">
public interface IUsuariosBO {
  //Este m&eacute;todo debe comprobar que el password coincide con lo que devuelve el DAO
  public Usuario login(String login, String password);
  //Estos m&eacute;todos delegan el trabajo en el DAO
  public List&lt;Usuario&gt; listar();
  public void alta(Usuario u);
}
</pre>
<p>Las implementaciones de dicho interfaz hacen uso del DAO de usuarios:</p>
<pre class="brush:java;">
@Service
public class UsuariosBOSimple implements IUsuariosBO {
  @Autowired
  IUsuariosDAO udao;

  @Override
  public Usuario login(String login, String password) {
    Usuario u = udao.getUsuario(login);
    if (u!=null  &amp;&amp; u.getPassword().equals(password))
      return u;
    else
      return null;
  }
}
</pre>
<p>Adem&aacute;s de probar por separado el BO y el DAO nos va a interesar hacer pruebas de integraci&oacute;n de ambos. En Spring si hacemos test de la capa BO autom&aacute;ticamente estamos haciendo pruebas de integraci&oacute;n ya que el framework resuelve e instancia la dependencia BO-&gt;DAO.</p>
<pre class="brush:java;">
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations={"classpath:config/daos-test.xml", 
   "classpath:config/bos-test.xml"})
public class UsuariosBOTest {
  @Autowired
  IUsuariosBO ubo;
  
  @Test
  public void testLogin() {
    //el usuario "experto" s&iacute; est&aacute; en la BD
    assertNotNull(ubo.login("experto", "experto"));
    //pero no el usuario "dotnet" (&iexcl;jam&aacute;s!)
    assertNull(ubo.login("dotnet", "dotnet"));
  }
}
</pre>
<p>Como antes, simplemente le pedimos a Spring con @Autowired que nos inyecte el objeto que deseamos probar. No necesitamos instanciar el DAO, lo har&aacute; Spring. La &uacute;nica diferencia con el ejemplo anterior es que usamos un fichero de configuraci&oacute;n adicional para la capa BO (en un momento veremos por qu&eacute; nos podr&iacute;a interesar tener la capa DAO y BO en ficheros de configuraci&oacute;n distintos). N&oacute;tese que cuando se usan varios, hay que hacerlo con notaci&oacute;n de inicializaci&oacute;n de array (entre llaves), y explicitando el nombre del atributo: "location".</p>
<p>Pero &iquest;qu&eacute; ocurre si queremos hacer pruebas unitarias de la capa BO, sin que "interfiera" el comportamiento de los DAO?. Necesitamos entonces sustituir estos &uacute;ltimos por <strong>objetos <em>mock</em></strong>. Podr&iacute;amos escribirlos nosotros mismos, pero en Java hay varios <em>frameworks</em> que nos ayudar&aacute;n a generar estos objetos. Vamos a usar aqu&iacute; <a href="http://code.google.com/p/mockito/">mockito</a>. El objetivo no es ver aqu&iacute; c&oacute;mo se usa este <em>framework</em> en s&iacute;, sino ver una breve introducci&oacute;n a c&oacute;mo usarlo dentro de Spring.</p>
<p>Supongamos que queremos construir un <em>mock</em> del interfaz <span class="codefrag">IUsuariosDAO</span> y hacer que tenga un determinado comportamiento. El API b&aacute;sico de mockito es bastante simple:</p>
<pre class="brush:java;">
import static org.mockito.Mockito.*;
//creamos el mock
IUsuariosDAO udaoMock = mock(IUsuariosDAO.class);
//Creamos un usuario de prueba con login "hola" y password "mockito"
Usuario uTest = new Usuario("hola", "mockito");
//grabamos el comportamiento del mock
when(udaoMock.getUsuario("hola")).thenReturn(uTest);
//imprime el usuario de prueba
System.out.println(udaoMock.getUsuario("hola"));
</pre>
<p>Como se ve en el c&oacute;digo anterior, primero creamos el <em>mock</em> con la llamada al m&eacute;todo est&aacute;tico <span class="codefrag">mock</span> y luego especificamos para la entrada indicada (<span class="codefrag">when</span>) qu&eacute; salida debe proporcionar (<span class="codefrag">thenReturn</span>). Nuestro <em>mock</em> ser&aacute; una especie de "tabla" con respuestas predefinidas ante determinadas entradas.</p>
<p>Ahora para integrar el mock dentro de Spring tenemos que resolver dos problemas: el primero es c&oacute;mo sustituir nuestra implementaci&oacute;n de IUsuariosDAO por el mock. Definiremos un bean de Spring que se construya llamando al m&eacute;todo <span class="codefrag">mock</span> de mockito. Vamos a hacerlo en XML, aunque tambi&eacute;n lo podr&iacute;amos hacer con configuraci&oacute;n Java (pero no con la anotaci&oacute;n @Repository, ya que la clase a anotar no es nuestra, sino generada por mockito):</p>
<pre class="brush:xml;">

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:jee="http://www.springframework.org/schema/jee"
  xmlns:jdbc="http://www.springframework.org/schema/jdbc"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.2.xsd
    http://www.springframework.org/schema/jee
    http://www.springframework.org/schema/jee/spring-jee-3.2.xsd
    http://www.springframework.org/schema/jdbc
    http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd"&gt;

  &lt;bean id="usuarioDAO" class="org.mockito.Mockito" factory-method="mock"&gt;
    &lt;constructor-arg value="es.ua.jtech.dao.IUsuariosDAO" /&gt;
  &lt;/bean&gt;
&lt;/beans&gt;

</pre>
<p>Ahora podemos ver por qu&eacute; nos interesaba tener en ficheros de configuraci&oacute;n distintos la capa DAO y BO. De este modo podemos tener un XML para la capa DAO de "producci&oacute;n" (que busque anotaciones @Repository digamos en es.ua.jtech.dao) y de pruebas de integraci&oacute;n y este otro para pruebas con mocks.</p>
<p>El segundo problema a resolver es c&oacute;mo especificar el comportamiento del <em>mock</em>. Aprovecharemos el <span class="codefrag">@Autowired</span> de Spring para acceder al objeto y el <span class="codefrag">@Before</span> para especificar su comportamiento. Si el bean es un <em>singleton</em>, el BO tendr&aacute; acceso a la misma instancia que hemos controlado nosotros y por tanto su comportamiento ser&aacute; el deseado.</p>
<pre class="brush:java;">
@RunWith(SpringJUnit4ClassRunner.class)
//daos-mock-test.xml es el XML de configuraci&oacute;n anterior, 
//con la definici&oacute;n del mock de IUsuariosDAO
@ContextConfiguration(locations={"classpath:config/daos-mock-test.xml", 
   "classpath:config/bos-test.xml"})
public class UsuariosBOMockTest {
  @Autowired
  IUsuariosBO ubo;
  
  //Esto nos dar&aacute; acceso al mock
  @Autowired
  IUsuariosDAO udao;
  
  @Before
  public void setup() {
    when(udao.getUsuario("test")).thenReturn(new Usuario("test","test"));
    when(udao.getUsuario("test2")).thenReturn(new Usuario("test2","test2"));
  }
  
  @Test
  public void testLogin() {
    //este usuario est&aacute; "grabado" en el mock
    assertNotNull(ubo.login("test", "test"));
    //pero este no, por tanto el BO deber&iacute;a devolver null
    assertNull(ubo.login("experto", "experto"));
  }
}
</pre>
<a name="N10229"></a><a name="Pruebas+de+la+capa+web"></a>
<h3 class="underlined_5">Pruebas de la capa web</h3>
<p>Una de las novedades de la versi&oacute;n 3.2 de Spring (la &uacute;ltima en el momento de escribir estos apuntes) es la extensi&oacute;n del soporte de pruebas a la capa web. Sin necesidad de desplegar la aplicaci&oacute;n en un contenedor web podemos simular peticiones HTTP y comprobar que lo que devuelve el controller, la vista a la que se salta o los objetos que se a&ntilde;aden al modelo son los esperados.</p>
<p>Hay dos posibilidades para ejecutar pruebas en la capa web, una de ellas es usar la misma configuraci&oacute;n que se usa en producci&oacute;n y otra es establecer manualmente una configuraci&oacute;n simplificada. Vamos a ver aqu&iacute; la primera de ellas, ya que nos permite hacer pruebas m&aacute;s completas y m&aacute;s pr&oacute;ximas a como se ejecuta el c&oacute;digo dentro del contenedor web.</p>
<p>Veamos primero un ejemplo muy sencillo. Supongamos que tenemos el siguiente controller, que lo &uacute;nico que hace es devolver un mensaje de texto:</p>
<pre class="brush:java;">
@Controller
public class HolaSpringController {
  @RequestMapping("/hola")
  public @ResponseBody String hola() {
    return "Hola Spring";
  }
}
</pre>
<p>Para las pruebas necesitamos una instancia de <span class="codefrag">MockMVC</span>, que se construye a partir del <span class="codefrag">WebApplicationContext</span> (el contexto de aplicaci&oacute;n generado a partir del fichero de configuraci&oacute;n de la capa web). Podemos pedirle a Spring una instancia de este &uacute;ltimo con <span class="codefrag">@Autowired</span>, as&iacute; que no es excesivamente complicado construir el <span class="codefrag">MockMVC</span>:</p>
<pre class="brush:java;">
@RunWith(SpringJUnit4ClassRunner.class)
@WebAppConfiguration
@ContextConfiguration(locations={"classpath:config/web-test.xml", 
   "classpath:config/daos-test.xml", "classpath:config/bos-test.xml"})
public class HolaSpringControllerTest {
  @Autowired
  private WebApplicationContext wac;

  private MockMvc mockMvc;

  @Before
  public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
  }

  //ahora vienen los test, un poco de paciencia...
  ...
}
</pre>
<p>N&oacute;tese que adem&aacute;s necesitamos anotar la clase del test con <span class="codefrag">@WebAppConfiguration</span>, para indicarle a Spring que estamos usando un contexto de aplicaci&oacute;n web.</p>
<p>El fichero de configuraci&oacute;n de la capa web para testing (en el ejemplo, web-test.xml) puede ser el mismo de producci&oacute;n o uno simplificado. Como m&iacute;nimo, si usamos anotaciones, deber&aacute; tener el context:component-scan. Adem&aacute;s tambi&eacute;n deber&iacute;a tener un viewresolver, as&iacute; podremos comprobar el nombre f&iacute;sico de la p&aacute;gina a la que saltamos tras el controller.</p>
<p>El API para hacer las llamadas de prueba es bastante intuitivo. Por desgracia al ser una funcionalidad muy recientemente a&ntilde;adida a Spring (antes estaba en un proyecto aparte) la documentaci&oacute;n de referencia todav&iacute;a no es muy detallada y para algunas cosas hay que acudir al propio Javadoc del API. Vamos a ver aqu&iacute; algunos ejemplos sencillos. Por ejemplo, para comprobar que la respuesta da un c&oacute;digo de estado OK y que es la que deseamos, har&iacute;amos</p>
<pre class="brush:java;">
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
...
...
@Test
public void testHola() throws Exception  {
  this.mockMvc.perform(get("/hola"))
    .andExpect(status().isOk())
    .andExpect(content().string("Hola Spring"));
}
</pre>
<p>como se ve, el esquema b&aacute;sico es que se hace una petici&oacute;n con <span class="codefrag">perform</span> y luego se espera una serie de resultados.</p>
<p>Vamos a ver varios ejemplos de c&oacute;mo hacer peticiones y comprobar el resultado de la ejecuci&oacute;n del controller. Para m&aacute;s informaci&oacute;n, se recomienda consultar la <a href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/testing.html#spring-mvc-test-framework">secci&oacute;n correspondiente</a> de la documentaci&oacute;n de Spring</p>
<a name="N1026F"></a><a name="Simular+la+petici%C3%B3n"></a>
<h4>Simular la petici&oacute;n</h4>
<p>Podemos especificar el m&eacute;todo HTTP a usar y el tipo de datos que aceptamos (el valor de la cabecera Accept):</p>
<pre class="brush:java;">
mockMvc.perform(get("/usuarios/").accept(MediaType.APPLICATION_JSON));
</pre>
<p>Podemos usar URI templates como en REST</p>
<pre class="brush:java;">
this.mockMvc.perform(put("/usuarios/{id}", 42)
    .content("{'login':'experto', 'password':'experto'}"));
</pre>
<p>O a&ntilde;adir par&aacute;metros HTTP a la petici&oacute;n</p>
<pre class="brush:java;">
mockMvc.perform(get("/verUsuario").param("login", "experto"));
</pre>
<a name="N1028E"></a><a name="Comprobar+el+resultado"></a>
<h4>Comprobar el resultado </h4>
<p>Ya hemos visto c&oacute;mo comprobar el c&oacute;digo de estado y el contenido de la respuesta. Veamos otros ejemplos. Podemos comprobar la vista a la que se intenta saltar:</p>
<pre class="brush:java;">
this.mockMvc.perform(post("/login").param("login","experto").param("password", "123456"))
  .andExpect(view().name("home"));
</pre>
<p>Tambi&eacute;n podemos verificar que el modelo generado por el controller es correcto. Por ejemplo, supongamos que el controller deber&iacute;a haber a&ntilde;adido al modelo un atributo "usuario" con el usuario a ver, cuyos datos se muestran a trav&eacute;s de la vista "datos_usuario"</p>
<pre class="brush:java;">
this.mockMvc.perform(get("/usuarios/experto"))
   .andExpect(model().size(1))
   .andExpect(model().attributeExists("usuario"))
   .andExpect(view().name("datos_usuario"));   
</pre>
<p>Podemos verificar una parte del contenido de la respuesta. Si es JSON, podemos usar la sintaxis de <a href="https://github.com/jayway/JsonPath">JsonPath</a> para especificar la parte que nos interesa. Este ejemplo buscar&iacute;a una propiedad llamada "localidad" con valor "alicante".
</p>
<pre class="brush:java;">
this.mockMvc.perform(get("/usuarios/experto").accept("application/json;charset=UTF-8"))
  .andExpect(status().isOk())
  .andExpect(content().contentType("application/json"))
  .andExpect(jsonPath("$.localidad").value("Alicante");
</pre>
<p>En caso de que la respuesta sea XML podemos usar el est&aacute;ndar xpath.</p>
<p>Podemos comprobar otros aspectos del resultado. El framework nos ofrece distintos <span class="codefrag">ResultMatchers</span>, que nos sirven para esto. Se recomienda consultar directamente el JavaDoc del API de Spring, en concreto el package <span class="codefrag">org.springframework.test.web.servlet.result</span>
</p>
</div> 


<p class="pageBreakAfter"> 
</p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Depto. Ciencia de la computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
