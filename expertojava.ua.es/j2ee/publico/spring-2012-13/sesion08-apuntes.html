<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Desarrollo r&aacute;pido de aplicaciones con Spring Roo</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Experto Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Spring" src="images/baner_j2ee_der.gif" title="Spring"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li>
<a class="base-not-selected" href="index.html">Spring</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_1.1', 'skin/')" id="menu_1.1Title" class="menutitle">Spring</div>
<div id="menu_1.1" class="menuitemgroup">
<div class="menuitem">
<a href="index.html" title="Spring">Indice</a>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion08-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Desarrollo r&aacute;pido de aplicaciones con Spring Roo</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n+r%C3%A1pida+a+Spring+Roo">Introducci&oacute;n r&aacute;pida a Spring Roo</a>
<ul class="minitoc">
<li>
<a href="#%C2%BFQu%C3%A9+es+Roo%3F">&iquest;Qu&eacute; es Roo?</a>
</li>
<li>
<a href="#Arquitectura+de+las+aplicaciones+Roo">Arquitectura de las aplicaciones Roo</a>
</li>
<li>
<a href="#Roo+en+diez+minutos+o+menos">Roo en diez minutos o menos</a>
</li>
<li>
<a href="#Trabajar+con+Roo+desde+SpringSource+Tool+Suite">Trabajar con Roo desde SpringSource Tool Suite</a>
</li>
<li>
<a href="#Reglas+generales+sobre+c%C3%B3mo+editar+c%C3%B3digo+en+una+aplicaci%C3%B3n+Roo">Reglas generales sobre c&oacute;mo editar c&oacute;digo en una aplicaci&oacute;n Roo</a>
</li>
</ul>
</li>
<li>
<a href="#La+capa+de+acceso+a+datos">La capa de acceso a datos</a>
<ul class="minitoc">
<li>
<a href="#Active+Record">Active Record</a>
</li>
<li>
<a href="#Validaci%C3%B3n">Validaci&oacute;n</a>
</li>
<li>
<a href="#Pruebas">Pruebas</a>
</li>
<li>
<a href="#Relaciones+entre+entidades">Relaciones entre entidades</a>
</li>
</ul>
</li>
<li>
<a href="#La+capa+web">La capa web</a>
<ul class="minitoc">
<li>
<a href="#Scaffolding">Scaffolding</a>
</li>
<li>
<a href="#Clientes+REST">Clientes REST</a>
</li>
<li>
<a href="#Finders+en+la+web">Finders en la web</a>
</li>
</ul>
</li>
<li>
<a href="#Refactorizaci%C3%B3n+del+c%C3%B3digo+Roo">Refactorizaci&oacute;n del c&oacute;digo Roo</a>
</li>
</ul>
</div>

<a name="N1000C"></a><a name="Introducci%C3%B3n+r%C3%A1pida+a+Spring+Roo"></a>
<h2 class="underlined_10">Introducci&oacute;n r&aacute;pida a Spring Roo</h2>
<div class="section">
<a name="N10012"></a><a name="%C2%BFQu%C3%A9+es+Roo%3F"></a>
<h3 class="underlined_5">&iquest;Qu&eacute; es Roo?</h3>
<p>Aunque casi nadie niega que JavaEE sea una plataforma robusta, escalable y que incorpora multitud de funcionalidades, no brilla precisamente por su productividad. Y eso que se ha simplificado mucho con los a&ntilde;os. En gran medida el problema procede del propio lenguaje de desarrollo: Java es un lenguaje est&aacute;ticamente tipado e induce a un  estilo de programaci&oacute;n demasiado verboso.</p>
<p>Como alternativa, las plataformas de desarrollo r&aacute;pido (RAD) de aplicaciones web, como Ruby on Rails o Django, suelen usar lenguajes de tipado din&aacute;mico o filosof&iacute;as como la "convenci&oacute;n por encima de la configuraci&oacute;n" (<em>convention over configuration</em>) con el objetivo de hacer el desarrollo m&aacute;s r&aacute;pido y &aacute;gil y el producto resultante m&aacute;s ligero y simple. En el mundo Java tenemos un representante de estas ideas en <strong>Groovy on Grails</strong>, inspirado en Rails y usando el lenguaje din&aacute;mico Groovy pero con la plataforma JavaEE por debajo (Grails tiene su propio m&oacute;dulo en este curso).</p>
<p>Spring Roo toma prestadas algunas de las ideas t&iacute;picas de las plataformas al estilo Rails (la convenci&oacute;n por encima de la configuraci&oacute;n, el <em>active record</em> para la persistencia,...), pero conceptualmente est&aacute; m&aacute;s cerca de las herramientas MDA y de las de generaci&oacute;n de c&oacute;digo. Es decir, b&aacute;sicamente Roo nos va a generar el esqueleto de una aplicaci&oacute;n Spring completa, ahorr&aacute;ndonos el tedioso trabajo de tener que configurarlo todo manualmente y tener que escribir el t&iacute;pico c&oacute;digo repetitivo, como por ejemplo las partes de CRUD en JPA o en la web.</p>
<p>Roo respeta los siguientes principios:</p>
<ul>
 
<li>Uso de tecnolog&iacute;as "est&aacute;ndar" (en el sentido de ampliamente conocidas y probadas): genera un proyecto Maven con c&oacute;digo Spring, JPA y Tiles entre otros.</li>
 
<li>No incorpora componentes en tiempo de ejecuci&oacute;n. No hay lenguajes interpretados ni librer&iacute;as adicionales.</li>
 
<li>Separa f&iacute;sicamente el c&oacute;digo generado de los archivos editables por el desarrollador, de modo que al modificar estos &uacute;ltimos no "rompamos" o trastoquemos la aplicaci&oacute;n, que es un problema t&iacute;pico de las herramientas de generaci&oacute;n de c&oacute;digo. Como veremos, esto se consigue mediante el uso de AOP. Esto no significa que no haya que tener cuidado al editar el c&oacute;digo. Luego veremos algunas directrices.</li>
 
<li>Intenta evitar convertirse en una dependencia imprescindible: de modo que si en alg&uacute;n momento deseamos dejar de usarlo podamos refactorizar el c&oacute;digo de manera sencilla y pasar a tener un c&oacute;digo fuente sin dependencias de &eacute;l.</li>

</ul>
<p>Evidentemente, en desarrollo software no hay f&oacute;rmulas m&aacute;gicas, as&iacute; que Roo no puede resolver todos nuestros problemas ni escribir autom&aacute;ticamente una aplicaci&oacute;n no trivial (pero quiz&aacute; pueda darnos un 80% del c&oacute;digo hecho para concentrarnos en el 20% realmente interesante). Por otro lado, y como ya hemos dicho, al ser una herramienta que genera c&oacute;digo hay que llevar cierto cuidado con los cambios que hacemos para evitar que la aplicaci&oacute;n se "rompa". </p>
<a name="N10040"></a><a name="Arquitectura+de+las+aplicaciones+Roo"></a>
<h3 class="underlined_5">Arquitectura de las aplicaciones Roo</h3>
<p>Habitualmente las aplicaciones web JavaEE se estructuran en tres capas: la capa web, la de negocio y la de acceso a datos. En la de negocio suele haber una "sub-capa" de servicios (Business Objects) que ofrecen eso, servicios, a la capa web o a clientes remotos (REST y otros). Adem&aacute;s aqu&iacute; se suele considerar que est&aacute; el modelo del dominio. Finalmente, en la capa de acceso a datos habitualmente tenemos los DAOs, que se encargan de la persistencia.</p>
<p>La arquitectura de las aplicaciones generadas por Roo por defecto es mucho m&aacute;s simple que la que acabamos de describir. B&aacute;sicamente tiene dos capas: la web y la de entidades o modelo del dominio. Las entidades se convierten en una especie de "superentidades" que se encargan no solo de modelar el dominio sino tambi&eacute;n de tareas como su propia persistencia, la validaci&oacute;n de sus datos e incluso su serializaci&oacute;n a JSON. Esta idea de que los propios objetos del dominio se encarguen de su persistencia no es exclusiva de Roo, en realidad es muy t&iacute;pica de plataformas RAD como Rails, Django, Grails y otras, y se conoce habitualmente como <em>Active Record</em>.</p>
<p>En ciertos casos nos interesar&aacute; tener en la aplicaci&oacute;n servicios y/o DAOs. Aunque no los use por defecto, Roo tambi&eacute;n puede generarlos si se lo pedimos. No obstante, en estos apuntes nos concentraremos en el modelo m&aacute;s simple de dos capas.</p>
<a name="N10053"></a><a name="Roo+en+diez+minutos+o+menos"></a>
<h3 class="underlined_5">Roo en diez minutos o menos</h3>
<p>Desde el punto de vista de su uso, Roo est&aacute; dise&ntilde;ado como un shell interactivo al estilo de Rails o de Grails. Para facilitar su uso tiene autocompletado de los comandos y ayuda contextual. Adem&aacute;s en todo momento nos mostrar&aacute; solo los comandos que sean v&aacute;lidos y nos dar&aacute; pistas de cu&aacute;l es la siguiente tarea a realizar si estamos un poco perdidos.</p>
<p>Vamos a ver aqu&iacute; c&oacute;mo se interact&uacute;a con Roo a nivel b&aacute;sico, teclearemos comandos sin explicar en mucho detalle qu&eacute; hace cada uno, en eso ya entraremos en los siguientes apartados.</p>
<p>Crearemos la t&iacute;pica aplicaci&oacute;n de gesti&oacute;n de tareas pendientes. Para comenzar, lo primero es crear un directorio para el proyecto:</p>
<pre class="brush:shell;">
mkdir tareas
cd tareas
</pre>
<p>Y ahora ya podemos arrancar el shell de Roo. El script en sistemas Unix se llama <span class="codefrag">roo.sh</span> (<span class="codefrag">roo.bat</span> en Windows). Aparecer&aacute; la siguiente pantalla:</p>
<p>
<img alt="El shell de Spring Roo" content-width="10cm" src="imagenes/sesion08/roo_shell.jpg">
</p>
<div class="frame warning">
<div class="label">Cuidado con el directorio inicial</div>
<div class="content">
Cuando arranca, el <em>shell</em> de Roo examina recursivamente los subdirectorios del directorio actual, de modo que si lo ejecutamos desde nuestro <span class="codefrag">$HOME</span> o desde la ra&iacute;z del disco, puede pasarse mucho rato navegando por subdirectorios y examinando archivos y tener problemas de memoria. Por eso hay que ejecutarlo siempre desde el propio directorio del proyecto.  
</div>
</div>
<p>El propio <em>shell</em> nos sugiere que pulsemos TAB para autocompletar comandos. Si lo hacemos, aparecer&aacute; una lista con los comandos disponibles, que no son todos los de Roo, sino solo los que tiene sentido usar en este momento. Adem&aacute;s, el <em>shell</em> nos indica que si tecleamos el comando hint, nos "dar&aacute; una pista" de qu&eacute; hacer a continuaci&oacute;n:</p>
<p>
<img alt="El comando 'hint' nos dice qu&eacute; podemos hacer a continuaci&oacute;n" content-width="10cm" src="imagenes/sesion08/roo_hint.jpg">
</p>
<p>Como vemos, lo primero que debemos hacer es crear la estructura del proyecto con el comando <span class="codefrag">project</span>. Para ahorrarnos tecleos innecesarios podemos emplear TAB para autocompletar, de modo que si tecleamos proj-TAB-TAB el resultado ser&aacute;:</p>
<pre class="brush:shell;">
project --topLevelPackage
</pre>
<p>Ahora tecleamos un nombre para el "dominio" base del proyecto, por ejemplo es.ua.jtech. Roo crear&aacute; la estructura b&aacute;sica necesaria para comenzar a trabajar con nuestro proyecto:</p>
<p>
<img alt="Creando la estructura del proyecto con el comando 'project'" content-width="10cm" src="imagenes/sesion08/roo_project.jpg">
</p>
<p>Podemos ver que se ha creado el pom.xml de Maven y un fichero XML de configuraci&oacute;n de beans de Spring. Ahora, si no sabemos qu&eacute; hacer, podemos teclear de nuevo 'hint':</p>
<p>
<img alt="Empezando a trabajar con la capa de persistencia" content-width="10cm" src="imagenes/sesion08/roo_hint_jpa.jpg">
</p>
<p>Y vemos que Roo nos sugiere empezar a trabajar con la capa de persistencia de nuestra aplicaci&oacute;n. Lo primero de todo es seleccionar lo que Roo llama un "proveedor de persistencia", es decir, una tecnolog&iacute;a de persistencia de entre las que soporta Roo. Por defecto lo m&aacute;s habitual en Roo es usar JPA, aunque tambi&eacute;n viene preparado para bases de datos NoSQL como MongoDB.</p>
<p>Vamos entonces a configurar la capa de persistencia. Usaremos JPA con la implementaci&oacute;n de Hibernate y como base de datos emplearemos hsqldb en memoria, para no depender de ning&uacute;n servidor de base de datos externo.</p>
<pre class="brush:shell;">
roo&gt; jpa setup --provider HIBERNATE --database HYPERSONIC_IN_MEMORY 
</pre>
<p>El siguiente paso es crear las entidades del modelo del dominio. Crearemos una clase <span class="codefrag">Tarea</span> y luego le iremos a&ntilde;adiendo campos: titulo, fecha l&iacute;mite y prioridad. Ponemos todos los comandos seguidos, obviando la informaci&oacute;n que Roo nos da entre comando y comando de todos los archivos que va creando para dar soporte a la aplicaci&oacute;n.</p>
<pre class="brush:shell;">
roo&gt; entity jpa --class es.ua.jtech.domain.Tarea
~.domain.Tarea roo&gt; field string --fieldName titulo
~.domain.Tarea roo&gt; field date --fieldName limite --type java.util.Date
~.domain.Tarea roo&gt; field number --type int --fieldName prioridad
</pre>
<div class="frame note">
<div class="label">El archivo .log de Roo</div>
<div class="content">Cada uno de los comandos que tecleamos en el <em>shell</em> se guarda en un archivo llamado <span class="codefrag">log.roo</span> en el directorio del proyecto. As&iacute;, si queremos repetir los pasos para volver a crear de nuevo el mismo proyecto podemos ejecutar este fichero como un <em>script</em>, mediante el comando Roo del mismo nombre: <span class="codefrag">script --file log.roo</span> 
</div>
</div>
<p>Con todo esto hemos creado una entidad que autom&aacute;ticamente incorpora m&eacute;todos de persitencia CRUD y algunos m&eacute;todos de b&uacute;squeda b&aacute;sicos (buscar tareas por identificador - Roo crea una autom&aacute;ticamente, al no haberlo hecho nosotros -), N&oacute;tese que tras crear la entidad <span class="codefrag">Tarea</span>, el <em>prompt</em> de Roo cambia indicando que el foco de las siguientes operaciones est&aacute; fijado en ella, es decir, que los campos se van a crear por defecto en esa entidad. Roo abrevia el nombre del paquete de nivel superior de la aplicaci&oacute;n (en nuestro ejemplo <span class="codefrag">es.ua.jtech</span>) con el s&iacute;mbolo de la tilde, <span class="codefrag">~</span>. Podemos usar ese s&iacute;mbolo en nuestros comandos en lugar de teclear el nombre completo del paquete, aunque por desgracia no es una abreviatura muy pr&aacute;ctica para el teclado en castellano. Para cambiar el foco a otra entidad podemos usar el comando <span class="codefrag">focus --class nombre_de_la_clase_cualificado</span>
</p>
<p>Por otro lado, aunque aqu&iacute; estamos creando los campos de la clase con comandos de Roo podr&iacute;amos hacerlo tambi&eacute;n editando directamente el archivo <span class="codefrag">Tarea.java</span>, como har&iacute;amos si no estuvi&eacute;ramos usando Roo. Si abrimos este archivo, veremos que tiene un aspecto como el siguiente (obviando los imports):
</p>
<pre class="brush:java;">
@RooJavaBean
@RooToString
@RooJpaActiveRecord
public class Tarea {

    @Temporal(TemporalType.TIMESTAMP)
    @DateTimeFormat(style = "M-")
    private Date limite;

    private int prioridad;

    private String titulo;
}
</pre>
<p>Vemos que es c&oacute;digo est&aacute;ndar con algunas anotaciones de Roo. Pero a poco que lo examinemos, es un poco sorprendente: &iquest;d&oacute;nde est&aacute;n los <em>getters</em> y <em>setters</em>? &iquest;y el supuesto c&oacute;digo CRUD que se hab&iacute;a autogenerado? &iquest;no ser&aacute; un enga&ntilde;o todo esto de Roo ;)?. La respuesta es que para no interferir con los archivos que nosotros podemos modificar, Roo coloca todo este c&oacute;digo generado en archivos aparte. El mecanismo que se usa es bastante ingenioso: estos archivos son lo que se denominan <em>Inter-Type Declarations</em> (ITD) de AspectJ, y son los ficheros con extensi&oacute;n <span class="codefrag">.aj</span> que Roo ha ido creando y actualizando tras cada uno de los comandos que hemos ejecutado sobre nuestra entidad. Por ejemplo el <span class="codefrag">Tarea_Roo_JavaBean.aj</span> contiene los <em>getters</em> y <em>setters</em>, el <span class="codefrag">Tarea_Roo_Jpa_ActiveRecord.aj</span> contiene el c&oacute;digo de persistencia, ... En tiempo de compilaci&oacute;n, el compilador de AspectJ "mezcla" (<em>weaves</em>, en argot AOP) este c&oacute;digo generado con el c&oacute;digo escrito por nosotros, produciendo ficheros .class convencionales con una combinaci&oacute;n de nuestro c&oacute;digo y el generado autom&aacute;ticamente.
</p>
<p>Roo es lo suficientemente "inteligente" como para detectar en tiempo real los cambios que hacemos a nuestros .java y actuar en consecuencia. Por ejemplo si a&ntilde;adimos un campo para la descripci&oacute;n de la tarea
</p>
<pre class="brush:java;">
private String descripcion;
</pre>
<p>Al actualizar el archivo .java, y si seguimos teniendo abierto el shell de Roo, este detectar&aacute; el cambio y actualizar&aacute; los ITD pertinentes para incluir el nuevo campo.
</p>
<p>Para terminar nuestra aplicaci&oacute;n, vamos a a&ntilde;adirle una capa web y a generar autom&aacute;ticamente la parte CRUD de la web. A esto &uacute;ltimo, en el &aacute;mbito de las herramientas web de desarrollo r&aacute;pido, se le suele denominar <em>scaffolding</em>.</p>
<pre class="brush:shell;">
roo&gt; web mvc setup
roo&gt; web mvc all --package es.ua.jtech.web
</pre>
<p>Finalmente, con el comando <span class="codefrag">quit</span> nos salimos del shell de roo y podemos proceder a desplegar nuestra aplicaci&oacute;n. Al ser un proyecto web Maven, podemos desplegarla y ejecutarla autom&aacute;ticamente por ejemplo en el contenedor web Jetty con: 
</p>
<pre class="brush:shell;">
$ mvn jetty:run
</pre>
<p>Si es la primera vez que usamos Jetty desde Maven tardar&aacute; un rato en bajarse las dependencias, pero el proceso es autom&aacute;tico. Una vez aparezca en la consola el mensaje "Started Jetty Server", el servidor est&aacute; listo, y podemos acceder a la aplicaci&oacute;n abriendo la URL <span class="codefrag">http://localhost:8080/jtech</span> desde un navegador. Veremos el interfaz web generado por Roo, en el que podemos realizar las t&iacute;picas operaciones CRUD.</p>
<p>
<img alt="Pantalla inicial de la aplicaci&oacute;n web" content-width="12cm" src="imagenes/sesion08/roo_web_1.jpg" width="600"></p>
<p>
<img alt="Creaci&oacute;n de tarea" content-width="12cm" src="imagenes/sesion08/roo_web_2.jpg" width="600">
</p>
<p>
<img alt="Lista de tareas" content-width="12cm" src="imagenes/sesion08/roo_web_3.jpg" width="600"></p>
<a name="N1014D"></a><a name="Trabajar+con+Roo+desde+SpringSource+Tool+Suite"></a>
<h3 class="underlined_5">Trabajar con Roo desde SpringSource Tool Suite</h3>
<p>Como no pod&iacute;a ser de otro modo, STS, el IDE de SpringSource, est&aacute; preparado para trabajar con Roo. Entre los distintos tipos de proyectos que podemos crear est&aacute; el "Spring Roo Project". El cuadro de di&aacute;logo para introducir los datos tiene muchas opciones pero podemos dejar la mayor&iacute;a con los valores por defecto. Por ejemplo, para darle las mismas propiedades que el proyecto que hemos creado desde el <em>shell</em> de Roo, har&iacute;amos: </p>
<p>
<img alt="Crear nuevo proyecto Roo en STS" content-width="12cm" src="imagenes/sesion08/sts_new.jpg" width="400">
</p>
<p>Una vez creado el esqueleto del proyecto, aparecer&aacute; una ventana de Eclipse con un shell de Roo, que es el mismo que hemos usado antes desde fuera de STS. La diferencia m&aacute;s aparente es que ya se est&aacute; ejecutando por defecto en el directorio del proyecto y adem&aacute;s que desde STS para autocompletar no se usa TAB sino Ctrl-Espacio, al estilo Eclipse. De hecho el propio shell de Roo lo detecta y cambia el mensaje en pantalla para indicarlo.</p>
<div class="frame warning">
<div class="label">Problema con el proyecto reci&eacute;n creado</div>
<div class="content">En la versi&oacute;n instalada en la m&aacute;quina virtual hay un peque&ntilde;o <em>bug</em>, ya que STS espera por defecto que haya una carpeta src/test/resources, mientras que Roo no la crea autom&aacute;ticamente. Para que desaparezca el error de "<em>Project 'XXXX' is missing required source folder: 'src/test/resources'</em>" tendremos que crear dichas carpetas manualmente.</div>
</div>
<p>Por defecto STS oculta los ITD con extensi&oacute;n .aj. Para verlos, en la ventana del <span class="codefrag">Package Explorer</span> hacemos clic sobre la peque&ntilde;a flecha apuntando hacia abajo de la esquina superior derecha, seleccionamos <span class="codefrag">Filters...</span> y desmarcamos la opci&oacute;n de "Hide generated Spring ROO ITDs".</p>
<p>El desarrollo en Roo usando STS tambi&eacute;n se basa en comandos que hay que teclear en la terminal, con la comodidad adicional que nos ofrece el IDE al escribir c&oacute;digo o ejecutar la aplicaci&oacute;n (al crear Roo una aplicaci&oacute;n web est&aacute;ndar, podemos ejecutarla desde STS con <span class="codefrag">Run As</span> tras a&ntilde;adirle la capa web). Adem&aacute;s STS nos ofrece algunas funcionalidades adicionales, por ejemplo para refactorizar c&oacute;digo, como veremos posteriormente.
</p>
<a name="N1017E"></a><a name="Reglas+generales+sobre+c%C3%B3mo+editar+c%C3%B3digo+en+una+aplicaci%C3%B3n+Roo"></a>
<h3 class="underlined_5">Reglas generales sobre c&oacute;mo editar c&oacute;digo en una aplicaci&oacute;n Roo</h3>
<p>Al ser Roo una herramienta de generaci&oacute;n de c&oacute;digo, hay que llevar cuidado al modificar manualmente nuestro proyecto porque podemos eliminar o cambiar algo vital para Roo y "romper" el c&oacute;digo. En la pr&aacute;ctica, como todo el c&oacute;digo generado por Roo est&aacute; en los .aj esto no va a pasar con tanta facilidad como con otras herramientas de generaci&oacute;n de c&oacute;digo. Vamos a dar unas directrices generales de qu&eacute; editar y c&oacute;mo y qu&eacute; no:</p>
<ul>

<li>
<em>No se deben modificar/eliminar los archivos .aj</em> ya que es Roo el que los gestiona y modifica autom&aacute;ticamente.</li>

<li>
<em>Se puede modificar c&oacute;digo de los .java generados por Roo</em>. Ya que Roo vigilar&aacute; los cambios y modificar&aacute; los .aj para que los reflejen. Como iremos viendo, algunos comandos de Roo lo &uacute;nico que hacen en realidad es introducir ciertas anotaciones propias del framework en el c&oacute;digo Java. Estas anotaciones, de hecho, son las que hacen que Roo genere y actualice los .aj. De modo que tambi&eacute;n podemos introducirlas a mano en lugar de hacerlo mediante los comandos del shell de Roo. Evidentemente, esto quiere decir que si las eliminamos o modificamos inadvertidamente, la "magia" de Roo podr&iacute;a dejar de funcionar.</li>

<li>En general <em>tambi&eacute;n se pueden editar los artefactos est&aacute;ndar</em>, por ejemplo el pom.xml para a&ntilde;adir dependencias o plugins, eso s&iacute;, llevando cuidado de no eliminar nada que haya introducido Roo.</li>

</ul>
</div>  


<a name="N1019C"></a><a name="La+capa+de+acceso+a+datos"></a>
<h2 class="underlined_10">La capa de acceso a datos</h2>
<div class="section">
<p>Vamos a ver en este apartado de manera un poco m&aacute;s detallada qu&eacute; puede hacer Roo por nosotros al crear las entidades del dominio de nuestra aplicaci&oacute;n. Como ya hemos visto en la introducci&oacute;n r&aacute;pida este es el primer paso que se hace tras la creaci&oacute;n de un proyecto.</p>
<p>Vimos que el primer paso era especificar qu&eacute; proveedor de persistencia y qu&eacute; base de datos &iacute;bamos a usar, con el comando <span class="codefrag">jpa setup</span>. En cualquier momento podemos cambiar la configuraci&oacute;n de la base de datos y del proveedor de persistencia las veces que deseemos ejecutando de nuevo <span class="codefrag">jpa setup</span>. As&iacute;, en las primeras versiones de la aplicaci&oacute;n podemos usar una base de datos <span class="codefrag">hsqldb</span> en memoria, como hicimos en el ejemplo de la aplicaci&oacute;n de tareas, y luego cambiar a otra base de datos como MySQL u Oracle. En este &uacute;ltimo caso, lo normal ser&aacute; que tengamos que editar manualmente las propiedades de conexi&oacute;n con la base de datos, que Roo almacena en el archivo <span class="codefrag">src/main/resources/META-INF/spring/database.properties</span>. Tambi&eacute;n se pueden mostrar/editar dichas propiedades desde el shell de Roo con el comando <span class="codefrag">properties</span>.</p>
<div class="frame note">
<div class="label">Generar las entidades a partir de la BD</div>
<div class="content">Aqu&iacute; vamos a crear y mantener las entidades manualmente, pero Roo tambi&eacute;n ofrece la posibilidad de generarlas autom&aacute;ticamente haciendo ingenier&iacute;a inversa de la base de datos. No obstante esa forma de trabajar queda fuera del &aacute;mbito de estos apuntes. Se recomienda consultar la secci&oacute;n denominada DBRE (DataBase Reverse Engineering) de la documentaci&oacute;n de Roo.</div>
</div>
<a name="N101BB"></a><a name="Active+Record"></a>
<h3 class="underlined_5">Active Record</h3>
<p>Antes hemos comentado que Roo implementa el patr&oacute;n de dise&ntilde;o <em>Active Record</em>, dando autom&aacute;ticamente a las entidades funcionalidad CRUD. Esta funcionalidad se implementa f&iacute;sicamente en el .aj cuyo nombre comienza con el de la entidad y acaba en <span class="codefrag">ActiveRecord</span>. El API es bastante sencillo, consistiendo en un conjunto de m&eacute;todos muy similares a los de JPA. Por ejemplo:</p>
<pre class="brush:java;">
//Create
Tarea t = new Tarea();
t.setLimite(new Date());
t.setPrioridad(1);
t.setTitulo("Probando");
t.persist();
//Read
for (Tarea t_i : Tarea.findAllTareas()) {
	System.out.println(t_i.getTitulo());
}
//Update
Tarea t2 = Tarea.findTarea(1L);
t2.setPrioridad(1);
t2.merge();
//Delete
Tarea t3 = Tarea.findTarea(2L);
t3.remove();
</pre>
<p>Como se ve, los m&eacute;todos de este API son los mismos que los de JPA, pero los implementa la propia clase de la entidad. El <span class="codefrag">find</span> de JPA se implementa como un m&eacute;todo est&aacute;tico y se a&ntilde;ade un <span class="codefrag">findAll</span>, un m&eacute;todo de conveniencia para obtener todas las entidades sin necesidad de crear una query, tambi&eacute;n est&aacute;tico.
</p>
<p>En <em>active record</em>, los m&eacute;todos que sirven para buscar entidades especificando determinadas condiciones se denominan gen&eacute;ricamente <em>finders</em>. Adem&aacute;s del <span class="codefrag">find</span> y del <span class="codefrag">findAll</span>, Roo puede generar por nosotros el c&oacute;digo de muchos otros <em>finders</em> sin necesidad de escribir manualmente la <em>query</em> JPA-QL. Los <em>finders</em> codifican la <em>query</em> en el nombre del m&eacute;todo seg&uacute;n una serie de convenciones, que nos permiten buscar por un campo o por varios (findXXXByYYY, findXXXByYYYAndZZZ), o buscar aquellas entidades en las que un campo cumpla o no determinada condici&oacute;n (findXXXByYYYNotEquals,...). Algunos ejemplos concretos:</p>
<pre class="brush:java;">
findTareasByTituloEquals(String titulo) 
findTareasByTituloNotEquals(String titulo)
findTareasByTituloLike(String titulo)  
findTareasByPrioridad(int prioridad)
findTareasByLimiteLessThan(Date limite)
findTareasByLimiteBetween(Date minLimite, Date maxLimite)
</pre>
<p>Para saber exactamente qu&eacute; finders puede implementar Roo por nosotros, podemos usar el comando <span class="codefrag">finder list</span>, teniendo el foco en la entidad que nos interesa, lo que nos imprimir&aacute; en el shell una lista con todos los <em>finder</em> posibles para esta entidad. Ahora, para generar uno de ellos usamos el comando <span class="codefrag">finder add --finderName</span> seguido del nombre del <em>finder</em> a generar. Por ejemplo:</p>
<pre class="brush:shell;">
~.domain.Tarea roo&gt; finder add --finderName findTareasByPrioridad
</pre>
<p>Como ya hemos dicho, podemos generar <em>finders</em> que combinen dos o m&aacute;s campos (en el nombre aparecer&aacute;n unidos por <span class="codefrag">And</span> u <span class="codefrag">Or</span>,por ejemplo <span class="codefrag">findTareasByPrioridadAndLimiteLessThan</span>). Para listarlos, podemos a&ntilde;adir el par&aacute;metro <span class="codefrag">--depth</span> indicando cu&aacute;ntos campos queremos combinar. &iexcl;Cuidado, f&aacute;cilmente se producir&aacute; una explosi&oacute;n combinatoria en el n&uacute;mero de <em>finders</em> posibles!.</p>
<a name="N10222"></a><a name="Validaci%C3%B3n"></a>
<h3 class="underlined_5">Validaci&oacute;n</h3>
<p>Vamos a probar cosas un poco m&aacute;s sofisticadas que las que hicimos en la introducci&oacute;n "en diez minutos". Continuando con el ejemplo de las tareas, vamos a suponer ahora que tenemos proyectos y que cada proyecto est&aacute; compuesto de una o varias tareas. Vamos a crear la entidad Proyecto con los campos t&iacute;tulo y prioridad. En el siguiente apartado nos ocuparemos de la relaci&oacute;n uno a muchos entre proyecto y tareas. Por ahora vamos a decirle a Roo que queremos <strong>validar</strong> los campos t&iacute;tulo y prioridad: el t&iacute;tulo no puede estar vac&iacute;o y la prioridad debe ser un entero de 1 a 3. La creaci&oacute;n de la entidad la hacemos con los comandos:</p>
<pre class="brush:shell;">
roo&gt; entity jpa --class es.ua.jtech.domain.Proyecto
~.domain.Proyecto roo&gt; field string --fieldName nombre --notNull	
~.domain.Proyecto roo&gt; field number --fieldName prioridad --type int --min 1 --max 3
</pre>
<p>Lo que hace Roo es introducir anotaciones de JSR303 para validar los campos. Tambi&eacute;n podr&iacute;amos haber creado los campos e introducido las anotaciones manualmente en el c&oacute;digo. Para m&aacute;s informaci&oacute;n sobre los distintos par&aacute;metros para la validaci&oacute;n, consultar la referencia de Roo.</p>
<a name="N10237"></a><a name="Pruebas"></a>
<h3 class="underlined_5">Pruebas</h3>
<p>Para probar el c&oacute;digo de persistencia y validaci&oacute;n, podemos decirle a Roo que genere autom&aacute;ticamente un conjunto de tests. Dicho conjunto lo podemos generar con el comando <span class="codefrag">test integration</span>:</p>
<pre class="brush:shell;">
roo&gt; test integration --entity es.ua.jtech.domain.Proyecto
</pre>
<p>Tambi&eacute;n pod&iacute;amos haber creado los test en el momento de crear la entidad con el comando <span class="codefrag">entity</span> a&ntilde;adiendo al final el <em>switch</em> <span class="codefrag">--testAutomatically</span>.</p>
<p>Una vez creados los test, veremos que se ha generado, entre otros, una clase de prueba <span class="codefrag">ProyectoIntegrationTest</span> en <span class="codefrag">src/test/java</span> que como no pod&iacute;a ser menos en Roo, no contiene en apariencia ning&uacute;n test (solo uno que est&aacute; vac&iacute;o). En realidad los test de integraci&oacute;n est&aacute;n en un .aj, y prueban todas las funcionalidades CRUD que Roo le proporciona a la entidad. Como el .aj se "mezcla" con el .java al compilarse, los test CRUD se ejecutar&aacute;n autom&aacute;ticamente con Maven o bien podemos ejecutarlos manualmente con bot&oacute;n derecho y <span class="codefrag">Run As &gt; JUnit Test</span>.</p>
<p>Por supuesto, podemos incluir nuestros propios test. Con el objeto de facilitarnos su implementaci&oacute;n, Roo nos genera junto a los tests de CRUD una clase denominada <span class="codefrag">XXXDataOnDemand</span>, donde <span class="codefrag">XXX</span> es el nombre de la entidad. Esta clase nos proporciona bajo demanda nuevas instancias de la entidad con valores aleatorios, asegur&aacute;ndose de que cumplan las restricciones de validaci&oacute;n.</p>
<pre class="brush:java;highlight:[3,4]">
@Test
public void testDeEjemplo() {
	ProyectoDataOnDemand pdod = new ProyectoDataOnDemand();
	Proyecto p = pdod.getNewTransientProyecto(1);
	p.persist();
	Proyecto p2 = Proyecto.findProyecto(p.getId());
	assertEquals(p.toString(),p2.toString());
}</pre>
<a name="N10270"></a><a name="Relaciones+entre+entidades"></a>
<h3 class="underlined_5">Relaciones entre entidades</h3>
<p>Por supuesto, tan importante como gestionar las entidades es gestionar las relaciones entre ellas. Al crear los campos, si especificamos  que representan una relaci&oacute;n con otra entidad introducir&aacute; las anotaciones JPA pertinentes. Como siempre, tambi&eacute;n podr&iacute;amos escribir manualmente el c&oacute;digo.</p>
<p>Vamos a modelar una relaci&oacute;n uno a muchos entre proyecto y tareas. En el proyecto A&ntilde;adiremos un campo "tareas" que referencie las tareas dentro de &eacute;l. En Roo este tipo de campo se define como "set" (en Java ser&aacute; un Set&lt;Tarea&gt;). Por defecto se supone cardinalidad muchos a muchos, salvo que lo especifiquemos. Para el campo del lado "muchos a uno" se usa el tipo "reference".</p>
<pre class="brush:shell;">
roo&gt; focus --class es.ua.jtech.domain.Proyecto
~.domain.Proyecto roo&gt; field set --fieldName tareas --type Tarea 
                                 --cardinality ONE_TO_MANY --mappedBy proyecto
~.domain.Proyecto roo&gt; focus --class es.ua.jtech.domain.Tarea
~.domain.Tarea roo&gt; field reference --fieldName proyecto --type Proyecto 
                                 --cardinality MANY_TO_ONE
  </pre>
<p>Como es de suponer, el <span class="codefrag">--mappedBy</span> representa el atributo del mismo nombre de la anotaci&oacute;n <span class="codefrag">@OneToMany</span>
</p>
</div>  



<a name="N1028B"></a><a name="La+capa+web"></a>
<h2 class="underlined_10">La capa web</h2>
<div class="section">
<p>Roo puede generar el c&oacute;digo de la capa web para diferentes <em>frameworks</em>. El usado por defecto es Spring MVC, que es el que vamos a ver aqu&iacute;, pero tambi&eacute;n podemos emplear JSF, GWT u otros menos conocidos como Vaadin.</p>
<p>Lo primero es crear toda la configuraci&oacute;n y los artefactos necesarios para la capa web. Entre otras cosas, si el proyecto era hasta ahora de tipo JAR, Roo cambiar&aacute; la configuraci&oacute;n a .WAR, crear&aacute; el descriptor de despliegue web.xml, introducir&aacute; las nuevas dependencias en el pom.xml, crear&aacute; el fichero de configuraci&oacute;n de beans para la capa web... todo esto se consigue con el comando</p>
<pre class="brush:shell;">
roo&gt; web mvc setup
</pre>
<a name="N1029F"></a><a name="Scaffolding"></a>
<h3 class="underlined_5">Scaffolding</h3>
<p>El <em>scaffolding</em> es una funcionalidad muy habitual en las herramientas de desarrollo r&aacute;pido para web y consiste en que la herramienta nos va a generar todo lo necesario para un interfaz web CRUD de las entidades, desde las p&aacute;ginas JSP y el CSS hasta los <em>controllers</em> (en Spring MVC, en otros <em>frameworks</em> generar&aacute; los artefactos equivalentes). Podemos decirle a Roo que queremos scaffolding para todas las entidades con</p>
<pre class="brush:shell;">
roo&gt; web mvc all --package es.ua.jtech.web
</pre>
<p>Con <span class="codefrag">--package</span> estamos especificando el paquete donde queremos que Roo genere el c&oacute;digo de los controllers. Por cada entidad se va a generar un controlador con m&eacute;todos CRUD, accesibles mediante URLs al estilo REST. As&iacute;, por ejemplo, haciendo una petici&oacute;n GET a la URL <span class="codefrag">/tareas/</span> obtendr&iacute;amos una lista de tareas, mientras que haciendo una petici&oacute;n POST a la misma URL crear&iacute;amos una tarea nueva, pasando los datos como par&aacute;metros HTTP. Todos estos m&eacute;todos se implementan en el archivo <span class="codefrag">XXXController_Roo_Controller.aj</span>, donde <span class="codefrag">XXX</span> es el nombre de la entidad. Se recomienda consultar la documentaci&oacute;n de Spring Roo para m&aacute;s informaci&oacute;n sobre los m&eacute;todos generados.</p>
<div class="frame warning">
<div class="label">Cuidado con los plurales</div>
<div class="content">Roo usa autom&aacute;ticamente el plural del nombre de la entidad para las URL asociadas. Por desgracia, usa las reglas del idioma ingl&eacute;s para generar los plurales. Eso ha funcionado bien con la entidad Tarea, pero Proyecto se asociar&aacute; a "proyectoes" y no a "proyectos". Para solucionarlo, hay que editar la clase ProyectoController y cambiar la anotaci&oacute;n <span class="codefrag">@RequestMapping</span> y el valor del atributo path de la anotaci&oacute;n <span class="codefrag">@RooWebScaffold</span>.</div>
</div>
<p>Existe la posibilidad de hacer el <em>scaffolding</em> solo para una determinada entidad, con el comando <span class="codefrag">web mvc scaffold</span>. Primero tenemos que poner el foco en la entidad: </p>
<pre class="brush:shell;">
roo&gt; focus es.ua.jtech.domain.Proyecto
~.domain.Proyecto roo&gt; web mvc scaffold --class es.ua.jtech.web.ProyectoController
</pre>
<p>Si no quisi&eacute;ramos generar alg&uacute;n m&eacute;todo CRUD podemos especificarlo con el par&aacute;metro <span class="codefrag">--disallowedOperations</span> y una lista de las operaciones separadas por comas (de entre 'create', 'update' o 'delete', por ejemplo <span class="codefrag">--disallowedOperations update,delete</span>. Tambi&eacute;n podemos modificar la anotaci&oacute;n <span class="codefrag">@RooWebScaffold</span> que Roo coloca en la clase controller, a&ntilde;adiendo como atributo nombre_operacion=false, por ejemplo: </p>
<pre class="brush:java;highlight:[2]">
@RooWebScaffold(path = "proyecto", formBackingObject = Proyecto.class, 
                update = false, delete = false)
@RequestMapping("/proyectos")
@Controller
public class ProyectoController {}
</pre>
<p>El <em>scaffolding</em> es &uacute;til, pero hay muchos casos en los que queremos implementar operaciones distintas del simple CRUD. Para no tener que empezar a implementar el controlador desde cero, Roo nos ofrece la posibilidad de generar solo el esqueleto del controlador, con el comando "web mvc controller". Esto no solo genera el c&oacute;digo (casi vac&iacute;o) del controlador. Adem&aacute;s, crea una p&aacute;gina JSP asociada e incluye un enlace al controlador en el men&uacute; principal.</p>
<a name="N102F6"></a><a name="Clientes+REST"></a>
<h3 class="underlined_5">Clientes REST</h3>
<p>Podemos serializar autom&aacute;ticamente las entidades en JSON, lo que nos ser&aacute; &uacute;til para los clientes REST. Para ello usaremos la secuencia de comandos:</p>
<pre class="brush:shell;">
 roo&gt; json all #da soporte JSON a todas las entidades
 roo&gt; web json setup #solo necesario si no hemos hecho ya web mvc setup
 roo&gt; web mvc json all #genera los controllers CRUD para json
 </pre>
<p>El soporte para la serializaci&oacute;n JSON lo ofrece la librer&iacute;a <em>open source</em> <a href="http://flexjson.sourceforge.net">flexjson</a>, por lo que para averiguar c&oacute;mo se configura el JSON generado tendremos que acudir a su documentaci&oacute;n.</p>
<p>Al igual que con otros comandos, lo que hacen los de json b&aacute;sicamente es incluir un par de anotaciones en las ciertas clases. Estas anotaciones le indican a Roo que debe crear o introducir ciertas funcionalidades en los ITD autom&aacute;ticamente. En concreto, "json all" lo que hace es anotar todas las entidades con <span class="codefrag">@RooJson</span>, y "web mvc json all" anota los controladores con <span class="codefrag">@RooWebJson</span>
</p>
<a name="N10317"></a><a name="Finders+en+la+web"></a>
<h3 class="underlined_5">Finders en la web</h3>
<p>Podemos dar acceso en la capa web a los finders que hayamos creado en las entidades. Autom&aacute;ticamente Roo incluir&aacute; un m&eacute;todo en el controlador para llamar al finder, lo mapear&aacute; con una URL determinada e incluso crear&aacute; un formulario web para introducir los datos y un enlace en la p&aacute;gina principal de la aplicaci&oacute;n. El comando para dar acceso a todos los finders es "web mvc finder all", que introduce en los controladores la anotaci&oacute;n <span class="codefrag">@RooWebFinder</span>.</p>
</div>  


<a name="N10325"></a><a name="Refactorizaci%C3%B3n+del+c%C3%B3digo+Roo"></a>
<h2 class="underlined_10">Refactorizaci&oacute;n del c&oacute;digo Roo</h2>
<div class="section">
<p>En muchos casos, nos servir&aacute; aproximadamente el c&oacute;digo generado por Roo pero querremos modificarlo para que se adapte a nuestras necesidades. Por ejemplo, al serializar los objetos en JSON, las relaciones uno a muchos no se serializan por defecto. Para cambiarlo tendr&iacute;amos que cambiar c&oacute;digo en un .aj. Pero ya hemos dicho que los .aj no se deber&iacute;an editar, ya que Roo los gestiona y actualiza autom&aacute;ticamente y podr&iacute;a deshacer nuestros cambios de buenas a primeras. La soluci&oacute;n es refactorizar el c&oacute;digo para llevarnos el m&eacute;todo que nos interese desde el .aj hasta el correspondiente .java. A esto se le denomina <em>push-in refactoring</em>.</p>
<p>El <em>push-in refactoring</em> est&aacute; implementado en el IDE STS. Desde el package explorer seleccionamos el .aj del que nos interesa extraer el m&eacute;todo, desplegamos sus m&eacute;todos y pulsamos sobre el m&eacute;todo objetivo con el bot&oacute;n derecho. Para refactorizar seleccionamos Refactor &gt; Push In. Luego modificar&iacute;amos manualmente el c&oacute;digo, ya en el .java, con la seguridad de que Roo no va a "meter las narices" en los cambios que hagamos.</p>
<p>
<img alt="Push-in refactoring en STS" content-width="16cm" src="imagenes/sesion08/push_in.jpg">
</p>
<p>En el ejemplo que hab&iacute;amos comentado, para serializar en JSON todas las tareas de un proyecto, har&iacute;amos un push-in del m&eacute;todo toJson() del Proyecto_Roo_Json.aj. El c&oacute;digo acabar&iacute;a en Proyecto.java donde podr&iacute;amos modificarlo, con la ayuda de la documentaci&oacute;n de FlexJSON, para que se incluya el campo "tareas" en la serializaci&oacute;n: </p>
<pre class="brush:java;">
public String toJson() {
        return new JSONSerializer().include("tareas").serialize(this);
}
</pre>
<p>Aunque es de uso mucho menos habitual, la refactorizaci&oacute;n contraria al "push in" es "pull out" y consiste en que trasladamos c&oacute;digo de una clase Java a un .aj. Tambi&eacute;n est&aacute; implementada en STS.</p>
<p>
<strong>Eliminar Roo de nuestro proyecto</strong> se podr&iacute;a ver como "el push-in definitivo", o sea, trasladar el c&oacute;digo de todos los .aj a las clases Java correspondientes. Adem&aacute;s, eliminar&iacute;amos las anotaciones y algunas dependencias ya innecesarias del pom.xml. Seguir&iacute;amos estos pasos:</p>
<ol>

<li>Hacer el push-in de todos los .aj: en STS seleccionar&iacute;amos el proyecto y con el bot&oacute;n derecho, como antes, Refactor &gt; Push In</li>

<li>Eliminar todas las anotaciones de Roo: es relativamente sencillo, ya que todas comienzan por <span class="codefrag">@Roo</span>.</li>

<li>Finalmente, eliminamos la dependencia de &lt;artifactId&gt;org.springframework.roo.annotations&lt;/artifactId&gt; del pom.xml</li>

</ol>
</div>	


<p class="pageBreakAfter"> 
</p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Depto. Ciencia de la computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
