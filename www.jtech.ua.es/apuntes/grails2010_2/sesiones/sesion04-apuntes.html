<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Librer&iacute;as propias de Groovy</title>
<link type="text/css" href="../skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="../skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="../skin/highlight/shCore.js" type="text/javascript"></script><script src="../skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="../skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="../skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="../skin/print.css" rel="stylesheet">
<link type="text/css" href="../skin/profile.css" rel="stylesheet">
<script src="../skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="../skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="../skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="../index.html">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="jtech" src="../images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Groovy&amp;Grails: desarrollo r&aacute;pido de aplicaciones" src="../images/baner_j2ee_der.gif" title="Groovy&amp;Grails: desarrollo r&aacute;pido de aplicaciones"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">Home</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Sesiones</a>
</li>
<li>
<a class="base-not-selected" href="../ejercicios/index.html">Ejercicios</a>
</li>
<li>
<a class="base-not-selected" href="../bibliografia/index.html">Bibliograf&iacute;a</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', '../skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('../skin/images/chapter_open.gif');">Sesiones</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html" title="Introducci&oacute;n a Groovy">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="El lenguaje Groovy">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html" title="Aspectos avanzados en Groovy">Sesi&oacute;n 3</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 4</div>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html" title="Introducci&oacute;n a Grails">Sesi&oacute;n 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html" title="Construir la interfaz de usuario (I)">Sesi&oacute;n 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html" title="Controladores">Sesi&oacute;n 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html" title="Construir la interfaz de usuario (II)">Sesi&oacute;n 8</a>
</div>
<div class="menuitem">
<a href="sesion09-apuntes.html" title="Dominios y servicios (I)">Sesi&oacute;n 9</a>
</div>
<div class="menuitem">
<a href="sesion10-apuntes.html" title="Dominios y servicios (II)">Sesi&oacute;n 10</a>
</div>
<div class="menuitem">
<a href="sesion11-apuntes.html" title="Seguridad">Sesi&oacute;n 11</a>
</div>
<div class="menuitem">
<a href="sesion12-apuntes.html" title="Despliegue de aplicaciones">Sesi&oacute;n 12</a>
</div>
<div class="menuitem">
<a href="sesion13-apuntes.html" title="Web 2.0">Sesi&oacute;n 13</a>
</div>
<div class="menuitem">
<a href="sesion14-apuntes.html" title="AJAX">Sesi&oacute;n 14</a>
</div>
<div class="menuitem">
<a href="sesion15-apuntes.html" title="Dos horas para crear twitter">Sesi&oacute;n 15</a>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="../skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion04-apuntes.pdf"><img alt="PDF -icon" src="../skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Librer&iacute;as propias de Groovy</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Groovy+Builders">Groovy Builders</a>
<ul class="minitoc">
<li>
<a href="#MarkupBuilder">MarkupBuilder</a>
</li>
<li>
<a href="#AntBuilder">AntBuilder</a>
</li>
</ul>
</li>
<li>
<a href="#DSL%27s">DSL's</a>
</li>
<li>
<a href="#Tratamiento+de+archivos+XML">Tratamiento de archivos XML</a>
</li>
<li>
<a href="#Bases+de+datos">Bases de datos</a>
<ul class="minitoc">
<li>
<a href="#Trabajar+directamente+con+SQL">Trabajar directamente con SQL</a>
</li>
<li>
<a href="#Trabajar+con+DataSets">Trabajar con DataSets</a>
</li>
<li>
<a href="#GORM+%28Groovy+ORM%29">GORM (Groovy ORM)</a>
</li>
</ul>
</li>
</ul>
</div>
         

<p>
	En esta sesi&oacute;n, vamos a introducir diferentes librer&iacute;as propias de Groovy, para la realizaci&oacute;n de diversas tareas. En primer lugar veremos los <em>GroovyBuilders</em>, los cuales nos facilitan el trabajo en varios aspectos tales como la escritura de archivos XML y HTML o la automatizaci&oacute;n de tareas con <em>Ant</em>. Posteriormente definiremos las caracter&iacute;sticas que hacen de Groovy un lenguaje perfecto para escribir nuestros propios <em>DSL's (Lenguajes de Especificaci&oacute;n de Dominio)</em>. Por &uacute;ltimo, veremos el modelo de abstracci&oacute;n de base de datos que presenta Groovy y las diferentes formas de acceso a las mismas.
</p>


<a name="N10018"></a><a name="Groovy+Builders"></a>
<h2 class="underlined_10">Groovy Builders</h2>
<div class="section">
<p>
	Los <em>Builders</em> en Groovy se utilizan para hacer que determinadas tareas complejas se conviertan en un juego de ni&ntilde;os. Con ellos veremos que la construcci&oacute;n de archivos XML, la automatizaci&oacute;n de tareas con Ant o el dise&ntilde;o de interfaces gr&aacute;ficas se facilita much&iacute;simo. Empecemos escribiendo archivos XML con los <em>builders</em> que Groovy pone a nuestra disposici&oacute;n.
</p>
<a name="N10027"></a><a name="MarkupBuilder"></a>
<h3 class="underlined_5">MarkupBuilder</h3>
<p>
		Los archivos XML son un tipo de archivo ampliamente extendido para el intercambio de informaci&oacute;n entre aplicaciones, as&iacute; que Groovy quiere ayudarnos en esa labor, tratando que escribamos el c&oacute;digo para construir esos archivos XML de la forma m&aacute;s sencilla y clara posible y el <em>builder</em> encargado de esa labor es <em>MarkupBuilder</em>, el cual nos ayudar&aacute; a escribir tanto archivos XML como HTML.
	</p>
<p>
	El ejemplo que vamos a ver consiste en crear un archivo XML referido a facturas de una empresa. Cada factura contendr&aacute; una serie de &iacute;tems, cada uno con un producto.
	</p>
<pre class="code">writer = new StringWriter()
builder = new groovy.xml.MarkupBuilder(writer)
facturas = builder.facturas {
    for (dia in 1..3) {
        factura(fecha: new Date(106,0,dia)) {
            item(id:dia){
                producto(nombre: 'Teclado', euros:876)
            }
        }
    }
}

result = writer.toString().replaceAll("\r","")</pre>
<p>
		Lo que producir&iacute;a el siguiente archivo XML.
	</p>
<pre class="code">&lt;facturas&gt;
	&lt;factura fecha='Sun Jan 01 00:00:00 CET 2006'&gt;
		&lt;item id='1'&gt;
			&lt;producto nombre='Teclado' euros='876' /&gt;
		&lt;/item&gt;
	&lt;/factura&gt;
	&lt;factura fecha='Mon Jan 02 00:00:00 CET 2006'&gt;
		&lt;item id='2'&gt;
			&lt;producto nombre='Teclado' euros='876' /&gt;
		&lt;/item&gt;
	&lt;/factura&gt;
	&lt;factura fecha='Tue Jan 03 00:00:00 CET 2006'&gt;
		&lt;item id='3'&gt;
			&lt;producto nombre='Teclado' euros='876' /&gt;
		&lt;/item&gt;
	&lt;/factura&gt;
&lt;/facturas&gt;</pre>
<p>
		Se puede comprobar que la limpieza del c&oacute;digo utilizado para generar el archivo XML es incre&iacute;ble y pr&aacute;cticamente, el c&oacute;digo sigue el mismo tabulado que el posterior archivo XML, con lo que la lectura del c&oacute;digo por terceras personas se facilita much&iacute;simo.
	</p>
<p>
		Pero <em>MarkupBuilder</em> no s&oacute;lo nos va a servir para generar archivos XML, sino tambi&eacute;n archivos HTML. No es raro, puesto que HTML es en el fondo XML. Veamos como construir el mismo ejemplo anterior para que se vea como una p&aacute;gina web. Un ejemplo de p&aacute;gina web podr&iacute;a ser el siguiente:
	</p>
<pre class="code">&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;Facturas&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Facturas&lt;/h1&gt;
		&lt;ul&gt;
			&lt;li&gt;Sun Jan 01 00:00:00 CET 2006&lt;/li&gt;
			&lt;ul&gt;
				&lt;li&gt;1.- Teclado =&gt; 876euros&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/ul&gt;
		&lt;ul&gt;
			&lt;li&gt;Sun Jan 02 00:00:00 CET 2006&lt;/li&gt;
			&lt;ul&gt;
				&lt;li&gt;2.- Teclado =&gt; 876euros&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/ul&gt;
		&lt;ul&gt;
			&lt;li&gt;Sun Jan 03 00:00:00 CET 2006&lt;/li&gt;
			&lt;ul&gt;
				&lt;li&gt;3.- Teclado =&gt; 876euros&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/ul&gt;
	&lt;/body&gt;
&lt;/html&gt;</pre>
<p>
		Que producir&iacute;a algo as&iacute;:<br>
		
<img alt="Facturas" src="../images/sesion4/facturashtml.jpg">
	</p>
<p>
		Este ejemplo de HTML se podr&iacute;a construir con el siguiente c&oacute;digo, haciendo uso de MarkupBuilder.
	</p>
<pre class="code">def writer = new StringWriter()
def builder = new groovy.xml.MarkupBuilder()

builder.html {
    head {
        title 'Facturas'
    }

    body {
        h1 'Facturas'

        for (dia in 1..3){
            ul{
                li new Date(106,0,dia).toString()
                ul {
                    li "$dia.- Teclado =&gt; 876euros"
                }
            }        
        }     
    }
}</pre>
<p>
		El c&oacute;digo HTML generado por MarkupBuilder ser&aacute; compatible con los est&aacute;ndares y no tendremos incluso que preocuparnos por la conversi&oacute;n de determinados caracteres como el s&iacute;mbolo &lt; (&amp;lt;), ya que &eacute;l mismo ser&aacute; el encargado de realizar dicha conversi&oacute;n.
	</p>
<a name="N10065"></a><a name="AntBuilder"></a>
<h3 class="underlined_5">AntBuilder</h3>
<p>
		
<em>Ant</em> es una herramienta ampliamente utilizada para la automatizaci&oacute;n de tareas, tales como la manipulaci&oacute;n del sistema de ficheros, compilaci&oacute;n de ficheros fuente, ejecuci&oacute;n de pruebas, etc. El uso de Ant con las librer&iacute;as de Java en ocasiones se hace muy pesado, pero en Groovy disponemos del builder <em>AntBuilder</em> para hacer de esta tarea algo trivial.
	</p>
<p>
		El ejemplo que se muestra a continuaci&oacute;n, es un t&iacute;pico fichero de Ant, con el que se eliminar&aacute;n todos los archivos de un directorio destino y posteriormente se copiar&aacute;n todos los archivos <em>.doc</em> de un determinado directorio, obviando los archivos temporales (~*).
	</p>
<pre class="code">&lt;project name="prepararDirectorioLibros" default="copy"&gt;
	&lt;property name="destino.dir" value="destino"/&gt;
	&lt;property name="capitulos.dir" value="capitulos"/&gt;

	&lt;target name="copy"&gt;
		&lt;delete dir="${destino.dir}" /&gt;
		&lt;copy todir="${destino.dir}"&gt;
			&lt;fileset dir="${capitulos.dir}"
				includes="*.doc"
				excludes="~*" /&gt;
		&lt;/copy&gt;
	&lt;/target&gt;
&lt;/project&gt;</pre>
<p>
		En Groovy ya no ser&aacute; necesario utilizar Ant ni su sintaxis tipo XML para este tipo de tareas, ya que podemos utilizar <em>AntBuilder</em> para estos quehaceres. El siguiente ejemplo muestra como ser&iacute;a el script en Groovy con la misma funcionalidad que el ejemplo anterior.
	</p>
<pre class="code">DESTINO_DIR = 'destino'
CAPITULOS_DIR = 'capitulos'
ant = new AntBuilder()

ant.delete(dir:DESTINO_DIR)
ant.copy(todir:DESTINO_DIR){
	fileset(dir:CAPITULOS_DIR, includes:'*.doc', excludes:'~*')
}</pre>
<p>
		Para convertir un archivo en formato Ant en uno que funcione en Groovy, debemos seguir las siguientes reglas:
	</p>
<ul>
		
<li>Las <em>tareas</em> en Ant se corresponden con los nombres de los m&eacute;todos en <em>AntBuilder</em>
</li>
		
<li>Los <em>atributos</em> de Ant se pasan en forma de mapa a los m&eacute;todos de <em>AntBuilder</em>
</li>
		
<li>En aquellos lugares donde con Ant era obligatorio utilizar cadenas de texto para escribir otros tipos de datos (valor:"1", analizado:"true"), con <em>AntBuilder</em> se pueden utilizar sus tipos de datos correspondientes (valor:1, analizado:true).</li>
	
</ul>
</div>


<a name="N100A6"></a><a name="DSL%27s"></a>
<h2 class="underlined_10">DSL's</h2>
<div class="section">
<p>
	Las siglas de DSL son el acr&oacute;nimo de <em>Domain Specific Language</em> que traducido significa <em>Lenguaje espec&iacute;fico de Dominio</em>. Un DSL es un <em>lenguaje de programaci&oacute;n</em> reducido que permite representar el conocimiento de un campo espec&iacute;fico. Imaginemos una aplicaci&oacute;n que se encargue de la toma de decisiones en el entorno financiero. Para realizar la programaci&oacute;n en Java o Groovy, quien se encargue de esta programaci&oacute;n deber&iacute;a tener los conocimientos necesarios del sistema financiero as&iacute; como del lenguaje de programaci&oacute;n utilizado. Utilizando un DSL nos ahorraremos las reglas espec&iacute;ficas del lenguaje de programaci&oacute;n, centrando nuestros objetivos en la especificaci&oacute;n de las reglas financieras necesarias para el correcto funcionamiento del sistema.
</p>
<p>
	Se dice de Groovy que es un buen lenguaje para escribir DSLs. &iquest;Por qu&eacute;? Pues simplemente porque es un lenguaje din&aacute;mico que nos proporciona mucha libertad a la hora de crear estructuras necesarias en un contexto particular. Las caracter&iacute;sticas de Groovy que lo hacen id&oacute;neo para escribir DSLs son:
</p>
<ul>
	
<li>Los <em>Builders</em> nos permiten crear estructuras en forma de &aacute;rbol estructurado</li>
	
<li>Se pueden a&ntilde;adir nuevos m&eacute;todos y propiedades a trav&eacute;s de <em>categor&iacute;as</em> y <em>metaclases</em>. Incluso se puede hacer esto con los n&uacute;meros para especificar cosas como <em>4.veces</em> o <em>24.horas</em>
</li>
	
<li>La mayor&iacute;a de los operadores se pueden sobrecargar para poder hacer cosas como <span class="codefrag">totalMinutos = 4.dias + 12.horas</span>
</li>
	
<li>Utilizar un mapa como par&aacute;metro en un m&eacute;todo es muy intuitivo, como por ejemplo <span class="codefrag">mover(x:500.metros, y:2:kilometros)</span>
</li>
	
<li>Tambi&eacute;n podemos crear nuevas estructuras de control utilizando los closures, como por ejemplo <span class="codefrag">siFaltaMenosDeUnDia{...}</span>
</li>

</ul>
<p>
	Un ejemplo de DSL puede ser <em>GORM</em>, del que hablaremos posteriormente. GORM es el framework de persistencia utilizando en <em>Grails</em>. Basado en <em>Hibernate</em>, podemos utilizar GORM sin haber visto en nuestra vida nada sobre Hibernate, simplemente conociendo el modelo de datos. Por ejemplo, imaginemos que tenemos una clase <em>Persona</em> mapeada contra una tabla de la base de datos. Gracias a GORM, podr&iacute;amos acceder a los datos de la siguiente forma:
</p>
<pre class="code">class Persona{
	Date fechaNacimiento
	String nombre
	String apellidos
}	

//Para acceder a los datos de las Personas con GORM se har&iacute;a as&iacute;
def lista1 = Persona.findByNombre("Manuel")
def lista2 = Persona.findByNombreNotNull()
def lista3 = Persona.findByNombreLike("Ma%")
def lista4 = Persona.findByFechaNacimientoBetween(fecha1,fecha2)
def lista5 = Persona.findByNombreLikeOrApellidoLike("M%", "L%")</pre>
<p>
	De esta forma el programador no necesita conocer a fondo la sintaxis de SQL para generar sentencias y puede centrarse en desarrollar la l&oacute;gica de negocio de la aplicaci&oacute;n.
</p>
<p>
	Pero para ver una utilidad de lo que son los DSLs, vamos a desarrollar un ejemplo que permite la conversi&oacute;n entre unidades de distancia sin problemas. De esta forma, cualquier persona sin conocimientos de Groovy, podr&iacute;a escribir unas l&iacute;neas de c&oacute;digo sin demasiado esfuerzo. 
</p>
<p>
	La idea del ejemplo, es que se puedan realizar operaciones entre variables que contienen distancias medidas en diferentes unidades (metros, kil&oacute;metros, cent&iacute;metros, etc). Para ello, en primer lugar vamos a crear la clase <em>Distancia</em> y vamos a sobrecargar los operadores <span class="codefrag">+</span> y <span class="codefrag">-</span>, que como vimos en la sesi&oacute;n 2, se referir&aacute; a sobrecargar realmente los m&eacute;todos <span class="codefrag">plus()</span> y <span class="codefrag">minus()</span>.
</p>
<pre class="code">class Distancia implements Comparable {
	BigDecimal longitud
	Unidad unidad

	Distancia plus(Distancia operando) {
		def nuevaLongitud = this.longitud + Unidad.convertirUnidad(operando, this.unidad)
		new Distancia(longitud : nuevaLongitud, unidad : this.unidad)
	}

	Distancia minus(Distancia operando) {
		def nuevaLongitud = this.longitud - Unidad.convertirUnidad(operando, this.unidad)
		new Distancia(longitud : nuevaLongitud, unidad : this.unidad)
	}

	int compareTo(otro) {
		if(this.unidad == otro.unidad)
			return this.longitud &lt;=&gt; otro.longitud
		return this.longitud &lt;=&gt; Unidad.convertirUnidad(otro, this.unidad)
	}

	String toString() {
		"$longitud $unidad.nombre"
	}
}</pre>
<p>
	La clase tambi&eacute;n debe sobrecargar el m&eacute;todo <span class="codefrag">compareTo()</span> para comprobar que no s&oacute;lo la <em>longitud</em> es la misma, sino tambi&eacute;n la <em>Unidad</em>.
</p>
<p>
	El siguiente paso consistir&aacute; en crear la clase <em>Unidad</em>. Esta clase ser&aacute; la encargada de convertir las unidades para que puedan ser operadas entre si. La clave de esta clase es la tabla que define la relaci&oacute;n entre todas las unidades.
</p>
<pre class="code">class Unidad {
	def ratio
	String nombre

	static def convertirUnidad(Distancia d, Unidad nuevaUnidad) {
		def factor = ratioTabla[d.unidad.ratio][nuevaUnidad.ratio]
		if(factor)
		    return d.longitud * factor
		else
		    return d.longitud / ratioTabla[nuevaUnidad.ratio][d.unidad.ratio]
	}

	static ratioTabla = [
		//        mm,         cm,          m,        km,    y, mi
		[          1,          0,          0,         0,    0, 0 ],    // mm
		[         10,          1,          0,         0,    0, 0 ],    // cm
		[        1e3,        1e2,          1,         0,    0, 0 ],    //  m
		[        1e6,        1e5,        1e3,         1,    0, 0 ],    // km
		[      914.4,      91.44,     0.9144, 0.9144e-3,    1, 0 ],    // yd
		[ 1.609344e6, 1.609344e5, 1.609344e3,  1.609344, 1760, 1 ],    // mi
	]

	public static final mm = new Unidad(ratio : 0, nombre : "mil&iacute;metros")
	public static final cm = new Unidad(ratio : 1, nombre : "cent&iacute;metros")
	public static final  m = new Unidad(ratio : 2, nombre : "metros")
	public static final km = new Unidad(ratio : 3, nombre : "kilometros")
	public static final yd = new Unidad(ratio : 4, nombre : "yarda")
	public static final mi = new Unidad(ratio : 5, nombre : "milla(s)")
}</pre>
<p>
	Por &uacute;ltimo, para crear el DSL necesitamos crear una categor&iacute;a que implemente los m&eacute;todos <span class="codefrag">get()</span> para los tipos de datos <span class="codefrag">Number</span> y <span class="codefrag">Distancia</span>. Al definir el m&eacute;todo <span class="codefrag">get()</span> por el tipo de dato <span class="codefrag">Number</span> permitiremos utilizar la notaci&oacute;n <span class="codefrag">4.3.mi</span>, mientras que al hacer lo propio con el tipo de dato <span class="codefrag">Distancia</span> podremos utilizar la notaci&oacute;n <span class="codefrag">4.3.mi.km</span> para hacer una conversi&oacute;n al vuelo de millas a kil&oacute;metros. La nueva clase quedar&iacute;a as&iacute;:
</p>
<pre class="code">class DistanciaCategoria {
	static Distancia getMm(Number n) { 
		new Distancia(longitud : n, unidad : Unidad.mm) 
	}

	static Distancia getMm(Distancia d) {
		new Distancia(longitud : Unidad.convertirUnidad(d, Unidad.mm), unidad : Unidad.mm)
	}
	static Distancia getCm(Number n) { 
		new Distancia(longitud : n, unidad : Unidad.cm) 
	}

	static Distancia getCm(Distancia d) {
		new Distancia(longitud : Unidad.convertirUnidad(d, Unidad.cm), unidad : Unidad.cm)
	}
	static Distancia getM(Number n) { 
		new Distancia(longitud : n, unidad : Unidad.m) 
	}

	static Distancia getM(Distancia d) {
		new Distancia(longitud : Unidad.convertirUnidad(d, Unidad.m), unidad : Unidad.m)
	}
	static Distancia getKm(Number n) { 
		new Distancia(longitud : n, unidad : Unidad.km) 
	}

	static Distancia getKm(Distancia d) {
		new Distancia(longitud : Unidad.convertirUnidad(d, Unidad.km), unidad : Unidad.km)
	}
	static Distancia getYd(Number n) { 
		new Distancia(longitud : n, unidad : Unidad.yd) 
	}

	static Distancia getYd(Distancia d) {
		new Distancia(longitud : Unidad.convertirUnidad(d, Unidad.yd), unidad : Unidad.yd)
	}
	static Distancia getMi(Number n) { 
		new Distancia(longitud : n, unidad : Unidad.mi) 
	}

	static Distancia getMi(Distancia d) {
		new Distancia(longitud : Unidad.convertirUnidad(d, Unidad.mi), unidad : Unidad.mi)
	}	
}</pre>
<p>
	Ya s&oacute;lo nos queda probarlo todo. Vamos a intentar hacer una serie de operaciones entre diferentes unidades de medida de distancia.
</p>
<pre class="code">use(DistanciaCategoria.class) {
	def d1 = 1.m
	def d2 = 1.yd
	def d3 = 1760.yd
	def d4 = 100.cm
	println d1 + 1.yd
	println 1.yd + 1.mi
	println 1.m - 1.yd
	println d2.m
	println d3.mi
	println d4.m
	println 1000.yd.km
	println 1000.yd
}</pre>
</div>


<a name="N1014D"></a><a name="Tratamiento+de+archivos+XML"></a>
<h2 class="underlined_10">Tratamiento de archivos XML</h2>
<div class="section">
<p>
	La lectura de los archivos XML es una tarea habitual en cualquier tipo de proyecto software y que en ocasiones se vuelve muy compleja. Groovy dispone de tres m&eacute;todos diferentes para la lectura de archivos XML:
</p>
<ul>
	
<li>Mediante las rutas del DOM y las mejoras introducidas en las clases <em>XmlParser</em> y <em>XmlSlurper</em>
</li>
	
<li>El analizador basado en eventos <em>SAX</em>
</li>
	
<li>Y el m&eacute;todo analizador <em>StAX</em>
</li>

</ul>
<p>
	El m&eacute;todo que vamos a ver en esta sesi&oacute;n ser&aacute; utilizando las rutas del DOM y las clases XmlParser y XmlSlurper.
</p>
<p>
	En primer lugar, vamos a exponer un ejemplo de un archivo XML con el que trabajaremos en la lectura del mismo. El ejemplo supone establecer un plan de horas de estudio semanales con un m&aacute;ximo de horas por semana y una serie de tareas en cada semana, con el control del n&uacute;mero de horas dedicadas al estudio para cada tarea.
</p>
<pre class="code">&lt;plan&gt;
	&lt;semana maximo="10"&gt;
		&lt;tarea prevision="3" hechas="3" titulo="Aserciones"/&gt;
		&lt;tarea prevision="4" hechas="4" titulo="GroovyBeans"/&gt;
		&lt;tarea prevision="2" hechas="1" titulo="Librer&iacute;a GString"/&gt;
	&lt;/semana&gt;
	&lt;semana maximo="10"&gt;
		&lt;tarea prevision="3" hechas="0" titulo="Groovy Builders"/&gt;
		&lt;tarea prevision="2" hechas="0" titulo="GORM"/&gt;
		&lt;tarea prevision="2" hechas="0" titulo="DSLs"/&gt;
	&lt;/semana&gt;
&lt;/plan&gt;</pre>
<p>
	A partir de este archivo xml, desarrollaremos un ejemplo completo en Groovy para proceder a su lectura. Para leer un archivo xml en Groovy,podemos utilizar una clase llamada <span class="codefrag">XmlParser</span>. Con esta clase, podemos acceder a los nodos del archivo xml como si estuvi&eacute;semos accediendo a un array, mientras que los atributos estar&aacute;n accesibles por medio del operador <em>@</em>, tal y como podemos comprobar en el siguiente ejemplo.
</p>
<pre class="code">def plan = new XmlParser().parse(new File('datos/plan.xml'))

assert 'plan' == plan.name()
assert 'semana' == plan.semana[0].name()
assert 'tarea' == plan.semana[0].tarea[0].name()
assert 'GroovyBeans' == plan.semana[0].tarea[1].@titulo</pre>
<p>
	Para definir el analizador, ni siquiera es necesario importar ning&uacute;n paquete, puesto que la clase <span class="codefrag">XmlParser</span> forma parte del paquete <span class="codefrag">groovy.util</span>, uno de los que Groovy importa autom&aacute;ticamente. El analizador devuelve un objeto del tipo <span class="codefrag">groovy.util.Node</span>. Pero adem&aacute;s de la clase <span class="codefrag">XmlParser</span>, Groovy dispone de la clase <span class="codefrag">XmlSlurper</span> que a&ntilde;ade nuevas funcionalidades. Ambas clases comparten el m&eacute;todo <span class="codefrag">parse()</span>, el cual puede recibir diversos tipos de objetos.
</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
	
<tr>
		
<th colspan="1" rowspan="1">M&eacute;todo</th>
		<th colspan="1" rowspan="1">Comentario</th>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">parse(InputSource is)</span></td>
		<td colspan="1" rowspan="1">Lee un objeto de la clase <span class="codefrag">org.xml.sax.InputSource</span></td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">parse(File file)</span></td>
		<td colspan="1" rowspan="1">Lee un objeto de la clase <span class="codefrag">java.io.File</span></td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">parse(InputStream is)</span></td>
		<td colspan="1" rowspan="1">Lee un objeto de la clase <span class="codefrag">java.io.InputStream</span></td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">parse(Reader r)</span></td>
		<td colspan="1" rowspan="1">Lee un objeto de la clase <span class="codefrag">java.io.Reader</span></td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">parse(String uri)</span></td>
		<td colspan="1" rowspan="1">Lee el contenido apuntado por la direcci&oacute;n <em>uri</em></td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">parseText(String text)</span></td>
		<td colspan="1" rowspan="1">Utiliza el par&aacute;metro <em>text</em> como entrada</td>
	
</tr>

</table>
<p>
	La diferencia de estos m&eacute;todos en ambas clases es que <span class="codefrag">XmlParser</span> devuelve objetos del tipo <span class="codefrag">groovy.util.Node</span> mientras que <span class="codefrag">XmlSlurper</span> lo hace del tipo <span class="codefrag">GPathResult</span>. La siguiente tabla muestra un listado con los m&eacute;todos m&aacute;s habituales en ambas clases.
</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
	
<tr>
		
<th colspan="1" rowspan="1">M&eacute;todo XmlParser</th>
		<th colspan="1" rowspan="1">M&eacute;todo XmlSlurper</th>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">Object name()</td>
		<td colspan="1" rowspan="1">String name()</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">String text()</td>
		<td colspan="1" rowspan="1">String text()</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">String toString()</td>
		<td colspan="1" rowspan="1">String toString()</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">Node parent()</td>
		<td colspan="1" rowspan="1">GPathResult parent()</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">List children()</td>
		<td colspan="1" rowspan="1">GPathResult children()</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">Map attributes()</td>
		<td colspan="1" rowspan="1">Map attributes()</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">Iterator iterator()</td>
		<td colspan="1" rowspan="1">Iterator iterator()</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">List depthFirst()</td>
		<td colspan="1" rowspan="1">Iterator depthFirst()</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">List breadthFirst()</td>
		<td colspan="1" rowspan="1">Iterator breadthFirst()</td>
	
</tr>

</table>
<p>
	En ambas clases (XmlParser y XmlSlurper), el acceso a los elementos hijo y sus atributos se hace como si fueran propiedades del objeto, tal y como se muestra en la siguiente tabla.
</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
	
<tr>
		
<th colspan="1" rowspan="1">Node (XmlParser)</th>
		<th colspan="1" rowspan="1">GPathResult (XmlSlurper)</th>
		<th colspan="1" rowspan="1">Significado</th>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">['nombreElemento']<br>.nombreElemento</td>
		<td colspan="1" rowspan="1">['nombreElemento']<br>.nombreElemento</td>
		<td colspan="1" rowspan="1">Todos los elementos con este nombre</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">[indice]</td>
		<td colspan="1" rowspan="1">[indice]</td>
		<td colspan="1" rowspan="1">Elemento hijo que coincida con el &iacute;ndice</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">['@nombreAtributo']<br>.'@nombreAtributo'</td>
		<td colspan="1" rowspan="1">['@nombreAtributo']<br>.'@nombreAtributo'<br>.@nombreAtributo</td>
		<td colspan="1" rowspan="1">El valor del atributo con este nombre</td>
	
</tr>

</table>
<p>
	El siguiente fragmento de c&oacute;digo muestra diferentes ejemplos de acceso con ambas clases sobre el archivo xml utilizado anteriormente. Como puedes observar, no hay diferencias en utilizar ambas clases.
</p>
<pre class="code">def node = new XmlParser().parse(new File('datos/plan.xml'))
def gpath = new XmlSlurper().parse(new File('datos/plan.xml'))

assert 'plan' == node.name()
assert 'plan' == gpath.name()

assert 2 == node.children().size()
assert 2 == gpath.children().size()

assert 6 == node.semana.tarea.size()
assert 6 == gpath.semana.tarea.size()

assert 8 == node.semana.tarea.'@hechas'*.toInteger().sum()

assert gpath.semana[1].tarea.every{ it.'@hechas' == '0'}</pre>
<p>
	Pero, &iquest;para que queremos dos clases que hacen lo mismo y funcionan exactamente igual? En realidad, ambas clases no funcionan igual y esas diferencias se ven sobre todo cuando hablamos de tareas m&aacute;s avanzadas que los simples ejemplos sobre los que hemos trabajado. Si pudi&eacute;ramos medir el rendimiento de ambas clases sobre el ejemplo anterior, ver&iacute;amos que obtendr&iacute;amos resultados muy similares. Pero con ejemplos m&aacute;s complejos, la cosa cambia y cambian porque <em>XmlParser</em> necesita almacenar en memoria el contenido del archivo xml mientras que con <em>XmlSlurper</em> el procesamiento de las operaciones no se realiza hasta que no son solicitadas. Por ejemplo, para procesar la sentencia <span class="codefrag">node.semana.tarea.'@hechas'</span> con XmlParser se crean: una lista con las semanas (dos entradas), una lista con las tareas (seis entradas) y una lista de los valores del atributo <em>hechas</em> (seis valores). Sin embargo, con <em>XmlSlurper</em> este consumo extra de memoria no existe.
</p>
</div>


<a name="N1030E"></a><a name="Bases+de+datos"></a>
<h2 class="underlined_10">Bases de datos</h2>
<div class="section">
<p>
	Las bases de datos relacionales se basan en el modelo relacional, que como est&aacute;ndar para realizar todo tipo de operaciones utiliza el lenguaje SQL(<em>Structured Query Language</em>). Muchos lenguajes de programaci&oacute;n (PHP, Python, Ruby, etc) ofrecen un acceso r&aacute;pido e inmediato a las operaciones con la base de datos, mientras que Java utiliza JDBC (Java Database Connectivity), que no suele ser tan sencillo. Por su parte Groovy se basa tambi&eacute;n en JDBC, pero a&ntilde;ade la librer&iacute;a <em>groovy.sql</em> con cuatro clases (<em>Sql</em>, <em>DataSet</em>, <em>GroovyResultSet</em> y <em>GroovyRowResult</em>) que facilitan este acceso.
</p>
<p>
	En esta secci&oacute;n vamos a ver como realizar las operaciones b&aacute;sicas sobre las bases de datos como son el establecimiento de la conexi&oacute;n con la base de datos, la creaci&oacute;n del esquema de las mismas y el trabajo con algunos datos.
</p>
<a name="N1032C"></a><a name="Trabajar+directamente+con+SQL"></a>
<h3 class="underlined_5">Trabajar directamente con SQL</h3>
<p>
		Empezaremos por el establecimiento de la conexi&oacute;n con la base de datos. La instalaci&oacute;n de Groovy no viene con ninguna base de datos, sin embargo, podemos utilizar cualquier sistema de base de datos con su correspondiente controlador JDBC. En esta secci&oacute;n vamos a utilizar HSQLDB (<a class="external" href="http://hsqldb.org">http://hsqldb.org</a>). Su instalaci&oacute;n es tan simple como copiar el correspondiente <em>hsqldb.jar</em> en el classpath. Para hacer esto, simplemente copiamos el archivo hsqldb.jar al directorio <em>lib</em> de la instalaci&oacute;n de Groovy. HSQLDB puede funcionar de tres formas diferentes: como servidor de base de datos, mediante ficheros o de forma no persistente como una base de datos almacenada en memoria. Nosotros utilizaremos esta &uacute;ltima, aunque utilizar cualquier otra, no supondr&iacute;a muchos cambios.
	</p>
<p>
		Para realizar la conexi&oacute;n con la base de datos, necesitamos utilizar un objeto del tipo <em>groovy.sql.Sql</em> y un m&eacute;todo llamado <em>newInstance()</em> indic&aacute;ndole la siguiente informaci&oacute;n de acceso:
	</p>
<ul>
		
<li>URL de la base de datos</li>
		
<li>Usuario de la base de datos</li>
		
<li>Contrase&ntilde;a</li>
		
<li>Controlador. En nuestro caso <em>org.hsqldb.jdbcDriver</em>
</li>
	
</ul>
<p>
		Nosotros vamos a crear una base de datos llamada <em>biblioteca</em>.
	</p>
<pre class="code">import groovy.sql.Sql
db = Sql.newInstance(
    'jdbc:hsqldb:mem:Biblioteca',
    'sa',
    '',
    'org.hsqldb.jdbcDriver')</pre>
<p>
		Ya tenemos creada la base de datos <em>Biblioteca</em> y su referencia a la misma mediante la variable <em>db</em>. A continuaci&oacute;n vamos a crear nuestra primera tabla en la base de datos. Lo haremos con la tabla <em>Escritores</em> que contendr&aacute; un <em>nombre</em>, <em>apellidos</em> y <em>fecha de nacimiento</em>. Tambi&eacute;n crearemos el campo <em>idEscritor</em> que se utilizar&aacute; como clave primaria de la tabla. Para ello utilizaremos el m&eacute;todo <span class="codefrag">execute()</span> al cual le pasaremos la sentencia para crear dicha tabla. Antes de crear la tabla, comprobamos si existe una con el mismo nombre y en caso afirmativo, la eliminamos.
	</p>
<pre class="code">db.execute '''
    DROP TABLE Escritores IF EXISTS;
    CREATE TABLE Escritores (
        idEscritor    INTEGER GENERATED BY DEFAULT as IDENTITY,
        nombre    VARCHAR(128),
        apellidos    VARCHAR (128),
        fechaNacimiento    DATE
    );
	'''</pre>
<p>
		Una vez ya tenemos creada nuestra primera tabla en la base de datos, vamos a ver como introducir nuestros primeros registros. Utilizaremos el mismo m&eacute;todo <span class="codefrag">execute()</span> y le pasaremos las sentencias SQL para la introducci&oacute;n de estos datos.
	</p>
<pre class="code">db.execute '''
    INSERT INTO Escritores (nombre, apellidos, fechaNacimiento)
        VALUES ('Camilo Jos&eacute;', 'Cela Trulock', '1916-05-11');
    INSERT INTO Escritores (nombre, apellidos, fechaNacimiento)
        VALUES ('Miguel', 'de Cervantes Saavedra', '1547-09-29');
    INSERT INTO Escritores (nombre, apellidos, fechaNacimiento)
        VALUES ('Miguel', 'Hern&aacute;ndez Gilabert', '1910-10-30');
    INSERT INTO Escritores (nombre, apellidos, fechaNacimiento)
        VALUES ('Felix', 'Lope de Vega y Carpio', '1562-11-25');
    '''</pre>
<p>
		Esta forma de introducir los datos en la tabla contiene muchos datos duplicados, ya que la parte <span class="codefrag">INSERT INTO Escritores (nombre, apellidos, fechaNacimiento) VALUE</span> siempre se repite sin aportar nada nuevo a la sentencia. Existen otras formas mejores de introducir estos datos, como pueden ser las <span class="codefrag">preparedStatement</span>. El siguiente ejemplo de introducci&oacute;n de datos, utiliza una <span class="codefrag">preparedStatement</span> y como puedes observar, cada car&aacute;cter <span class="codefrag">?</span> de la misma se sustituye por cada uno de los par&aacute;metros pasados a la funci&oacute;n.
	</p>
<pre class="code">String insertaEscritores = '''
    INSERT INTO Escritores (nombre, apellidos, fechaNacimiento)
        VALUES (?,?,?);
    '''
db.execute insertaEscritores, ['Camilo Jos&eacute;', 'Cela Trulock', '1916-05-11']
db.execute insertaEscritores, ['Miguel', 'de Cervantes Saavedra', '1547-09-29']
db.execute insertaEscritores, ['Miguel', 'Hern&aacute;ndez Gilabert', '1910-10-30']
db.execute insertaEscritores, ['Felix', 'Lope de Vega y Carpio', '1562-11-25']</pre>
<p>
		Sin embargo, esta forma tambi&eacute;n tiene sus problemas. En nuestro ejemplo, s&oacute;lo tenemos que insertar tres campos en cada registro, pero imagina el caso de tener que insertar muchos campos. Esto complicar&iacute;a la inserci&oacute;n ya que podr&iacute;amos confundir cada hueco donde insertar los valores. Para solucionar esto, podemos utilizar un <em>Mapa</em> para insertar los datos de los escritores y posteriormente utilizar un closure con este mapa y realizar las inserciones correspondientes.
	</p>
<pre class="code">def escritores = [
	[nombre:'Camilo Jos&eacute;', apellidos:'Cela Trulock', fechaNacimiento:'1916-05-11'],
	[nombre:'Miguel', apellidos:'de Cervantes Saavedra', fechaNacimiento:'1547-09-29'],
	[nombre:'Miguel', apellidos:'Hern&aacute;ndez Gilabert', fechaNacimiento:'1910-10-30'],
	[nombre:'Felix', apellidos:'Lope de Vega y Carpio', fechaNacimiento:'1562-11-25']
]

escritores.each{
	db.execute """
		INSERT INTO Escritores (nombre, apellidos, fechaNacimiento)
			VALUES (${it.nombre}, ${it.apellidos}, ${it.fechaNacimiento});
		"""
}</pre>
<p>
		Ahora que ya hemos conectado con la base de datos y realizado nuestras primeras inserciones, llega el turno a realizar el borrado de registros y su modificaci&oacute;n. Para eliminar un registro, simplemente tendremos que utilizar la sentencia SQL <em>DELETE</em>. En nuestro eliminaremos aquellos escritores cuyos apellidos sean "Hern&aacute;ndez Gilabert"
	</p>
<pre class="code">db.execute '''
    DELETE FROM Escritores WHERE apellidos = 'Hern&aacute;ndez Gilabert'
    '''</pre>
<p>
		Mientras que para la realizaci&oacute;n de modificaciones a los registros utilizaremos la sentencia SQL <em>UPDATE</em>. Queremos modificar el nombre de Felix, para a&ntilde;adirle su correspondiente acento para quedar como F&eacute;lix.
	</p>
<pre class="code">db.execute '''
    UPDATE Escritores SET nombre='Felix' WHERE nombre='F&eacute;lix'
    '''</pre>
<p>
		El m&eacute;todo <span class="codefrag">execute()</span> devuelve un valor booleano, indicando si la sentencia devuelve o no un objeto del tipo <span class="codefrag">ResultSet</span>. Tambi&eacute;n existe otra forma de ejecutar la sentencias de modificaci&oacute;n de registros para saber, cuantos registros se han visto afectados y es la sentencia <em>executeUpdate</em>.
	</p>
<pre class="code">db.executeUpdate '''
    UPDATE Escritores SET nombre='F&eacute;lix' WHERE nombre='Felix'
    '''</pre>
<p>
		De las cuatro operaciones b&aacute;sicas que se realizan sobre las bases de datos, <em>creaci&oacute;n</em>, <em>lectura</em>, <em>modificaci&oacute;n</em> y <em>borrado</em>, ya s&oacute;lo nos queda por ver la lectura, para saber como recuperar los datos almacenados. Para la recuperaci&oacute;n de estos datos, Groovy dispone de cuatro m&eacute;todos:
	</p>
<ul>
		
<li>void eachRow()</li>
		
<li>void query()</li>
		
<li>List rows()</li>
		
<li>Object firstRow()</li>
	
</ul>
<p>
		Empecemos por el m&eacute;todo <span class="codefrag">eachRow()</span>. Este m&eacute;todo recibe como primer par&aacute;metro, la sentencia SQL a ejecutar y como segundo par&aacute;metro, disponemos de un closure para hacer con los datos obtenidos de la sentencia SQL lo que queramos. Vamos a imprimir un listado que muestre todos los escritores almacenados en la base de datos, separados por una l&iacute;nea de guiones.
	</p>
<pre class="code">println "-------------------- Escritores --------------------"  
db.eachRow('SELECT * FROM Escritores'){
    println "${it.nombre} ${it.apellidos}, nacido el ${it.fechaNacimiento}"
    println "-" * 52
}</pre>
<p>
		De igual forma que accedemos mediante el operador punto (<em>.</em>), tambi&eacute;n podemos hacerlo como si fuera una lista mediante el operador corchete (<em>[]</em>).
	</p>
<pre class="code">println "-------------------- Escritores --------------------"  
db.eachRow('SELECT nombre, apellidos, fechaNacimiento FROM Escritores'){ row -&gt; 
    println row[0] + ' ' + row[1] + ', nacido el ' + row[2]
    println "-" * 52
}</pre>
<p>
		Otro m&eacute;todo utilizado para recuperar los datos es <span class="codefrag">query()</span>. Este m&eacute;todo recibe igualmente como primer par&aacute;metro una sentencia SQL y como segundo par&aacute;metro un closure. Este m&eacute;todo permite trabajar en el closure con un objeto del tipo <em>ResultSet</em> y para movernos por los resultados, deberemos iterar nosotros mismos por este objeto. Para acceder a los campos devueltos por la sentencia SQL, necesitamos m&eacute;todos del tipo <em>getString()</em>, <em>getDate()</em>, tal y como vemos en el ejemplo.
	</p>
<pre class="code">db.query('SELECT nombre, apellidos, fechaNacimiento FROM Escritores') { resultSet -&gt; 
       if (resultSet.next()){
           println resultSet.getString('nombre') + ' '+resultSet.getString(2) + ', nacido el '+ resultSet.getDate('fechaNacimiento')
       }
   }</pre>
<p>
		Podemos acceder bien por el nombre del campo o por su posici&oacute;n, teniendo en cuenta que se empieza por el valor 1.
	</p>
<p>
		Siguiendo con los m&eacute;todos existentes para leer datos de una tabla, nos encontramos con el m&eacute;todo <span class="codefrag">rows()</span> que devuelve una lista con todas las filas encontradas por la sentencia SQL. Posteriormente, esta lista puede ser recorrida, tal y como vimos en la sesi&oacute;n 2. Veamos un ejemplo para mostrar todos los escritores en una sola l&iacute;nea.
	</p>
<pre class="code">List escritores = db.rows('SELECT nombre, apellidos FROM Escritores')
println "Tenemos ${escritores.size()} en la base de datos:"
println escritores.collect{"${it.nombre} ${it.apellidos}"}.join(", ")</pre>
<p>
		Por &uacute;ltimo, el m&eacute;todo <em>firstRow()</em> es como si ejecut&aacute;ramos el m&eacute;todo <em>rows()</em> y s&oacute;lo tuvi&eacute;ramos en cuenta la posici&oacute;n 0 de la lista devuelta.
	</p>
<pre class="code">def primerEscritor = db.firstRow('SELECT nombre, apellidos FROM Escritores')
println primerEscritor.nombre + ' ' +primerEscritor.apellidos</pre>
<a name="N10430"></a><a name="Trabajar+con+DataSets"></a>
<h3 class="underlined_5">Trabajar con DataSets</h3>
<p>
		El lenguaje SQL es una disciplina que puede quedar lejos del trabajo real de un programador, as&iacute; que facilitarles esta tarea es algo fundamental. En este sentido, Groovy dispone del concepto de <em>DataSet</em>, que nos permitir&aacute; a&ntilde;adir filas a una tabla y extraer sus registros. Sin embargo, los <em>DataSets</em> no permiten crear el esquema de la base de datos, ni realizar operaciones del tipo <em>delete</em> o <em>update</em>.
	</p>
<p>
		Podemos crear un objeto del tipo <em>DataSet</em> mediante el m&eacute;todo <em>dataSet()</em> de la clase <em>groovy.sql.Sql</em>: <span class="codefrag">dataSetEscritores = db.dataSet('Escritores')</span>. Una vez creado el <em>DataSet</em>, ya podemos ejecutar cualquiera de los m&eacute;todos de la clase. El m&eacute;todo <em>add()</em> recibe una <em>mapa</em> con los valores a introducir como nuevo registro.
	</p>
<pre class="code">dataSetEscritores.add(
       nombre: 'Luis',
       apellidos: 'de G&oacute;ngora y Argote',
       fechaNacimiento: '1561-07-11'
   )</pre>
<p>
		De esta forma, no necesitamos introducir sentencias SQL para introducir nuevos registros en la base de datos. Para recorrer los registros del <em>DataSet</em>, podemos utilizar tambi&eacute;n el m&eacute;todo <em>each()</em>, que recibe como par&aacute;metro un closure. 
	</p>
<pre class="code">dataSetEscritores.each {
	println "${it.nombre} ${it.apellidos}, nacido el ${it.fechaNacimiento}"
}</pre>
<p>
		Existe tambi&eacute;n el m&eacute;todo <em>findAll()</em> para obtener s&oacute;lo los registros que cumplen una determinada condici&oacute;n. Imagina que queremos obtener los escritores de nuestra base de datos nacidos en el siglo XX. Este m&eacute;todo devuelve a su vez un objeto del tipo <em>DataSet</em>, con lo que podemos recorrer sus resultados de igual forma que acabamos de hacer en el ejemplo anterior.
	</p>
<pre class="code">escritoresSigloXX = dataSetEscritores.findAll{ it.fechaNacimiento &gt; '1900-1-1' }
escritoresSigloXX.each{ println it.nombre +' '+it.apellidos }</pre>
<p>
		Los objetos del tipo <em>DataSet</em> nos permiten acceder a determinadas propiedades de la sentencia SQL que se corresponde con el actual DataSet y los par&aacute;metros pasados. Si accedemos a estas propiedades del DataSet <em>escritoresSigloXX</em>, obtenemos el siguiente resultado
	</p>
<pre class="code">println escritoresSigloXX.sql
println escritoresSigloXX.parameters

----Resultado---------------------------
select * from Escritores where fechaNacimiento &gt; ?
[1900-1-1]</pre>
<p>
		Todo lo que hemos hecho hasta ahora, es trabajar con una sola tabla, lo cual no suele ser lo m&aacute;s habitual en el modelo relacional. Imaginemos que los escritores de nuestra base de datos, como es normal, han escrito libros, que estar&aacute;n almacenados en otra tabla con una clave ajena que contiene la informaci&oacute;n sobre el escritor. En el siguiente ejemplo queremos obtener un listado con los libros almacenados en la tabla correspondiente y el nombre y apellidos de su autor. Empecemos por crear la tabla correspondiente e insertar algunos datos de ejemplo.
	</p>
<pre class="code">db.execute '''
    DROP TABLE Libros IF EXISTS;
    CREATE TABLE Libros (
        idLibro    INTEGER GENERATED BY DEFAULT as IDENTITY,
        titulo    VARCHAR(128),
        anyo    INTEGER,
        fkEscritor    INTEGER
    );
    '''    
def insertaLibros(titulo, anyo, apellidos) {
	db.execute """
	    INSERT INTO Libros(titulo, anyo, fkEscritor)
	        SELECT $titulo, $anyo, idEscritor
	        FROM Escritores
	        WHERE apellidos=$apellidos
	    """
}

insertaLibros('La colmena', 1951, 'Cela Trulock') 
insertaLibros('Rol de cornudos', 1976, 'Cela Trulock')
insertaLibros('La galatea', 1585, 'de Cervantes Saavedra')
insertaLibros('El ingenioso hidalgo don Quijote de la Mancha', 1605, 'de Cervantes Saavedra')
insertaLibros('La dorotea', 1632, 'Lope de Vega y Carpio')
insertaLibros('La dragontea', 1602, 'Lope de Vega y Carpio')</pre>
<p>
		Ahora ya tenemos datos en ambas tablas y un campo en la tabla <em>Libros</em> que indica que escritor ha escrito cada libro. Para listar los libros con su correspondiente autor, debemos crear una vista que combine los <em>Libros</em> con los <em>Escritores</em>. Veamos como:
	</p>
<pre class="code">db.execute '''
    DROP VIEW EscritoresLibros IF EXISTS;
    CREATE VIEW EscritoresLibros AS
        SELECT * FROM Escritores INNER JOIN Libros
            ON fkEscritor=idEscritor
'''

escritoresLibros = db.dataSet('EscritoresLibros')
escritoresLibros.each {
    println it.titulo + '(' + it.anyo + '), escrito por ' +it.nombre + ' ' + it.apellidos
}</pre>
<p>
		Con el uso de los <em>DataSets</em> lo que conseguimos es eliminar los conocimientos necesarios del lenguaje SQL y hacer el c&oacute;digo m&aacute;s portable
	</p>
<a name="N104A6"></a><a name="GORM+%28Groovy+ORM%29"></a>
<h3 class="underlined_5">GORM (Groovy ORM)</h3>
<p>
		Desde hace un tiempo, se intenta que el acceso a las bases de datos se haga de la forma m&aacute;s sencilla y amena posible y para ello se cre&oacute; el modelo <em>ORM (Object-Relational Mapping)</em>, que intenta que el acceso a la base de datos se haga utilizando objetos, aprovechando de esta forma el modelo orientado a objetos. Se recuperan los datos como objetos, se manipulan y posteriormente se vuelcan los cambios a la base de datos en caso de que sea necesario. Es el propio sistema ORM quien se encarga de que se cumplan las restricciones correspondientes.
	</p>
<p>
		En el mundo de Java hay fundamentalmente dos sistemas ampliamente utilizados: <em>Java Data Objects</em> y <em>Hibernate</em>. Por su parte, desde el proyecto <em>Grails</em>, se est&aacute; desarrollando un ORM propio de Groovy (<em>GORM</em>), basado en Hibernate y que veremos prof&uacute;ndamente cuando hablemos de Grails.
	</p>
</div>


<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2010-2011 Depto. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
