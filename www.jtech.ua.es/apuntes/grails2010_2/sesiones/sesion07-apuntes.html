<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Controladores</title>
<link type="text/css" href="../skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="../skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="../skin/highlight/shCore.js" type="text/javascript"></script><script src="../skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="../skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="../skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="../skin/print.css" rel="stylesheet">
<link type="text/css" href="../skin/profile.css" rel="stylesheet">
<script src="../skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="../skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="../skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="../index.html">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="jtech" src="../images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Groovy&amp;Grails: desarrollo r&aacute;pido de aplicaciones" src="../images/baner_j2ee_der.gif" title="Groovy&amp;Grails: desarrollo r&aacute;pido de aplicaciones"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">Home</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Sesiones</a>
</li>
<li>
<a class="base-not-selected" href="../ejercicios/index.html">Ejercicios</a>
</li>
<li>
<a class="base-not-selected" href="../bibliografia/index.html">Bibliograf&iacute;a</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', '../skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('../skin/images/chapter_open.gif');">Sesiones</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html" title="Introducci&oacute;n a Groovy">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="El lenguaje Groovy">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html" title="Aspectos avanzados en Groovy">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html" title="Librer&iacute;as propias en Groovy">Sesi&oacute;n 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html" title="Introducci&oacute;n a Grails">Sesi&oacute;n 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html" title="Construir la interfaz de usuario (I)">Sesi&oacute;n 6</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 7</div>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html" title="Construir la interfaz de usuario (II)">Sesi&oacute;n 8</a>
</div>
<div class="menuitem">
<a href="sesion09-apuntes.html" title="Dominios y servicios (I)">Sesi&oacute;n 9</a>
</div>
<div class="menuitem">
<a href="sesion10-apuntes.html" title="Dominios y servicios (II)">Sesi&oacute;n 10</a>
</div>
<div class="menuitem">
<a href="sesion11-apuntes.html" title="Seguridad">Sesi&oacute;n 11</a>
</div>
<div class="menuitem">
<a href="sesion12-apuntes.html" title="Despliegue de aplicaciones">Sesi&oacute;n 12</a>
</div>
<div class="menuitem">
<a href="sesion13-apuntes.html" title="Web 2.0">Sesi&oacute;n 13</a>
</div>
<div class="menuitem">
<a href="sesion14-apuntes.html" title="AJAX">Sesi&oacute;n 14</a>
</div>
<div class="menuitem">
<a href="sesion15-apuntes.html" title="Dos horas para crear twitter">Sesi&oacute;n 15</a>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="../skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion07-apuntes.pdf"><img alt="PDF -icon" src="../skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Controladores</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n">Introducci&oacute;n</a>
<ul class="minitoc">
<li>
<a href="#%C3%81mbitos">&Aacute;mbitos</a>
</li>
<li>
<a href="#El+m%C3%A9todo+render%28%29">El m&eacute;todo render()</a>
</li>
</ul>
</li>
<li>
<a href="#Mejorando+los+controladores">Mejorando los controladores</a>
</li>
<li>
<a href="#Interceptadores+de+acciones">Interceptadores de acciones</a>
</li>
<li>
<a href="#Filtros">Filtros</a>
</li>
</ul>
</div>


<p>
	En la sesi&oacute;n anterior, vimos como crear y modificar plantillas en nuestra aplicaci&oacute;n, as&iacute; como algunas etiquetas &uacute;tiles que nos servir&aacute;n a lo largo de todo el proceso de desarrollo de una aplicaci&oacute;n con Grails. Tambi&eacute;n vimos como implementar algunas acciones en los controladores.
</p>

<p>
	En esta sesi&oacute;n empezaremos viendo una introducci&oacute;n a los controladores y posteriormente, veremos como mejorar su funcionalidad y mantenimiento. Posteriormente pasaremos a ver tambi&eacute;n un concepto conocido como <em>interceptadores de acciones</em>, que permite ejecutar una serie de m&eacute;todos antes de que una determinada acci&oacute;n sea invocada por un controlador. Por &uacute;ltimo, echaremos un vistazo a los filtros, que son bastantes similares a los interceptadores de acciones con algunas peque&ntilde;as diferencias como la posibilidad de definir estos filtros para que puedan ser utilizados en diversos controladores.
</p>


<a name="N10015"></a><a name="Introducci%C3%B3n"></a>
<h2 class="underlined_10">Introducci&oacute;n</h2>
<div class="section">
<p>
	En una aplicaci&oacute;n que siga el patr&oacute;n Modelo Vista Controlador, los controladores son los componentes que se encargan de recibir las &oacute;rdenes por parte del usuario, gestionar la ejecuci&oacute;n de la l&oacute;gica de negocio por parte de los servicios y posteriormente actualizar la vista para que el usuario pueda ver como ha quedado el modelo de datos tras las actualizaciones pertinentes.
</p>
<p>
	Hablando en t&eacute;rminos de aplicaciones web, los controladores se encargan de interceptar las peticiones HTTP del navegador y generar la respuesta correspondiente, bien sea html, xml, json o cualquier otro formato, bien desde el propio controlador o delegando el trabajo en una vista GSP.
</p>
<p>
	La convenci&oacute;n que utiliza Grails en el caso de los controladores es que un controlador es cualquier clase que se encuentre en el directorio <em>grails-app/controllers</em> de nuestro proyecto y su nombre termine por la palabra <em>Controller</em>.
</p>
<p>
	En cada petici&oacute;n HTTP, Grails debe determinar que controlador debe ser invocado en funci&oacute;n de las reglas establecidas en el archivo <em>grails-app/conf/UrlMappings.groovy</em>. La configuraci&oacute;n por defecto que utiliza Grails es <span class="codefrag">/[controlador]/[accion]/[id]</span>. En la sesi&oacute;n 12 veremos como modificar este comportamiento por defecto.
</p>
<a name="N10033"></a><a name="%C3%81mbitos"></a>
<h3 class="underlined_5">&Aacute;mbitos</h3>
<p>
	Para facilitar el almacenamiento de la informaci&oacute;n generada por la aplicaci&oacute;n durante su utilizaci&oacute;n, los controladores disponen de una serie de objetos impl&iacute;citos. Estos objetos son <em>mapas</em> y coinciden con los &aacute;mbitos que se pueden encontrar habitualmente en cualquier aplicaci&oacute;n web.
</p>
<ul>
	
<li>
<span class="codefrag">servletContext</span> - contiene los datos del &aacute;mbito de la aplicaci&oacute;n. Cualquier valor que almacenemos en este objeto estar&aacute; disponible globalmente, desde cualquier controlador o acci&oacute;n</li>
	
<li>
<span class="codefrag">session</span> - permite asociar un estado a cada usuario, habitualmente mediante el env&iacute;o de cookies. Los datos que guardaremos en este &aacute;mbito ser&aacute;n visibles &uacute;nicamente para el usuario, mientras su sesi&oacute;n est&eacute; activa</li>
	
<li>
<span class="codefrag">request</span> - estos valores s&oacute;lo estar&aacute;n disponibles durante la ejecuci&oacute;n de la solicitud actual</li>
	
<li>
<span class="codefrag">params</span> - contiene todos los par&aacute;metros de la petici&oacute;n actual, tanto los de la url como los del formulario. El mapa <em>params</em> puede ser modificado en cualquier momento para a&ntilde;adir valores o modificar los existentes</li>
	
<li>
<span class="codefrag">flash</span> - este &aacute;mbito es un almac&eacute;n temporal para atributos que necesitaremos durante la petici&oacute;n actual y la siguiente, y que ser&aacute;n eliminados cuando ambas se hayan procesado. Este &aacute;mbito se suele utilizar para almacenar el c&oacute;digo de error en caso de redirecciones, tal y como veremos en la sesi&oacute;n 8.</li>

</ul>
<a name="N1005F"></a><a name="El+m%C3%A9todo+render%28%29"></a>
<h3 class="underlined_5">El m&eacute;todo render()</h3>
<p>
	Cuando una acci&oacute;n de un controlador que se est&aacute; ejecutando no incluye ninguna llamada al m&eacute;todo <em>render</em>, Grails buscar&aacute; la vista predeterminada para dicha acci&oacute;n en el archivo <em>grails-app/views/[controlador]/[acci&oacute;n]</em>. Esto sucede en el m&eacute;todo <span class="codefrag">login</span> de la clase <em>Usuario</em> donde no especific&aacute;bamos ninguna llamada al m&eacute;todo <span class="codefrag">render</span>.
</p>
<p>
	En caso de que la acci&oacute;n devuelva un mapa con el modelo a mostrar, los campos definidos en el mapa estar&aacute;n disponibles en la vista GSP como variables locales. Mientras que si la acci&oacute;n no devuelve nada, la p&aacute;gina GSP tendr&aacute; acceso s&oacute;lo a las variables locales definidas en el propio controlador.
</p>
<p>
	En muchos casos esto ser&aacute; suficiente para producir la salida de nuestras p&aacute;ginas GSP, pero habr&aacute; otros casos en los que necesitaremos mayor control sobre esta salida producida. Para ello necesitamos el m&eacute;todo <span class="codefrag">render()</span>, que es un m&eacute;todo que se utiliza para enviar respuestas al cliente de varias formas. El m&eacute;todo <span class="codefrag">render()</span> acepta varios par&aacute;metros en funci&oacute;n de la salida que necesitemos.
</p>
<ul>
	
<li>
<span class="codefrag">text</span> - la respuesta enviada ser&aacute; en texto plano</li>
	
<li>
<span class="codefrag">builder</span> - se puede enviar un builder para generar la respuesta</li>
	
<li>
<span class="codefrag">view</span> - se indica la vista que queremos procesar para generar la respuesta</li>
	
<li>
<span class="codefrag">template</span> - se indica la plantilla que queremos procesar para generar la respuesta</li>
	
<li>
<span class="codefrag">plugin</span> - se indica el plugin donde buscar la plantilla, si &eacute;sta no pertenece a nuestra aplicaci&oacute;n</li>
	
<li>
<span class="codefrag">bean</span> - un objeto con los datos para generar la respuesta</li>
	
<li>
<span class="codefrag">var</span> - el nombre de la variable con la que accederemos al <em>bean</em>. Si no se indica este par&aacute;metro, se utilizar&aacute; la variable <em>it</em>
</li>
	
<li>
<span class="codefrag">model</span> - un mapa con el modelo para usar en la vista</li>
	
<li>
<span class="codefrag">collection</span> - Una colecci&oacute;n para procesar una plantilla con cada elemento</li>
	
<li>
<span class="codefrag">contentType</span> - el tipo mime de la respuesta</li>
	
<li>
<span class="codefrag">encoding</span> - el juego de caracteres de la respuesta</li>
	
<li>
<span class="codefrag">converter</span> - un objeto del tipo <em>grails.converters.*</em> para generar la respuesta</li>

</ul>
<p>
	Todos estos par&aacute;metros son opcionales y en funci&oacute;n de los que proporcionemos, la salida ser&aacute; diferente. Veamos algunos ejemplos:
</p>
<pre class="code">//Enviar texto
render "un texto devuelto"

//especificar el tipo mime y codificaci&oacute;n
render (
	text:"&lt;error&gt;Ha habido un error&lt;/error&gt;",
	contentType:"text/xml",
	encoding:"UTF-8"
)

//procesar una plantilla con un modelo
render (
	template:'listado',
	model:[lista:Usuario.list()]
)

//o una colecci&oacute;n
render (
	template:'listado',
	collection:[u1,u2,u3]
)

//o con un objeto
render (
	template:'listado',
	bean:Usuario.get(2),
	var:'u'
)

//procesar una vista con un modelo
render (
	view:'listado',
	model:[lista:Usuario.list()]
)

//o con el propio controlador como modelo
render (view:'usuario')

//con un builder
render {
	div(id:'miDiv','Contenido del div')
}
render (contentType:'text/xml'){
	listado {
		Usuario.list().each {
			usuario(
				nombre:it.nombre,
				apellidos:it.apellidos
			)
		}
	}
}

//generando JSON
def u = Usuario.get(1)
render (contentType:'text/json') {
	usuario(nombre:u.nombre, apellidos:u.apellidos)
}

//generar XML y JSON autom&aacute;ticamente
import grails.converters.*

render Usuario.list(params) as XML
render Usuario.get(params.id) as JSON</pre>
</div>


<a name="N100D3"></a><a name="Mejorando+los+controladores"></a>
<h2 class="underlined_10">Mejorando los controladores</h2>
<div class="section">
<p>
	Hasta ahora, hemos utilizado el scaffolding din&aacute;mico para gestionar la informaci&oacute;n de las diferentes clases de nuestra aplicaci&oacute;n y lo que es evidente es que si Grails permite este tipo de scaffolding al vuelo, tambi&eacute;n permitir&aacute; un scaffolding est&aacute;tico en el cual el c&oacute;digo se genere de forma offline para que pueda ser modificado a nuestro antojo.
</p>
<p>
	La primera clase que vamos a modificar va a ser la clase <em>Usuario</em> y en primer lugar, necesitamos generar sus vistas, que hasta ahora se estaban generando din&aacute;micamente. Para ello, debemos ejecutar el comando <span class="codefrag">grails generate-views biblioteca.Usuario</span>. Este comando utiliza unas plantillas para crear las vistas de las cuatro operaciones b&aacute;sicas, lo que se resume en la creaci&oacute;n en el directorio <em>grails-app/views/usuario</em> de cuatro archivos, uno para cada una de las vistas. Estos archivos son: <em>create.gsp</em>, <em>edit.gsp</em>, <em>list.gsp</em> y <em>show.gsp</em>. Si nos fijamos en nuestro proyecto en NetBeans, veremos que se han creado cuatro nuevos archivos en la categor&iacute;a de <em>Views and Layouts</em>.
</p>
<p>
	Ahora que ya tenemos las vistas generadas, necesitamos volver a generar el controlador de la clase <em>Usuario</em> para que en lugar de utilizar scaffolding din&aacute;mico a partir de ahora sea est&aacute;tico. Antes de ejecutar el comando <span class="codefrag">grails generate-controller biblioteca.Usuario</span>, hacemos una copia de seguridad del controlador de la clase <em>Usuario</em> para conservar los m&eacute;todos <span class="codefrag">login()</span>, <span class="codefrag">handleLogin()</span> y <span class="codefrag">logout()</span>.
</p>
<p>
	Una vez realizada dicha copia de seguridad y ejecutado el comando <span class="codefrag">grails generate-controller biblioteca.Usuario</span>, podemos volver a abrir el archivo <em>UsuarioController.groovy</em> y comprobaremos que su contenido se ha modificado bastante del que ten&iacute;amos al principio y se han generado una serie de m&eacute;todos. Si echamos un vistazo al nombre de estos m&eacute;todos (<span class="codefrag">index(), list(), show(), delete(), edit(), update(), create() y save()</span>), nos daremos cuenta de que se corresponden con los m&eacute;todos necesarios para realizar el scaffolding de forma est&aacute;tica.
</p>
<p>
	El siguiente paso ser&aacute; copiar los m&eacute;todos <span class="codefrag">login(), handleLogin() y logout()</span> de la copia de seguridad que hemos hecho del anterior controlador de la clase <em>Usuario</em>. Cuando ya hayamos copiado estos m&eacute;todos, la copia de seguridad ya no nos sirve y la podremos eliminar. Ahora ya podemos empezar a mejorar el controlador de la clase <em>Usuario</em> y la primera mejora consistir&aacute; en conseguir que un usuario s&oacute;lo pueda modificar sus datos.
</p>
<p>
	Para solucionar este problema de autenticaci&oacute;n, cada vez que alguien intente editar o eliminar un usuario, se comprobar&aacute; que ese <em>alguien</em> coincida con el usuario en cuesti&oacute;n. En caso contrario, se mostrar&aacute; un mensaje de error indic&aacute;ndole que s&oacute;lo puede editar su propia informaci&oacute;n. En primer lugar nos centraremos en la posibilidad de editar los datos de un usuario y para ello, modificaremos el m&eacute;todo <span class="codefrag">edit()</span>. El contenido actual de este m&eacute;todo es el siguiente:
</p>
<pre class="code">def edit = {
    def usuarioInstance = Usuario.get( params.id )

    if(!usuarioInstance) {
        flash.message = "${message(code: 'default.not.found.message', args: [message(code: 'usuario.label', default: 'Usuario'), params.id])}"
        redirect(action:list)
    }
    else {
        return [ usuarioInstance : usuarioInstance ]
    }
}</pre>
<p>
	Como puedes comprobar, en primer lugar se identifica que usuario se desea modificar por medio de <span class="codefrag">Usuario.get(params.id)</span>. Si el usuario no existe, se mostrar&aacute; un mensaje de error y en caso contrario se devuelve la instancia generada. Pues bien, antes de todo este c&oacute;digo vamos a comprobar que el <em>ID</em> pasado por par&aacute;metro coincide con el que tenemos almacenado en la variable <em>session</em> (est&aacute; ah&iacute; desde que el usuario se identific&oacute; en el sistema). Si no coincide, mostraremos un mensaje de error, invocaremos el m&eacute;todo <span class="codefrag">list()</span> de la clase Usuario y haremos un <span class="codefrag">return</span> para abandonar el m&eacute;todo actual. En caso contrario, se continuar&aacute; con la ejecuci&oacute;n normal del m&eacute;todo. El nuevo m&eacute;todo <span class="codefrag">edit()</span> quedar&iacute;a as&iacute;:
</p>
<pre class="code">def edit = {
	<strong>if (session?.usuario?.id as String != params.id){
	    flash.message = "S&oacute;lo puedes editar tu informaci&oacute;n"
	    redirect(action:list)
	    return
	}</strong>

	def usuarioInstance = Usuario.get( params.id )

	if(!usuarioInstance) {
	    flash.message = "${message(code: 'default.not.found.message', args: [message(code: 'usuario.label', default: 'Usuario'), params.id])}"
	    redirect(action:list)
	}
	else {
	    return [ usuarioInstance : usuarioInstance ]
	}
}</pre>
<p>
	Si intentamos ahora modificar los datos de un usuario diferente al cual nos hemos identificado, el sistema nos mostrar&aacute; el mensaje de error que hemos especificado. Esta misma comprobaci&oacute;n la debemos implementar en las funciones <span class="codefrag">update()</span> y <span class="codefrag">delete()</span>.
</p>
<p>
	Nuestra aplicaci&oacute;n acaba de aumentar su seguridad, sin embargo, todav&iacute;a queda mucho por hacer. Si recordamos la especificaci&oacute;n de la aplicaci&oacute;n, dec&iacute;amos que los <em>administradores</em> eran los &uacute;nicos encargados de la creaci&oacute;n de usuarios, con lo que debemos hacer algo para comprobar que s&oacute;lo los administradores tengan la posibilidad de crear nuevos usuarios. Para conseguir esto, en el m&eacute;todo <span class="codefrag">create()</span> debemos comprobar que el usuario que intenta crear un nuevo usuario es del tipo <em>administrador</em>. Siguiendo la misma metodolog&iacute;a que en el m&eacute;todo <span class="codefrag">edit()</span>, el m&eacute;todo <span class="codefrag">create()</span> quedar&iacute;a as&iacute;:
</p>
<pre class="code">def create = {
    <strong>if (session?.usuario?.tipo != "administrador"){
        flash.message = "S&oacute;lo los administradores pueden crear usuarios"
        redirect(action:list)
        return
    }</strong>
    
    def usuarioInstance = new Usuario()
    usuarioInstance.properties = params
    return ['usuarioInstance':usuarioInstance]
}</pre>
<p>
	Si ahora intentamos crear un usuario sin ser <em>administradores</em>, el sistema nos indicar&aacute; que no podemos, puesto que no tenemos los privilegios suficientes.
</p>
<p>
	De igual forma que s&oacute;lo los administradores pueden crear nuevos usuarios, los datos de los usuarios s&oacute;lo podr&aacute;n ser editados por los propios usuarios y por los administradores, con lo que los m&eacute;todos <span class="codefrag">edit()</span>, <span class="codefrag">update()</span> y <span class="codefrag">delete()</span> anteriores, deben ser modificados para controlar esta restricci&oacute;n.
</p>
<pre class="code">def edit = {
	<strong>if ((session?.usuario?.id as String != params.id) &amp;&amp; (session?.usuario?.tipo != "administrador")){</strong>
		flash.message = "S&oacute;lo puedes editar tu informaci&oacute;n"
		redirect(action:list)
		return
	}

	def usuarioInstance = Usuario.get( params.id )

	if(!usuarioInstance) {
	    flash.message = "${message(code: 'default.not.found.message', args: [message(code: 'usuario.label', default: 'Usuario'), params.id])}"
	    redirect(action:list)
	}
	else {
	    return [ usuarioInstance : usuarioInstance ]
	}
}</pre>
<p>
	Veamos algo sobre la variable <em>param</em>. Esta variable es de tipo <em>mapa</em> y recoge los valores pasados en la petici&oacute;n. Para acceder a las propiedades de este mapa podemos utilizar el operador punto (.id) o bien el operador corchete ['id']. El operador corchete nos servir&aacute; para aquellos casos en los que la propiedad a analizar tenga caracteres extra&ntilde;os como un punto (.) o una barra (/) o en aquellas situaciones en que se deba componer el nombre de la propiedad.
</p>
<p>
	Pero, &iquest;c&oacute;mo se pasan los par&aacute;metros al controlador? Si nos vamos al listado de usuarios y hacemos clic en cualquiera de los usuarios para ver su informaci&oacute;n, podemos ver la siguiente direcci&oacute;n web: <em>http://localhost:8080/biblioteca/usuario/show/1</em>. Esta direcci&oacute;n url podemos dividirla en seis partes:
</p>
<ul>
	
<li>
<em>http://localhost</em>: dominio</li>
	
<li>
<em>8080</em>: puerto</li>
	
<li>
<em>biblioteca</em>, nombre de la aplicaci&oacute;n</li>
	
<li>
<em>usuario</em>, nombre del controlador</li>
	
<li>
<em>show</em>, nombre de la acci&oacute;n ejecutada por el controlador</li>
	
<li>
<em>1</em>, el par&aacute;metro ID</li>

</ul>
<p>
	Si nos fijamos a partir de ahora en las direcciones url utilizadas por nuestra aplicaci&oacute;n, veremos como todas siguen el mismo convenio. Fij&eacute;monos ahora en la sentencia <span class="codefrag">return [usuarioInstance: usuarioInstance]</span>. Esta sentencia devuelve un mapa de valores, en el que la entrada anterior al s&iacute;mbolo : se refiere a la clave y la segunda se refiere al valor. Desde los archivos correspondientes a la vista, como por ejemplo en el archivo <em>show.gsp</em>, podemos ver como se accede a esta informaci&oacute;n de la siguiente forma:
</p>
<pre class="code">&lt;tr class="prop"&gt;
    &lt;td valign="top" class="name"&gt;
        &lt;g:message code="usuario.login.label" default="Login" /&gt;
    &lt;/td&gt;
    
    &lt;td valign="top" class="value"&gt;
        <strong>${fieldValue(bean:usuarioInstance, field:'login')}</strong>
    &lt;/td&gt;  
&lt;/tr&gt;</pre>
<p>
	Como podemos ver, se hace referencia a la variable <em>usuarioInstance</em>, que es la misma que devuelve el m&eacute;todo <span class="codefrag">show()</span> del controlador y en este caso a la propiedad <em>login</em>. El m&eacute;todo <span class="codefrag">fieldValue()</span> no s&oacute;lo se puede utilizar como tal pas&aacute;ndole el <em>bean</em> utilizado y el campo a devolver, sino tambi&eacute;n como una etiqueta <span class="codefrag">&lt;g:fieldValue bean="${usuarioInstance}" field="login" /&gt;</span> que puede ser incluida en cualquier p&aacute;gina GSP.
</p>
<p>
	Sigamos analizando los controladores generados autom&aacute;ticamente por el scaffolding est&aacute;tico de Grails. Si ahora prestamos atenci&oacute;n al m&eacute;todo <span class="codefrag">save()</span> del controlador de la clase <em>Usuario</em> (utilizado para persistir la informaci&oacute;n en la base de datos de los nuevos usuarios creados), nos daremos cuenta de lo potente que es Grails a la hora de pasar informaci&oacute;n entre la vista y el controlador.
</p>
<pre class="code">def save = {
    <strong>def usuarioInstance = new Usuario(params)</strong>
    if(!usuarioInstance.hasErrors() &amp;&amp; usuarioInstance.save()) {
        flash.message = "${message(code: 'default.created.message', args: [message(code: 'usuario.label', default: 'Usuario'), usuarioInstance.id])}"
        redirect(action:show,id:usuarioInstance.id)
    }
    else {
        <strong>render(view:'create',model:[usuarioInstance:usuarioInstance])</strong>
    }
}</pre>
<p>
	Simplemente con una sola l&iacute;nea de c&oacute;digo, <span class="codefrag">def usuarioInstance = new Usuario(params)</span> hemos creado el nuevo usuario, aunque &eacute;ste todav&iacute;a no ha sido almacenado en la base de datos. La vista <em>create.gsp</em> es la encargada de generar el formulario de entrada de los datos del nuevo usuario (<em>login, password, nombre, apellidos y tipo</em>). Cuando el usuario env&iacute;a este formulario, todos los datos del nuevo usuario se pasan al controlador a trav&eacute;s de la variable <em>params</em>, que posteriormente es utilizado para crear el nuevo usuario a trav&eacute;s del constructor de la clase <em>Usuario</em>. Esta forma de trabajar nos ahorra mucho tiempo y esfuerzo y si alguna vez has trabajado con otros frameworks o lenguajes de programaci&oacute;n, podr&aacute;s constatarlo.
</p>
<p>
	Si todo ha ido bien, lo cual se comprueba chequeando la presencia de errores mediante <span class="codefrag">hasErrors()</span> e intentando salvar el nuevo usuario en la base de datos mediante el m&eacute;todo de GORM <span class="codefrag">save()</span>, se mostrar&aacute; un mensaje indicando que el nuevo usuario se ha generado correctamente. En caso de que se produzca alg&uacute;n error, se renderizar&aacute; la vista <em>create.gsp</em> a la cual se le pasar&aacute; como modelo los datos del nuevo usuario para que se corrijan los datos err&oacute;neos.
</p>
<p>
	Pero sigamos mejorando nuestra aplicaci&oacute;n. En cuanto a los usuarios, quiz&aacute;s lo &uacute;nico que nos resta por controlar ser&aacute; evitar que los usuarios que no sean administradores no puedan modificar la propiedad <em>tipo</em> para que un usuario malintencionado no consiga elevar sus privilegios y tirarnos abajo el sistema. Para ello, vamos a a&ntilde;adir una comprobaci&oacute;n a la vista <em>edit.gsp</em> para que s&oacute;lo se muestre la posibilidad de editar la propiedad <em>tipo</em> de un usuario en caso de que el usuario que intente modificarlo sea un administrador. 
</p>
<pre class="code">
<strong>&lt;g:if test="${session?.usuario?.tipo == 'administrador' }"&gt;</strong>
	&lt;tr class="prop"&gt;
	    &lt;td valign="top" class="name"&gt;
	        &lt;label for="tipo"&gt;&lt;g:message code="usuario.tipo.label" default="Tipo" /&gt;&lt;/label&gt;
	    &lt;/td&gt;
	    &lt;td valign="top" class="value ${hasErrors(bean:usuarioInstance,field:'tipo','errors')}"&gt;
	        &lt;g:select id="tipo" name="tipo" from="${usuarioInstance.constraints.tipo.inList}" value="${usuarioInstance.tipo}" &gt;&lt;/g:select&gt;
	    &lt;/td&gt;
	&lt;/tr&gt;
<strong>&lt;/g:if&gt;</strong>
</pre>
</div>


<a name="N10223"></a><a name="Interceptadores+de+acciones"></a>
<h2 class="underlined_10">Interceptadores de acciones</h2>
<div class="section">
<p>
	Como cualquier aplicaci&oacute;n en fase de desarrollo, los fallos y problemas son comunes y necesitamos establecer sistemas para detectar y solucionarlos en el menor tiempo posible. Cuando se produce uno de estos fallos, es necesario conocer el controlador que caus&oacute; el fallo as&iacute; como los datos de entrada y la acci&oacute;n que se ejecut&oacute;. Por este motivo, Grails a&ntilde;ade lo que se conoce como <em>Interceptadores de acciones</em> que no son m&aacute;s que m&eacute;todos que se ejecutan antes y despu&eacute;s de cualquier acci&oacute;n de un controlador. Una de las utilidades de los interceptadores de acciones se refiere a la generaci&oacute;n de archivos de <em>log</em> con todas las acciones ejecutadas en nuestra aplicaci&oacute;n, as&iacute; como los datos de entrada.
</p>
<p>
	Grails nos ofrece la posibilidad de utilizar los interceptadores antes y despu&eacute;s de las acciones. Los m&eacute;todos encargados son <span class="codefrag">beforeInterceptor()</span> y <span class="codefrag">afterInterceptor()</span>. En nuestra aplicaci&oacute;n, vamos a utilizar estos m&eacute;todos para la generaci&oacute;n de un archivo de <em>log</em> con todas las acciones ejecutadas en ella. En concreto, escribiremos en nuestro <em>log</em> el nombre del usuario que realiza la acci&oacute;n, el nombre del controlador y la acci&oacute;n invocada, as&iacute; como los par&aacute;metros.
</p>
<p>
	En primer lugar, vamos a a&ntilde;adir los m&eacute;todos <span class="codefrag">beforeInterceptor()</span> y <span class="codefrag">afterInterceptor()</span> al controlador de la clase <em>Usuario</em>. De esta forma, podremos conocer todo lo que se ha realizado en cuanto a la gesti&oacute;n de los usuarios.
</p>
<pre class="code">def beforeInterceptor = {
    log.trace("${session?.usuario?.login} Controlador ${controllerName} Empieza la acci&oacute;n ${actionName}() : par&aacute;metros $params")
}</pre>
<p>
	De igual forma, el m&eacute;todo <span class="codefrag">afterInterceptor()</span> ser&aacute; muy similar al m&eacute;todo <span class="codefrag">beforeInterceptor()</span> con la salvedad de que ahora se le pasar&aacute; el <em>modelo</em> para que se pueda imprimir en el <em>log</em>.
</p>
<pre class="code">def afterInterceptor = { model -&gt;
    log.trace("${session?.usuario?.login} Controlador ${controllerName} Termina la acci&oacute;n ${actionName}() : devuelve $model")
}</pre>
<p>
	Los m&eacute;todos <span class="codefrag">beforeInterceptor()</span> y <span class="codefrag">afterInterceptor()</span> son invocados antes y despu&eacute;s de acci&oacute;n en un controlador. Sin embargo, es posible que no queramos que estos m&eacute;todos se ejecutan antes y despu&eacute;s de todas las acciones que consideremos intrascendentes. Si en nuestro ejemplo, consideramos innecesario realizar un log sobre la acci&oacute;n <span class="codefrag">list()</span>, podr&iacute;amos utilizar el siguiente c&oacute;digo.
</p>
<pre class="code">def beforeInterceptor = [action:this.&amp;beforeAudit,except:['list']]

def afterInterceptor = [action:{model -&gt;this.&amp;afterAudit(model)}, except:['list']]

def beforeAudit = {
    log.trace("${session?.usuario?.login} Controlador ${controllerName} Empieza la acci&oacute;n ${actionName}() : par&aacute;metros $params")
}

def afterAudit = { model -&gt;
    log.trace("${session?.usuario?.login} Controlador ${controllerName} Termina la acci&oacute;n ${actionName}() : devuelve $model")
}</pre>
<p>
	Para poder generar estos archivos de log necesarios para realizar un completo an&aacute;lisis de nuestra aplicaci&oacute;n, necesitamos configurar <em>log4j</em>, una librer&iacute;a de Apache ampliamente utilizada para este tipo de tareas. Esta librer&iacute;a permite establecer una serie de niveles de granularidad de los mensajes emitidos por el sistema. Con log4j se acabaron los t&iacute;picos <span class="codefrag">println()</span> que tantos problemas pueden provocar.
</p>
<p>
	Log4j presenta seis niveles de detalle:
</p>
<ul>
	
<li>
<em>Fatal:</em> se utiliza para mensajes cr&iacute;ticos del sistema, generalmente despu&eacute;s de guardar el mensaje el programa abortar&aacute;.</li>
	
<li>
<em>Error:</em> se utiliza en mensajes de error de la aplicaci&oacute;n que se desea guardar. Estos eventos afectan al programa pero lo dejan seguir funcionando, como por ejemplo que alg&uacute;n par&aacute;metro de configuraci&oacute;n no es correcto y se carga el par&aacute;metro por defecto.</li>
	
<li>
<em>Warn:</em> se utiliza para mensajes de alerta sobre eventos que se desea mantener constancia, pero que no afectan al correcto funcionamiento del programa.</li>
	
<li>
<em>Info:</em> se utiliza para mensajes similares al modo <em>verbose</em> en otras aplicaciones.</li>
	
<li>
<em>Debug:</em> se utiliza para escribir mensajes de depuraci&oacute;n. Este nivel no debe estar activado cuando la aplicaci&oacute;n se encuentre en producci&oacute;n.</li>
	
<li>
<em>Trace:</em> se utiliza para mostrar mensajes con un mayor nivel de detalle que debug.</li>

</ul>
<p>
	En log4j los mensajes son enviados a una o varias salidas de destino, lo que se denomina un <em>appender</em>. Por defecto existen varios <em>appender</em> disponibles y configurados, pero tambi&eacute;n podemos crear nuestros propios appenders. Los t&iacute;picos appender son aquellos en los que la salida es redirigida a un fichero de texto con extensi&oacute;n .log (<span class="codefrag">FileAppender, RollingFileAppender</span>), aunque tambi&eacute;n es posible almacenar estos registros en un servidor remoto gracias a <span class="codefrag">SocketAppender</span>, a una direcci&oacute;n de correo electr&oacute;nico con <span class="codefrag">SMTPAppender</span> e incluso a una base de datos con <span class="codefrag">JDBCAppender</span>. 
</p>
<p>
	En nuestro ejemplo vamos a volcar la informaci&oacute;n generada en un fichero llamada <em>mylog.log</em> que se ubicar&aacute; en la ra&iacute;z de la aplicaci&oacute;n. Para eso debemos configurar log4j para que funcione correctamente en nuestra aplicaci&oacute;n y eso es algo que debemos hacer en el archivo <em>grails-app/conf/Config.groovy</em>, donde si echamos un vistazo r&aacute;pido podremos comprobar como el sistema ya ha generado un peque&ntilde;o ejemplo para nosotros, que ahora debemos modificar.
</p>
<p>
	Como puedes ver, la apariencia de la configuraci&oacute;n de log4j en Grails es el t&iacute;pico closure similar a los que vimos cuando hablamos sobre Groovy. En el ejemplo que viene por defecto en el archivo de configuraci&oacute;n <em>Config.groovy</em>, debemos a&ntilde;adir un appender de tipo <em>file</em> para que vuelque la salida a un fichero pasado tambi&eacute;n por par&aacute;metro. Con esto, la parte de configuraci&oacute;n de log4j quedar&iacute;a as&iacute;:
</p>
<pre class="code">// log4j configuration
log4j = {
    <strong>appenders {
        file name:'file', file:'mylog.log'
    }
    root {
        info 'file'
        additivity = true
    }

    trace "grails.app.controller.biblioteca.UsuarioController"</strong>

    error  'org.codehaus.groovy.grails.web.servlet',  //  controllers
		'org.codehaus.groovy.grails.web.pages', //  GSP
		'org.codehaus.groovy.grails.web.sitemesh', //  layouts
		'org.codehaus.groovy.grails."web.mapping.filter', // URL mapping
		'org.codehaus.groovy.grails."web.mapping', // URL mapping
		'org.codehaus.groovy.grails.commons', // core / classloading
		'org.codehaus.groovy.grails.plugins', // plugins
		'org.codehaus.groovy.grails.orm.hibernate', // hibernate integration
		'org.springframework',
		'org.hibernate',
		'net.sf.ehcache.hibernate'

    warn   'org.mortbay.log'
}</pre>
<p>
	Adem&aacute;s del appender que le indica al sistema que la informaci&oacute;n ser&aacute; volcada a un fichero, le hemos indicado tambi&eacute;n que el controlador <em>UsuarioController</em> va a tener un nivel de granularidad de nivel <em>trace</em>, puesto que en los m&eacute;todos <span class="codefrag">beforeAudit()</span> y <span class="codefrag">afterAudit()</span> ya le indicamos este nivel.
</p>
<p>
	Si ejecutamos nuestra aplicaci&oacute;n y realizamos algunas operaciones sobre los usuarios, podemos comprobar como el fichero <em>mylog.log</em> va a&ntilde;adiendo todas las operaciones relacionadas con el controlador <em>Usuario</em>.
</p>
</div>


<a name="N102EB"></a><a name="Filtros"></a>
<h2 class="underlined_10">Filtros</h2>
<div class="section">
<p>
	Los filtros son similares a los <em>interceptadores de acciones</em> en el sentido de que se ejecutan antes y despu&eacute;s de una acci&oacute;n. Sin embargo, la diferencia entre ellos es que los filtros son m&aacute;s flexibles ya que, a diferencia de los interceptadores, &eacute;stos pueden ser utilizados en m&uacute;ltiples controladores.
</p>
<p>
	Vamos a ver alg&uacute;n ejemplo donde podemos utilizar los filtros. En la primera parte de esta sesi&oacute;n ve&iacute;amos como a&ntilde;adir algo de seguridad a nuestra aplicaci&oacute;n comprobando que determinadas acciones (crear, editar, y eliminar usuarios), s&oacute;lo podr&iacute;an ser realizadas bien por los administradores o por el propio usuario. Gracias a los filtros vamos a centralizar estas comprobaciones para que s&oacute;lo se realicen desde una determinada funci&oacute;n. Por ejemplo, en las acciones <span class="codefrag">edit()</span>, <span class="codefrag">update()</span> y <span class="codefrag">delete()</span> comprob&aacute;bamos que s&oacute;lo el propio usuario y los administradores podr&iacute;as realizar estas acciones y lo hac&iacute;amos de la siguiente forma:
</p>
<pre class="code">if ((session?.usuario?.id as String != params.id) &amp;&amp; (session?.usuario?.tipo != "administrador")){
	flash.message = "S&oacute;lo puedes editar tu informaci&oacute;n"
	redirect(action:list)
	return
}</pre>
<p>
	Esta l&oacute;gica se repite en los tres m&eacute;todos comentados, as&iacute; que vamos a utilizar un filtro para centralizar su tratamiento. En Grails, los filtros se generan creando una nueva clase que termine con la palabra <em>Filters</em> o bien mediante el comando <span class="codefrag">grails create-filters</span> para que sea Grails quien lo haga por nosotros y nos cree adem&aacute;s un esqueleto de la clase en cuesti&oacute;n. Estas nuevas clases se deben crear en el directorio <em>grails-app/conf</em>. Cada filtro implementa la l&oacute;gica a ejecutar antes y despu&eacute;s de las acciones as&iacute; como sobre que acciones se debe hacer. En nuestro caso, debemos crear un filtro ejecutando el comando <span class="codefrag">grails create-filters usuario</span> que se ubicar&aacute; en el directorio <em>grails-app/conf/biblioteca</em> y se llamar&aacute; <em>UsuarioFilters.groovy</em>. Un ejemplo de c&oacute;digo de un filtro en Grails podr&iacute;a ser el siguiente:
</p>
<pre class="code">package biblioteca

class UsuarioFilters {
    def filters = {
        chequeoModificacionUsuario(controller: 'usuario', action: '*') {
            ...
        }
        otroFiltro(uri: '/usuario/*') {
        }
    }
}</pre>
<p>
	Tal y como vemos en el c&oacute;digo de ejemplo, se han definido dos <em>filtros</em> para la clase <em>Usuario</em>. De momento s&oacute;lo se ha especificado el &aacute;mbito de aplicaci&oacute;n de estos filtros. Para el primer filtro definido el &aacute;mbito de aplicaci&oacute;n es el controlador <em>Usuario</em> y las acciones donde se ejecutar&aacute; este filtro ser&aacute;n todas, gracias al s&iacute;mbolo <strong>*</strong>. En nuestro caso, las acciones donde necesitamos ejecutar este filtro son 3, <span class="codefrag">edit()</span>, <span class="codefrag">update()</span> y <span class="codefrag">delete()</span>, pero esto lo vamos a controlar dentro de la propia l&oacute;gica del filtro, tal y como veremos a continuaci&oacute;n.
</p>
<p>
	Para el segundo filtro se ha escogido otra forma de declarar el &aacute;mbito de aplicaci&oacute;n de los filtros, que es especificando la direcci&oacute;n <em>uri</em> empleada, en el ejemplo, se referir&iacute;a a cualquier acci&oacute;n ejecutada dentro del controlador de la clase <em>Usuario</em>, con lo que ambos filtros se ejecutar&iacute;an en todas las acciones de la clase <em>Usuario</em>.
</p>
<p>
	Lo &uacute;nico que nos restar&iacute;a por indicarle al primer filtro es cuando queremos que se ejecuten estos m&eacute;todos. Los filtros en Grails pueden ser ejecutados antes (<span class="codefrag">before()</span>) o despu&eacute;s de la acci&oacute;n (<span class="codefrag">after()</span>) o incluso despu&eacute;s de que la vista se haya renderizado (<span class="codefrag">afterView()</span>). En nuestro caso necesitamos que el filtro se ejecute antes de que comience la acci&oacute;n y podr&iacute;amos tener algo as&iacute;:
</p>
<pre class="code">package biblioteca

class UsuarioFilters {
    def filters = {
        chequeoModificacionUsuario(controller: 'usuario', action: '*') {
            before = {
                if (actionName == 'edit' || actionName == 'update' || actionName == 'delete') {
                    if (session?.usuario?.id as String != params?.id) {
                        flash.message = "S&oacute;lo puedes editar tu informaci&oacute;n"
                        redirect(controller:'usuario', action: 'list')
                        return false
                    }
                }
            }
        }
    }
}</pre>
<p>
	Si ahora eliminamos las comprobaciones introducidas anteriormente en el controlador de la clase <em>Usuario</em>, veremos como un usuario s&oacute;lo podr&aacute; editar y eliminarse a si mismo.
</p>
<p>
	Ahora bien, tambi&eacute;n debemos a&ntilde;adir la posibilidad a los administradores de realizar estas acciones, con lo que debemos modificar este filtro para a&ntilde;adir esa caracter&iacute;stica a la aplicaci&oacute;n. El filtro final quedar&iacute;a as&iacute;:
</p>
<pre class="code">package biblioteca

class UsuarioFilters {
    def filters = {
        chequeoModificacionUsuario(controller: 'usuario', action: '*') {
            before = {
                if (actionName == 'edit' || actionName == 'update' || actionName == 'delete') {
                    if ((session?.usuario?.id as String != params?.id) &amp;&amp; (session?.usuario?.tipo != "administrador")) {
                        flash.message = "S&oacute;lo puedes editar tu informaci&oacute;n"
                        redirect(controller:'usuario', action: 'list')
                        return false
                    }
                }
            }
        }
    }
}</pre>
<p>
	Con estos filtros, el c&oacute;digo de nuestros controladores queda m&aacute;s limpio y hemos conseguido centralizar la l&oacute;gica que gestiona las comprobaciones de usuario en un s&oacute;lo fichero y una sola funci&oacute;n.
</p>
<p>
	Otra caracter&iacute;stica de nuestra aplicaci&oacute;n era que s&oacute;lo los administradores de la aplicaci&oacute;n pueden crear usuarios, cosa que ya hab&iacute;amos a&ntilde;adido a nuestro controlador, pero que ahora vamos a cambiar para hacerlo utilizando los filtros, que para algo est&aacute;n. Para esto, vamos a crear un nuevo filtro en la clase <em>UsuarioFilters</em> que se encargue de esta comprobaci&oacute;n.
</p>
<pre class="code">chequeoCreacionUsuario(controller: 'usuario', action: '*') {
    before = {
        if (actionName == 'create' || actionName == 'save'){
            if (session?.usuario?.tipo != "administrador") {
                flash.message = "S&oacute;lo los administradores pueden crear usuarios"
                redirect(controller:'usuario', action: 'list')
                return false
            }
        }
    }
}</pre>
<p>
	Ahora podemos eliminar esta comprobaci&oacute;n que antes se realizaba directamente en los m&eacute;todos <span class="codefrag">create()</span> y <span class="codefrag">save()</span> del controlador de la clase <em>Usuario</em> y veremos como s&oacute;lo los administradores son capaces de crear usuarios.
</p>
</div>


<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2010-2011 Depto. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
