<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Configuraci&oacute;n y despliegue de aplicaciones</title>
<link type="text/css" href="../skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="../skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="../skin/highlight/shCore.js" type="text/javascript"></script><script src="../skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="../skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="../skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="../skin/print.css" rel="stylesheet">
<link type="text/css" href="../skin/profile.css" rel="stylesheet">
<script src="../skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="../skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="../skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="../index.html">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="jtech" src="../images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Groovy&amp;Grails: desarrollo r&aacute;pido de aplicaciones" src="../images/baner_j2ee_der.gif" title="Groovy&amp;Grails: desarrollo r&aacute;pido de aplicaciones"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">Home</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Sesiones</a>
</li>
<li>
<a class="base-not-selected" href="../ejercicios/index.html">Ejercicios</a>
</li>
<li>
<a class="base-not-selected" href="../bibliografia/index.html">Bibliograf&iacute;a</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', '../skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('../skin/images/chapter_open.gif');">Sesiones</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html" title="Introducci&oacute;n a Groovy">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="El lenguaje Groovy">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html" title="Aspectos avanzados en Groovy">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html" title="Librer&iacute;as propias en Groovy">Sesi&oacute;n 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html" title="Introducci&oacute;n a Grails">Sesi&oacute;n 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html" title="Construir la interfaz de usuario (I)">Sesi&oacute;n 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html" title="Controladores">Sesi&oacute;n 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html" title="Construir la interfaz de usuario (II)">Sesi&oacute;n 8</a>
</div>
<div class="menuitem">
<a href="sesion09-apuntes.html" title="Dominios y servicios (I)">Sesi&oacute;n 9</a>
</div>
<div class="menuitem">
<a href="sesion10-apuntes.html" title="Dominios y servicios (II)">Sesi&oacute;n 10</a>
</div>
<div class="menuitem">
<a href="sesion11-apuntes.html" title="Seguridad">Sesi&oacute;n 11</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 12</div>
</div>
<div class="menuitem">
<a href="sesion13-apuntes.html" title="Web 2.0">Sesi&oacute;n 13</a>
</div>
<div class="menuitem">
<a href="sesion14-apuntes.html" title="AJAX">Sesi&oacute;n 14</a>
</div>
<div class="menuitem">
<a href="sesion15-apuntes.html" title="Dos horas para crear twitter">Sesi&oacute;n 15</a>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="../skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion12-apuntes.pdf"><img alt="PDF -icon" src="../skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Configuraci&oacute;n y despliegue de aplicaciones</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Configuraci%C3%B3n+de+aplicaciones">Configuraci&oacute;n de aplicaciones</a>
<ul class="minitoc">
<li>
<a href="#El+archivo+Config.groovy">El archivo Config.groovy</a>
</li>
<li>
<a href="#El+archivo+DataSource.groovy">El archivo DataSource.groovy</a>
</li>
<li>
<a href="#El+archivo+BootStrap.groovy">El archivo BootStrap.groovy</a>
</li>
<li>
<a href="#El+archivo+UrlMappings.groovy">El archivo UrlMappings.groovy</a>
</li>
</ul>
</li>
<li>
<a href="#Empaquetamiento+de+aplicaciones">Empaquetamiento de aplicaciones</a>
</li>
<li>
<a href="#Actualizaci%C3%B3n+de+aplicaciones">Actualizaci&oacute;n de aplicaciones</a>
</li>
<li>
<a href="#Tareas+programadas+con+Quartz">Tareas programadas con Quartz</a>
<ul class="minitoc">
<li>
<a href="#Env%C3%ADo+de+notificaciones+autom%C3%A1ticas">Env&iacute;o de notificaciones autom&aacute;ticas</a>
</li>
</ul>
</li>
<li>
<a href="#Otros+comandos+interesantes+de+Grails">Otros comandos interesantes de Grails</a>
</li>
</ul>
</div>
         

<p>
	Ahora que ya tenemos los conocimientos necesarios para el desarrollo de aplicaciones con Grails y su completo entorno de desarrollo, es hora de pensar en lo que viene despu&eacute;s de la fase de desarrollo y testeo, la fase de producci&oacute;n.
</p>

<p>
	En esta sesi&oacute;n veremos como configurar nuestra aplicaci&oacute;n en funci&oacute;n del entorno en el que estemos trabajando. Posteriormente veremos como realizar el empaquetamiento de aplicaciones, para terminar hablando de la actualizaci&oacute;n de aplicaciones ante nuevas versiones de Grails.
</p>


<a name="N10012"></a><a name="Configuraci%C3%B3n+de+aplicaciones"></a>
<h2 class="underlined_10">Configuraci&oacute;n de aplicaciones</h2>
<div class="section">
<a name="N10018"></a><a name="El+archivo+Config.groovy"></a>
<h3 class="underlined_5">El archivo Config.groovy</h3>
<p>
	El archivo <em>grails-app/conf/Config.groovy</em> contiene los par&aacute;metros de configuraci&oacute;n general de nuestra aplicaci&oacute;n. En este archivo se pueden declarar variables que estar&aacute;n disponibles en cualquier artefacto de nuestra aplicaci&oacute;n a trav&eacute;s del objeto global <span class="codefrag">grailsApplication.config</span>. Por ejemplo si definimos la siguiente variable <span class="codefrag">com.biblioteca.miParametro = "dato"</span>, &eacute;sta va a ser accesible desde cualquier controlador, vista, servicio, etc. mediante la expresi&oacute;n <span class="codefrag">grailsApplication.config.com.biblioteca.miParametro</span>.
</p>
<p>
	Adem&aacute;s, de poder declarar nuevas variables globales, el archivo <em>Config.groovy</em> utiliza una serie de variables definidas que tienen el siguiente significado:
</p>
<ul>
	
<li>
<span class="codefrag">grails.config.location</span>: ubicaciones donde encontrar otros archivos de configuraci&oacute;n que se fundir&aacute;n con el principal <em>Config.groovy</em>
</li>
	
<li>
<span class="codefrag">grails.project.groupId</span>: nombre por defecto del paquete en el que se crean todos los artefactos de la aplicaci&oacute;n. Por defecto tenemos que este paquete coincidir&aacute; con el nombre de la aplicaci&oacute;n.</li>
	
<li>
<span class="codefrag">grails.enable.native2ascii</span>: en caso de que el valor sea true, Grails utilizar&aacute; native2ascii para convertir los archivos properties al formato unicode</li>
	
<li>
<span class="codefrag">grails.views.default.codec</span>: especifica el formato por defecto de nuestras p&aacute;ginas GSPs. Puede tomar el valor 'none', que es el valor por defecto, 'html', o 'base64'</li>
	
<li>
<span class="codefrag">grails.views.gsp.encoding</span>: codificaci&oacute;n de las p&aacute;ginas GSP</li>
	
<li>
<span class="codefrag">grails.converters.encoding</span>: codificaci&oacute;n de los convertidores</li>
	
<li>
<span class="codefrag">grails.mime.file.extensions</span>: habilita el uso de la extensi&oacute;n en la url para fijar el <em>content-type</em> de la respuesta. Por ejemplo, si se a&ntilde;ade la extensi&oacute;n <em>.xml</em> al final de cualquier url, el content-type se fijar&aacute; autom&aacute;ticamente a 'text/xml', ignorando la cabecera Accept del navegador</li>
	
<li>
<span class="codefrag">grails.mime.types</span>: indica un mapa con los posibles tipos mime soportados en nuestra aplicaci&oacute;n</li>
	
<li>
<span class="codefrag">grails.serverURL</span>: la parte "fija" de nuestros enlaces cuando queremos generar rutas absolutas. Podemos incluso hacer distinci&oacute;n por entorno.</li>

</ul>
<a name="N1006C"></a><a name="El+archivo+DataSource.groovy"></a>
<h3 class="underlined_5">El archivo DataSource.groovy</h3>
<p>
	Muchas empresas disponen de varios entornos que las aplicaciones deben superar para finalmente pasar a disposici&oacute;n de los usuarios finales. Los entornos m&aacute;s habituales son el <em>entorno de desarrollo</em> que se refiere al entorno propio del desarrollador, con su propio servidor local instalado en su ordenador, el <em>entorno de tests</em> en el que otras personas se encargan de comprobar que la aplicaci&oacute;n funciona tal y como se espera de ella y por &uacute;ltimo, el <em>entorno de producci&oacute;n</em>, que es donde aparecen en escena los usuarios finales, que son quienes realmente probar&aacute;n el buen funcionamiento de la aplicaci&oacute;n.
</p>
<p>
	En cada uno de estos entornos, lo habitual es tener una configuraci&oacute;n diferente para cada uno, puesto que los requerimientos ser&aacute;n distintos. Por ejemplo, en un entorno de desarrollo posiblemente nos sea suficiente utilizar una base de datos en memoria como HSQLDB, pero probablemente para los entornos de test y producci&oacute;n es m&aacute;s que probable que este tipo de bases de datos no nos sirvan y tengamos que utilizar un servidor de base de datos como por ejemplo MySQL.
</p>
<p>
	Como no pod&iacute;a ser menos, Grails lo tiene todo preparado para realizar esta diferenciaci&oacute;n sin problemas. El archivo <em>grails-app/conf/DataSource.groovy</em> se encarga de todo mediante la creaci&oacute;n por defecto de tres entornos de desarrollo: <em>desarrollo, test y producci&oacute;n</em>, tal y como puedes comprobar en el siguiente ejemplo.
</p>
<pre class="code">dataSource {
	pooled = true
	driverClassName = "org.hsqldb.jdbcDriver"
	username = "sa"
	password = ""
}
hibernate {
    cache.use_second_level_cache=true
    cache.use_query_cache=true
    cache.provider_class='com.opensymphony.oscache.hibernate.OSCacheProvider'
}
// environment specific settings
environments {
	development {
		dataSource {
			dbCreate = "create-drop" // one of 'create', 'create-drop','update'
			url = "jdbc:hsqldb:mem:devDB"
		}
	}
	test {
		dataSource {
			dbCreate = "update"
			url = "jdbc:hsqldb:mem:testDb"
		}
	}
	production {
		dataSource {
		    pooled = true
		    dbCreate = "update"
		    url = "jdbc:mysql://localhost/biblioteca"
		    driverClassName = "com.mysql.jdbc.Driver"
		    username = "user_biblioteca"
		    password = "pwdbiblio"
		}
	}
}</pre>
<p>
	En el primer bloque <em>dataSource</em> se definen una serie de valores gen&eacute;ricos, que posteriormente podremos sobreescribir en cada uno de los entornos. El bloque <em>hibernate</em> se refiere a par&aacute;metros de configuraci&oacute;n del propio hibernate, mientras que el &uacute;ltimo bloque de <em>environments</em> es el que nos va a permitir diferenciar cada uno de los entornos.
</p>
<p>
	Por defecto Grails crea los tres entornos de los que habl&aacute;bamos anteriormente. Con el comando <span class="codefrag">grails run-app</span> que hemos utilizado hasta ahora, la aplicaci&oacute;n se ejecuta en el entorno de desarrollo, que es el utilizado por defecto, pero si quisi&eacute;ramos utilizar otro entorno podr&iacute;amos ejecutar los comandos de la siguiente tabla:
</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
	
<tr>
		
<th colspan="1" rowspan="1">Entorno</th>
		<th colspan="1" rowspan="1">Comando</th>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">Desarrollo</td>
		<td colspan="1" rowspan="1"><span class="codefrag">grails dev run-app</span> o <span class="codefrag">grails run-app</span></td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">Test</td>
		<td colspan="1" rowspan="1"><span class="codefrag">grails test run-app</span></td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">Producci&oacute;n</td>
		<td colspan="1" rowspan="1"><span class="codefrag">grails prod run-app</span></td>
	
</tr>

</table>
<p>
	En el fichero <em>DataSource.groovy</em> se puede comprobar las tres configuraciones para cada uno de los entornos. Para los entornos de desarrollo y test se va a utilizar una base de datos en memoria como HSQLDB, eso si, diferente para cada uno de ellos (<em>devDB</em> y <em>testDb</em>).  
</p>
<p>
	Para el entorno de producci&oacute;n vamos a utilizar una base de datos m&aacute;s robusta y propia de entornos de producci&oacute;n como es MySQL. Para ello le especificamos la URI de la base de datos, as&iacute; como el controlador, el nombre de usuario y la contrase&ntilde;a de acceso a la misma.
</p>
<p>
	Adem&aacute;s, mediante el par&aacute;metro <em>dbCreate</em> podemos especificar la forma en la que Grails debe generar el esquema de la base de datos a partir de la definici&oacute;n de las clases de dominio. Este par&aacute;metro puede tomar tres valores diferentes:
</p>
<ul>
	
<li>
<span class="codefrag">create-drop</span>. El esquema de la base de datos se crear&aacute; cada vez que arranquemos la aplicaci&oacute;n en el entorno dado, y ser&aacute; destruido al interrumpir su ejecuci&oacute;n.</li>
	
<li>
<span class="codefrag">create</span>. Crea el esquema de la base de datos, en caso de que el &eacute;ste no exista, pero no modifica el esquema existente, aunque si borrar&aacute; todos los datos almacenados en la misma.</li>
	
<li>
<span class="codefrag">update</span>. Crea la base de datos si no existe, y actualiza las tablas si detecta que se han a&ntilde;adido entidades nuevas o campos a los ya existentes. Estas modificaciones no incluir&aacute;n la eliminaci&oacute;n o modificaci&oacute;n de nada en la base de datos, con lo que hay que tener cuidado con este tipo de cambios en las clases de dominio y que luego no se ven reflejados autom&aacute;ticamente en la base de datos.</li>
	
<li>
<span class="codefrag">validate</span>. Simplemente compara nuestro esquema actual con la base de datos especificada para enviarnos alg&uacute;n que otro aviso de diferencia.</li>
	
<li>
<span class="codefrag">cualquier otro valor</span>. Si especificamos cualquier otro valor, Grails no har&aacute; nada por nosotros. No debemos especificar ning&uacute;n valor a la variable <em>dbCreate</em> si nos encargaremos de la base de datos nosotros mismos mediante una herramienta externa.</li>

</ul>
<a name="N10112"></a><a name="El+archivo+BootStrap.groovy"></a>
<h3 class="underlined_5">El archivo BootStrap.groovy</h3>
<p>
	A lo largo de las sesiones relativas a Grails, hemos utilizado un archivo de configuraci&oacute;n llamado <em>BootStrap.groovy</em> para insertar ciertos datos de ejemplo en nuestra aplicaci&oacute;n que nos han servido para comprobar su funcionamiento.
</p>
<p>
	El archivo define dos closures, <span class="codefrag">init</span> y <span class="codefrag">destroy</span>. El primero de ellos se ejecutar&aacute; cada vez que ejecutemos la aplicaci&oacute;n mediante el comando <span class="codefrag">grails run-app</span> en cualquiera de los entornos de ejecuci&oacute;n recientemente comentados. Mientras que el closure <span class="codefrag">destroy</span> se ejecutar&aacute; cuando paremos la ejecuci&oacute;n de la aplicaci&oacute;n.
</p>
<p>
	Hasta el momento, cuando hemos insertado los datos en la base de datos, lo hac&iacute;amos independientemente del entorno de ejecuci&oacute;n en el que estuvi&eacute;ramos, algo que no ser&aacute; lo habitual, puesto que para los entornos de test y producci&oacute;n, es m&aacute;s que probable que los datos ya est&eacute;n almacenados en la base de datos o bien se inserten mediante una bater&iacute;a de pruebas.
</p>
<p>
	Teniendo en cuesta esto, necesitaremos diferenciar en cada momento el entorno de ejecuci&oacute;n de nuestra aplicaci&oacute;n para insertar datos o no. Para ello, Grails dispone del paquete <span class="codefrag">grails.util.GrailsUtil</span> y la variable <span class="codefrag">GrailsUtil.environment</span> que nos indica cual es el entorno de ejecuci&oacute;n actual. El siguiente c&oacute;digo de ejemplo, muestra como realizar esta distinci&oacute;n a la hora de insertar datos en diferentes entornos.
</p>
<pre class="code">import grails.util.GrailsUtil

class BootStrap {
	def init = { servletContext -&gt; 
		switch (GrailsUtil.environment){
			case "development": configuracionDesarrollo()
				break;
			case "test":configuracionTest()
				break;
			case "production":configuracionProduccion()
				break;
		}
	}
	def destroy = {
		switch (GrailsUtil.environment){
			case "development": salirDesarrollo()
				break;
			case "test":salirTest()
				break;
			case "production":salirProduccion()
				break;
		}
	}
}</pre>
<a name="N1013E"></a><a name="El+archivo+UrlMappings.groovy"></a>
<h3 class="underlined_5">El archivo UrlMappings.groovy</h3>
<p>
	Otro de los archivos interesantes en la configuraci&oacute;n de una aplicaci&oacute;n Grails es <em>UrlMappings.groovy</em>. Gracias a este archivo vamos a poder definir nuevas relaciones entre las URLs y los controladores.
</p>
<p>
	Por defecto, este archivo indica que el primer par&aacute;metro que sigue al nombre de la aplicaci&oacute;n se refiere al controlador, el segundo a la acci&oacute;n y el tercero al identificador de la instancia de la clase de dominio que estamos tratando.
</p>
<pre class="code">class UrlMappings {
   static mappings = {
      "/$controller/$action?/$id?"{
	      constraints {
			 // apply constraints here
		  }
	  }
      "/"(view:"/index")
      "500"(view:'/error')
   }
}</pre>
<p>
	Un ejemplo t&iacute;pico del uso del mapeo de URLs es modificar este comportamiento para permitir otras URLs m&aacute;s limpias. Por ejemplo, si en nuestra aplicaci&oacute;n escribi&eacute;ramos algo como http://localhost:8080/biblioteca/libro/3, desear&iacute;amos ver lo mismo que si escribi&eacute;semos http://localhost:8080/biblioteca/libro/show/3, es decir, querr&iacute;amos ver los datos del libro que tenga el identificador 3.
</p>
<p>
	Para ello, podemos introducir una nueva regla en el archivo <em>UrlMappings.groovy</em> para que la aplicaci&oacute;n sepa como actuar cuando le llegue una petici&oacute;n con una URL del estilo de la comentada. La siguiente regla se encargar&iacute;a de este redireccionamiento encubierto.
</p>
<pre class="code">"/libro/$id"(controller:"libro",action:"show")</pre>
<p>
	O bien podemos optar por una sintaxis diferente.
</p>
<pre class="code">"/libro/$id"{
      controller = "libro"
      action = "show"
}</pre>
<p>
	En primer lugar le especificamos la parte de la URL a partir del nombre de la aplicaci&oacute;n que necesitamos que concuerde y despu&eacute;s definimos que controlador y que acci&oacute;n se deben encargar de procesar esta petici&oacute;n.
</p>
<p>
	Otra posible utilidad del mapeo de URLs es la internacionalizaci&oacute;n de las URLs. Por ejemplo, en nuestra aplicaci&oacute;n hemos definido las clases de dominio en castellano y por lo tanto las URLs se muestran tambi&eacute;n en castellano. Si deseamos que estas URLs se muestren tambi&eacute;n en ingl&eacute;s, podemos crear una serie de reglas en el archivo <em>UrlMappings.groovy</em>.
</p>
<pre class="code">"/book/$action/$id"{
      controller = "libro"
}

"/user/$action/$id"{
      controller = "usuario"
}

"/operation/$action/$id"{
      controller = "operacion"
}</pre>
<p>
	Las reglas de mapeo tambi&eacute;n permiten la introducci&oacute;n de restricciones que deben cumplir las partes de la URL. Por ejemplo, algo t&iacute;pico de los blogs es mostrar la direcci&oacute;n de un art&iacute;culo con la fecha (a&ntilde;o y mes) en la que fue publicado seguido del identificador del art&iacute;culo, como por ejemplo, http://localhost/blog/2009/06/2. Las restricciones que debe cumplir la URL son que el a&ntilde;o debe ser una cifra de cuatro d&iacute;gitos mientras que el mes debe estar compuesta por dos n&uacute;meros. Para que la aplicaci&oacute;n supiera que hacer con este tipo de direcciones debemos introducir la siguiente regla de mapeo.
</p>
<pre class="code">"/blog/$anyo/$mes/$id" {
	controller = "blog"
	action = "show"
	constraints {
		anyo(matches:/d{4}/)
		mes(matches:/d{2}/)
	}	
}</pre>
<p>
	Otro aspecto interesante del mapeo de URLs puede ser la captura de los c&oacute;digos de error que se producen en el acceso a una aplicaci&oacute;n web, como por ejemplo el t&iacute;pico error 404 cuando la p&aacute;gina solicitada no existe. En este tipo de casos, estar&iacute;a bien modificar la t&iacute;pica pantalla de este tipo de errores, por otra en que se mostrar&aacute; informaci&oacute;n sobre nuestra aplicaci&oacute;n, como por ejemplo un mapa de todas las opciones de la aplicaci&oacute;n. Para controlar la informaci&oacute;n mostrada al producirse estos errores, podemos a&ntilde;adir lo siguiente en el archivo <em>UrlMapping.groovy</em> <span class="codefrag">"404"(view:'/error')</span> para que sea una p&aacute;gina GSP quien se encargue de esta gesti&oacute;n o bien <span class="codefrag">"404"(controller:'errores', action:'notFound')</span>, para que sea un controlador quien haga este trabajo.
</p>
</div>

<a name="N10187"></a><a name="Empaquetamiento+de+aplicaciones"></a>
<h2 class="underlined_10">Empaquetamiento de aplicaciones</h2>
<div class="section">
<p>
	Al terminar una nueva funcionalidad de una aplicaci&oacute;n o una nueva versi&oacute;n de la misma, necesitamos generar el paquete <em>WAR</em> correspondiente a la nueva versi&oacute;n para desplegarla en el servidor de destino.
</p>
<p>
	La generaci&oacute;n del archivo <em>WAR</em> se realiza simplemente ejecutando el comando <span class="codefrag">grails war</span>, el cual nos generar&aacute; un archivo con extensi&oacute;n <em>.war</em> con el nombre de la aplicaci&oacute;n, en nuestro caso <em>biblioteca</em>, seguido de la versi&oacute;n de la aplicaci&oacute;n. En nuestro caso, la primera vez que ejecutemos el comando <span class="codefrag">grails war</span> el fichero generado se llamar&aacute; <em>biblioteca-0.1.war</em>.
</p>
<p>
	Esto ser&iacute;a lo m&aacute;s b&aacute;sico para generar el archivo <em>WAR</em> de la aplicaci&oacute;n, sin embargo, lo habitual es hacer alguna cosa m&aacute;s, tal y como se muestra en el siguiente listado.
</p>
<ol>
	
<li>Actualizar el c&oacute;digo fuente del repositorio de control de versiones para asegurarse de que todas las partes del proyecto est&aacute;n actualizadas</li>
	
<li>Ejecutar los tests de integraci&oacute;n, unitarios y funcionales que hayamos implementado para comprobar que todo funciona tal y como esperamos</li>
	
<li>Incrementar la variable <em>app.version</em> del archivo <em>application.properties</em> manualmente o bien mediante el comando <span class="codefrag">grails set-version 0.2</span>
</li>
	
<li>Limpiar el proyecto de archivos temporales mediante el comando <span class="codefrag">grails clean</span>
</li>
	
<li>Generar el archivo <em>WAR</em> indic&aacute;ndole el entorno donde queremos desplegar este <em>WAR</em>. Por ejemplo, el comando <span class="codefrag">grails prod war</span> crear&iacute;a un archivo <em>WAR</em> para ser desplegado en nuestro entorno de producci&oacute;n.</li>

</ol>
<p>
	Una aplicaci&oacute;n Grails empaquetada como un archivo <em>WAR</em> puede ser desplegada en servidores de aplicaciones JAVA EE tales como <a class="external" href="http://www.jboss.org/">JBoss</a>, <a class="external" href="https://glassfish.dev.java.net/">GlassFish</a>, <a class="external" href="http://geronimo.apache.org">Apache Geronimo</a>, <a class="external" href="http://www.bea.com">BEA WebLogic</a> o <a class="external" href="http://www.ibm.com/software/websphere">IBM WebSphere</a> o incluso en un contenedor web como <a class="external" href="http://tomcat.apache.org">Apache Tomcat</a> o <a class="external" href="http://www.mortbay.com">Jetty</a>. Cada uno de estos servidores o contenedores tendr&aacute;n su propia especificaci&oacute;n y forma de desplegar los archivos <em>WAR</em> generados. Unos mediante unos directorios especiales donde copiar los <em>WAR</em>, otros mediante una consola basada en web, otros por l&iacute;nea de comandos e incluso mediante tareas de tipo Ant. En la secci&oacute;n <a class="external" href="http://www.grails.org/Deployment">Deployment</a> de la web oficial de Grails puedes encontrar informaci&oacute;n sobre como desplegar los archivos <em>WAR</em> en varios servidores.
</p>
<p>
	Como puedes observar, la variedad de servidores donde se pueden desplegar los archivos <em>WAR</em> generados es muy elevada. Quiz&aacute;s sea ese el motivo por el que no existen ning&uacute;n comando <span class="codefrag">grails deploy</span>, pero nosotros vamos a crear nuestro propio script para realizar esta tarea.
</p>
<p>
	Si nos fijamos cuando ejecutamos cualquiera de los comandos vistos hasta ahora, por ejemplo el &uacute;ltimo del que hemos hablado <span class="codefrag">grails war</span>, en la l&iacute;nea de comandos se nos muestra una serie de datos, y pr&aacute;cticamente la primera de ellas nos indica que script se est&aacute; ejecutando mediante el comando en cuesti&oacute;n. En el caso de <span class="codefrag">grails war</span>, podemos ver como se ejecuta el comando <em>War.groovy</em> que est&aacute; ubicado en el directorio <em>scripts</em> del directorio donde est&aacute; instalado Grails.
</p>
<p>
	Si abrimos este directorio, podemos comprobar la existencia de una serie de archivos con extensi&oacute;n <em>.groovy</em> que coinciden con las opciones que tenemos con el comando <span class="codefrag">grails</span>. Con esto tenemos, que si creamos cualquier script dentro de este directorio, vamos a poder ejecutarlo en l&iacute;nea de comandos. Pero no s&oacute;lo tenemos este directorio para copiar nuestros scripts sino que tambi&eacute;n vamos a poder ubicarlos en <em>USER_HOME/.grails/scripts</em>, <em>PROJECT_HOME/scripts</em>, <em>PROJECT_HOME/plugins/*/scripts/</em> o en <em>GRAILS_HOME/scripts</em>.
</p>
<p>
	Lo que vamos a hacer ahora, es crear un nuevo script en el directorio <em>scripts</em> de nuestra aplicaci&oacute;n para que el proceso de despliegue de una aplicaci&oacute;n en un servidor no sea tan traum&aacute;tica como en ocasiones puede llegar a ser. En este script vamos a suponer que la aplicaci&oacute;n se va a desplegar en un servidor JBoss, el cual permite el despliegue autom&aacute;tico de aplicaciones simplemente copiando el archivo <em>WAR</em> en un directorio especial de despliegue.
</p>
<p>
	Grails dispone nuevamente de un comando para realizar esta acci&oacute;n que en este caso ser&aacute; <span class="codefrag">grails create-script Deploy</span>.
</p>
<pre class="code">includeTargets &lt;&lt; grailsScript("War")

target(deploy: "Despliegue del archivo war generado en un servidor jboss") {
    depends(war)

    def deployDir = "jbossserver"

    ant.copy(todir:"${deployDir}", overwrite:true) {
        fileset(dir:"target", includes:"*.war")
    }
    
    event("StatusFinal", ["Archivo WAR copiado en ${deployDir}"])
}

setDefaultTarget(deploy)</pre>
<p>
	En primer lugar se ejecuta el comando para generar un archivo <em>WAR</em> de la aplicaci&oacute;n y posteriormente se copia este archivo al directorio indicado en la variable <em>deployDir</em>. Ahora ya podremos ejecutar el comando <span class="codefrag">grails deploy</span> para desplegar el archivo war generado en el directorio correspondiente. Comentar tambi&eacute;n que si quisi&eacute;ramos disponer de este nuevo script en todos nuestros proyectos de Grails deber&iacute;amos haberlo copiado en el directorio <em>$GRAILS_HOME/scripts</em> en lugar de en el directorio <em>scripts</em> de nuestro proyecto.
</p>
</div>


<a name="N10258"></a><a name="Actualizaci%C3%B3n+de+aplicaciones"></a>
<h2 class="underlined_10">Actualizaci&oacute;n de aplicaciones</h2>
<div class="section">
<p>
	Desde los inicios de Grails, se vio claramente que, con las constantes actualizaciones del framework, se hac&iacute;a necesario un m&eacute;todo para actualizar la versi&oacute;n de Grails instalada sin que aquello provocara mayor problema. Como la mayor&iacute;a de partes en Grails, esto se soluciona por medio de un comando, en este caso <span class="codefrag">grails upgrade</span>.
</p>
<p>
	Cuando ejecutamos el comando <span class="codefrag">grails run-app</span> sobre una aplicaci&oacute;n, Grails comprueba que la versi&oacute;n de Grails instalada coincida con la que se indica en el archivo ubicado en la raiz del proyecto <em>application.properties</em> y en caso de no ser as&iacute;, se mostrar&iacute;a un mensaje de advertencia indic&aacute;ndonos que debemos actualizar la versi&oacute;n de Grails con el comando <span class="codefrag">grails upgrade</span>.
</p>
</div>

<a name="N10271"></a><a name="Tareas+programadas+con+Quartz"></a>
<h2 class="underlined_10">Tareas programadas con Quartz</h2>
<div class="section">
<p>
	Una de las partes habituales de cualquier aplicaci&oacute;n web es la ejecuci&oacute;n programada de determinadas tareas o scripts. Esta tareas deben ser lanzadas sistem&aacute;ticamente a determinadas horas del d&iacute;a o cada cierto intervalo de tiempo. En la mayor&iacute;a de ocasiones este tipo de sistemas suelen quedarse fuera de la propia aplicaci&oacute;n, tal y como ocurre con Apache y el crontab de linux, lo que lo hace poco aconsejable cuando llega el momento de exportar el proyecto a otros servidores.
</p>
<p>
	Para solucionar esta falta de integraci&oacute;n entre las tareas programadas y el proyecto de aplicaci&oacute;n, Grails dispone del plugin <a class="external" href="http://grails.org/Quartz+plugin">Quartz</a>, que permite la planificaci&oacute;n de estas tareas insert&aacute;ndolas en una clase de nuestra aplicaci&oacute;n. 
</p>
<p>
	Empecemos como siempre instalando este plugin. Para ello debemos ejecutar el comando <span class="codefrag">grails install-plugin quartz</span>. Una vez instalado el plugin, tendremos la posibilidad de utilizar dos nuevos comandos que se habr&aacute;n agregado a la lista de posibles comandos de Grails, <span class="codefrag">grails create-job</span> o <span class="codefrag">grails install-quartz-config</span>.
</p>
<p>
	Con el comando <span class="codefrag">grails install-quartz-config</span> vamos a poder configurar dos par&aacute;metros del plugin. Cuando ejecutemos este comando, se crear&aacute; un archivo de configuraci&oacute;n en el directorio de nuestra aplicaci&oacute;n <em>grails-app/conf</em> llamado <em>QuartzConfig.groovy</em> y que nos permitir&aacute; controlar una serie de variables.
</p>
<pre class="code">quartz {
    autoStartup = true
    jdbcStore = false
    waitForJobsToCompleteOnShutdown = true
}

environments {
    test {
        quartz {
            autoStartup = false
        }
    }
}</pre>
<p>
La variable <span class="codefrag">autoStartup</span> indica si cuando arranque la aplicaci&oacute;n arrancar&aacute; tambi&eacute;n la ejecuci&oacute;n de Quartz. Su valor por defecto es <span class="codefrag">true</span>. La variable <span class="codefrag">jdbcStore</span> indica si los trabajos programados deben ser persistidos en la base de datos. Su valor por defecto es <span class="codefrag">false</span>. Por &uacute;ltimo, la variable <span class="codefrag">waitForJobsToCompleteOnShutdown</span> indica si debemos esperar a la finalizaci&oacute;n de los trabajos en el caso de que se apague el servidor. Su valor por defecto es <span class="codefrag">true</span>. Estas variables pueden tener valores diferentes en funci&oacute;n del entorno, algo que nos da mucho margen de maniobra.
</p>
<p>
	El otro comando generado mediante la instalaci&oacute;n del plugin <em>Quartz</em> es <span class="codefrag">grails create-job</span>. Si invocamos este comando, el sistema nos pedir&aacute; el nombre del trabajo que queremos crear y se crear&aacute; una nueva clase en el directorio <em>grails-app/jobs/biblioteca</em> con el nombre dado seguido de la palabra <em>Job</em>. Veamos un ejemplo.
</p>
<pre class="code">package biblioteca

class TareasJob {
    def startDelay = 30000
    def timeout = 1000

    def group = "GrupoDeTareas1"

    def execute(){
        print "Ejecuto la tarea programada!"
    }
}</pre>
<p>
	Aqu&iacute; de nuevo vuelve a aparecer la teor&iacute;a de convenio sobre configuraci&oacute;n de Grails. En esta ocasi&oacute;n, el convenio se refiere a la utilizaci&oacute;n de la variable <span class="codefrag">startDelay</span> para indicarle a la aplicaci&oacute;n cuanto tiempo en milisegundos debe esperar para lanzar la tarea por primera vez (30 segundos en nuestro ejemplo).
</p>
<p>
	Con la variable <span class="codefrag">timeout</span> le indicamos al sistema cuanto tiempo debe esperar en milisegundos para volver a ejecutar la tarea. El m&eacute;todo <span class="codefrag">execute()</span> ser&aacute; el que se ejecute cada vez que lance la tarea. Adem&aacute;s, podemos agrupar las tareas en grupos gracias a la variable <span class="codefrag">group</span>. Si no especificamos ning&uacute;n valor a las variables <span class="codefrag">startDelay</span> y <span class="codefrag">timeout</span>, el valor por defecto que tomar&aacute;n ser&aacute;n 30 y 60 segundos respectivamente. No es conveniente especificar un valor a la variable <span class="codefrag">startDelay</span> por debajo de 30 segundos, ya que la aplicaci&oacute;n debe estar completamente inicializada para empezar a ejecutar las tareas programadas.
</p>
<p>
	En el ejemplo anterior, ve&iacute;amos como pod&iacute;amos ejecutar una tarea programada indic&aacute;ndole al sistema cada cuanto tiempo debe ejecutarse mediante las variables <span class="codefrag">startDelay</span> y <span class="codefrag">timeout</span>. Sin embargo, existe otra forma m&aacute;s conocida sobre todo entre la gente que utiliza Linux como son las expresiones de tipo <em>cron</em>. Con una expresi&oacute;n de este tipo vamos a poder especificarle al sistema que los d&iacute;as 28 de cada mes se ejecute una determinada tarea o que todos los d&iacute;as a las 17:30 queremos hacer una determinada acci&oacute;n.
</p>
<p>
	El siguiente ejemplo muestra el c&oacute;digo de una nueva tarea programada que se ejecutar&iacute;a todos los d&iacute;as a las 15h.
</p>
<pre class="code">package biblioteca
	
class TareasCronJob  {
 def cronExpression = "0 0 15 * * ?"

 def group = "GrupoDeTareas1"

 def execute(){
   print "Ha llegado la hora!"
 }
}</pre>
<p>
	Las expresiones de tipo cron tienen 6 campos obligatorios m&aacute;s uno opcional. Por orden de aparici&oacute;n, los campos de una expresi&oacute;n tipo cron tienen el siguiente significado:
</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
	
<tr>
		
<th colspan="1" rowspan="1">Campo</th>
		<th colspan="1" rowspan="1">Valores permitidos</th>
		<th colspan="1" rowspan="1">Valores especiales permitidos</th>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">Segundos</td>
		<td colspan="1" rowspan="1">0-59</td>
		<td colspan="1" rowspan="1">, - * /</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">Minutos</td>
		<td colspan="1" rowspan="1">0-59</td>
		<td colspan="1" rowspan="1">, - * /</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">Horas</td>
		<td colspan="1" rowspan="1">0-23</td>
		<td colspan="1" rowspan="1">, - * /</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">D&iacute;a del mes</td>
		<td colspan="1" rowspan="1">1-31</td>
		<td colspan="1" rowspan="1">, - * ? / L W</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">Mes</td>
		<td colspan="1" rowspan="1">1-12 o JAN-DEC</td>
		<td colspan="1" rowspan="1">, - * /</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">D&iacute;a de la semana</td>
		<td colspan="1" rowspan="1">1-7 o SUN-SAT (la semana empieza los domingos)</td>
		<td colspan="1" rowspan="1">, - * ? / L #</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">A&ntilde;o (opcional)</td>
		<td colspan="1" rowspan="1">1970-2099</td>
		<td colspan="1" rowspan="1">, - * /</td>
	
</tr>

</table>
<ul>
	
<li>El car&aacute;cter '*' se especifica para indicar todos los valores. Por ejemplo, si ponemos un '*' en el campo minutos, se indica que se debe ejecutar la tarea cada minuto</li>
	
<li>El car&aacute;cter '?' indica que no se especifica ning&uacute;n valor determinado</li>
	
<li>El car&aacute;cter '-' se utiliza para especificar rangos. Por ejemplo, si indicamos en la hora el rango '10-12' le estamos indicando al sistema que la tarea se debe ejecutar a las 10, a las 11 y a las 12</li>
	
<li>El car&aacute;cter ',' se utiliza para especificar valores adicionales. Por ejemplo, podemos indicar que los lunes, martes y mi&eacute;rcoles se debe ejecutar determinada tarea especificando el valor '2,3,4' (recuerda que la semana empieza los domingos)</li>
	
<li>El car&aacute;cter '/' se utiliza para especificar incrementos. Por ejemplo, si especificamos en el campo minuto el valor '0/15', la tarea se ejecutar&aacute; en los minutos 0, 15, 30 y 45 de cada hora. Utilizar el car&aacute;cter '*' antes del car&aacute;cter '/' es equivalente a especificar como valor inicial el 0.</li>
	
<li>El car&aacute;cter 'L' es el m&eacute;todo abreviado de <em>last</em> (&uacute;ltimo), pero en los dos campos donde este car&aacute;cter est&aacute; permitido tiene un significado diferente en cada uno de ellos. Si especificamos el valor 'L' en el campo d&iacute;a del mes, estaremos indic&aacute;ndole el &uacute;ltimo d&iacute;a del m&eacute;s (28, 29, 30 o 31). Si indicamos 'L' en el campo d&iacute;a de la semana, significar&aacute; el &uacute;ltimo d&iacute;a de la semana, o sea el s&aacute;bado. Pero si utilizamos este car&aacute;cter en el campo d&iacute;a de la semana seguido de otro valor, por ejemplo '6L', esto significar&aacute; el &uacute;ltimo viernes de cada mes.</li>
	
<li>El car&aacute;cter 'W' solamente se permite en el campo d&iacute;a del mes y se utiliza para especificar el pr&oacute;ximo d&iacute;a de entre semana m&aacute;s cercano a un valor especificado. Por ejemplo, si indicamos '15W' se indicar&aacute; el d&iacute;a de lunes a viernes m&aacute;s cercano al d&iacute;a 15 de cada mes. Si el 15 de un mes fuera s&aacute;bado, la tarea programada se ejecutar&iacute;a el lunes 17 de ese mes.</li>
	
<li>El car&aacute;cter '#' s&oacute;lo se permite para el campo d&iacute;a de la semana. Especificando el valor '6#3' estar&iacute;amos especificando que queremos ejecutar la tarea el tercer viernes de cada mes.</li>

</ul>
<p>
	A continuaci&oacute;n tenemos algunos ejemplos de expresiones de tipo cron
</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
	
<tr>
		
<th colspan="1" rowspan="1">Expresi&oacute;n</th>
		<th colspan="1" rowspan="1">Significado</th>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">0 0 12 * * ?</td>
		<td colspan="1" rowspan="1">Todos los d&iacute;as a las 12h</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">0 15 10 * * ? *</td>
		<td colspan="1" rowspan="1">Todos los d&iacute;as a las 10:15h</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">0 15 10 * * ? 2009</td>
		<td colspan="1" rowspan="1">Todos los d&iacute;as a las 10:15h en el 2009</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">0 * 14 * * ?</td>
		<td colspan="1" rowspan="1">Cada minuto desde las 14:00h hasta las 14:59h</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">0 0/5 14,18 * * ?</td>
		<td colspan="1" rowspan="1">Cada 5 minutos desde las 14:00h hasta las 14:59h y cada 5 minutos desde las 18:00h hasta las 18:59h</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">0 15 10 ? * MON-FRI</td>
		<td colspan="1" rowspan="1">Cada lunes, martes, mi&eacute;rcoles, jueves y viernes a las 10:15h</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">0 15 10 L * ?</td>
		<td colspan="1" rowspan="1">El &uacute;ltima d&iacute;a del mes a las 10:15h</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">0 15 10 ? * 6L</td>
		<td colspan="1" rowspan="1">El &uacute;ltimo viernes de cada mes a las 10:15h</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1">0 15 10 ? * 6#3</td>
		<td colspan="1" rowspan="1">El tercer viernes de cada mes a las 10:15h</td>
	
</tr>

</table>
<p>
	Una vez visto las expresiones cron, veamos como ejecutar m&uacute;ltiples tareas en una sola clase. Para ello, debemos configurar la variable <span class="codefrag">triggers</span> y podemos hacerlo de tres formas diferentes.
</p>
<ul>
	
<li>
<em>simpleTrigger</em>, especificando el tiempo que tarda la tarea en empezar con <span class="codefrag">startDelay</span>, el <span class="codefrag">timeout</span> entre ejecuciones y el n&uacute;mero de repeticiones en la variable <span class="codefrag">repeatCount</span>
</li>
	
<li>
<em>cronTrigger</em>, especificando el tiempo que tarda la tarea en empezar con <span class="codefrag">startDelay</span> y una expresi&oacute;n cron</li>
	
<li>
<em>customTrigger</em>, una clase que implementa la interface Trigger y cualquier par&aacute;metro necesario por el trigger</li>

</ul>
<pre class="code">class TareasTriggerJob {
    static triggers = {
        simpleTrigger startDelay:10000, timeout: 30000, repeatCount: 10
        cronTrigger startDelay:10000, cronExpression: '0/6 * 15 * * ?'
        customTrigger claseTrigger:MiClaseTrigger, miParametro:miValor, miOtroParametro:miOtroValor
    }

    def execute() {
        println "Ejecuto una tarea!"
    }
}</pre>
<p>
	Con esta configuraci&oacute;n, la tarea se ejecutar&aacute; 11 veces cada 30 segundos, y adem&aacute;s tambi&eacute;n se ejecutar&aacute; cada 6 segundos desde las 15:00h a las 15:59h. Y por &uacute;ltimo, tambi&eacute;n se ejecutar&iacute;a nuestra propia clase.
</p>
<a name="N10459"></a><a name="Env%C3%ADo+de+notificaciones+autom%C3%A1ticas"></a>
<h3 class="underlined_5">Env&iacute;o de notificaciones autom&aacute;ticas</h3>
<p>
	Si sois miembros de cualquier universidad, supongo que en alguna ocasi&oacute;n habr&eacute;is recibido alg&uacute;n correo electr&oacute;nico procedente de la biblioteca en el que os avisan de que un libro que ten&eacute;is reservado, ya est&aacute; a vuestra disposici&oacute;n para que pas&eacute;is a recogerlo. En otras ocasiones, ese correo electr&oacute;nico se refiere a que ha caducado un pr&eacute;stamos de un libro y que deb&eacute;is devolverlo cuanto antes.
</p>
<p>
	Por supuesto, detr&aacute;s de ese env&iacute;o de correo electr&oacute;nico no hay ninguna persona comprobando las operaciones caducadas o las reservas disponibles, sino que es un proceso autom&aacute;tico y programado.
</p>
<p>
	Aprovechando el servicio de mensajer&iacute;a desarrollado en la sesi&oacute;n 10 y el automatizado de tareas que acabamos de ver gracias al plugin Quartz, vamos a ver como quedar&iacute;a un sistema similar al que hemos comentado.
</p>
<p>
	En primer lugar, vamos a crear una nueva tarea con el comando <span class="codefrag">grails create-job</span> llamado <em>NotificacionOperacion</em>. En esta tarea necesitamos obtener aquellos pr&eacute;stamos caducados cuyo estado sea activo. Una vez obtenidas estas operaciones, enviaremos un correo electr&oacute;nico indic&aacute;ndole al usuario que su pr&eacute;stamo ha caducado y que debe devolver el libro. La tarea programada quedar&iacute;a as&iacute;:
</p>
<pre class="code">class NotificacionOperacionJob  {
    def cronExpression = "0 0 0 * * ?"

    def notificadorService

    def execute(){
    	def operacionesCaducadas = Operacion.findAll("from Operacion as o where o.fechaFin &lt; ? and o.tipo = ? and o.estado = ?", [new Date(), "prestamo", true])
        if (operacionesCaducadas.size()&gt;0){
            operacionesCaducadas.each {
                notificadorService.mandarMails(it.usuario.email,"Aviso de la Biblioteca","El prestamo del libro ${it.libro.titulo} ha caducado")
            }
        }
    }
}</pre>
<p>
	La tarea programada se ejecutar&aacute; todos los d&iacute;as a las 00:00h y en primer lugar, se buscar&aacute;n todas aquellas reservas cuya fecha fin sea anterior a la fecha actual y su estado sea activo. Podemos comprobar el funcionamiento de esta tarea modificando la fecha de lanzamiento de la tarea.
</p>
</div>

<a name="N1047A"></a><a name="Otros+comandos+interesantes+de+Grails"></a>
<h2 class="underlined_10">Otros comandos interesantes de Grails</h2>
<div class="section">
<p>
	A lo largo de todo el curso, han ido apareciendo varios de los comandos m&aacute;s habituales que utilizaremos cuando creemos aplicaciones con Grails. Sin embargo, los comandos vistos hasta ahora no son los &uacute;nicos y es ahora cuando veremos algunos de ellos. Ten en cuenta tambi&eacute;n que cuando instalamos plugins, es posible que tambi&eacute;n se a&ntilde;adan nuevos comandos.
</p>
<p>
	Si ejecutamos el comando <span class="codefrag">grails help</span> veremos un listado con todos los posibles comandos que tenemos disponibles en nuestra instalaci&oacute;n de Grails. La siguiente tabla muestra los comandos m&aacute;s interesantes que no hemos visto hasta ahora.
</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
	
<tr>
		
<th colspan="1" rowspan="1">Comando</th>
		<th colspan="1" rowspan="1">Descripci&oacute;n</th>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails bug-report</span></td>
		<td colspan="1" rowspan="1">Genera un archivo comprimido en ZIP con los archivos fuente de nuestro proyecto para el caso de que queramos informar de un bug</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails clean</span></td>
		<td colspan="1" rowspan="1">Limpia el directorio <em>tmp</em> de nuestra aplicaci&oacute;n. Este comando puede ser combinado con otros comandos como por ejemplo <span class="codefrag">grails clean run-app</span></td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails console</span></td>
		<td colspan="1" rowspan="1">Nos muestra la consola de Groovy que ve&iacute;amos en la primera sesi&oacute;n del curso para que podamos hacer nuestras pruebas.</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails doc</span></td>
		<td colspan="1" rowspan="1">Genera la documentaci&oacute;n completa de nuestro proyecto.</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails help</span></td>
		<td colspan="1" rowspan="1">Muestra un listado de comandos disponibles en Grails. Si le pasamos como par&aacute;metro uno de esos posibles comandos, nos mostrar&aacute; informaci&oacute;n adicional sobre el comando dado. Por ejemplo <span class="codefrag">grails help doc</span></td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails list-plugins</span></td>
		<td colspan="1" rowspan="1">Muestra un listado completo tanto de los plugins disponibles como de los ya instalados en la aplicaci&oacute;n.</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails plugin-info</span></td>
		<td colspan="1" rowspan="1">Muestra la informaci&oacute;n completa del plugin pasado como par&aacute;metro al comando.</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails run-app -https</span></td>
		<td colspan="1" rowspan="1">Ejecuta el comando <span class="codefrag">grails run-app</span> utilizando como servidor Jetty pero sobre un servidor seguro <em>https</em>. El puerto por defecto es 8443 y puede ser modificado a&ntilde;adiendo al comando <span class="codefrag">-Dserver.port.https=&lt;numero_puerto&gt;</span></td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails schema-export</span></td>
		<td colspan="1" rowspan="1">Genera un fichero con las sentencias SQL necesarias para exportar la base de datos.</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails set-version</span></td>
		<td colspan="1" rowspan="1">Establece la versi&oacute;n de la aplicaci&oacute;n. Por ejemplo <span class="codefrag">grails set-version 1.0.4</span></td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails stats</span></td>
		<td colspan="1" rowspan="1">Nos muestra una serie de datos referentes a nuestro proyecto, con respecto al n&uacute;mero de controladores, clases de dominio, servicios, librer&iacute;as de etiquetas, tests de integraci&oacute;n, etc. y al n&uacute;mero de l&iacute;neas totales en cada apartado.</td>
	
</tr>
	
<tr>
		
<td colspan="1" rowspan="1"><span class="codefrag">grails uninstall-plugin</span></td>
		<td colspan="1" rowspan="1">Desinstala el plugin pasado como par&aacute;metro de la aplicaci&oacute;n.</td>
	
</tr>

</table>
<p>
	Pod&eacute;is encontrar un listado completo de todos los comandos disponibles en Grails en la direcci&oacute;n <a class="external" href="http://www.grails.org/Command+Line">http://www.grails.org/Command+Line</a>.
</p>
</div>


<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2010-2011 Depto. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
