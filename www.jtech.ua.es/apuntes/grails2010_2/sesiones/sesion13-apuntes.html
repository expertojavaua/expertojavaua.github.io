<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Web 2.0</title>
<link type="text/css" href="../skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="../skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="../skin/highlight/shCore.js" type="text/javascript"></script><script src="../skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="../skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="../skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="../skin/print.css" rel="stylesheet">
<link type="text/css" href="../skin/profile.css" rel="stylesheet">
<script src="../skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="../skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="../skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="../index.html">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="jtech" src="../images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Groovy&amp;Grails: desarrollo r&aacute;pido de aplicaciones" src="../images/baner_j2ee_der.gif" title="Groovy&amp;Grails: desarrollo r&aacute;pido de aplicaciones"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">Home</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Sesiones</a>
</li>
<li>
<a class="base-not-selected" href="../ejercicios/index.html">Ejercicios</a>
</li>
<li>
<a class="base-not-selected" href="../bibliografia/index.html">Bibliograf&iacute;a</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', '../skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('../skin/images/chapter_open.gif');">Sesiones</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html" title="Introducci&oacute;n a Groovy">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="El lenguaje Groovy">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html" title="Aspectos avanzados en Groovy">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html" title="Librer&iacute;as propias en Groovy">Sesi&oacute;n 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html" title="Introducci&oacute;n a Grails">Sesi&oacute;n 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html" title="Construir la interfaz de usuario (I)">Sesi&oacute;n 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html" title="Controladores">Sesi&oacute;n 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html" title="Construir la interfaz de usuario (II)">Sesi&oacute;n 8</a>
</div>
<div class="menuitem">
<a href="sesion09-apuntes.html" title="Dominios y servicios (I)">Sesi&oacute;n 9</a>
</div>
<div class="menuitem">
<a href="sesion10-apuntes.html" title="Dominios y servicios (II)">Sesi&oacute;n 10</a>
</div>
<div class="menuitem">
<a href="sesion11-apuntes.html" title="Seguridad">Sesi&oacute;n 11</a>
</div>
<div class="menuitem">
<a href="sesion12-apuntes.html" title="Despliegue de aplicaciones">Sesi&oacute;n 12</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 13</div>
</div>
<div class="menuitem">
<a href="sesion14-apuntes.html" title="AJAX">Sesi&oacute;n 14</a>
</div>
<div class="menuitem">
<a href="sesion15-apuntes.html" title="Dos horas para crear twitter">Sesi&oacute;n 15</a>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="../skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion13-apuntes.pdf"><img alt="PDF -icon" src="../skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Web 2.0</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Texto+enriquecido">Texto enriquecido</a>
</li>
<li>
<a href="#Tooltips">Tooltips</a>
</li>
<li>
<a href="#Plugin+de+b%C3%BAsqueda+de+contenido">Plugin de b&uacute;squeda de contenido</a>
</li>
<li>
<a href="#Carga+de+archivos">Carga de archivos</a>
</li>
<li>
<a href="#Exportar+a+varios+formatos">Exportar a varios formatos</a>
</li>
<li>
<a href="#Crear+fuentes+RSS">Crear fuentes RSS</a>
</li>
<li>
<a href="#Librer%C3%ADa+de+etiquetas">Librer&iacute;a de etiquetas</a>
<ul class="minitoc">
<li>
<a href="#Etiquetas+simples">Etiquetas simples</a>
</li>
<li>
<a href="#Etiquetas+l%C3%B3gicas">Etiquetas l&oacute;gicas</a>
</li>
<li>
<a href="#Etiquetas+iteradoras">Etiquetas iteradoras</a>
</li>
<li>
<a href="#Generador+de+c%C3%B3digo+HMTL">Generador de c&oacute;digo HMTL</a>
</li>
</ul>
</li>
</ul>
</div>
         

<p>
	Podemos considerar que nuestra aplicaci&oacute;n est&aacute; bastante avanzada si hablamos de funcionalidad, pero hoy en d&iacute;a, esto no es suficiente y siempre debemos ser capaces de proporcionar algo m&aacute;s. Para eso, en esta sesi&oacute;n vamos a ver como implementar diversas caracter&iacute;sticas de la llamada Web 2.0 en las aplicaciones que generemos con Grails.
</p>

<p>
	En primer lugar veremos como podemos utilizar varios plugins para mejorar la forma en la que los usuarios pueden crear contenido con un formato mejorado en las aplicaciones. Posteriormente veremos como mediante un plugin de Grails vamos a ser capaces de dotar a nuestra aplicaci&oacute;n de un sistema de b&uacute;squedas sin mayores complicaciones. 
</p>

<p>
	Tambi&eacute;n veremos como podemos subir archivos a nuestras aplicaciones para que, por ejemplo, los usuarios puedan subir una foto suya o que los bibliotecarios puedan subir la portada de los libros. Por &uacute;ltimo, veremos como la creaci&oacute;n de librer&iacute;as de etiquetas nos facilita determinadas tareas repetitivas.
</p>


<a name="N10015"></a><a name="Texto+enriquecido"></a>
<h2 class="underlined_10">Texto enriquecido</h2>
<div class="section">
<p>
	Si necesitamos que los usuarios de nuestras aplicaciones sean capaces de introducir c&oacute;digo formateado podemos hacer dos cosas. Una de ellas consiste en permitir que sean ellos mismos quienes introduzcan c&oacute;digo HTML, con los peligros que esto puede conllevar. La segunda opci&oacute;n consiste en utilizar alg&uacute;n editor de texto enriquecido de los existentes como FCK Editor, TinyMCE o un editor tipo Wiki. Nosotros vamos a centrarnos en dotar a nuestra aplicaci&oacute;n la posibilidad de insertar texto formateado por medio del editor FCK Editor.
</p>
<p>
	En Grails tenemos un plugin llamado <a class="external" href="http://www.grails.org/RichUI+Plugin">Rich UI</a> que nos proporciona diversos componentes del tipo Web 2.0 o AJAX, entre las que se encuentra el editor de texto enriquecido FCK. Como siempre, necesitamos instalar dicho plugin y lo haremos mediante el comando <span class="codefrag">grails install-plugin richui</span>. 
</p>
<p>
	Algunos de los componentes que vienen con este plugin requieren de determinadas librer&iacute;as Javascript o CSS, pero no debemos preocuparnos por ello, porque con la instalaci&oacute;n del plugin, estas librer&iacute;as ya se han descargado. Cada vez que queremos utilizar uno de los componentes instalados con el plugin, debemos incluir en los archivos GSP donde vayamos a utilizarlo el siguiente c&oacute;digo
</p>
<pre class="code">&lt;resource: nombreComponente/&gt;</pre>
<p>
	En el caso del editor de texto enriquecido, el nombre del componente es <em>richTextEditor</em> con lo que en las p&aacute;ginas GSP donde vayamos a utilizarlo debemos incluir la sentencia <span class="codefrag">&lt;resource:richTextEditor/&gt;</span>. La etiqueta que implementa un editor de este tipo es <span class="codefrag">&lt;richui:richTextEditor/&gt;</span>, la cual soporta los siguientes atributos:
</p>
<ul>
	
<li>
<em>name</em>, nombre del elemento del formulario. Obligatorio</li>
	
<li>
<em>id</em>, identificador HTML del elemento del formulario. Opcional</li>
	
<li>
<em>value</em>, valor del elemento del formulario. Opcional</li>
	
<li>
<em>height</em>, altura del editor</li>
	
<li>
<em>width</em>, anchura del editor</li>

</ul>
<p>
	Adem&aacute;s, podemos especificar en la etiqueta <span class="codefrag">&lt;resource:richTextEditor /&gt;</span> el tipo de editor que deseamos mediante el atributo <span class="codefrag">type</span>, que puede tomar cualquiera de los valores siguientes:
</p>
<ul>
	
<li>
<em>simple</em>
</li>
	
<li>
<em>medium</em>
</li>
	
<li>
<em>advanced</em>
</li>
	
<li>
<em>full</em>
</li>

</ul>
<p>
	Las siguientes im&aacute;genes muestran ejemplos de como quedar&iacute;an los editores para cada uno de los tipos comentados.
</p>
<p>
	
<img alt="Editor simple" height="161" src="../images/sesion13/richTextEditor_simple.jpg" width="531">
</p>
<p>
	
<img alt="Editor medio" height="170" src="../images/sesion13/richTextEditor_medium.jpg" width="539">
</p>
<p>
	
<img alt="Editor avanzado" height="167" src="../images/sesion13/richTextEditor_advanced.jpg" width="715">
</p>
<p>
	
<img alt="Editor completo" height="220" src="../images/sesion13/richTextEditor_full.jpg" width="685">
</p>
<p>
	Un lugar ideal para probar este editor de texto enriquecido puede ser en la propiedad <em>descripci&oacute;n</em> de la clase de dominio <em>Libro</em>. Para conseguir esto, vamos a tener que modificar los archivos de las vistas <em>create.gsp</em> y <em>edit.gsp</em>. Aqu&iacute; modificaremos s&oacute;lo el archivo <em>edit.gsp</em>, puesto que con <em>create.gsp</em> se actuar&iacute;a de la misma forma.
</p>
<p>
	Abrimos el archivo <em>edit.gsp</em> y modificamos el elemento del formulario relativo a la descripci&oacute;n para que ahora contenga un editor de texto enriquecido, quedando de la siguiente forma:
</p>
<pre class="code">&lt;tr class="prop"&gt;
    &lt;td valign="top" class="name"&gt;
        &lt;label for="descripcion"&gt;Descripcion:&lt;/label&gt;
    &lt;/td&gt;
    &lt;td valign="top" class="value ${hasErrors(bean:libroInstance,field:'descripcion','errors')}"&gt;
        <strong>&lt;richui:richTextEditor name="descripcion" value="${fieldValue(bean:libroInstance, field:'descripcion').decodeHTML()}" width="525" /&gt;</strong>
    &lt;/td&gt;
&lt;/tr&gt;</pre>
<p>
	Adem&aacute;s de la etiqueta correspondiente y rellenar el valor del elemento con el contenido de la propiedad, hemos tenido que decodificar la salida en HTML con la funci&oacute;n <span class="codefrag">decodeHTML()</span> ya que en caso de no haberlo hecho, se hubieran convertido todas los caracteres &lt; y &gt; por &amp;lt; y &amp;gt; y no se hubiera mostrado el texto en formato HTML.
</p>
<p>
	
<img alt="Editor de Texto Enriquecido" height="526" src="../images/sesion13/richtexteditor.jpg" width="640">
</p>
<p>
	Si ahora comprobamos como ha quedado el texto introducido con formato, veremos que &eacute;ste se muestra con las etiquetas HTML, es decir, sin mostrar el formato. Para solucionar este problema, debemos utilizar tambi&eacute;n la funci&oacute;n <span class="codefrag">decodeHTML()</span> en el archivo de la vista <em>show.gsp</em> para que la salida se muestre tal y como queremos.
</p>
<pre class="code">&lt;tr class="prop"&gt;
    &lt;td valign="top" class="name"&gt;Descripcion:&lt;/td&gt;
    
    &lt;td valign="top" class="value"&gt;${fieldValue(bean:libroInstance, field:'descripcion').<strong>decodeHTML()</strong>}&lt;/td&gt;
    
&lt;/tr&gt;</pre>
<p>
	Ahora, deber&iacute;amos hacer lo mismo para cuando se inserta un nuevo libro en la base de datos modificando la vista <em>create.gsp</em>.
</p>
<p>
	El plugin instalado para poder utilizar los editores de texto enriquecidos <em>RichUI</em> tiene adem&aacute;s otras funcionalidades que pueden ser &uacute;tiles para dotar a nuestra aplicaci&oacute;n de mayor interactividad y dinamismmo. En la p&aacute;gina <a class="external" href="http://www.grails.org/RichUI+Plugin">http://www.grails.org/RichUI+Plugin</a> se puede encontrar toda la informaci&oacute;n referente a este plugin.
</p>
</div>

<a name="N100EC"></a><a name="Tooltips"></a>
<h2 class="underlined_10">Tooltips</h2>
<div class="section">
<p>
	Si has visitado la p&aacute;gina del plugin RichUI, habr&aacute;s podido comprobar como este plugin cuenta con otras caracter&iacute;sticas, entre las que se encuentra la posibilidad de a&ntilde;adir <em>tooltips</em> en nuestras p&aacute;ginas. Los tooltips son peque&ntilde;os textos de ayuda que aparecen sobre las im&aacute;genes o los enlaces que habitualmente nos indican el t&iacute;tulo del mismo.
</p>
<p>
	Para utilizar este plugin, al igual que hicimos con el plugin relativo al texto enriquecido, debemos insertar en la cabecera de la p&aacute;gina donde vayamos a utilizarlo la etiqueta correspondiente a esta caracter&iacute;stica. En este caso ser&aacute; <span class="codefrag">&lt;resource:tooltip /&gt;</span>.
</p>
<p>
	Para probar este plugin, vamos a mostrar una ayuda que le indique a un usuario que desee registrarse en el sistema el n&uacute;mero m&iacute;nimo de caracteres que debe tener la contrase&ntilde;a. Para ello, podemos a&ntilde;adir el siguiente contenido en el archivo <em>register.gsp</em> tras el campo de texto de la contrase&ntilde;a.
</p>
<pre class="code">&lt;span id="ayudaPassword" title="La contrase&ntilde;a debe tener al menos 6 caracteres"&gt;
	Ayuda
&lt;/span&gt;
&lt;richui:tooltip id="ayudaPassword" /&gt;</pre>
</div>


<a name="N10109"></a><a name="Plugin+de+b%C3%BAsqueda+de+contenido"></a>
<h2 class="underlined_10">Plugin de b&uacute;squeda de contenido</h2>
<div class="section">
<p>
	Otro aspecto interesante para cualquier aplicaci&oacute;n de este estilo, es dotar a la misma de un buscador que permita localizar f&aacute;cilmente determinada informaci&oacute;n. Para nuestra aplicaci&oacute;n, ser&iacute;a muy interesante que los usuarios pudieran encontrar la informaci&oacute;n de los libros simplemente introduciendo algunas palabras relativas a los mismos.
</p>
<p>
	Para esta tarea de b&uacute;squeda, Grails cuenta tambi&eacute;n con un plugin llamado <em>Searchable</em> que nos va a facilitar much&iacute;simo esta labor. Este plugin adem&aacute;s, est&aacute; basado en el framework <a class="external" href="http://www.opensymphony.com/compass/">OpenSymphony Compass Search Engine</a> y que tiene por detr&aacute;s a Apache Lucene, con lo que el plugin cuenta con mucho respaldo.
</p>
<p>
	Como siempre, lo primero que debemos hacer es instalarlo y para ello debemos ejecutar el comando <span class="codefrag">grails install-plugin searchable</span>. Una vez instalado, podemos comprobar que en la direcci&oacute;n http://localhost:8080/biblioteca/searchable, tenemos un buscador que se ha generado autom&aacute;ticamente. Sin embargo, si probamos a hacer alguna b&uacute;squeda, el buscador nos dir&aacute; que no ha encontrada nada. Esto es porque todav&iacute;a no le hemos dicho al plugin donde debe buscar la informaci&oacute;n.
</p>
<p>
	Como coment&aacute;bamos anteriormente, en nuestra aplicaci&oacute;n vamos a necesitar un buscador de libros para facilitar la labor a los usuarios. Para que el plugin <em>searchable</em> sea capaz de encontrar libros que contengan un determinado texto en su definici&oacute;n, necesitamos modificar la clase de dominio <em>Libro</em> y a&ntilde;adirle una nueva propiedad llamada <span class="codefrag">searchable</span>. Esta propiedad es <em>static</em> y debe contener un valor booleano, con lo que la clase de dominio <em>Libro</em> quedar&iacute;a as&iacute;:
</p>
<pre class="code">class Libro {

    String isbn
    String titulo
    String autor
    String editorial
    Integer anyo
    String descripcion
    Date fecha

    <strong>static searchable = true</strong>
......</pre>
<p>
	Si ahora volvemos a realizar la b&uacute;squeda anterior, el buscador nos devolver&aacute; los resultados en donde haya encontrado alguna coincidencia, tal y como aparece en la siguiente imagen, donde se ha buscado aquellas entradas de libros que coincidan con la palabra <em>hidalgo</em>.
</p>
<p>
	
<img alt="Searchable" height="178" src="../images/sesion13/searchable.jpg" width="689">
</p>
<p>
	Como has podido comprobar, a&ntilde;adir un buscador a nuestra aplicaci&oacute;n ha sido muy r&aacute;pido y sencillo, sin embargo, dicho buscador puede tener una apariencia y un comportamiento que difiera en lo que nosotros est&aacute;bamos buscando.
</p>
<p>
	Para conseguir modificar tanto el comportamiento como la apariencia del plugin, &eacute;ste viene con un controlador y una vista que podemos modificar a nuestro gusto para que se adapte a nuestras necesidades. Nosotros no vamos a meternos tan a fondo y simplemente vamos a ver algunas modificaciones que podemos hacer para afinar la b&uacute;squeda en nuestras clases de dominio.
</p>
<p>
	A&ntilde;adiendo la propiedad <span class="codefrag">static searchable = true</span> a la clase de dominio <em>Libro</em>, estamos permitiendo que <em>searchable</em> busque en cualquier propiedad de la clase, lo que no siempre puede ser lo correcto. En determinadas ocasiones es posible que necesitemos buscar s&oacute;lo en determinadas propiedades de la clase. Para ello, el plugin permite la utilizaci&oacute;n de dos variables con las que le indicaremos al sistema donde puede buscar o donde no.
</p>
<p>
	Estas dos variables son <em>only</em> y <em>except</em> y podemos definirlas de la siguiente forma <span class="codefrag">static searchable = [only: ['titulo', 'autor', 'descripcion']]</span>, para indicarle que debe buscar en las propiedades <em>titulo</em>, <em>autor</em> y <em>descripcion</em> o bien mediante <span class="codefrag">static searchable = [except: 'isbn']</span>, si lo que queremos es indicarle s&oacute;lo aquellas propiedades en las que no debemos realizar la b&uacute;squeda. En este &uacute;ltimo caso, buscaremos en todas las propiedades de la clase de dominio <em>Libro</em> excepto en <em>isbn</em>.
</p>
</div>


<a name="N1017B"></a><a name="Carga+de+archivos"></a>
<h2 class="underlined_10">Carga de archivos</h2>
<div class="section">
<p>
	Otra caracter&iacute;stica interesante, esta quiz&aacute;s no tan 2.0, puede ser la carga de archivos. Para ver como los clientes podr&iacute;an subir archivos a nuestra aplicaci&oacute;n, vamos a crear la posibilidad de que los usuarios suban una imagen con su perfil. Para ello, necesitamos crear una serie de propiedades y restricciones en la clase de dominio <em>Usuario</em>, que quedar&iacute;a de la siguiente forma.
</p>
<pre class="code">class Usuario {
    String login
    String password
    String nombre
    String apellidos
    String tipo
    <strong>byte[] imagen
    String nombreImagen
    String contentTypeImagen</strong>

    ......
    
    static constraints = {
        ....
        <strong>imagen(nullable:true, blank:true)
        nombreImagen(nullable:true, blank:true)
        contentTypeImagen(nullable:true, blank:true)</strong>
    }
    ......
}</pre>
<p>
	En este ejemplo se va a optar por almacenar la imagen directamente en la base de datos, por eso se ha indicado el tipo de dato <em>byte[]</em> para la propiedad <em>imagen</em>. Adem&aacute;s, se han creado tambi&eacute;n un par de nuevos campos para indicar tanto el nombre de la imagen subida como el tipo de la misma.
</p>
<p>
	En primer lugar, vamos a empezar creando el elemento del formulario correspondiente en la p&aacute;gina <em>edit.gsp</em> y modificando el tipo de formulario para que permita la carga de archivos con el atributo <span class="codefrag">enctype="multipart/form-data"</span>. As&iacute; quedar&iacute;an las modificaciones realizadas en el archivo <em>edit.gsp</em>

</p>
<pre class="code">
<strong>&lt;g:form method="post" enctype="multipart/form-data"&gt;</strong>
.....
&lt;tr class="prop"&gt;
    &lt;td valign="top" class="name"&gt;
        &lt;label for="tipo"&gt;&lt;g:message code="usuario.imagen.label" default="Imagen" /&gt;:&lt;/label&gt;
    &lt;/td&gt;
    &lt;td valign="top" class="value ${hasErrors(bean:usuarioInstance,field:'imagen','errors')}"&gt;
        <strong>&lt;input type="file" name="imagen"/&gt;</strong>
    &lt;/td&gt;
&lt;/tr&gt;
.....
&lt;/g:form&gt;</pre>
<p>
	El siguiente paso ser&iacute;a modificar el m&eacute;todo correspondiente en el controlador de la clase <em>Usuario</em> para que almacene la informaci&oacute;n necesaria (<em>contentTypeImagen</em> y <em>nombreImagen</em>). El m&eacute;todo modificado ser&iacute;a <span class="codefrag">update()</span> y las modificaciones quedan resaltadas en negrita en el siguiente fragmento de c&oacute;digo.
</p>
<pre class="code">def update = {
    params.password = DigestUtils.md5Hex(params.password)
    def usuarioInstance = Usuario.get( params.id )
    if(usuarioInstance) {
        if(params.version) {
            def version = params.version.toLong()
            if(usuarioInstance.version &gt; version) {
                
                usuarioInstance.errors.rejectValue("version", "usuario.optimistic.locking.failure", "Another user has updated this Usuario while you were editing.")
                render(view:'edit',model:[usuarioInstance:usuarioInstance])
                return
            }
        }
        <strong>params.contentTypeImagen = params.imagen.contentType
        params.nombreImagen = params.imagen.originalFilename</strong>
        usuarioInstance.properties = params
        if(!usuarioInstance.hasErrors() &amp;&amp; usuarioInstance.save()) {
            flash.message = "usuario.updated.message"
            flash.args = [usuarioInstance.nombre, usuarioInstance.apellidos]
            flash.defaultMsg = "Usuario modificado correctamente"
            redirect(action:show,id:usuarioInstance.id)
        }
        else {
            render(view:'edit',model:[usuarioInstance:usuarioInstance])
        }
    }
    else {
        flash.message = "${message(code: 'default.not.found.message', args: [message(code: 'usuario.label', default: 'Usuario'), params.id])}"
        redirect(action:edit,id:params.id)
    }
}</pre>
<p>
	Simplemente con estas dos modificaciones, nuestra aplicaci&oacute;n va a tener la posibilidad de subir im&aacute;genes correspondientes a los usuarios. Pero, &iquest;c&oacute;mo podemos ver estas im&aacute;genes subidas?. Necesitamos un nuevo m&eacute;todo en el controlador de la clase <em>Usuario</em> que nos muestre estas im&aacute;genes. Vamos a llamar al nuevo m&eacute;todo <span class="codefrag">showImagen()</span>.
</p>
<pre class="code">def showImagen = {
    def usuarioInstance = Usuario.get( params.id )
    response.setHeader("Content-disposition", "inline; filename='${usuarioInstance.nombreImagen}'")
    response.contentType="${usuarioInstance.contentTypeImagen}"
    response.outputStream &lt;&lt; usuarioInstance.imagen
}</pre>
<p>
	Si ahora accedemos a http://localhost:8080/biblioteca/usuario/showImagen/1, el sistema nos mostrar&aacute; la imagen correspondiente al usuario con identificador n&uacute;mero 1. Si en lugar de haber utilizado como <span class="codefrag">Content-disposition</span> el valor <em>inline</em>, hubi&eacute;ramos indicado el valor <em>attachment</em>, el sistema intentar&iacute;a descargar el archivo en lugar de visualizarlo. 
</p>
<p>
	Utilizando este mismo m&eacute;todo, vamos a mostrar esa imagen cuando se edite la informaci&oacute;n del usuario. S&oacute;lo se mostrar&aacute; la imagen en caso de que el usuario haya subido alguna. Esta imagen se mostrar&aacute; junto al elemento de formulario necesario para subir el fichero.
</p>
<pre class="code">&lt;tr class="prop"&gt;
    &lt;td valign="top" class="name"&gt;
        &lt;label for="tipo"&gt;Imagen:&lt;/label&gt;
    &lt;/td&gt;
    &lt;td valign="top" class="value ${hasErrors(bean:usuarioInstance,field:'imagen','errors')}"&gt;
        &lt;input type="file" name="imagen"/&gt;&lt;br/&gt;
        <strong>&lt;g:if test="${usuarioInstance?.contentTypeImagen != '' }"&gt;
            &lt;img src="showImagen/${usuarioInstance?.id}"/&gt;
        &lt;/g:if&gt;</strong>
    &lt;/td&gt;
&lt;/tr&gt;</pre>
</div>

<a name="N101E9"></a><a name="Exportar+a+varios+formatos"></a>
<h2 class="underlined_10">Exportar a varios formatos</h2>
<div class="section">
<p>
	Hoy en d&iacute;a, cualquier aplicaci&oacute;n que se precie debe ser capaz de exportar sus datos a otros formatos para que el usuario tenga la comodidad de elegir como quiere utilizar los datos. Los formatos m&aacute;s comunes a exportar la informaci&oacute;n de nuestra aplicaci&oacute;n ser&aacute; <em>pdf</em>, <em>hojas de c&aacute;lculo excel</em>, <em>csv (datos separados por comas)</em> u <em>ods (la hoja de c&aacute;lculo de OpenOffice)</em>.
</p>
<p>
	Esta tarea que en otros sistemas se vuelve complicada y pesada, en Grails podemos solucionarla utilizando un plugin disponible llamado <em>export</em>. Como siempre, lo primero que vamos a hacer es instalarlo mediante el comando <span class="codefrag">grails install-plugin export</span>.
</p>
<p>
	Una vez instalado el plugin <em>export</em> debemos a&ntilde;adir algunos <em>mime types</em> en la variable <span class="codefrag">grails.mime.types</span> del archivo <em>Config.groovy</em>. Los nuevos <em>mime types</em> ser&aacute;n los relativos a <em>csv</em>, <em>excel</em>, <em>pdf</em> y <em>ods</em>. La variable <span class="codefrag">grails.mime.types</span> quedar&iacute;a as&iacute;:
</p>
<pre class="code">grails.mime.types = [ html: ['text/html','application/xhtml+xml'],
                      xml: ['text/xml', 'application/xml'],
                      text: 'text/plain',
                      js: 'text/javascript',
                      rss: 'application/rss+xml',
                      atom: 'application/atom+xml',
                      css: 'text/css',
                      <strong>pdf: 'application/pdf',
                      excel: 'application/vnd.ms-excel',
                      ods: 'application/vnd.oasis.opendocument.spreadsheet',
                      csv: 'text/csv',</strong>
                      all: '*/*',
                      json: ['application/json','text/json'],
                      form: 'application/x-www-form-urlencoded',
                      multipartForm: 'multipart/form-data'
                    ]</pre>
<p>
	Para empezar a utilizar el plugin, debemos incluir la etiqueta <span class="codefrag">&lt;export:resource/&gt;</span> en la cabecera del archivo GSP donde queramos incluir las opciones para exportar. Esto incluir&aacute; los archivos CSS necesarios para crear una barra de herramientas con las opciones para exportar la p&aacute;gina actual.
</p>
<p>
	El siguiente paso consistir&aacute; en incluir la barra de herramientas necesaria para exportar la p&aacute;gina HTML generada a alg&uacute;n formato de los ya comentados. Para esto el plugin pone a nuestra disposici&oacute;n una nueva etiqueta <span class="codefrag">&lt;export:formats /&gt;</span>, la cual acepta como par&aacute;metro un listado de los formatos a los que queremos exportar la p&aacute;gina, como por ejemplo <span class="codefrag">&lt;export:formats formats="['csv','excel','ods','pdf','xml']"/&gt;</span>.
</p>
<p>
	Si queremos a&ntilde;adir por ejemplo en la p&aacute;gina que contiene el listado de libros una barra para exportar dicho listado, podr&iacute;amos tener algo as&iacute; en la p&aacute;gina <em>grails-app/views/libro/list.gsp</em>.
</p>
<pre class="code">&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/&gt;
        &lt;meta name="layout" content="main" /&gt;
        &lt;g:javascript library="scriptaculous"/&gt;
        <strong>&lt;export:resource /&gt;</strong>
        &lt;title&gt;Libro List&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="nav"&gt;
            &lt;span class="menuButton"&gt;&lt;a class="home" href="${createLinkTo(dir:'')}"&gt;Home&lt;/a&gt;&lt;/span&gt;
            &lt;span class="menuButton"&gt;&lt;g:link class="create" action="create"&gt;New Libro&lt;/g:link&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="body"&gt;
            &lt;h1&gt;Libro List&lt;/h1&gt;
            &lt;g:if test="${flash.message}"&gt;
            &lt;div class="message"&gt;${flash.message}&lt;/div&gt;
            &lt;/g:if&gt;
            <strong>&lt;export:formats formats="['csv', 'excel', 'ods', 'pdf', 'xml']" /&gt;</strong>
            &lt;div class="list"&gt;
	........
&lt;/html&gt;</pre>
<p>
	Si echamos un vistazo al listado de libros comprobaremos como en la parte superior de los mismos aparecer&aacute; una barra con los formatos a los que podamos exportar dicho listado.
</p>
<p>
	
<img alt="Barra para exportar a varios formatos" height="216" src="../images/sesion13/exportbar.jpg" width="677">
</p>
<p>
	Sin embargo, si intentamos exportar el listado a cualquier de los formatos utilizados, veremos como no sucede nada nuevo y la aplicaci&oacute;n vuelve a mostrarnos el listado tal y como ha aparecido siempre, es decir, en formato HTML. Para que la aplicaci&oacute;n pueda exportar a los nuevos formatos, debemos modificar el controlador de la clase de dominio <em>Libro</em> y m&aacute;s en concreto el m&eacute;todo <span class="codefrag">list()</span> para que acepte los nuevos formatos.
</p>
<pre class="code">package biblioteca

<strong>import org.codehaus.groovy.grails.commons.ConfigurationHolder</strong>

class LibroController {

    <strong>// Servicio para exportar a varios formatos ofrecidos por el plugin Export
    def exportService</strong>
    
    def index = { redirect(action:list,params:params) }

    // the delete, save and update actions only accept POST requests
    static allowedMethods = [delete:'POST', save:'POST', update:'POST']

    def list = {
        params.max = Math.min( params.max ? params.max.toInteger() : 10,  100)
        <strong>if(params?.format &amp;&amp; params.format != "html"){
            response.contentType = ConfigurationHolder.config.grails.mime.types[params.format]
            response.setHeader("Content-disposition", "attachment; filename=libros.${params.format}")
            exportService.export(params.format, response.outputStream, Libro.list(params), [:], [:])
        }</strong>

        [ libroInstanceList: Libro.list( params ), libroInstanceTotal: Libro.count() ]
    }</pre>
<p>
	Ahora nuestra aplicaci&oacute;n s&iacute; va a ser capaz de exportar a otros formatos para que el usuario final elija cual de ellos utilizar en cada ocasi&oacute;n. Sin embargo, si echamos un vistazo por ejemplo al formato en PDF, comprobaremos como el listado que aparece muestra todas las propiedades de la clase <em>Libro</em>, a excepci&oacute;n de la propiedad <em>version</em>, lo cual no va a ser aconsejable.
</p>
<p>
	Para mejorar esto, el plugin permite especificar que propiedades queremos mostrar e incluso la etiqueta que queremos que aparezca en la fila de encabezados de la tabla. Para conseguir esto, necesitamos completar los dos &uacute;ltimos par&aacute;metros del m&eacute;todo <span class="codefrag">export()</span> que anteriormente dej&aacute;bamos vac&iacute;os. Adem&aacute;s, tambi&eacute;n necesitaremos indicarle el formato de como deseamos las propiedades de los libros y un mapa de par&aacute;metros para el fichero exportado. As&iacute; quedar&iacute;a el m&eacute;todo <span class="codefrag">list()</span>.
</p>
<pre class="code">def list = {
    params.max = Math.min( params.max ? params.max.toInteger() : 10,  100)
    if(params?.format &amp;&amp; params.format != "html"){
        response.contentType = ConfigurationHolder.config.grails.mime.types[params.format]
        response.setHeader("Content-disposition", "attachment; filename=libros.${params.format}")

        <strong>List propiedades = ["isbn", "titulo", "autor", "editorial", "anyo", "descripcion"]
        Map etiquetas = ["isbn":"ISBN", "titulo":"T&iacute;tulo", "autor":"Autor", "editorial":"Editorial", "anyo":"A&ntilde;o", "descripcion":"Descripci&oacute;n"]

        // Closure formateador
        def mayusculas = { domain, value -&gt;  return value.toUpperCase() }

        Map formateadores = [isbn: mayusculas]
        Map parametros = [title: "LISTADO DE LIBROS"]

        exportService.export(params.format, response.outputStream, Libro.list(params), propiedades, etiquetas, formateadores, parametros)</strong>
    }

    [ libroInstanceList: Libro.list( params ), libroInstanceTotal: Libro.count() ]
}</pre>
<p>
	Por &uacute;ltimo, comentar tambi&eacute;n que podemos cambiar los textos asociados a cada uno de los formatos que aparecen en la barra para exportar. Simplemente debemos crear nuevas entradas en el archivo <em>grails-app/i18n/messages.properties</em> correspondientes, tal y como aparece en el siguiente fragmento de c&oacute;digo.
</p>
<pre class="code">default.csv = CSV
default.excel = EXCEL
default.pdf = PDF
default.xml = XML
default.ods = ODS</pre>
</div>

<a name="N10294"></a><a name="Crear+fuentes+RSS"></a>
<h2 class="underlined_10">Crear fuentes RSS</h2>
<div class="section">
<p>
	Otro aspecto interesante de las aplicaciones web recientes es la posibilidad de intercambiar informaci&oacute;n mediante el formato RSS. Las siglas han ido evolucionando su significado desde <em>Rich Site Summary</em>, pasando por <em>RDF Site Summary</em> para terminar significando <em>Really Simple Syndication</em>. El formato RSS no es m&aacute;s que un archivo XML utilizado para distribuir contenido de un sitio web sin necesidad de utilizar un navegador web. Habitualmente, los RSS se utilizan para generar otra forma de ver las noticias generadas en un sitio web.
</p>
<p>
	En nuestra aplicaci&oacute;n no tenemos noticias, sin embargo, si tenemos <em>libros</em> y quiz&aacute;s estar&iacute;a bien tener un RSS que informara a los usuarios de la biblioteca los nuevos libros que vaya adquiriendo nuestro centro. Para que el usuario no tenga que estar constantemente accediendo a la web, que mejor que disponer de una fuente RSS donde se recojan estas nuevas adquisiciones.
</p>
<p>
	Para a&ntilde;adir esta nueva funcionalidad en nuestra aplicaci&oacute;n, Grails pone a nuestra disposici&oacute;n un plugin que se encargar&aacute; de hacer el trabajo sucio. Este plugin se llama <em>feeds</em> y como siempre, lo primero que vamos a hacer es instalarlo mediante el comando <span class="codefrag">grails install-plugin feeds</span>.
</p>
<p>
	Una vez instalado el plugin, debemos crear en el controlador de la clase <em>Libro</em> un nuevo m&eacute;todo llamado <span class="codefrag">feed()</span> que se encargue de la generaci&oacute;n de la fuente RSS. El m&eacute;todo realizar&aacute; una llamada a la funci&oacute;n <span class="codefrag">render()</span> habitual, pero en lugar de especificar una vista le indicaremos el tipo de RSS y la versi&oacute;n que queremos generar, as&iacute; como un closure donde construiremos el contenido de la fuente RSS. Actualmente el plugin soporta tanto el formato RSS como ATOM. El m&eacute;todo <span class="codefrag">feed()</span> podr&iacute;a quedar as&iacute;:
</p>
<pre class="code">package biblioteca
	
class LibroController {

.....
	
   def feed = {
      render(feedType:"rss", feedVersion:"2.0") {
         title = "Los nuevos libros"
         link = "http://localhost:8080/biblioteca/libro/feed"
         description = "Fuente RSS de los nuevos libros adquiridos por la biblioteca"

         Libro.list().each() { libro -&gt;
            entry(libro.titulo) {
               link = "http://localhost:8080/biblioteca/libro/show/${libro.id}"
               author = libro.autor
               publishedDate = libro.fecha
               libro.descripcion
            }
         }
      }
   }
}</pre>
<p>
	El par&aacute;metro <em>feedType</em> es obligatorio y puede tomar los valores <em>rss</em> o <em>atom</em>, mientras que el par&aacute;metro <em>feedVersion</em> es opcional y si no se especifica tomar&aacute; por defecto los valores <em>2.0</em> para <em>rss</em> y <em>1.0</em> para <em>atom</em>.
</p>
<p>
	Las entradas del feed tomar&aacute;n como par&aacute;metro el t&iacute;tulo de la misma, en nuestro caso <em>libro.titulo</em> y tambi&eacute;n se le pueden especificar los par&aacute;metros <em>link</em>, <em>author</em>, <em>publishedDate</em>, as&iacute; como el contenido del mismo 
</p>
<p>
	S&oacute;lo nos queda probar que nuestra fuente de datos RSS funciona correctamente accediendo a la direcci&oacute;n <em>http://localhost:8080/biblioteca/libro/feed</em>.
</p>
</div>

<a name="N102F9"></a><a name="Librer%C3%ADa+de+etiquetas"></a>
<h2 class="underlined_10">Librer&iacute;a de etiquetas</h2>
<div class="section">
<p>
	Grails nos ofrece la posibilidad de utilizar un amplio rango de etiquetas tanto JSP como GSP, pero en ocasiones, es posible que necesitemos crear nuestra propia librer&iacute;a de etiquetas. Estas etiquetas nos van a permitir realizar tareas repetitivas de forma r&aacute;pida y sencilla.
</p>
<p>
	Las librer&iacute;as de etiquetas no requieren ninguna tarea de configuraci&oacute;n y se recargan autom&aacute;ticamente sin reiniciar el servidor.
</p>
<p>
	En Grails tenemos dos m&eacute;todos para crear etiquetas. Por un lado mediante el comando <span class="codefrag">grails create-tag-lib</span> y por otro creando una nueva clase en el directorio <em>grails-app/taglib</em> cuyo nombre termine en <em>TagLib</em>. Nosotros utilizaremos como hasta ahora el comando <span class="codefrag">grails create-tag-lib Biblioteca</span>.
</p>
<a name="N10314"></a><a name="Etiquetas+simples"></a>
<h3 class="underlined_5">Etiquetas simples</h3>
<p>
	El primer ejemplo de etiqueta creada por nosotros, va a ser una etiqueta que permita la inclusi&oacute;n de archivos de funciones javascript en el c&oacute;digo de nuestras p&aacute;ginas GSPs. Para ello definimos un m&eacute;todo en la nueva clase <em>BibliotecaTagLib</em> con el siguiente contenido:
</p>
<pre class="code">def includeJs = {attrs -&gt;
	out &lt;&lt; "&lt;script src='scripts/${attrs['script']}.js' /&gt;"
}</pre>
<p>
	La creaci&oacute;n de la etiqueta necesita como par&aacute;metro los atributos de la misma. En este primer ejemplo, s&oacute;lo vamos a utilizar un atributo que ser&aacute; el nombre del archivo javascript que queremos invocar en nuestra p&aacute;gina GSP.
</p>
<p>
	Una vez creada la etiqueta, para realizar la invocaci&oacute;n de la misma en las p&aacute;ginas GSP utilizaremos el siguiente c&oacute;digo.
</p>
<pre class="code">&lt;g:includeJs script="miscript"/&gt;</pre>
<p>
	Para invocar la nueva librer&iacute;a creada se utiliza el <em>namespace</em> gen&eacute;rico <em>&lt;g&gt;</em>. Sin embargo, Grails nos permite crear nuestro propio espacio de nombres para que el c&oacute;digo generado sea sencillo de leer. El espacio de nombres que vamos a utilizar ser&aacute; <em>me</em>, acr&oacute;nimo de <em>mis etiquetas</em>. Para ello debemos definir una variable est&aacute;tica al inicio de la clase <em>BibliotecaTagLib</em> llamada <em>namespace</em> e indic&aacute;ndole el valor del nuevo espacio de nombres, tal y como aparece en el siguiente fragmento de c&oacute;digo.
</p>
<pre class="code">package biblioteca

class BibliotecaTagLib {
    <strong>static namespace = 'me'</strong>
    def includeJs = {attrs -&gt;
        out &lt;&lt; "&lt;script src='scripts/${attrs['script']}.js'/&gt;"
    }
}</pre>
<p>
	De esta forma, en nuestras p&aacute;ginas GSP ya no tendr&iacute;amos que utilizar <span class="codefrag">&lt;g:includeJs script="miscript"/&gt;</span> sino que podr&iacute;amos emplear <span class="codefrag">&lt;me:includeJs script="miscript"/&gt;</span>, con lo que la persona que lea el c&oacute;digo podr&aacute; detectar que esa etiqueta es una etiqueta propia de la aplicaci&oacute;n.
</p>
<a name="N10354"></a><a name="Etiquetas+l%C3%B3gicas"></a>
<h3 class="underlined_5">Etiquetas l&oacute;gicas</h3>
<p>
	Con Grails tambi&eacute;n es posible crear etiquetas l&oacute;gicas que eval&uacute;en una cierta condici&oacute;n y act&uacute;en en consecuencia en funci&oacute;n de dicha evaluaci&oacute;n. Si pensamos en algo que podr&iacute;a sernos &uacute;til en nuestra aplicaci&oacute;n podr&iacute;a ser una nueva etiqueta que compruebe si el usuario autenticado es un administrador. El siguiente m&eacute;todo realiza esta comprobaci&oacute;n y en caso de ser cierto, se mostrar&iacute;a el contenido encerrado entre la etiqueta.
</p>
<pre class="code">def esAdmin = { attrs, body -&gt;
    def usuario = attrs['usuario']
    if(usuario != null &amp;&amp; usuario.tipo=="administrador") {
        out &lt;&lt; body()
    }
}</pre>
<p>
	En esta ocasi&oacute;n, la nueva etiqueta no s&oacute;lo recibe el atributo <em>attrs</em> sino que tambi&eacute;n necesita del atributo <em>body</em>, que se refiere a aquello que est&eacute; encerrado entre la apertura y el cierre de la etiqueta. El m&eacute;todo comprueba si el usuario pasado por par&aacute;metro es un administrador. En la p&aacute;gina GSP correspondiente deber&iacute;amos indicar el siguiente c&oacute;digo.
</p>
<pre class="code">&lt;me:esAdmin usuario="${session.usuario}"&gt;
	//Acciones restringidas a los administradores
&lt;/me:esAdmin&gt;</pre>
<a name="N1036F"></a><a name="Etiquetas+iteradoras"></a>
<h3 class="underlined_5">Etiquetas iteradoras</h3>
<p>
	De igual forma que las etiquetas l&oacute;gicas, en Grails tambi&eacute;n vamos a poder crear nuestras propias librer&iacute;as de etiquetas iteradoras, que nos facilitar&aacute;n las tareas repetitivas. Vamos a desarrollar un ejemplo de etiqueta, que nos imprime en nuestra p&aacute;gina un determinado p&aacute;rrafo un n&uacute;mero de veces pasado por par&aacute;metro.
</p>
<p>
	Para conseguir esto, creamos una nueva etiqueta en la clase <em>BibliotecaTagLib</em> creando el m&eacute;todo <span class="codefrag">repetir()</span>, al cual le pasaremos los par&aacute;metros <em>attrs</em> y <em>body</em>. Como par&aacute;metro esta etiqueta simplemente recibir&aacute; el n&uacute;mero de veces que deseamos repetir el cuerpo de la etiqueta.
</p>
<pre class="code">def repetir = { attrs, body -&gt;
    def i = Integer.valueOf( attrs["times"] )
    def actual = 0
    i.times {
        out &lt;&lt; body( ++actual )
    }
}</pre>
<p>
	Tambi&eacute;n es posible pasarle par&aacute;metros al <em>body</em>. En este caso le hemos indicado como par&aacute;metro la iteraci&oacute;n actual. Posteriormente, en el c&oacute;digo insertado en la p&aacute;gina GSP vamos a poder referencia a este par&aacute;metro mediante la palabra reservada <em>it</em>.
</p>
<pre class="code">&lt;me:repetir times="4"&gt;
    Este ser&iacute;a el p&aacute;rrafo n&uacute;mero ${it}&lt;br/&gt;
&lt;/me:repetir&gt;</pre>
<a name="N10399"></a><a name="Generador+de+c%C3%B3digo+HMTL"></a>
<h3 class="underlined_5">Generador de c&oacute;digo HMTL</h3>
<p>
	Grails ofrece la posibilidad de generar c&oacute;digo HTML de forma muy sencilla gracias a un Builder del que ya hablamos en la sesi&oacute;n 4, el <em>MarkupBuilder</em>. Para comprobar el funcionamiento de este Builder, vamos a crear una nueva etiqueta que imprima un enlace cuyo atributo <em>href</em> coincida con el t&iacute;tulo. Por ejemplo, para imprimir un enlace a la p&aacute;gina de Google, normalmente debemos incluir el c&oacute;digo <span class="codefrag">&lt;a href="http://www.google.com"&gt;http://www.google.com&lt;/a&gt;</span>. Con esta etiqueta que vamos a crear nos ahorraremos escribir la direcci&oacute;n url dos veces.
</p>
<p>
	En primer lugar creamos un nuevo m&eacute;todo en el archivo <em>BibliotecaTagLib.groovy</em> y lo llamaremos <span class="codefrag">printLink()</span>. Este m&eacute;todo utilizar&aacute; el <span class="codefrag">MarkupBuilder</span> e imprimir&aacute; un enlace con el valor del atributo <em>href</em> igual al contenido.
</p>
<pre class="code">def printLink = { attrs, body -&gt;
    def mkp = new groovy.xml.MarkupBuilder(out)
    mkp {
        a(href:body(),body())
    }
}</pre>
<p>
	Ahora en la vista podemos a&ntilde;adir una etiqueta como <span class="codefrag">&lt;me:printLink&gt;http://www.google.com&lt;/me:printLink&gt;</span>, la cual ser&aacute; traducida al c&oacute;digo HTML <span class="codefrag">&lt;a href="http://www.google.com"&gt;http://www.google.com&lt;/a&gt;</span>.
</p>
</div>


<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2010-2011 Depto. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
