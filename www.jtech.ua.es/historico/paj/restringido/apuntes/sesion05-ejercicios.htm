<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Ejercicios de Entrada/Salida</title>
         
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
     
  <link rel="stylesheet" href="../../apuntes.css" type="text/css">
</head>
  <body bgcolor="#ffffff" text="#000000">
<h1><span class="section">Entrada/Salida </span> </h1>
<p><b>1.</b> Vamos a realizar un programa que lea un fichero de texto ASCII, y 
  lo vaya mostrando por pantalla. El esqueleto del programa se encuentra en el 
  fichero <i>Ej1.java</i>. Se pide:</p>
  <blockquote>
    <p><i>a) </i>¿Qué tipo de flujo de datos utilizaremos para leer el
    fichero? Añadir al programa la creación del flujo de datos adecuado
    (variable <i>in</i>),
    compilar y comprobar su correcto funcionamiento.</p>
    <p><i>b)</i>  Podemos utilizar un flujo de procesamiento llamado <b>BufferedReader</b>
    que mantendrá un <i>buffer</i> de los caracteres leídos y nos permitirá
    leer el fichero línea a línea además de utilizar los métodos de lectura
    a más bajo nivel que estamos usando en el ejemplo. Consultar la
    documentación de la clase <b>BufferedReader</b> y aplicar la
    transformación sobre el flujo de entrada (ahora <i>in</i> deberá ser
    un objeto <b>BufferedReader</b>). Compilar y comprobar que sigue funcionando
    correctamente el método de lectura implementado.</p>
    <p><i>c)</i>  Ahora vamos a cambiar la forma de leer el fichero y lo vamos a
    hacer línea a línea aprovechando el <b>BufferedReader</b>. ¿Qué método
    de este objeto nos permite leer líneas de la entrada? ¿Qué nos devolverá
    este método cuando se haya llegado al final el fichero? Implementar un
    bucle que vaya leyendo estas líneas y las vaya imprimiendo, hasta llegar al
    final del fichero. Compilar y comprobar que sigue funcionando de la misma
    forma.</p>
  </blockquote>
  
<p><b>2.</b> En el fichero <i>Ej2.java</i> tenemos un programa que realizará una 
  copia de ficheros en Java. Se pide:</p>
  <blockquote>
    <p><i>a) </i>Intentar compilar el programa y ver que errores obtenemos.
    Añadir la captura de las excepciones necesarias para que el programa
    compile (no capturar <b>Exception</b> en general).</p>
    <p><i>b)</i>  Probar el programa copiando un fichero de texto. Comprobar que
    la copia se ha hecho correctamente.</p>
    
  <p><i>c)</i> Ahora probar a copiar el fichero <i>notepad.exe</i> con nuestro 
    programa. Intentar ejecutar la copia y comprobar que falla. ¿Por qué ocurre 
    esto? ¿Cómo podemos solucionarlo? Cambiar el tipo de flujo de datos para solucionar 
    este problema y comprobar que la nueva versión realiza un copia correcta de 
    <i>notepad.exe</i>.</p>
  </blockquote>
  
<p><b>3.</b> <b>(CHAT) </b>Realizar un programa que lea l&iacute;neas de texto 
  de la entrada est&aacute;ndar y muestre por la salida est&aacute;ndar lo que 
  ha introducido el usuario. Deber&aacute; funcionar como se muestra a continuaci&oacute;n:</p>
<blockquote>
  <pre class="codigo">hola
Ha escrito &quot;hola&quot;</pre>
  </blockquote>
  <p>Realizaremos un módulo que pueda ser reutilizado para nuestro chat.
  Crearemos una clase llamada <b>EntradaConsola </b>en el paquete <b>es</b>
  (entrada/salida) que nos permitirá leer líneas que el usuario introduzca en
  la consola y pedir al usuario determinados datos. Podemos encontrar una
  plantilla de esta clase en <i>es/EntradaConsola.java </i>que deberá ser
  completada y probada.&nbsp;</p>
   
  
<p>El fichero <i>Ej3.java</i> contiene un conductor para probar este módulo. Se 
  pide:</p>
   
  <blockquote>    
    <p><i>a) </i>En la clase <b>EntradaConsola </b>deberemos crear un flujo que
    lea líneas de la entrada estándar. Recordemos que esto podemos hacerlo
    mediante un flujo <b>BufferedReader</b>. Sin embargo, si nos fijamos la
    entrada estándar es un flujo de bytes, mientras que los objetos <b>BufferedReader
    </b>se crean a partir de flujos de caracteres. ¿Qué tendremos que hacer
    para poder crear <b>BufferedReader </b>de la entrada estándar? Aplicar el
    cambio en el código de la clase y comprobar que compila correctamente.<br>
    <i>b)</i> Añadir en <i>readLine() </i>de la clase <b>EntradaConsola<i> </i></b>la 
    llamada al método que sea necesaria para leer la línea introducida en la consola 
    y devolverla. Capturar la excepciones necesarias, devolviendo <i>null</i> 
    en caso de error. Compilar y ejecutar, comprobando que lee correctamente las 
    líneas introducidas. </p>
  </blockquote>
     
  
<p><b>4.</b>&nbsp; <b>(CHAT) </b>Ahora vamos a hacer un módulo para el acceso 
  a un fichero con información sobre los usuarios registrados. Recuerda incorporar 
  las clases del chat creadas en sesiones anteriores para que funcione correctamente. 
  En este caso el módulo de acceso a usuarios utilizará la excepción <b>LoginInvalidoException</b>. 
  Este módulo deberá leer ficheros con el siguiente formato:</p>
     
<blockquote>
  <pre class="codigo">login usuario 1:password usuario 1
login usuario 2:password usuario 2
...
login usuario N:password usuario N</pre>
  </blockquote>
  
<p>Podemos encontrar un fichero con los datos de los usuarios en <i>datos\usuarios</i>. 
  Necesitaremos leer una serie de cadenas (login y password) separadas por caracteres 
  de dos puntos y saltos de líneas (podemos ver estas cadenas como <i>tokens </i>de 
  tipo WORD). Del acceso a este fichero se encargará la clase <b>AccesoFicheroUsuarios 
  </b>de la cual podemos encontrar una plantilla en <i>usuarios\AccesoFicheroUsuarios.java</i>. 
  A continuación completaremos su método <i>leeFichero(String filename) </i>para 
  que realice correctamente la lectura de este formato de ficheros. </p>
<p>El conductor para probar este m&oacute;dulo se encuentra en el fichero <i>Ej4.java</i>. 
  Se pide:</p>
   
    <blockquote>        
      <p><i>a)</i>  ¿Qué clase de Java nos permitirá leer este fichero de
      forma sencilla, obteniendo en cada lectura una de las cadenas?</p>
         
      
  <p align="left"><i>b) </i>Si queremos que el carácter ':' (constante <i>SEPARADOR</i> 
    de la clase <b>AccesoFicheroUsuarios</b>) se utilice como separador (espacio 
    en blanco) entre <i>tokens </i>, ¿qué deberemos hacer? Implementarlo en el 
    código y probar que lee correctamente el fichero.</p>
         
      
  <p><i>c)</i> Añadir al fichero de usuarios algún usuario con espacios en blanco 
    en su login y probar el programa, ¿qué ocurre?, ¿qué deberemos hacer para 
    que lea toda la cadena (incluidos los espacios) como un único <i>token</i>? 
    Hacer las modificaciones necesarias, y comprobar que funciona correctamente. 
    Una vez comprobado que lee el fichero correctamente podremos eliminar las 
    líneas <i>System.out.println() </i>que imprimen el login y el password.</p>
      <p><i>d)</i>  Ahora nos surge un problema: ¿y si en el fichero se ha
      dejado un espacio al principio o al final de la cadena, o bien se han
      separado los dos puntos de la cadena del login o del password mediante
      espacios? Al reconocer los espacios como caracteres de la cadena, no será
      la misma cadena si está rodeada de espacios o si no lo está, cuando
      normalmente estos caracteres deben ser ignorados. La operación de
      'limpiar' estos espacios del principio y del final de la cadena se
      denomina <i>trim</i>. ¿En qué clase deberíamos buscar esta función?
      Buscarla y aplicarla a las cadenas leídas del fichero. Comprobar que
      realmente ahora el programa ignora esos caracteres.</p>
      
  <p><i>e)</i> Por último, vamos a completar el método de escritura del fichero 
    de usuarios <i>escribeFichero(String filename, Vector lista)</i>. Queremos 
    utilizar un flujo que nos permita escribir cadenas con el método <i>println()</i>, 
    en lugar de tener que hacerlo carácter a carácter con los métodos de bajo 
    nivel. Para ello podemos utilizar un objeto <b>PrintWriter</b>. Crear tanto 
    el flujo de salida al fichero, como un objeto <b>PrintWriter </b>al que llamaremos 
    <i>out</i> a partir de dicho flujo de salida a fichero. Ahora podemos probar 
    el programa registrando nuevos usuarios y comprobando que se almacenan correctamente 
    en el fichero de usuarios.</p>
  </blockquote>
       
          </body>
          </html>
