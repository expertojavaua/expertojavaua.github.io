<!-- saved from url=(0022)http://internet.e-mail -->
<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                                                            
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
                                                            
  <meta name="Author" content="Nacho">
                                                            
  <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
                                                        
  <link rel="stylesheet" href="../../../apuntes.css" type="text/css">
  <title>Tema 3: Conceptos avanzados</title>
</head>
  <body>
           
      <b>      
<h2>3.2. Seguridad en servlets</h2>
      </b><p>Podemos tener básicamente dos motivos para proteger una
      aplicación web: </p>
           
      <ul>
        <li>Evitar que usuarios no autorizados accedan a determinados recursos.</li>
        <li>Prevenir que se acceda a los datos que se intercambian en una
          transferencia a lo largo de la red.</li>
      </ul>
      <p>Para cubrir estos agujeros, un sistema de seguridad se
      apoya en tres aspectos importantes: </p>
           
      <ul>
        <li><b>Autentificación</b>: medios para identificar a los elementos que
          intervienen en el acceso a recursos. </li>
        <li><b>Confidencialidad</b>: asegurar que sólo los elementos que
          intervienen entienden el proceso de comunicación establecido.</li>
        <li><b>Integridad</b>: verificar que el contenido de la comunicación no
          se modifica durante la transmisión.</li>
      </ul>
           
      <h4>3.2.1. Tipos de seguridad</h4>
           
      <p>Existen dos formas de seguridad que se pueden implantar en un sistema
      Web: </p>
           
      <p><b>1. Seguridad declarativa</b> </p>
           
      <p>Aquella estructura de
      seguridad sobre una aplicación&nbsp; que es externa a dicha aplicación.
      Con ella, no tendremos que preocuparnos de gestionar la seguridad en
      ningún servlet, página JSP, etc, de nuestra aplicación, sino que el
      propio servidor Web se encarga de todo. Así, ante cada petición,
      comprueba si el usuario se ha autentificado ya, y si no le pide login y
      password para ver si puede acceder al recurso solicitado. Todo esto se
      realiza de
      forma transparente al usuario. Mediante el descriptor de la aplicación
      principalmente (fichero <i>web.xml </i>en Tomcat), comprueba la configuración de
      seguridad que queremos dar.</p>
      <p><b>2. Seguridad programada</b>&nbsp;</p>
      <p>Mediante la seguridad programada, son los servlets y páginas JSP
      quienes, al menos parcialmente, controlan la seguridad de la aplicación.</p>
      <h4>3.2.2. Autentificación</h4>
           
      <p>Veremos ahora, resumidos, los distintos tipos de autentificación que podemos
      emplear: </p>
           
      <p><b>1. Autentificación <i>basic</i></b> </p>
           
      <p>Vimos con <a href="http.htm"> HTTP</a> que se proporcionaba un mecanismo
      de autentificación básico, basado en cabeceras de autentificación para
      solicitar datos del usuario (el servidor) y para enviar los datos del
      usuario (el cliente). Esta autentificación no proporciona
      confidencialidad ni integridad, sólo se emplea una codificación Base64. </p>
           
      <p><b>2. Autentificación <i>digest</i></b> </p>
           
      <p>También vimos que existía una variante de lo anterior, la autentificación <b>digest</b>, donde, en
      lugar de transmitir el password por la red, se emplea un password
      codificado
      utilizando el método de encriptado MD5. Sin embargo, algunos
      servidores no soportan este tipo de autentificación. </p>
           
      <p><b>3. Autentificación basada en formularios</b> </p>
           
      <p>Con este tipo de autentificación, el usuario introduce su login y
      password mediante un formulario HTML (y no con un cuadro de diálogo, como
      las anteriores). El fichero descriptor
      contiene para ello entradas que indican la página con el formulario de
      autentificación y una página de error. Tiene el mismo inconveniente que la autentificación <i>basic</i>:
      el password se codifica con un mecanismo muy pobre. </p>
           
      <p><b>4. Certificados digitales y SSL</b> </p>
           
      <p>También con HTTP se vio el mecanismo de funcionamiento de SSL y los
      certificados digitales, apoyados en los sistemas de criptografía de clave
      pública. Así, la capa SSL, trabajando entre TCP/IP y HTTP, aseguraba,
      mediante criptografía de clave pública, la integridad, confidencialidad
      y autentificación. </p>
           
      <h4>3.2.3. Seguridad declarativa</h4>
           
      <p>En este apartado se explican algunas técnicas comunes empleadas en la
      seguridad declarativa, como son la autentificación basada en formularios
      y la autentificación <i>basic</i>. </p>
           
      <h4>3.2.3.1. Autentificación basada en formularios</h4>
           
      <p>Veremos ahora con más profundidad la autentificación basada en
      formularios comentada anteriormente. Esta es la forma más comúnmente
      usada para imponer seguridad en una aplicación, puesto que se emplean <b>formularios
      HTML</b>. </p>
           
      <p>El programador emplea el descriptor de despliegue para
      identificar los recursos a proteger, e indicar la página con el
      formulario a mostrar, y la página con el error a mostrar en caso de
      autentificación incorrecta. Así, un usuario que intente acceder a la
      parte restringida es redirigido automáticamente a la página del
      formulario, si no ha sido autentificado previamente. Si se autentifica
      correctamente accede al recurso, y si no se le muestra la página de
      error. Todo este proceso lo controla el servidor automáticamente. </p>
           
      <p>Este tipo de autentificación no se garantiza que funcione cuando se
      emplea reescritura de URLs en el seguimiento de sesiones. También podemos incorporar SSL a este proceso, de forma que no se vea
      modificado el funcionamiento aparente del mismo. </p>
           
      <p>Para utilizar la autentificación basada en formularios, se siguen los
      pasos que veremos a continuación. Sólo el primero es dependiente del
      servidor que se utilice. </p>
           
      <p><b>1. Establecer los logins, passwords y roles</b> </p>
           
      <p>Aquí se establece una lista de usuarios, con su password y uno o
      varios roles a los que pueden pertenecer. </p>
           
      <p>Tomcat permite especificar la forma de gestionar estos datos (mediante
      base de datos, fichero de passwords, etc). Sin embargo, también propone
      una forma alternativa de tratar esta información, almacenando logins,
      passwords y roles en el fichero <b>conf/tomcat-users.xml</b>.&nbsp; </p>
           
      <p>Este fichero contiene una cabecera XML, seguida de una etiqueta raíz <b>&lt;tomcat-users&gt;</b>,
      que a su vez contiene una serie de etiquetas <b>&lt;user&gt;</b>, una por
      cada usuario que se defina. Cada una de estas etiquetas <i>&lt;user&gt;</i>
      contiene 3 atributos: </p>
           
      <ul>
        <li><b>name</b>: nombre (login) del usuario</li>
        <li><b>password</b>: password del usuario</li>
        <li><b>roles</b>: rol / roles a los que pertenece el usuario, separados
          por comas</li>
      </ul>
      <p>Un ejemplo de fichero sería:</p>
      <pre class="codigo">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;
&lt;tomcat-users&gt;
	&lt;user name=&quot;pepe&quot; password=&quot;pepepw&quot; roles=&quot;usuario&quot;/&gt;
	&lt;user name=&quot;manuel&quot; password=&quot;manolo&quot; roles=&quot;admin&quot;/&gt;
	&lt;user name=&quot;toni&quot; password=&quot;toni&quot; roles=&quot;usuario, admin&quot;/&gt;
&lt;/tomcat-users&gt;</pre>
           
      <p>Así, por ejemplo, para un recurso (URL) al que sólo puedan acceder
      roles de tipo <i>admin</i>, podrían acceder los usuarios <i>manuel</i> y <i>toni</i>.
      Notar también que los passwords están visibles en un fichero de texto
      fácilmente accesible por casi cualquiera, con lo que no es una buena
      forma de gestionar los passwords para una aplicación profesional. </p>
           
      <p><b>2. Indicar al servlet que se empleará autentificación basada en
      formularios, e indicar las páginas de formulario y error.</b> </p>
           
      <p>Se coloca para ello una etiqueta <b>&lt;login-config&gt;</b> en el
      descriptor de despliegue. Dentro, se emplean las subetiquetas: </p>
           
      <ul>
        <li> <b>&lt;auth-method&gt;</b>
          que en general puede valer:
          <ul>
            <li> <b>FORM</b>: para autentificación basada en formularios (como
              es el caso)</li>
            <li><b>BASIC</b>: para autentificación BASIC</li>
            <li><b>DIGEST</b>: para autentificación DIGEST</li>
            <li><b>CLIENT-CERT</b>: para SSL</li>
          </ul>
        </li>
        <li> <b>&lt;form-login-config&gt;</b> que indica las dos páginas HTML
          (la del formulario y la de error) con las etiquetas:
          <ul>
            <li> <b>&lt;form-login-page&gt;</b> (para la de autentificación)&nbsp;</li>
            <li><b>&lt;form-error-page&gt;</b> (para la página de error).</li>
          </ul>
        </li>
      </ul>
           
      <p>Por ejemplo, podemos tener las siguientes líneas
      en el descriptor de despliegue: </p>
           
      <pre class="codigo">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE web-app PUBLIC 
 &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN&quot;
 &quot;http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;

&lt;web-app&gt;
	...
<b>	&lt;login-config&gt;
		&lt;auth-method&gt;FORM&lt;/auth-method&gt;
		&lt;form-login-config&gt;
			&lt;form-login-page&gt;
				/login.jsp
			&lt;/form-login-page&gt;
			&lt;form-error-page&gt;
				/error.html
			&lt;/form-error-page&gt;
		&lt;/form-login-config&gt;
	&lt;/login-config&gt;
</b>	...
&lt;/web-app&gt;</pre>
           
      <p><b><a name="login"></a>3. Crear la página de login</b> </p>
           
      <p>El formulario de esta página debe contener
      campos para introducir el login y el password, que deben llamarse <i>j_username
      </i>y <i>j_password</i>. La acción del formulario debe ser <i>j_security_check</i>,
      y el METHOD = POST (para no mostrar los datos de identificación en la
      barra del explorador). Por ejemplo, podríamos tener la página: </p>
           
      <pre class="codigo">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;
&lt;html&gt;
&lt;body&gt;
&lt;form action=&quot;j_security_check&quot; METHOD=&quot;POST&quot;&gt;
	&lt;table&gt;
		&lt;tr&gt;&lt;td&gt;
			Login:
			&lt;input type=&quot;text&quot; name=&quot;j_username&quot;&gt;
		&lt;/td&gt;&lt;/tr&gt;
		&lt;tr&gt;&lt;td&gt;
			Password:
			&lt;input type=&quot;text&quot; name=&quot;j_password&quot;&gt;
		&lt;/td&gt;&lt;/tr&gt;
		&lt;tr&gt;&lt;td&gt;
			&lt;input type=&quot;submit&quot; value=&quot;Enviar&quot;&gt;
		&lt;/td&gt;&lt;/tr&gt;
	&lt;/table&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
           
      <p><b><a name="error"></a>4. Crear la página de error</b> </p>
           
      <p>La página puede tener el mensaje de error que se quiera. Ante fallos
      de autentificación, se redirigirá a esta página con un código 401. Un
      ejemplo de página sería: </p>
           
      <pre class="codigo">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;ERROR AL AUTENTIFICAR USUARIO&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
           
      <p><b>5. Indicar qué direcciones deben protegerse con autentificación</b> </p>
           
      <p>Para ello utilizamos etiquetas <b>&lt;security-constraint&gt;</b> en
      el descriptor de despliegue. Dichos elementos debe ir inmediatamente antes
      de <i>&lt;login-config&gt;</i>, y utilizan las subetiquetas: </p>
           
      <ul>
        <li><b>&lt;display-name&gt;</b> para dar un nombre identificativo a
          emplear (opcional)</li>
        <li><b>&lt;web-resource-collection&gt;</b> para especificar los patrones
          de URL que se protegen (requerido). Se permiten varias entradas de
          este tipo para especificar recursos de varios lugares. Cada uno
          contiene:
          <ul>
            <li>Una etiqueta <b>&lt;web-resource-name&gt;</b> que da un nombre
              identificativo arbitrario al recurso o recursos</li>
            <li>Una etiqueta <b>&lt;url-pattern&gt;</b> que indica las URLs que
              deben protegerse</li>
            <li>Una etiqueta <b>&lt;http-method&gt;</b> que indica el método o
              métodos HTTP a los que se aplicará la restricción (opcional)</li>
            <li>Una etiqueta <b>&lt;description&gt;</b> con documentación sobre
              el conjunto de recursos a proteger (opcional)</li>
          </ul>
        </li>
      </ul>
      <blockquote>
        <p>NOTA: este modo de restricción se aplica sólo cuando se accede al
        recurso directamente, no a través de arquitecturas MVC
        (Modelo-Vista-Controlador), con un <i>RequestDispatcher</i>. Es decir,
        si por ejemplo un servlet accede a una página JSP protegida, este
        mecanismo no tiene efecto, pero sí cuando se intenta a acceder a la
        página JSP directamente.</p>
      </blockquote>
           
      <ul>
        <li><b>&lt;auth-constraint&gt;</b> indica los roles de usuario que
          pueden acceder a los recursos indicados (opcional) Contiene:
          <ul>
            <li>Uno o varios subelementos <b>&lt;role-name&gt;</b> indicando
              cada rol que tiene permiso de acceso. Si queremos dar permiso a
              todos los roles, utilizamos una etiqueta <i>&lt;role-name&gt;*&lt;/role-name&gt;</i>.</li>
            <li>Una etiqueta <b>&lt;description&gt;</b> indicando la
              descripción de los mismos.</li>
          </ul>
          <p>En teoría esta etiqueta es opcional, pero omitiéndola indicamos
          que ningún rol tiene permiso de acceso. Aunque esto puede parecer
          absurdo, recordar que este sistema sólo se aplica al acceso directo a
          las URLs (no a través de u modelo MVC), con lo que puede tener su
          utilidad.</li>
      </ul>
           
      <p>Añadimos alguna dirección protegida al fichero que vamos
      construyendo:</p>
      <pre class="codigo">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE web-app PUBLIC 
 &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN&quot;
 &quot;http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;

&lt;web-app&gt;
<b>	&lt;security-constraint&gt;
		&lt;web-resource-collection&gt;
			&lt;web-resource-name&gt;
				Prueba
			&lt;/web-resource-name&gt;
			&lt;url-pattern&gt;
				/prueba/*
			&lt;/url-pattern&gt;
		&lt;/web-resource-collection&gt;
		&lt;auth-constraint&gt;
			&lt;role-name&gt;admin&lt;/role-name&gt;
			&lt;role-name&gt;subadmin&lt;/role-name&gt;
		&lt;/auth-constraint&gt;
	&lt;/security-constraint&gt;
</b>	&lt;login-config&gt;
	...
&lt;/web-app&gt;</pre>
           
      <p>En este caso protegemos todas las URLs de la forma <i>http//host/ruta_aplicacion/prueba/*</i>,
      de forma que sólo los usuarios que tengan roles de <i>admin</i> o de <i>subadmin</i>
      podrán acceder a ellas.</p>
      <p><b>6. Desactivar los servlets</b></p>
      <p>Hay que tener en cuenta que al proteger URLs, seguimos dejando libre
      una vía de acceso para los servlets, puesto que podemos llamarlos
      utilizando el alias <i>servlet</i>. Por ejemplo, supongamos que mapeamos
      el servlet <i>paqueteservlets.UnServlet</i> con la dirección <i>/pruebas/Prueba</i>.
      Supongamos también que protegemos la url <i>/pruebas/Prueba</i>. De
      esta forma, si llamamos al servlet con</p>
           
      <pre class="codigo">http://&lt;ruta&gt;/pruebas/Prueba</pre>
           
      <p>no podremos hacerlo a no ser que tengamos los permisos adecuados. Pero
      nadie ha prohibido llamar al servlet con:</p>
           
      <pre class="codigo">http://&lt;ruta&gt;/servlet/paqueteservlets.UnServlet</pre>
           
      <p>Hay que desactivar, por tanto, esta forma de llamar a los servlets
      implicados en el proceso de seguridad. En los conceptos iniciales de
      servlets vistos anteriormente vimos cómo podría hacerse eso. Una forma muy
      común es redirigir las direcciones <i>/servlet/*</i> hacia un mismo
      servlet que muestre una página de error:</p>
           
      <pre class="codigo">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE web-app PUBLIC 
 &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN&quot;
 &quot;http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;

&lt;web-app&gt;
<b>	&lt;servlet&gt;
		&lt;servlet-name&gt;Error&lt;/servlet-name&gt;
		&lt;servlet-class&gt;ErrorServlet&lt;/servlet-class&gt;
	&lt;/servlet&gt;

	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;Error&lt;/servlet-name&gt;
		&lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;	

</b>	&lt;security-constraint&gt;
	...
&lt;/web-app&gt;</pre>
           
      <p>El servlet <i>ErrorServlet</i>  puede simplemente mostrar un texto de
      error. </p>
           
      <p><b>EJEMPLO</b> </p>
           
      <p>Juntando todos los pasos previos, tenemos aquí un fichero <a href="ejemplos/avanzado/ejemploseguridadform.war.zip"> WAR</a>
      disponible con los ficheros implicados. El ejemplo tiene la siguiente
      estructura de directorios y archivos: </p>
           
      <ul>
        <li><b>/WEB-INF/web.xml</b>: fichero descriptor, que finalmente queda
          con <a href="ejemplos/avanzado/web1.txt">esta</a> apariencia.</li>
        <li><b>/WEB-INF/classes/ErrorServlet</b>: servlet de error para evitar accesos mediante <i>/servlet/...</i></li>
        <li><b>/WEB-INF/classes/PruebaServlet</b> es un servlet al que no
          debería poderse acceder (porque no está mapeado, y no se puede
          utilizar el acceso <i>/servlet/</i>).</li>
        <li><b>/login.jsp</b>: <a href="#login">página</a> que muestra el
          formulario de autentificación</li>
        <li><b>/error.html</b>: <a href="#error">página</a> que muestra error
          ante autentificaciones incorrectas</li>
        <li><b>/prueba/</b>: directorio que se quiere proteger. Dentro hay una
          página <b>index.html</b> de prueba para intentar acceder a ella.</li>
        <li><b>/login.jsp</b>: página de error</li>
      </ul>
      <p>Para probar el ejemplo, debemos colocar en el fichero <b>tomcat-users.xml</b>
      los valores de usuarios y passwords vistos antes en el ejemplo (u otros
      valores, si queremos). Se proporciona un fichero <i>tomcat-users.xml</i>
      en el WAR, para copiarlo directamente en el directorio <i>conf</i> de
      Tomcat (deberíamos copiar previamente el <i>tomcat-users.xml</i>
      original, para no perderlo). Luego copiamos el fichero WAR en el directorio <i>webapps</i>
      de Tomcat. Intentamos acceder a las direcciones: </p>
           
      <pre class="codigo">http://localhost:8080/ejemploseguridadform/prueba/index.html</pre>
           
      <pre class="codigo">http://localhost:8080/ejemploseguridadform/servlet/PruebaServlet</pre>
           
      <p>En el primero caso, probamos a introducir logins y passwords válidos e
      inválidos, para comprobar qué páginas se muestran en cada caso. En el
      segundo caso, nos mostrará la página que genera el servlet <i>ErrorServlet.</i> </p>
           
      <h4>3.2.3.2. Autentificación basic</h4>
           
      <p>El método de autentificación basada en formularios tiene algunos
      inconvenientes: si el navegador no soporta cookies, el proceso tiene que
      hacerse mediante reescritura de URLs, con lo que no se garantiza el
      funcionamiento. </p>
           
      <p>Por ello, una alternativa es utilizar el modelo de autentificación <i>basic</i>
      de HTTP, donde se emplea un cuadro de diálogo para que el usuario
      introduzca su login y password, y se emplea la cabecera <i>Authorization</i>
      de petición para recordar qué usuarios han sido autorizados y cuáles
      no. Una diferencia con respecto al método anterior es que es difícil
      entrar como un usuario distinto una vez que hemos entrado como un
      determinado usuario (habría que cerrar el navegador y volverlo a abrir). </p>
           
      <p>Al igual que en el caso anterior, podemos utilizar SSL sin ver
      modificado el resto del esquema del proceso. </p>
           
      <p>El método de autentificación <i>basic</i> consta de los siguientes
      pasos: </p>
           
      <p><b>1. Establecer los logins, passwords y roles</b> </p>
           
      <p>Este paso es exactamente igual que el visto para la autentificación
      basada en formularios. </p>
           
      <p><b>2. Indicar al servlet que se empleará autentificación BASIC, y
      designar los dominios</b> </p>
           
      <p>Se utiliza la misma etiqueta <b>&lt;login-config&gt;</b>  vista antes,
      pero ahora una etiqueta <b>&lt;auth-method&gt;</b>
      con valor <b>BASIC</b>. Se emplea una subetiqueta <b>&lt;realm-name&gt;</b>
      para indicar qué dominio se empleará en la autorización. Por ejemplo:&nbsp; </p>
           
      <pre class="codigo">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE web-app PUBLIC 
 &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN&quot;
 &quot;http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;

&lt;web-app&gt;
	...
<b>	&lt;login-config&gt;
		&lt;auth-method&gt;BASIC&lt;/auth-method&gt;
		&lt;realm-name&gt;dominio&lt;/realm-name&gt;
	&lt;/login-config&gt;
</b>	...
&lt;/web-app&gt;</pre>
           
      <p><b>3. Indicar qué direcciones deben protegerse con autentificación</b> </p>
           
      <p>Este paso también es idéntico al visto en la autentificación basada
      en formularios. </p>
           
      <p><b>4. Desactivar los servlets</b></p>
      <p>Este paso también es igual al visto en la autentificación basada en
      formularios.</p>
           
      <p><b>EJEMPLO</b> </p>
           
      <p>Juntando todos los pasos previos, tenemos aquí un fichero <a href="ejemplos/avanzado/ejemploseguridadbasic.war.zip"> WAR</a>
      disponible con los ficheros implicados. El ejemplo tiene la misma
      estructura de directorios que el visto para autentificación con
      formularios (quitando las páginas de login y error, que ya no son
      necesarias). El fichero descriptor queda ahora con <a href="ejemplos/avanzado/web2.txt">esta</a>
      apariencia. </p>
           
      <p>Para probar el ejemplo, seguimos también los mismos pasos que para el
      ejemplo anterior. </p>
           
      <h4>3.2.3.3. Seguridad declarativa y SSL</h4>
           
      <p>Podemos incorporar SSL a los métodos de autentificación basados en
      seguridad declarativa vistos antes, sin más que incluyendo, dentro de la
      etiqueta <b>&lt;security-constraint&gt;</b>, una subetiqueta <b>&lt;user-data-constraint&gt;</b>.
      No necesitamos modificar el resto de la estructura para utilizar SSL, lo
      único que se necesita es adaptar el servidor Web para que soporte SSL, y añadir esta etiqueta, que contiene: </p>
           
        <ul>
          <li>Una subetiqueta <b>&lt;transport-guarantee&gt;</b>, que tendrá
            como posibles valores NONE, INTEGRAL o CONFIDENTIAL.
            <ul>
              <li>Con NONE no se imponen restricciones en el protocolo de
                comunicación</li>
              <li>Con INTEGRAL se impone una variedad de comunicación que
                previene el hecho de modificar los datos mientras se envían,
                sin que se detecte dicho cambio.</li>
              <li>Con CONFIDENTIAL se indica que los datos se envían para
                evitar que cualquiera que los intercepte pueda leerlos.</li>
            </ul>
          </li>
          <li>Un elemento <b>&lt;description&gt;</b>  opcional</li>
        </ul>
        <p>La API de servlets proporciona, además, una forma de requerir a los
        clientes que se identifiquen con un certificado. Se puede proporcionar
        un valor de CLIENT-CERT a la etiqueta <i>&lt;auth-method&gt; </i>de <i>&lt;login-config&gt;</i>.
        Sin embargo, sólo los servidores que soporten J2EE por completo
        soportarán esta posibilidad. Incluso los servidores que soportan las
        versiones 2.3 de servlets y 1.2 de JSP no tienen por qué soportar SSL,
        con lo que esta característica puede no ser portable.</p>
      <p><b>EJEMPLO</b></p>
      <p>Utilizamos el mismo ejemplo visto en la autentificación BASIC,
      añadiendo un directorio <b>/ssl</b>, con un fichero <b>index.html</b>
      dentro. Luego, en el fichero descriptor protegemos dicho directorio con
      SSL, quedando:</p>
      <pre class="codigo">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE web-app PUBLIC 
 &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN&quot;
 &quot;http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;

&lt;web-app&gt;
	&lt;security-constraint&gt;
		&lt;web-resource-collection&gt;
			&lt;web-resource-name&gt;
				Prueba
			&lt;/web-resource-name&gt;
			&lt;url-pattern&gt;
				/prueba/*
			&lt;/url-pattern&gt;
		&lt;/web-resource-collection&gt;
		&lt;auth-constraint&gt;
			&lt;role-name&gt;admin&lt;/role-name&gt;
			&lt;role-name&gt;subadmin&lt;/role-name&gt;
		&lt;/auth-constraint&gt;
	&lt;/security-constraint&gt;
<b>
	&lt;security-constraint&gt;
		&lt;web-resource-collection&gt;
			&lt;web-resource-name&gt;
				PruebaSSL
			&lt;/web-resource-name&gt;
			&lt;url-pattern&gt;
				/ssl/*
			&lt;/url-pattern&gt;
		&lt;/web-resource-collection&gt;
		&lt;auth-constraint&gt;
			&lt;role-name&gt;admin&lt;/role-name&gt;
			&lt;role-name&gt;subadmin&lt;/role-name&gt;
		&lt;/auth-constraint&gt;
		&lt;user-data-constraint&gt;
			&lt;transport-guarantee&gt;
				CONFIDENTIAL
			&lt;/transport-guarantee&gt;
		&lt;/user-data-constraint&gt;
	&lt;/security-constraint&gt;

</b>	&lt;login-config&gt;
	...
&lt;/web-app&gt;</pre>
           
      <p>Dejamos protegido el recurso <i>Prueba</i> del ejemplo anterior de la
      misma forma que está, y añadimos <i>PruebaSSL</i>, para proteger el
      directorio <i>/ssl/*</i> con SSL.</p>
      <p>Aquí está el fichero <a href="ejemplos/avanzado/ejemploseguridadssl.war.zip">WAR</a>
      con toda la aplicación, y <a href="ejemplos/avanzado/web3.txt">aquí</a>
      el fichero descriptor. Para probarlo, podemos acceder a las direcciones:</p>
           
      <pre class="codigo">http://localhost:8080/ejemploseguridadform/prueba/index.html</pre>
           
      <pre class="codigo">http://localhost:8080/ejemploseguridadform/servlet/PruebaServlet</pre>
           
      <pre class="codigo">http://localhost:8080/ejemploseguridadssl/ssl/index.html</pre>
           
      <p>En los dos primeros casos, el comportamiento debe ser el mismo que en
      los ejemplos anteriores. En el tercer caso, entrará en juego la
      configuración SSL y nos mostrará pantallas para aceptar certificados,
      redirigiendo la petición a <i>https</i>. </p>
           
      <h4>3.2.4. Seguridad programada</h4>
           
      <p>La seguridad declarativa vista hasta ahora es la más comúnmente usada
      en las aplicaciones Web. Pero, ¿cómo hacer que nuestros servlets sean
      independientes de determinadas configuraciones del servidor, como la
      gestión de logins y passwords de usuarios, o la gestión de roles? Aquí
      entra en juego la seguridad programada, y con ella, dejamos que los
      servlets y páginas JSP controlen parcial o totalmente los aspectos de
      seguridad. </p>
           
      <h4>3.2.4.1. Combinación con seguridad gestionada por el contenedor</h4>
           
        <p>En algunos casos puede interesar mantener parte de las ventajas que
        ofrece la seguridad declarativa (como la gestión automática de
        usuarios y passwords), y añadir sobre eso las configuraciones
        particulares que podemos alcanzar con la seguridad programada. Así, no
        tenemos que renunciar a los elementos <i>&lt;login-config&gt;</i>, la
        autentificación <i>basic</i> o la basada en formularios, los elementos <i>&lt;security-constraint&gt;</i>,
        etc. Simplemente añadimos un tratamiento adicional a estas
        autentificaciones. </p>
           
        <p>Para poder combinar los dos tipos de seguridad, tenemos algunos
        métodos de utilidad en la clase <i>HttpServletRequest</i>:&nbsp; </p>
           
      <pre class="codigo">String getRemoteUser()
boolean isUserInRole(String role)
String getAuthType()</pre>
           
      <ul>
        <li>Con <b>getRemoteUser()</b> se obtiene el nombre que el cliente
          utilizó para autentificarse. Si no ha habido autentificación,
          devuelve <i>null</i>.</li>
        <li>Con <b>isUserInRole()</b> se obtiene si el usuario está dentro de
          un determinado <i>rol.</i> (si <i>getRemoteUser()</i>
          devuelve <i>null</i> este método devuelve siempre <i>false</i>).
          Además de poder utilizar los usuarios, passwords y roles definidos en
          el fichero de contraseñas, podemos utilizar elementos <b>&lt;secutiry-role-ref&gt;
          </b>dentro de los elementos <i>&lt;servlet&gt; </i>del descriptor de
          despliegue<i>, </i>para definir alias
          para los roles. Estos elementos a su vez pueden contener 3
          subetiquetas:
          <ul>
            <li><b>&lt;description&gt;</b> para indicar un texto descriptivo</li>
            <li> <b>&lt;role-name&gt;</b> para indicar el alias con que se mapea
              el rol</li>
            <li> <b>&lt;role-link&gt;</b>  con el rol que se mapea&nbsp;</li>
          </ul>
          <p>Por ejemplo, supongamos que en el fichero de usuarios tenemos un
          usuario con login <i>manuel</i>, que tiene como rol <i>admin</i> (uno
          de los usuarios de un fichero de passwords visto antes). Sin embargo,
          queremos utilizar un servlet <i>MiServlet</i> que utiliza un rol <i>supervisor</i>
          en lugar de <i>admin</i>. Lo que tenemos que hacer es indicar con las
          etiquetas vistas antes que el rol<i> admin </i>se mapea en <i>supervisor</i>
          para este servlet:</p>
          <pre class="codigo">&lt;?xml...?&gt;
&lt;!DOCTYPE...&gt;
&lt;web-app&gt;
	...
	&lt;servlet&gt;
		&lt;servlet-name&gt;
			Prueba
		&lt;/servlet-name&gt;
		&lt;servlet-class&gt;
			MiServlet
		&lt;/servlet-class&gt;
<b>		&lt;security-role-ref&gt;
			&lt;role-name&gt;
			supervisor
			&lt;/role-name&gt;
			&lt;role-link&gt;
			admin
			&lt;/role-link&gt;
		&lt;/security-role-ref&gt;
</b>	&lt;/servlet&gt;
	...
&lt;/web-app&gt;</pre>
           
          <p>Podemos utilizar dentro del servlet tantos elementos <i>&lt;security-role-ref&gt;</i>
          como sean necesarios para mapear todos los roles que se quiera.</p>
 </li>
        <li>
           
          <p>Con <b>getAuthType()</b> se obtiene el tipo de autentificación
          empleada.</p>
        </li>
      </ul>
        <p><b>EJEMPLO</b></p>
        <p>Vemos el siguiente ejemplo, empaquetado en este fichero <a href="ejemplos/avanzado/ejemploseguridadcombinada.war.zip">WAR</a>,
        y con la siguiente estructura:</p>
        <ul>
          <li>Como fichero descriptor (<i>web.xml</i>) se tiene el siguiente:</li>
        </ul>
        <pre class="codigo">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE web-app PUBLIC  &quot;-//Sun Microsystems, Inc.
//DTD Web Application 2.2//EN&quot;
 &quot;http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;

&lt;web-app&gt;

	&lt;servlet&gt;
		&lt;servlet-name&gt;
		Programada
		&lt;/servlet-name&gt;
		&lt;servlet-class&gt;
		SeguridadProgramadaServlet
		&lt;/servlet-class&gt;
		&lt;security-role-ref&gt;
			&lt;role-name&gt;
			supervisor
			&lt;/role-name&gt;
			&lt;role-link&gt;
			admin
			&lt;/role-link&gt;
		&lt;/security-role-ref&gt;
	&lt;/servlet&gt;

	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;
		Programada
		&lt;/servlet-name&gt;
		&lt;url-pattern&gt;
		/ejemploProgramada
		&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;

	&lt;security-constraint&gt;
		&lt;web-resource-collection&gt;
			&lt;web-resource-name&gt;
			Protegido
			&lt;/web-resource-name&gt;
			&lt;url-pattern&gt;
			/ejemploProgramada/*
			&lt;/url-pattern&gt;
		&lt;/web-resource-collection&gt;
		&lt;auth-constraint&gt;
			&lt;role-name&gt;*&lt;/role-name&gt;
		&lt;/auth-constraint&gt;
	&lt;/security-constraint&gt;

	&lt;login-config&gt;
		&lt;auth-method&gt;BASIC&lt;/auth-method&gt;
		&lt;realm-name&gt;Dominio&lt;/realm-name&gt;
	&lt;/login-config&gt;
&lt;/web-app&gt;</pre>
           
        <blockquote>
          <p>donde se mapea el servlet a la dirección <i>/ejemploProgramada/</i>,
          y se mapea el rol <i>admin</i> con un alias <i>supervisor</i> que se
          puede utilizar en su lugar en el código del servlet. Finalmente, se
          protege la ruta <i>/ejemploProgramada/*</i>&nbsp; con autentificación
          BASIC.</p>
        </blockquote>
        <ul>
          <li>El servlet <b> SeguridadProgramadaServlet</b> muestra por pantalla el rol
            al que pertenece el usuario que se ha autentificado con éxito</li>
        </ul>
        <pre class="codigo">import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class SeguridadProgramadaServlet 
extends HttpServlet
{
	public void doGet(HttpServletRequest request, 
			  HttpServletResponse response) 
	throws ServletException, IOException
	{
		response.setContentType(&quot;text/html&quot;);
		PrintWriter out=response.getWriter();
		out.println (&quot;&lt;HTML&gt;&lt;BODY&gt;&quot;);
		out.println 
		  (&quot;&lt;h2&gt;Usuario 'admin':&quot; + 
		  (request.isUserInRole(&quot;admin&quot;)?
		  &quot;SI&quot;:&quot;NO&quot;) + 
		  &quot;&lt;/h2&gt;&quot;);
		out.println 
		  (&quot;&lt;h2&gt;Usuario 'supervisor':&quot; + 
		  (request.isUserInRole(&quot;supervisor&quot;)?
		  &quot;SI&quot;:&quot;NO&quot;) + 
		  &quot;&lt;/h2&gt;&quot;);
		out.println 
		  (&quot;&lt;h2&gt;Usuario 'usuario':&quot; + 
		  (request.isUserInRole(&quot;usuario&quot;)?
		  &quot;SI&quot;:&quot;NO&quot;) + 
		  &quot;&lt;/h2&gt;&quot;);
		out.println (&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
	}

	public void doPost(HttpServletRequest request, 
		           HttpServletResponse response) 
	throws ServletException, IOException
	{
		doGet(request, response);
	}
}</pre>
           
        <ul>
          <li>El fichero de logins y passwords es el mismo que el visto en
            ejemplos anteriores.</li>
        </ul>
      <p>Para probar el ejemplo, intentamos acceder al servlet con: </p>
           
        <pre class="codigo">http://localhost:8080/ejemploseguridadcombinada/ejemploProgramada</pre>
           
      <p>Si entramos con alguno de los usuarios del fichero de passwords visto
      en ejemplos anteriores, nos dirá los roles que tiene dicho usuario. </p>
           
      <h4>3.2.4.2. Seguridad completamente programada</h4>
           
        <p>Como hemos visto, dejar en parte o totalmente que el contenedor
        gestione la seguridad tiene como inconvenientes que cuestiones como la
        gestión de usuarios son dependientes del servidor. Por ello en algunos
        casos interesa dejar que el servlet o la página JSP controle dicha
        gestión de usuarios también, convirtiendo la seguridad en algo
        completamente programado. </p>
           
        <p>Para implementar una seguridad completamente programada utilizando un
        método <i>basic</i> (el método <i>digest</i> no lo veremos por no
        estar demasiado difundido), los pasos son: </p>
           
        <p><b>1. Comprobar si hay una cabecera &quot;Authorization&quot;</b> </p>
           
        <p>Si no la hay, vamos al paso 5 </p>
           
        <p><b>2. Obtener el login y password codificados de dicha cabecera</b> </p>
           
        <p>Si hay cabecera <i>Authorization</i> tendrá el siguiente formato: </p>
           
        <pre class="codigo">Authorization: Basic datos_codificados</pre>
           
        <p>Saltándonos los 6 primeros caracteres (&quot;Basic &quot;)
        obtendremos los datos codificados que deberemos descodificar. </p>
           
        <p><b>3. Descodificar el login y password con Base64</b> </p>
           
        <p>Se utiliza para ello un objeto <i>Base64Decoder </i>(que viene con
        JDK, en el paquete <i>sun.misc</i>), y llamando a su método <i>decodeBuffer()</i>,
        que devuelve una cadena con el formato: </p>
           
        <pre class="codigo">usuario:password</pre>
           
        <p>Podemos luego separar login y password procesando esta cadena. Hay
        que tener en cuenta también que, al estar en el paquete <i>sun.misc</i>,
        no se garantiza la portabilidad del descodificador entre sistemas
        distintos. </p>
           
        <p><b>4. Comprobar si login y password son correctos</b> </p>
           
        <p>Para ello se pueden tener los login y passwords guardados en una base
        de datos, o en un objeto <i>Properties</i> en el servlet, o cualquier
        otra posibilidad. Se trata de buscar el password que hay en la base de
        datos para el usuario que ha entrado y compararlo con el que ha
        introducido. </p>
           
        <p><b>5. Si no hay autentificación, o falla, enviar la respuesta
        apropiada</b> </p>
           
        <p>Se envía un código 401, y una cabecera <i>WWW-Authenticate</i> para
        que el navegador muestre un diálogo y que el usuario se autentifique. </p>
           
        <p><b>EJEMPLO</b> </p>
           
        <p>Como ejemplo de seguridad completamente programada se tiene el <a href="apuntes1_5.htm#autHTTP">ejemplo</a>
        de cabeceras de autentificación visto en el apartado de cabeceras y
        códigos. </p>
           
        <h4>3.2.4.3. Seguridad programada y SSL</h4>
           
      <p>Al igual que con la seguridad declarativa, podemos incorporar SSL en
        nuestra aplicación Web con seguridad programada, aunque se requiere
        algo más de trabajo para poderlo incorporar. Además de adaptar el
      servidor Web para que permita SSL, entre otras cosas, se puede
        requerir: </p>
           
        <p><b>Determinar si se está usando SSL</b> </p>
           
        <p>La interfaz <i>ServletRequest</i> tiene los métodos: </p>
           
        <pre class="codigo">String getScheme()
boolean isSecure()</pre>
           
        <p>El primero devuelve <i>&quot;http&quot;</i> para peticiones normales
        y <i>&quot;https&quot;</i> para peticiones SSL. El segundo devuelve <i>true</i>
        para peticiones SSL, y <i>false</i> para peticiones normales. </p>
           
        <p><b>Redirigir peticiones que no sean SSL</b> </p>
           
        <p>Con la seguridad declarativa utilizábamos las etiquetas <i>&lt;user-data-constraint&gt;</i>
        y subetiquetas <i>&lt;transport-guarantee&gt;</i> para indicar que se
        redirigieran las peticiones <i>http</i> a <i>https</i>. </p>
           
        <p>Con seguridad programada, tenemos que hacer esta redirección a mano,
        empleando el método <b>sendRedirect()</b> de <i>ServletResponse</i>. El
        problema está en que la conversión de la URL desde <i>http</i> a <i>https</i>
        debe hacerse a mano, obteniendo la cadena de la URL con el método <b>getRequestURL()</b>
        de <i>ServletRequest</i>, cambiando luego <i>http</i> por <i>https</i>
        en la cadena y enviando esa cadena procesada al <i>sendRedirect()</i>
        (enviando también los datos del formulario tomándolos con <b>getQueryString()</b>) </p>
           
        <p><b>Obtener el número de bits de la clave y algoritmo</b> </p>
           
        <p>A partir de la versión 2.3 de servlets, podemos acceder a un
        atributo llamado: </p>
           
        <pre class="codigo">&quot;javax.servlet.request.key_size&quot;</pre>
           
        <p>pasándole este nombre al método <b>getAttribute()</b> del objeto <i>HttpServletRequest</i>.
        Se devuelve un objeto con el número de bits de la clave de encriptado,
        que luego tendremos que convertir a <i>Integer</i> para obtener su
        valor. </p>
           
        <p>De forma parecida podemos obtener el tipo de algoritmo empleado para
        encriptar, utilizando para ello el atributo: </p>
           
        <pre class="codigo">&quot;javax.servlet.request.cipher_suite&quot;</pre>
           
        <p>que deberemos convertir luego de <i>Object</i> a <i>String</i>. </p>
           
        <p><b>Acceder a los certificados X509 del cliente</b> </p>
           
        <p>Los certificados X509 están especificados en la RFC 1421. Cuando un
        cliente se autentifica con este certificado, el valor del mismo se
        coloca en el atributo </p>
           
        <pre class="codigo">&quot;javax.servlet.request.X509Certificate&quot;</pre>
           
        <p>de la petición. Este atributo está accesible tanto en la versión
        2.2 como la 2.3 de servlets. Al obtenerlo, tendremos que convertirlo
        luego de <i>Object</i> a <i>X509Certificate</i>. </p>
           
        <p>Una vez tengamos el certificado, podemos obtener el nombre del
        usuario, número de serie, valor de la firma, clave pública, etc. Para
        más información, se puede consultar la dirección: </p>
           
        <p><a href="http://java.sun.com/j2se/1.3/docs/api/java/security/cert/X509Certificate.html">http://java.sun.com/j2se/1.3/docs/api/java/security/cert/X509Certificate.html</a> </p>
           
        <p><b>EJEMPLO</b> </p>
           
        <p>El siguiente servlet muestra en una página toda la información
        sobre la conexión SSL, o bien redirige una petición <i>http</i> a <i>https</i>
        si es el caso: </p>
           
        <pre class="codigo">import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.security.cert.*;

public class ServletSSL extends HttpServlet
{
    public void doGet(HttpServletRequest request, 
		      HttpServletResponse response)
    throws ServletException, IOException
    {
	if (request.getScheme().equalsIgnoreCase(&quot;http&quot;))
	{
<b>	    // Convertimos la URL a https
</b>			
	    String urlInicial = 
		request.getRequestURL().toString();

	    int indice = urlInicial.indexOf(&quot;:&quot;);
	    String urlNueva = 
		urlInicial.substring(0, indice) + 
		&quot;s&quot; + urlInicial.substring(indice);
			
	    String datos = request.getQueryString();
	    if (datos != null)
		urlNueva = urlNueva + &quot;?&quot; + datos;
			
	    response.sendRedirect(urlNueva);
			
	} else {
	
<b>	    // Mostramos los datos de la conexion SSL
</b>	
	    PrintWriter out = response.getWriter();
	    out.println (&quot;&lt;HTML&gt;&quot;);
	    out.println (&quot;&lt;BODY&gt;&quot;);

	    if (request.isSecure())
	    {
		<b>// Bits de la clave
</b>
		Integer tamClave = 
		   (Integer)request.getAttribute(
		   &quot;javax.servlet.request.key_size&quot;);
		String cadenaTam = (tamClave != null)?
			           &quot;&quot; + tamClave.intValue():
				   &quot;Desconocido&quot;;
  	    	out.println (&quot;&lt;LI&gt;Tamaño: &quot; + 
			    cadenaTam + &quot;&lt;/LI&gt;&quot;);

		<b>// Algoritmo empleado</b>

	        String algoritmo = 
		   (String)request.getAttribute(
		   &quot;javax.servlet.request.cipher_suite&quot;);
		String cadenaAlg = (algoritmo != null)?
			           algoritmo:
				   &quot;Desconocido&quot;;
		out.println (&quot;&lt;LI&gt;Algoritmo: &quot; + 
			    cadenaAlg + &quot;&lt;/LI&gt;&quot;);

		<b>// Datos del certificado</b>

		X509Certificate cert = 
		   (X509Certificate)request.getAttribute(
		   &quot;javax.servlet.request.X509Certificate&quot;);
		String cadenaCer = (cert != null)?
			           cert.toString():
				   &quot;Desconocido&quot;;
	        out.println (&quot;&lt;LI&gt;Certificado: &quot; + 
			    cadenaCer + &quot;&lt;/LI&gt;&quot;);
	    }
			
	    out.println (&quot;&lt;/BODY&gt;&quot;);
	    out.println (&quot;&lt;/HTML&gt;&quot;);
	}		
    }	
}</pre>
           
      <blockquote>
           
        <p>&nbsp; </p>
           
      </blockquote>
           
        </body>
        </html>
