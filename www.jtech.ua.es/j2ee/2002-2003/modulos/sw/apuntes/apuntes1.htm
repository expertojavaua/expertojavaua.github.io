<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <title>Tema 1: Introducci&oacute;n a los Servicios Web</title>
                             
  <meta content="text/html; charset=iso-8859-1"
 http-equiv="Content-Type">
               
  <link href="../../../apuntes.css" rel="stylesheet" type="text/css">
                 
  <meta content="Microsoft FrontPage 4.0" name="GENERATOR">
</head>
  <body bgcolor="#ffffff" text="#000000">
<h1>1. Introducci&oacute;n a los Servicios Web</h1>
<p>El dise&ntilde;o del software tiende a ser cada vez m&aacute;s modular. Las 
  aplicaciones se componen de una serie de componentes (servicios) reutilizables, 
  que pueden encontrarse distribuidos a lo largo de una serie de m&aacute;quinas 
  conectadas en red.</p>
<p>Los Servicios Web nos permitir&aacute;n distribuir nuestra aplicaci&oacute;n 
  a trav&eacute;s de Internet, pudiendo una aplicaci&oacute;n utilizar los servicios 
  ofrecidos por cualquier servidor conectado a Internet.</p>
<h2>1.1 &iquest;Qu&eacute; es un Servicio Web?</h2>
<p>Un Servicio Web es un componente al que podemos acceder mediante protocolos 
  Web est&aacute;ndar, utilizando XML para el intercambio de informaci&oacute;n.</p>
<p>Normalmente nos referimos con Servicio Web a una colecci&oacute;n de procedimientos 
  (m&eacute;todos) a los que podemos llamar desde cualquier lugar de Internet 
  o de nuestra intranet, siendo este mecanismo de invocaci&oacute;n totalmente 
  independiente de la plataforma que utilicemos y del lenguaje de programaci&oacute;n 
  en el que se haya implementado internamente el servicio.</p>
<p>Cuando conectamos a un servidor web desde nuestro navegador, el servidor nos 
  devuelve la p&aacute;gina web solicitada, que es un documento que se mostrar&aacute; 
  en el navegador para que lo visualice el usuario, pero es dif&iacute;cilmente 
  entendible por una m&aacute;quina. Podemos ver esto como web para humanos. En 
  contraposici&oacute;n, los Servicios Web ofrecen informaci&oacute;n con un formato 
  est&aacute;ndar que puede ser entendido f&aacute;cilmente por una aplicaci&oacute;n. 
  En este caso estar&iacute;amos ante una web para m&aacute;quinas. </p>
<h2>1.2 Caracter&iacute;sticas de los Servicios Web</h2>
<p>Las caracter&iacute;sticas deseables de un Servicio Web son:</p>
<ul>
  <li>Un servicio debe poder ser <strong>accesible a trav&eacute;s de la Web</strong>. 
    Para ello debe utilizar protocolos de transporte est&aacute;ndares como HTTP, 
    y codificar los mensajes en un lenguaje est&aacute;ndar que pueda conocer 
    cualquier cliente que quiera utilizar el servicio.</li>
  <li>Un servicio debe contener una <strong>descripci&oacute;n de s&iacute; mismo</strong>. 
    De esta forma, una aplicaci&oacute;n podr&aacute; saber cu&aacute;l es la 
    funci&oacute;n de un determinado Servicio Web, y cu&aacute;l es su interfaz, 
    de manera que pueda ser utilizado de forma autom&aacute;tica por cualquier 
    aplicaci&oacute;n, sin la intervenci&oacute;n del usuario.</li>
  <li>Debe poder <strong>ser localizado</strong>. Deberemos tener alg&uacute;n 
    mecanismo que nos permita encontrar un Servicio Web que realice una determinada 
    funci&oacute;n. De esta forma tendremos la posibilidad de que una aplicaci&oacute;n 
    localice el servicio que necesite de forma autom&aacute;tica, sin tener que 
    conocerlo previamente el usuario.</li>
</ul>
<h2>1.3 Arquitectura de los Servicios Web</h2>
<p>Podemos ver la arquitectura de los Servicios Web desde dos puntos de vista. 
  En el primero de ellos estudiaremos la funci&oacute;n de cada agente en el mecanismo 
  de localizaci&oacute;n e invocaci&oacute;n de Servicios Web, mientras que en 
  el segundo abstraeremos una serie de capas en las que se organizan los protocolos 
  que se utilizan para realizar estas funciones </p>
<h3>1.3.1 Arquitectura funcional</h3>
<p>Podemos distinguir tres agentes con diferentes funciones:</p>
<table width="101%" border="0">
  <tr> 
    <td width="33%"><strong>Proveedor de servicio</strong> </td>
    <td width="67%">Implementa unas determinadas operaciones (servicio). Un cliente 
      podr&aacute; solicitar uno de estos servicios a este proveedor. </td>
  </tr>
  <tr> 
    <td><strong>Cliente del servicio</strong></td>
    <td>Invoca a un proveedor de servicio para la realizaci&oacute;n de alguna 
      de los operaciones que proporciona.</td>
  </tr>
  <tr> 
    <td><strong>Registro de servicios</strong></td>
    <td>Mantiene una lista de proveedores de servicios disponibles, junto a sus 
      descripciones.</td>
  </tr>
</table>
<p>El mecanismo b&aacute;sico de invocaci&oacute;n de servicios consistir&aacute; 
  en que un cliente solicitar&aacute; un determinado servicio a un proveedor, 
  efectuando el proveedor dicho servicio. El servidor devolver&aacute; una respuesta 
  al cliente como resultado del servicio invocado.</p>
<p>Esto podremos hacerlo as&iacute; si el cliente conoce de antemano el proveedor 
  del cual va a obtener el servicio. Pero hemos de pensar que en Internet encontraremos 
  una gran cantidad de Servicios Web dispersos, lo cual har&aacute; dif&iacute;cil 
  localizar el que busquemos. Adem&aacute;s, si hemos localizado uno que realiza 
  la funci&oacute;n que necesitamos, si dicho servicio no est&aacute; mantenido 
  por nosotros puede ocurrir que en alg&uacute;n momento este servicio cambie 
  de lugar, de interfaz o simplemente desaparezca, por lo que no podremos confiar 
  en que vayamos a poder utilizar siempre este mismo servicio.</p>
<p>Los registros de servicios nos permiten automatizar la localizaci&oacute;n 
  de Servicios Web. Un proveedor puede <em>anunciarse </em>en un determinado registro, 
  de forma que figurar&aacute; en dicho registro la localizaci&oacute;n de este 
  servicio junto a una descripci&oacute;n de su funcionalidad y de su interfaz, 
  que podr&aacute; ser entendida por una aplicaci&oacute;n.</p>
<p>Cuando un cliente necesite un determinado servicio, puede acudir directamente 
  a un registro y solicitar el tipo de servicio que necesita. Para ello es importante 
  establecer un determinada sem&aacute;ntica sobre las posibles descripciones 
  de funcionalidades de servicios, evitando las posibles ambig&uuml;edades.</p>
<p>El registro devolver&aacute; entonces una lista de servicios que realicen la 
  funci&oacute;n deseada, de los cuales el cliente podr&aacute; elegir el m&aacute;s 
  apropiado, analizar su interfaz, e invocarlo.</p>
<h3>1.3.2 Arquitectura de capas de protocolos</h3>
<p>Los protocolos utilizados en los Servicios Web se organizan en una serie de 
  capas:</p>
<table width="100%" border="0">
  <tr> 
    <td width="33%"><strong>Capa</strong></td>
    <td width="67%"><strong>Descripci&oacute;n</strong></td>
  </tr>
  <tr> 
    <td><em>Transporte de servicios</em></td>
    <td>Es la capa que se encarga de transportar los mensajes entre aplicaciones. 
      Normalmente se utiliza el protocolo <strong>HTTP</strong> para este transporte, 
      aunque los servicios web pueden viajar mediante otros protocolos de transferencia 
      de hipertexto como SMTP, FTP o BEEP.</td>
  </tr>
  <tr> 
    <td><em>Mensajer&iacute;a XML</em></td>
    <td>Es la capa responsable de codificar los mensajes en XML de forma que puedan 
      ser entendidos por cualquier aplicaci&oacute;n. Puede implementar los protocolos 
      XML-RPC o<strong> SOAP</strong>.</td>
  </tr>
  <tr> 
    <td><em>Descripci&oacute;n de servicios</em></td>
    <td>Se encarga de definir la interfaz p&uacute;blica de un determinado servicio. 
      Est&aacute; definici&oacute;n se realiza mediante <strong>WSDL</strong>.</td>
  </tr>
  <tr> 
    <td><em>Localizaci&oacute;n de servicios</em></td>
    <td>Se encarga del registro centralizado de servicios, permitiendo que estos 
      sean anunciados y localizados. Para ello se utiliza el protocolo <strong>UDDI</strong>.</td>
  </tr>
</table>
<p>M&aacute;s adelante describiremos cada una de las tecnolog&iacute;as para Servicios 
  Web vistas en las distintas capas.</p>
<h2>1.4 Seguridad</h2>
<p>En la utilizaci&oacute;n de los Servicios Web, encontramos problemas de seguridad 
  en diferentes aspectos. Podemos encontrar problemas de seguridad en cuanto a 
  la confidencialidad, la autentificaci&oacute;n y la seguridad de la red.</p>
<h3>1.4.1 Confidencialidad</h3>
<p>Cuando un cliente utiliza un Servicio Web, deber&aacute; enviarle un mensaje 
  a este servicio a trav&eacute;s de la red, y el servicio le responder&aacute; 
  mediante otro mensaje. Estos mensajes contendr&aacute;n informaci&oacute;n que 
  puede ser confidencial.</p>
<p>Dado que estos mensajes se env&iacute;an mediante protocolo HTTP, podr&aacute;n 
  ser encriptados mediante SSL evitando de esta forma que puedan ser interceptados 
  por un tercero.</p>
<p>Sin embargo, en aplicaciones en las que el mensaje deba atravesar una cadena 
  de servicios, este mensaje deber&aacute; desencriptarse y volverse a encriptar 
  entero en cada uno de estos servicios, por lo que los datos estar&aacute;n inseguros 
  dentro de cada nodo. Podr&iacute;amos solucionar este problema permitiendo que 
  s&oacute;lo se desencripte en cada nodo una parte del mensaje, que ser&aacute; 
  la parte que ata&ntilde;e a dicho nodo, pero que no pueda acceder al resto del 
  mensaje que no le concierne.</p>
<h3>1.4.2 Autentificaci&oacute;n</h3>
<p>Puede que necesitemos identificar a un usuario para prestarle un determinado 
  servicio, o bien para saber si tiene autorizaci&oacute;n para acceder a dicho 
  servicio. </p>
<p>Podemos utilizar para ello la autentificaci&oacute;n que nos proporciona el 
  protocolo HTTP. Encontramos el mismo problema que en el caso anterior, necesitamos 
  invocar un conjunto de servicios, deberemos autentificarnos por separado para 
  cada uno de ellos, ya que pueden estar distribuidos en distintos servidores 
  a trav&eacute;s de Internet. Para solucionar este problema, deber&iacute;amos 
  contar con un contexto compartido global de donde cualquier servicio pudiese 
  obtener esta informaci&oacute;n de autentificaci&oacute;n.</p>
<h3>1.4.3 Seguridad de la red</h3>
<p>Hemos de pensar que estamos permitiendo invocar procedimientos remotos mediante 
  protocolo HTTP, que en un principio fue dise&ntilde;ado para la extracci&oacute;n 
  de documentos. Por lo tanto, sus puertos no suelen ser cortados por ning&uacute;n 
  <em>firewall</em>, de forma cualquiera podr&aacute; utilizar estos servicios 
  libremente, sin que los <em>firewalls</em> puedan controlarlo.</p>
<h2>1.5 Tecnolog&iacute;as b&aacute;sicas</h2>
<p>Tenemos una serie de tecnolog&iacute;as, todas ellas basadas en XML, que son 
  fundamentales para el desarrollo de Servicios Web. Estas tecnolog&iacute;as 
  son independientes tanto del SO como del lenguaje de programaci&oacute;n utilizado 
  para implementar dichos servicios. Por lo tanto, ser&aacute;n utilizadas para 
  cualquier Servicio Web, independientemente de la plataforma sobre la que construyamos 
  dichos servicios (como puede ser J2EE o .NET). </p>
<h3>1.5.1 SOAP</h3>
<p>Se trata de un protocolo derivado de XML que nos sirve para intercambiar informaci&oacute;n 
  entre aplicaciones.</p>
<p>Normalmente utilizaremos SOAP para conectarnos a un servicio e invocar m&eacute;todos 
  remotos, aunque puede ser utilizado de forma m&aacute;s gen&eacute;rica para 
  enviar cualquier tipo de contenido. Podemos distinguir dos tipos de mensajes 
  seg&uacute;n su contenido:</p>
<ul>
  <li><strong>Mensajes orientados al documento</strong>: Contienen cualquier tipo 
    de contenido que queramos enviar entre aplicaciones.</li>
  <li><strong>Mensajes orientados a RPC</strong>: Este tipo de mensajes servir&aacute; 
    para invocar procedimientos de forma remota (<em>Remote Procedure Calls</em>). 
    Podemos verlo como un tipo m&aacute;s concreto dentro del tipo anterior, ya 
    que en este caso como contenido del mensaje especificaremos el m&eacute;todo 
    que queremos invocar junto a los par&aacute;metros que le pasamos, y el servidor 
    nos deber&aacute; devolver como respuesta un mensaje SOAP con el resultado 
    de invocar el m&eacute;todo.</li>
</ul>
<p>Cuando hablamos de Servicios Web normalmente nos referimos a RPC, por lo que 
  nos centraremos en este tipo de mensajes. </p>
<p>Puede ser utilizado sobre varios protocolos de transporte, aunque est&aacute; 
  especialmente dise&ntilde;ado para trabajar sobre HTTP.</p>
<p>Dentro del mensaje SOAP podemos distinguir los siguientes elementos:</p>
<center><img src="imagenes/soap.gif" width="203" height="225"></center>
<ul>
  <li>Un sobre (<strong>Envelope</strong>), que describe el mensaje, a quien va 
    dirigido, y c&oacute;mo debe ser procesado. El sobre incluye las definiciones 
    de tipos que se usar&aacute;n en el documento. Contiene una cabecera de forma 
    opcional, y el cuerpo del mensaje.</li>
  <li>Una cabecera (<strong>Header</strong>) opcional, donde podemos incluir informaci&oacute;n 
    sobre el mensaje. Por ejemplo, podemos especificar si el mensaje es obligatorio 
    (debe ser entendido de forma obligatoria por el destinatario), e indicar los 
    actores (lugares por donde ha pasado el mensaje).</li>
  <li>El cuerpo del mensaje (<strong>Body</strong>), que contiene el mensaje en 
    si. En el caso de los mensajes RPC se define una convenci&oacute;n sobre como 
    debe ser este contenido, en el que se especificar&aacute; el m&eacute;todo 
    al que se invoca y los valores que se pasan como par&aacute;metros. Puede 
    contener un error de forma opcional.</li>
  <li>Un error (<strong>Fault</strong>) en el cuerpo del mensaje de forma opcional. 
    Nos servir&aacute; para indicar en una respuesta SOAP que ha habido un error 
    en el procesamiento del mensaje de petici&oacute;n que mandamos.</li>
</ul>
<p>Hemos visto como los mensajes SOAP nos sirven para intercambiar cualquier documento 
  XML entre aplicaciones. Pero puede ocurrir que necesitemos enviar en el mensaje 
  datos que no son XML, como puede ser una imagen. En ese caso tendremos que recurrir 
  a la especificaci&oacute;n de mensajes SOAP con anexos.</p>
<p>Los mensajes SOAP con anexos a&ntilde;aden un elemento m&aacute;s al mensaje:</p>
<center><img src="imagenes/swa.gif" width="203" height="269"></center>
<ul>
  <li>El anexo (<strong>Attachment</strong>), puede contener cualquier tipo de 
    contenido (incluido el XML). De esta forma podremos enviar cualquier tipo 
    de contenido junto a un mensaje SOAP.</li>
</ul>
<p>Nuestro mensaje podr&aacute; contener tantos anexos como queramos.</p>
<p>Un ejemplo de mensaje SOAP es el siguiente:</p>
<pre class="codigo">&lt;SOAP-ENV:Envelope 
 xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;    
 SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;    
	&lt;SOAP-ENV:Body&gt; 
		&lt;ns:getTemperatura xmlns:ns=&quot;http://rvg.ua.es/ns&quot;&gt;    
			&lt;area&gt;Alicante&lt;/area&gt; 
		&lt;/ns:getTemperatura&gt; 
	&lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;</pre>
<p>En &eacute;l estamos llamando a nuestro m&eacute;todo <em>getTemperatura</em> 
  para obtener informaci&oacute;n meteorol&oacute;gica, proporcionando como par&aacute;metro 
  el &aacute;rea de la que queremos obtener la temperatura.</p>
<p>Podemos encontrar la especificaci&oacute;n de SOAP y SOAP con anexos publicada 
  en la p&aacute;gina del W3C, en las direcciones <em>http://www.w3.org/TR/SOAP/</em> 
  y <em>http://www.w3.org/TR/SOAP-attachments</em> respectivamente.</p>
<p></p>
<h3>1.5.2 WSDL</h3>
<p>Es otro lenguaje derivado de XML, que se utiliza para describir los Servicios 
  Web, de forma que una aplicaci&oacute;n pueda conocer de forma autom&aacute;tica 
  la funci&oacute;n de un Servicio Web, as&iacute; como la forma de uso de dicho 
  Servicio Web.</p>
<p>El fichero WSDL describir&aacute; la interfaz del Servicio Web, con los m&eacute;todos 
  a los que podemos invocar, los par&aacute;metros que debemos proporcionarles 
  y los tipos de datos de dichos par&aacute;metros.</p>
<p>Si desarrollamos un Servicio Web, y queremos que otras personas sean capaces 
  de utilizar nuestro servicio para sus aplicaciones, podremos proporcionar un 
  documento WSDL describiendo nuestro servicio. De esta forma, a partir de este 
  documento otros usuarios podr&aacute;n generar aplicaciones clientes en cualquier 
  plataforma (ya que WSDL se define como un est&aacute;ndar) que se ajusten a 
  nuestro servicio.</p>
<p>El elemento ra&iacute;z dentro de este fichero es <strong>definitions</strong>, 
  donde se especifican los espacios de nombres que utilizamos en nuestro servicio. 
  Dentro de este elemento ra&iacute;z encontramos los siguientes elementos:</p>
<ul>
  <li><strong>types</strong>: Se utiliza para definir los tipos de datos que se 
    intercambiar&aacute;n en el mensaje.</li>
  <li><strong>message</strong>: Define los distintos mensajes que se intercambiaran 
    durante el proceso de invocaci&oacute;n del servicio. Se deber&aacute;n definir 
    los mensajes de entrada y salida para cada operaci&oacute;n que ofrezca el 
    servicio. En el caso de mensajes RPC, en el mensaje de entrada se definir&aacute;n 
    los tipos de par&aacute;metros que se proporcionan, y en el de salida el tipo 
    del valor devuelto.</li>
  <li><strong>portType</strong>: Define las operaciones que ofrece el servicio. 
    De cada operaci&oacute;n indica cuales son los mensajes de entrada y salida, 
    de entre los mensajes definidos en el apartado anterior.</li>
  <li><strong>binding</strong>: Indica el protocolo y el formato de los datos 
    para cada mensaje de los definidos anteriormente. Este formato puede ser orientado 
    al documento u orientado a RPC. Si es orientado al documento tanto el mensaje 
    de entrada como el de salida contendr&aacute;n un documento XML. Si es orientado 
    a RPC el mensaje de entrada contendr&aacute; el m&eacute;todo invocado y sus 
    par&aacute;metros, y el de salida el resultado de invocar dicho m&eacute;todo.</li>
  <li><strong>service</strong>: Define el servicio como una colecci&oacute;n de 
    puertos a los que se puede acceder. Un puerto es la direcci&oacute;n (URL) 
    donde el servicio act&uacute;a. Esta ser&aacute; la direcci&oacute;n a la 
    que las aplicaciones deber&aacute;n conectarse para acceder al servicio. Adem&aacute;s 
    contiene la documentaci&oacute;n en lenguaje natural del servicio.</li>
</ul>
<p>Un documento WSDL de ejemplo es el siguiente:</p>
<pre class="codigo">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; 
  &lt;<strong>definitions</strong> xmlns:s=&quot;http://www.w3.org/2001/XMLSchema&quot;
	 xmlns:http=&quot;http://schemas.xmlsoap.org/wsdl/http/&quot;    
	 xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; 
	 xmlns:soapenc=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;
     xmlns:tns=&quot;http://rvg.ua.es/wsdl&quot;
     xmlns:mime=&quot;http://schemas.xmlsoap.org/wsdl/mime/&quot; 
	 targetNamespace=&quot;http://rvg.ua.es/wsdl&quot;
     xmlns=&quot;http://schemas.xmlsoap.org/wsdl/&quot;&gt;
   &lt;<strong>message</strong> name=&quot;getTempRequest&quot;&gt;
	   &lt;part name=&quot;string_1&quot; 
			xmlns:partns=&quot;http://www.w3.org/2001/XMLSchema&quot;
		    type=&quot;partns:string&quot; /&gt; 
   &lt;/<strong>message</strong>&gt;
   &lt;<strong>message</strong> name=&quot;getTempResponse&quot;&gt;
	   &lt;part name=&quot;double_1&quot; 
			xmlns:partns=&quot;http://www.w3.org/2001/XMLSchema&quot;
		    type=&quot;partns:double&quot; /&gt; 
   &lt;/<strong>message</strong>&gt;
   &lt;<strong>portType</strong> name=&quot;TempPortType&quot;&gt;
	   &lt;operation name=&quot;getTemp&quot;&gt;
		   &lt;input message=&quot;tns:getTempRequest&quot; /&gt; 
		   &lt;output message=&quot;tns:getTempResponse&quot; /&gt; 
	   &lt;/operation&gt;
   &lt;/<strong>portType</strong>&gt;
   &lt;<strong>binding</strong> name=&quot;TempPortSoapBinding&quot; type=&quot;tns:TempPortType&quot;&gt;
	   &lt;soap:binding style=&quot;rpc&quot; 
		transport=&quot;http://schemas.xmlsoap.org/soap/http&quot; /&gt; 
       &lt;operation name=&quot;getTemp&quot;&gt;
			&lt;soap:operation soapAction=&quot;&quot; style=&quot;rpc&quot; /&gt; 
			&lt;input&gt;
				&lt;soap:body use=&quot;encoded&quot; 
				namespace=&quot;http://rvg.ua.es/wsdl&quot; 
				encodingStyle=
					&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; /&gt; 
			&lt;/input&gt;
			&lt;output&gt;
				&lt;soap:body use=&quot;encoded&quot; 
				namespace=&quot;http://rvg.ua.es/wsdl&quot;    
				encodingStyle=
					&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; /&gt; 
			   &lt;/output&gt;
		&lt;/operation&gt;
   &lt;/<strong>binding</strong>&gt;
   &lt;<strong>service</strong> name=&quot;Temp&quot;&gt;
	   &lt;documentation&gt;Documentacion&lt;/documentation&gt;    
	   &lt;port name=&quot;TempPort&quot; binding=&quot;tns:TempPortSoapBinding&quot;&gt;
		   &lt;soap:address 
				location=&quot;http://localhost:7001/sw_temp/Temp&quot; /&gt; 
	   &lt;/port&gt;
   &lt;/<strong>service</strong>&gt;
&lt;/<strong>definitions</strong>&gt;</pre>
<p>En el que se define un servicio que proporciona el m&eacute;todo <em>getTemp</em>, 
  que toma como par&aacute;metro una cadena con el nombre del &aacute;rea que 
  queremos consultar, y nos devuelve un valor real. </p>
<p>En los elementos <strong>message</strong> vemos que tenemos dos mensajes: los 
  mensajes de entrada y salida de la operaci&oacute;n <em>getTemp</em> de nuestro 
  servicio. El mensaje de entrada contiene un dato de tipo <em>string</em> (el 
  par&aacute;metro del m&eacute;todo), y el de salida es de tipo <em>double</em> 
  (la temperatura que devuelve el servicio).</p>
<p>El elemento <strong>portType</strong> define la operaci&oacute;n <em>getTemp</em> 
  a partir de los mensajes de entrada y salida que la componen, y en <strong>binding</strong> 
  se establece esta operaci&oacute;n como de tipo RPC y se indica la codificaci&oacute;n 
  de estos mensajes.</p>
<p>Por &uacute;ltimo en el apartado <strong>service</strong> se especifica el 
  puerto al que podemos conectar para usar el servicio, dando la URL a la que 
  nuestro cliente deber&aacute; acceder. </p>
<p>Podemos encontrar la especificaci&oacute;n de WSDL publicada en la p&aacute;gina 
  del W3C, en la direcci&oacute;n <em>http://www.w3.org/TR/wsdl</em>.</p>
<p></p>
<h3>1.5.3 UDDI</h3>
<p>UDDI nos permite localizar Servicios Web. UDDI define la especificaci&oacute;n 
  para construir un directorio distribuido de Servicios Web, donde los datos se 
  almacenan en XML.</p>
<p>Adem&aacute;s, UDDI define una API para trabajar con dicho registro, que nos 
  permitir&aacute; buscar datos almacenados en &eacute;l, y publicar datos nuevos. 
</p>
<p>De esta forma, una aplicaci&oacute;n podr&aacute; anunciar sus servicios en 
  un registro UDDI, o bien localizar servicios que necesitemos mediante este registro.</p>
<p>Esta capacidad de localizar servicios en tiempo de ejecuci&oacute;n, y de que 
  una aplicaci&oacute;n pueda saber c&oacute;mo utilizarlo inmediatamente gracias 
  a la descripci&oacute;n del servicio, nos permitir&aacute; realizar una integraci&oacute;n 
  d&eacute;bilmente acoplada de nuestra aplicaci&oacute;n.</p>
<p>La interfaz de UDDI est&aacute; basada en SOAP. Para acceder al registro se 
  utilizar&aacute;n mensajes SOAP, que son transportados mediante protocolo HTTP.</p>
<p>Podemos encontrar la especificaci&oacute;n de UDDI, documentaci&oacute;n, y 
  m&aacute;s informaci&oacute;n en la direcci&oacute;n <em>http://www.uddi.org/</em>.</p>
<p></p>
<h2>1.6. Tecnolog&iacute;as J2EE para Servicios Web</h2>
<p>Hemos visto las tecnolog&iacute;as en las que se basan los Servicios Web, y 
  que los hacen independientes de la plataforma y del lenguaje de programaci&oacute;n 
  utilizado. Sin embargo, escribir manualmente los mensajes SOAP desde nuestras 
  aplicaciones puede ser una tarea tediosa. Por ello, las distintas plataformas 
  existentes incorporan librer&iacute;as y utilidades que se encargan de realizar 
  esta tarea por nosotros.</p>
<p>En este tema veremos las librer&iacute;as que incorpora J2EE para la generaci&oacute;n 
  y el procesamiento de c&oacute;digo XML, que nos servir&aacute;n para implementar 
  y utilizar Servicios Web.</p>
<h3>1.6.1 JAXP</h3>
<p>La API JAXP nos permite procesar cualquier documento XML desde lenguaje Java. 
  Tiene en cuenta los espacios de nombres, lo cual nos permite trabajar con DTDs 
  que podr&iacute;an tener conflictos de nombres si estos no estuviesen soportados. 
  Adem&aacute;s, soporta XSLT, lo cual nos permitir&aacute; convertir un documento 
  XML a otro formato, como por ejemplo HTML.</p>
<p>Esta es una librer&iacute;a gen&eacute;rica, para procesar cualquier documento 
  XML. A continuaci&oacute;n veremos una serie de librer&iacute;as, para tareas 
  m&aacute;s especificas, que se apoyan en JAXP para realizar el procesado de 
  diferentes lenguajes como SOAP, WSDL y UDDI, todos ellos derivados de XML. Por 
  lo tanto, todas estas librer&iacute;as depender&aacute;n de JAXP para su correcto 
  funcionamiento.</p>
<h3>1.6.2 JAXM</h3>
<p>La API JAXM implementa la mensajer&iacute;a XML en Java orientada al documento. 
  Nos permitir&aacute; de forma sencilla crear mensajes XML, insertando el contenido 
  que queramos en ellos, y enviarlos a cualquier destinatario, as&iacute; como 
  extraer el contenido de los mensajes que recibamos. Permite enviar y recibir 
  los mensajes de forma s&iacute;ncrona (modelo petici&oacute;n-respuesta) o as&iacute;ncrona 
  (env&iacute;o de mensaje sin esperar respuesta).</p>
<p>Los mensajes XML con los que trabaja JAXM siguen la especificaci&oacute;n SOAP 
  y SOAP con anexos. Dentro de JAXM encontramos dos APIs:</p>
<ul>
  <li>SAAJ (<em>SOAP with Attachmets API for Java</em>) es la API que se utiliza 
    para construir mensajes SOAP y para extraer la informaci&oacute;n que contienen. 
    Esta API es independiente, y suficiente para enviar mensajes de tipo petici&oacute;n-respuesta 
    (s&iacute;ncronos).</li>
  <li>JAXM proporciona un proveedor de mensajer&iacute;a XML, con el que podremos 
    enviar y recibir mensajes de forma as&iacute;ncrona, sin necesidad de esperar 
    una respuesta de la otra parte. Esta API depender&aacute; de SAAJ para funcionar, 
    ya que SAAJ es la que se encargar&aacute; de crear y manipular los mensajes.</li>
</ul>
<h3>1.6.3 JAX-RPC</h3>
<p>La API JAX-RPC implementa la infraestructura para realizar llamadas a procedimiento 
  remoto (RPC) mediante XML. En este caso se enviar&aacute; un mensaje SOAP con 
  el m&eacute;todo que queremos invocar junto a los par&aacute;metros que le pasamos, 
  y nos devolver&aacute; de forma s&iacute;ncrona una respuesta SOAP con el valor 
  devuelto por el m&eacute;todo tras su ejecuci&oacute;n. </p>
<p>Por lo tanto, JAX-RPC depender&aacute; de SAAJ para construir los mensajes 
  SOAP, para enviarlos, y para extraer la informaci&oacute;n del mensaje SOAP 
  que nos devuelve como resultado.</p>
<p>Esta API nos permitir&aacute;, de forma sencilla, invocar Servicios Web de 
  tipo RPC, as&iacute; como crear nuestros propios Servicios Web RPC a partir 
  de clases Java que tengamos implementadas. Cuando hablamos de Servicios Web, 
  normalmente nos referimos a este tipo de Servicios Web.</p>
<h3>1.6.4 JAXR</h3>
<p>La API JAXR nos permitir&aacute; acceder a registros XML a trav&eacute;s de 
  una API est&aacute;ndar Java. Esta API pretende proporcionar una interfaz &uacute;nica 
  para acceder a distintos tipos de registros, cada uno de los cuales tiene un 
  protocolo distinto.</p>
<p>Actualmente JAXR es capaz de trabajar con registros UDDI y ebXML. Podremos 
  realizar dos tipos de tareas distintas cuando accedamos a un registro mediante 
  JAXR:</p>
<ul>
  <li>Consultar el registro, para localizar los servicios que necesitemos.</li>
  <li>Publicar un servicio en el registro, para que otros clientes sean capaces 
    de localizarlo cuando lo necesiten, as&iacute; como modificar o eliminar los 
    servicios publicados que sean de nuestra propiedad.</li>
</ul>
<h3>1.6.5 JAXB</h3>
<p>La API de JAXB (<em>Java API for Binding</em>) nos permite asociar esquemas 
  XML y c&oacute;digo Java. A partir de un esquema XML, podremos generar una clase 
  Java que represente dicho esquema. </p>
<p>De esta forma podremos convertir un documento XML a una serie de objetos Java 
  que contendr&aacute;n la informaci&oacute;n de dicho documento (<em>unmarshalling</em>). 
  Podremos entonces trabajar desde nuestra aplicaci&oacute;n con estos objetos, 
  accediendo y modificando sus valores. Finalmente, podremos volver a obtener 
  un documento XML a partir de los objetos Java (<em>marshalling</em>).</p>
<p>Esto nos va a simplificar la tarea de utilizar tipos de datos propios en llamadas 
  a Servicios Web, ya que utilizando JAXB podremos realizar de forma sencilla 
  la conversi&oacute;n entre nuestra clase Java y un documento XML con la informaci&oacute;n 
  de dicha clase.</p>
<h3>1.6.6 Java API for WSDL</h3>
<p>La API de Java para WSDL nos permite de forma sencilla analizar documentos 
  WSDL, y de esa forma poder descubrir las caracter&iacute;sticas de un servicio 
  en tiempo de ejecuci&oacute;n. </p>
<p>Mediante esta API, podremos <em>&quot;interrogar&quot;</em> un servicio a partir 
  de su especificaci&oacute;n WSDL, y obtener informaci&oacute;n como las operaciones 
  que podemos invocar en este servicio, los par&aacute;metros que deberemos proporcionar 
  a cada una de ellas, y el tipo de datos resultante que nos devuelven. </p>
<p>De esta forma podremos realizar la integraci&oacute;n de la aplicaci&oacute;n 
  en tiempo de ejecuci&oacute;n, ya que no ser&aacute; necesario indicar al programa 
  c&oacute;mo debe acceder a un servicio, ni los m&eacute;todos a los que debe 
  llamar, sino que el programa ser&aacute; capaz de determinar esta informaci&oacute;n 
  analizando la especificaci&oacute;n WSDL del servicio.</p>
</body>
</html>
