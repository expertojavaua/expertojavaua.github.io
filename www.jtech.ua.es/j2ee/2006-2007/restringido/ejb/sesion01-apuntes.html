<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Introducci&oacute;n a los Enterprise JavaBeans</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Componentes EJB" src="images/baner_j2ee_der.gif" title="Componentes EJB"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Componentes EJB</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Componentes EJB">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 1</div>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="Beans de sesi&oacute;n">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html" title="Beans de sesi&oacute;n">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html" title="Beans de sesi&oacute;n">Sesi&oacute;n 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html" title="Seguridad">Sesi&oacute;n 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html" title="Transacciones">Sesi&oacute;n 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html" title="EJB 3.0">Sesi&oacute;n 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html" title="JPA">Sesi&oacute;n 8</a>
</div>
<div class="menuitem">
<a href="roadmap.html" title="Roadmap EJB">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html" title="Introducci&oacute;n a los Enterprise Beans">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html" title="Beans de sesi&oacute;n">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html" title="Beans de sesi&oacute;n">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html" title="Beans de sesi&oacute;n con estado">Sesi&oacute;n 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html" title="Seguridad">Sesi&oacute;n 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html" title="Transacciones">Sesi&oacute;n 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html" title="EJB 3.0">Sesi&oacute;n 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html" title="JPA">Sesi&oacute;n 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion01-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Introducci&oacute;n a los Enterprise JavaBeans</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Componentes+manejados+por+el+servidor+de+aplicaciones">Componentes manejados por el servidor de aplicaciones</a>
</li>
<li>
<a href="#Servicios+proporcionados+por+el+contenedor+EJB">Servicios proporcionados por el contenedor EJB</a>
</li>
<li>
<a href="#Funcionamiento+de+los+componentes+EJB">Funcionamiento de los componentes EJB</a>
</li>
<li>
<a href="#Un+ejemplo+de+cliente">Un ejemplo de cliente</a>
</li>
<li>
<a href="#Tipos+de+beans">Tipos de beans</a>
<ul class="minitoc">
<li>
<a href="#Beans+de+sesi%C3%B3n">Beans de sesi&oacute;n</a>
<ul class="minitoc">
<li>
<a href="#Beans+de+sesi%C3%B3n+sin+estado">Beans de sesi&oacute;n sin estado</a>
</li>
<li>
<a href="#Beans+de+sesi%C3%B3n+con+estado">Beans de sesi&oacute;n con estado</a>
</li>
</ul>
</li>
<li>
<a href="#Beans+de+entidad">Beans de entidad</a>
</li>
<li>
<a href="#Beans+dirigidos+por+mensajes">Beans dirigidos por mensajes</a>
</li>
</ul>
</li>
</ul>
</div>


<p>En este m&oacute;dulo del T&iacute;tulo de Especialista vamos a presentar la tecnolog&iacute;a Enterprise JavaBeans. Se trata de una tecnolog&iacute;a que permite definir componentes que encapsulan objetos de negocio gestionados por un servidor de aplicaciones.</p>


<p>Antes de empezar, es importante realizar una aclaraci&oacute;n sobre la versi&oacute;n de la arquitectura que vamos a estudiar en las pr&oacute;ximas sesiones. Recientemente se ha presentado la &uacute;ltima versi&oacute;n de la especificaci&oacute;n EJB, la 3.0. En ella se introducen cambios muy importantes con respecto a la 2.1, la versi&oacute;n anterior. Entre estos cambios destacan la utilizaci&oacute;n de anotaciones para definir los beans, sustituyendo a los ficheros de descripci&oacute;n de propiedades XML, y la introducci&oacute;n de un framework de persistencia muy similar a Hibernate, el JPA (<em>Java Persistence API</em>). Estas novedades simplifican bastante el desarrollo de los enterprise beans, y es previsible que la nueva especificaci&oacute;n tarde poco en ser adoptada por la industrian. Sin embargo, hoy por por hoy la gran mayor&iacute;a de servidores de aplicaciones todav&iacute;a no han dado el salto a la especificaci&oacute;n 3.0.</p>


<p>En el m&oacute;dulo vamos a presentar la arquitectura EJB, utilizando la especificaci&oacute;n m&aacute;s usada (por ahora) la 2.1 para definir beans de sesi&oacute;n. En las &uacute;ltimas sesiones del m&oacute;dulo realizaremos una breve introducci&oacute;n a la especificaci&oacute;n 3.0, comentando sobre todo el uso de anotaciones y JPA.</p>


<p>Para la especificaci&oacute;n 2.1 utilizaremos BEA WebLogic 9.2 como servidor de aplicaciones y BEA Workshop como entorno de desarrollo. Para la sesi&oacute;n en la que hablaremos de la especificaci&oacute;n 3.0 utilizaremos la versi&oacute;n pre-release BEA WebLogic 10 (todav&iacute;a en pruebas).</p>


<a name="N1001B"></a><a name="Componentes+manejados+por+el+servidor+de+aplicaciones"></a>
<h2 class="underlined_10">Componentes manejados por el servidor de aplicaciones</h2>
<div class="section">
<p>Comenzamos este nuevo m&oacute;dulo con una comparaci&oacute;n que ayudar&aacute; a entender qu&eacute; es la arquitectura Enterprise JavaBeans (EJB). Lo mejor es compararla con algo que ya conocemos y que hemos estudiado en produndidad: la arquitectura de las aplicaciones Web. Esta &uacute;ltima arquitectura permite el desarrollo de aplicaciones distribuidas cliente-servidor. Los clientes (navegadores Web) realizan peticiones a un servidor. Las peticiones se realizan en un protocolo especial (HTTP) que nos permite definir la petici&oacute;n y los argumentos que se pasan al servidor. El servidor recoge la petici&oacute;n, comprueba ciertos permisos (seguridad) y, si todo es correcto, la ejecuta mediante la llamada al servlet (c&oacute;digo Java) asociado a la petici&oacute;n. El servlet recoge los par&aacute;metros de la petici&oacute;n, los procesa, consulta recursos del servidor (bases de datos, objetos, etc.) y devuelve el resultado, en forma de texto HTML.</p>
<p>Supongamos que tenemos un servidor que gestiona una empresa de mensajer&iacute;a y queremos saber los pedidos que va a entregar un agente determinado. La forma de hacerlo siguiendo esta arquitectura ser&iacute;a realizar una petici&oacute;n HTTP en la que pondr&iacute;amos algo parecido a <span class="codefrag">/listaPedidos?agente=107</span> con la que pedimos la lista de pedidos asignada al agente 107. El resultado ser&iacute;a un c&oacute;digo HTML parecido a:</p>
<pre class="code">
&lt;ul&gt;
   &lt;li&gt;Pedido id=883247110&lt;/li&gt;
   &lt;li&gt;Pedido id=392349429&lt;/li&gt;
   &lt;li&gt;Pedido id=232494592&lt;/li&gt;
   &lt;li&gt;Pedido id=945821134&lt;/li&gt;
&lt;/ul&gt;</pre>
<p>El navegador interpretar&aacute; este texto HTML y mostrar&aacute; la lista de pedidos por pantalla. Este tipo de comportamiento puede ser apropiado si queremos mostrar el listado de pedidos. Pero si queremos que esta respuesta sea procesada por un programa que realiza alg&uacute;n proceso con los identificadores de los pedidos, el enfoque ya no es tan apropiado.</p>
<p> Podr&iacute;amos definir un cliente Java que (utilizando las librer&iacute;as de red) realizara una petici&oacute;n HTTP y recogiera la respuesta (fichero de texto HTML). El proceso deber&iacute;a recoger el HTML, descodificarlo (buscando ciertas etiquetas que deber&iacute;amos saber que est&aacute;n ah&iacute;) y obtener los identificadores. Los problemas son muy grandes. No s&oacute;lo de programaci&oacute;n, sino de mantenimiento. Si en un momento alguien cambia el texto devuelto por el servlet, hay que cambiar el c&oacute;digo del proceso que descodifica el resultado.</p>
<p>&iquest;No ser&iacute;a interesante poder escribir un c&oacute;digo Java en el cliente que pidiera los datos "directamente" al servidor? Sin utilizar el protocolo HTTP, sino de una forma mucho m&aacute;s directa. Por ejemplo:</p>
<pre class="code">(1) PedidosFactory pedidosFactory = getPedidosFactory(serverConection);
(2) Pedidos pedidos = pedidosFactory.create();
(3) List&lt;PedidoTo&gt; listaPedidos = pedidos.getLista("107");</pre>
<p>En la primera instrucci&oacute;n obtenemos una factoria de Pedidos. Esta factor&iacute;a crea a su vez objetos de tipo <span class="codefrag">Pedidos</span> (con el m&eacute;todo <span class="codefrag">create</span>) con los que podremos realizar directamente peticiones relacionadas con los pedidos. En l&iacute;nea 2 se crea un objeto de esta clase. Despu&eacute;s (l&iacute;nea 3) usamos ese objeto para pedir el m&eacute;todo <span class="codefrag">getLista</span> que devuelve una lista de pedidos (<em>transfer objects</em> de tipo <span class="codefrag">PedidoTo</span>) asociados al agente "107". Esta vez obtenemos una lista de objetos Java, que podemos procesar con sus m&eacute;todos <span class="codefrag">get</span> correspondientes. Esta forma de obtener una lista de pedidos es mucho m&aacute;s sencilla (y mantenible) que descodificar un fichero de texto.</p>
<p>Las tres llamadas del ejemplo anterior son remotas, realizadas desde un cliente en una m&aacute;quina virtual (u ordenador) hacia un ordenador remoto en el que reside un servidor que procesa estas peticiones.</p>
<p>El servidor del oordenador remoto recibe las peticiones, las "analiza" y las responde, incorporando sus funcionalidades a&ntilde;adidas (ver el siguiente apartado).</p>
<p>La arquitectura Enterprise JavaBeans permite este tipo de funcionamiento. El nombre que recibe el servidor que procesa este tipo de peticiones es el de <em>contenedor EJB</em>. El contenedor mantiene los <em>objetos remotos</em> y procesa las peticiones de los clientes, de la misma forma que un servidor web contiene aplicaciones web y procesa peticiones HTTP. Sin embargo, en esta arquitectura las peticiones son m&aacute;s similares a las <em>llamadas a procedimientos remotos</em>, en las que se intenta que la red sea transparente y que parezca que estamos llamando a un objeto normal situado en la propia m&aacute;quina virtual del cliente.</p>
<p>Para posibilitar esta arquitectura, el programador y dise&ntilde;ador debe implementar <em>componentes</em> que residen en el contenedor EJB. En este m&oacute;dulo veremos c&oacute;mo hacerlo. Tambi&eacute;n analizaremos cu&aacute;les son las posibilidades y limitaciones de estas entidades nuevas denominadas <em>componentes EJB</em>.</p>
<p>El desarrollo basado en componentes promete un paso m&aacute;s en el camino de la programaci&oacute;n orientada a objetos. Con la programaci&oacute;n orientada a objetos puedes reutilizar clases, pero con componentes es posible reutilizar funcionalidades de mayor nivel e incluso es posible modificar estas funcionalidades y adaptarlas a cada entorno de trabajo particular sin tocar el c&oacute;digo del componente desarrollado. Aunque veremos el tema con mucho m&aacute;s detalle, en este momento puedes ver un componente como un objeto tradicional que reside en un <em>contenedor</em> que soporta y ofrece al cliente un conjunto de servicios adicionales en tiempo de ejecuci&oacute;n. El contenedor se denomina <em>contenedor EJB</em> y es algo as&iacute; como el sistema operativo en el que &eacute;stos residen. El servicio de contenedor EJB es uno de los servicios proporcionados por los <em>servidores de aplicaciones</em>.</p>
<p>La implementaci&oacute;n de los componentes EJB remotos se basa en el modelo de programaci&oacute;n de objetos remotos de Java, denominado RMI. Con RMI es posible enviar peticiones a objetos que est&aacute;n ejecut&aacute;ndose en otra m&aacute;quina virtual Java. Podemos ver un componente EJB como un objeto remoto RMI que reside en un contenedor EJB que le proporciona un conjunto de servicios adicionales. Para el desarrollador de componentes EJB es &uacute;til el conocimiento de RMI a nivel te&oacute;rico, porque explica qu&eacute; est&aacute; sucediendo por debajo de la capa de abstracci&oacute;n proporcionada por la arquitectura EJB.</p>
<p>Cuando se est&aacute; trabajando con componentes se tiene que dedicar tanta atenci&oacute;n al despliegue (<em>deployment</em>) del componente como a su desarrollo.  Entendemos por despliegue la incorporaci&oacute;n del componente a nuestro contenedor EJB y a nuestro entorno de trabajo (bases de datos, arquitectura de la aplicaci&oacute;n, etc.). El despliegue se define de forma declarativa, mediante un fichero XML (descriptor del despliegue, <em>deployment descriptor</em>) en el que se definen todas las caracter&iacute;sticas del bean.</p>
<p>El desarrollo basado en componentes ha creado expectativas sobre la aparici&oacute;n de una serie de empresas dedicadas a implementar y vender componentes espec&iacute;ficos a terceros. Este mercado de componentes nunca ha llegado a tener la suficiente masa cr&iacute;tica como para crear una industria sostenible. Esto es debido a distintas razones, como la dificultad en el dise&ntilde;o de componentes gen&eacute;ricos capaces de adaptarse a distintos dominios de aplicaci&oacute;n, la falta de estandarizaci&oacute;n de los dominios de aplicaci&oacute;n o la diversidad de estos dominios. Aun as&iacute;, existe un campo creciente de negocio en esta &aacute;rea, que est&aacute; resurgiendo por la aparici&oacute;n de interfaces HTTP contra estos componentes formando los denominados <em>servicios web</em>.</p>
<p>Por &uacute;ltimo, comentar que no siempre los componentes EJB son distribuidos. Es posible utilizar componentes EJB de forma local y hacer que un proceso (un servlet, por ejemplo) se comunique de forma local con un componente EJB que reside en la misma m&aacute;quina virtual (el mismo servidor de aplicaciones). Aun en este caso, todas las peticiones al componente ser&aacute;n analizadas y gestionadas por el contenedor EJB, proporcionando servicios como la seguridad o transaccionalidad.</p>
</div>


<a name="N1008D"></a><a name="Servicios+proporcionados+por+el+contenedor+EJB"></a>
<h2 class="underlined_10">Servicios proporcionados por el contenedor EJB</h2>
<div class="section">
<p>En el apartado anterior hemos comentado que la diferencia fundamental entre los componentes y los objetos cl&aacute;sicos reside en que los componentes <em>viven</em> en un contenedor EJB que los envuelve proporcionando una capa de servicios a&ntilde;adidos. &iquest;Cu&aacute;les son estos servicios? Los m&aacute;s importantes son los siguientes:</p>
<ul>


<li>
<strong>Manejo de transacciones</strong>: apertura y cierre de transacciones asociadas a las llamadas a los m&eacute;todos del bean.</li>


<li>Seguridad: comprobaci&oacute;n de permisos de acceso a los m&eacute;todos del bean.</li>


<li>
<strong>Concurrencia</strong>: llamada simult&aacute;nea a un mismo bean desde m&uacute;ltiples clientes.</li>


<li>
<strong>Servicios de red</strong>: comunicaci&oacute;n entre el cliente y el bean en m&aacute;quinas distintas.</li>


<li>
<strong>Gesti&oacute;n de recursos</strong>: gesti&oacute;n autom&aacute;tica de m&uacute;ltiples recursos, como colas de mensajes, bases de datos o fuentes de datos en aplicaciones heredadas que no han sido traducidas a nuevos lenguajes/entornos y siguen us&aacute;ndose en la empresa.</li>


<li>
<strong>Persistencia</strong>: sincronizaci&oacute;n entre los datos del bean y tablas de una base de datos.</li>


<li>
<strong>Gesti&oacute;n de mensajes</strong>: manejo de Java Message Service (JMS).</li>


<li>
<strong>Escalabilidad</strong>: posibilidad de constituir clusters de servidores de aplicaciones con m&uacute;ltiples hosts para poder dar respuesta a aumentos repentinos de carga de la aplicaci&oacute;n con s&oacute;lo a&ntilde;adir hosts adicionales.</li>


<li>
<strong>Adaptaci&oacute;n en tiempo de despliegue</strong>: posibilidad de modificaci&oacute;n de todas estas caracter&iacute;sticas en el momento del despliegue del bean.</li>

</ul>
<p>Piensa en lo complicado que ser&iacute;a programar una clase "a mano" que implementara todas estas caracter&iacute;sticas. Como se suele decir, la programaci&oacute;n de EJB es sencilla si la comparamos con lo que habr&iacute;a que implementar de hacerlo todo por uno mismo.  Evidentemente, si en la aplicaci&oacute;n que est&aacute;s desarrollando no vas a necesitar estos servicios podr&iacute;as utilizar simplemente p&aacute;ginas JSP y JDBC.</p>
</div>


<a name="N100CB"></a><a name="Funcionamiento+de+los+componentes+EJB"></a>
<h2 class="underlined_10">Funcionamiento de los componentes EJB</h2>
<div class="section">
<p>El funcionamiento de los componentes EJB se basa fundamentalmente en el trabajo del contenedor EJB. El contenedor EJB es un programa Java que corre en el servidor y que contiene todas las clases y objetos necesarios para el correcto funcionamiento de los enterprise beans.</p>
<p>En la figura siguiente puedes ver una representaci&oacute;n de muy alto nivel del funcionamiento b&aacute;sico de los enterprise beans, en la que podemos ver los objetos que implementan un componente en el lado del servidor. Se trata de un ejemplo de utilizaci&oacute;n de los beans de forma remota, en el que el cliente que realiza las peticiones y el servidor que contiene el bean se encuentran en m&aacute;quinas virtuales Java y en hosts distintos. Vemos en la figura como el cliente realiza una petici&oacute;n a un m&eacute;todo de una interfaz, denominada <em>interfaz de negocio</em>, implementada por un objeto EJB (<em>EJB Object</em>). Este objeto usa los servicios del contenedor para comunicarse con el objeto (Enterprise bean) que es el que finalmente realiza la petici&oacute;n. El resultado de la petici&oacute;n es devuelto al objeto EJB interfaz y &eacute;ste lo devuelve al cliente.
</p>
<p>Hay que resaltar que el cliente <em>nunca</em> se comunica directamente con el enterprise bean, sino que el <em>EJBObject</em> hace de interfaz, proporcionando los servicios del contenedor (seguridad, transaccionalidad, etc.).</p>
<p>

<img alt="Representaci&oacute;n de alto nivel del funcionamiento de los enterprise beans." content-width="10cm" src="imagenes/apuntes/arquitecturaEJB.jpg" width="500"> 
</p>
<p>El objeto <em>EJBObject</em> es implementado autom&aacute;ticamente por el contenedor EJB (el programador s&oacute;lo debe <em>declarar</em> la interfaz) y se preocupa por tanto de cuestiones como:</p>
<ul>

<li>&iquest;Tiene el cliente permiso para llamar al m&eacute;todo?</li>


<li>Hay que abrir la transacci&oacute;n al comienzo de la llamada y cerrarla al terminar.</li>


<li>&iquest;Es necesario refrescar el bean con los datos de la base de datos?</li>

</ul>
<p>Vamos a ver un ejemplo para que puedas entender mejor el flujo de llamadas. Supongamos que tenemos una aplicaci&oacute;n de bolsa y el bean proporciona una implementaci&oacute;n de un Broker. La interfaz de negocio del Broker est&aacute; compuesta de varios m&eacute;todos, entre ellos, por ejemplo, los m&eacute;todos <em>compra</em> o <em>vende</em>. Supongamos que desde el objeto cliente queremos llamar al m&eacute;todo <em>compra</em>. Esto va a provocar la siguiente secuencia de llamadas:</p>
<ol>

<li>
<em>Cliente</em>: "Necesito realizar una petici&oacute;n de compra al bean Broker."</li>

<li>
<em>EJBObject</em>: "Espera un momento, necesito comprobar tus permisos."</li>

<li>
<em>Contenedor EJB</em>: "S&iacute;, el cliente tiene permisos suficientes para llamar al m&eacute;todo compra."</li>

<li>
<em>Contenedor EJB</em>: "Necesito un bean Broker para realizar una operaci&oacute;n de compra. Y no olvid&eacute;is comenzar la transacci&oacute;n en el momento de instanciaros."</li>

<li>
<em>Pool de beans</em>: "A ver... &iquest;a qui&eacute;n de nosotros le toca esta vez?".</li>

<li>
<em>Contenedor EJB</em>: "Ya tengo un bean Broker. P&aacute;sale la petici&oacute;n del cliente."</li>

</ol>
<p>Por cierto, la idea de usar este tipo de di&aacute;logos para describir el funcionamiento de un proceso o una arquitectura de un sistema inform&aacute;tico es de Kathy Sierra en sus libros <em>"Head First Java"</em> y "<em>Head First EJB"</em>. Se trata de un tipo de libros radicalmente distintos a los habituales manuales de Java que consiguen que realmente aprendas este lenguaje cuando los sigues.  &Eacute;chales un vistazo si tienes oportunidad.</p>
</div>


<a name="N1013B"></a><a name="Un+ejemplo+de+cliente"></a>
<h2 class="underlined_10">Un ejemplo de cliente</h2>
<div class="section">
<p>Vamos a ver un ejemplo real, con c&oacute;digo Java, de c&oacute;mo un cliente usa el bean <span class="codefrag">SaludoBean</span> de forma remota. Supongamos que ya tenemos desplegado el bean en el servidor de aplicaciones.</p>
<p> Para usar un <span class="codefrag">SaludoBean</span> el cliente tendr&aacute; que acceder al contenedor, obtener una referencia al <span class="codefrag">SaludoHome</span>, llamar a su m&eacute;todo <span class="codefrag">create()</span> para obtener un <span class="codefrag">Saludo</span> y llamar a su m&eacute;todo <span class="codefrag">saluda()</span>. Lo vemos en el siguiente c&oacute;digo.</p>
<pre class="code">package sesion1.clients;

import java.io.IOException;
import java.util.Properties;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.rmi.PortableRemoteObject;

import sesion1.beans.Saludo;
import sesion1.beans.SaludoHome;

public class SaludoClient {

   public static void main(String[] args) {
      try {
/*1*/         Context jndiContext = getInitialContext();
/*2*/         Object obj = jndiContext.lookup("SaludoBean"); 
/*3*/         SaludoHome home = (SaludoHome) narrow(obj, SaludoHome.class); 
/*4*/         obj = home.create(); 
         Saludo saludo = (Saludo) narrow(obj, Saludo.class);

         System.out.println("Voy a llamar al bean");
/*5*/         System.out.println("El bean saludo dice: " + saludo.saluda());
         System.out.println("Ya he llamado al bean");
/*6*/         saludo.remove();
      } catch (Exception e) {
/*7*/         e.printStackTrace();
      }
   }

   private static Context getInitialContext()
         throws javax.naming.NamingException, IOException {
      Properties p = new Properties();
      p.put(Context.INITIAL_CONTEXT_FACTORY,
            "weblogic.jndi.WLInitialContextFactory");
      p.put(Context.PROVIDER_URL, "t3://localhost:7001");
      return new InitialContext(p); //[8]
   }

   private static Object narrow(Object obj, Class clase) {
      return PortableRemoteObject.narrow(obj, clase);
   }
}</pre>
<p>B&aacute;sicamente, el cliente debe realizar siempre las siguientes tareas:</p>
<ul>

<li>L&iacute;nea [1]: Acceder al servicio JNDI, obteniendo el contexto JNDI inicial. Esto se hace en la la funci&oacute;n privada <span class="codefrag">getInitialContext</span>. All&iacute; se llama a <span class="codefrag">javax.naming.InitialContext()</span> (en la l&iacute;nea [8]), pas&aacute;ndole como argumento unas propiedades dependientes del servidor que implementa el JNDI. En este caso estamos asumiendo que el servicio JNDI lo proporciona un servidor de aplicaciones BEA weblogic que est&aacute; ejecut&aacute;ndose en el localhost, en el puerto 7001.</li>


<li>L&iacute;nea [2]: Localizar el bean proporcionando a JNDI su nombre l&oacute;gico (l&iacute;nea 15). En este caso, el nombre JNDI del bean es <span class="codefrag">SaludoBean</span>.</li>


<li>L&iacute;nea [3]: Hacer un casting del objeto que devuelve JNDI para convertirlo en un objeto de la clase <span class="codefrag">SaludoHome</span>. La forma de hacer el casting es especial, y se implementa en la funci&oacute;n privada <span class="codefrag">narrow()</span>, ya que antes de hacer el casting hay que obtener un objeto Java llamando al m&eacute;todo <span class="codefrag">PotableRemoteObject.narrow()</span>porque estamos recibiendo de JNDI un objeto que ha sido serializado usando el protocolo IIOP.</li>


<li>L&iacute;nea [4]: Llamar al m&eacute;todo <span class="codefrag">create()</span> del objeto home para crear un objeto de tipo <span class="codefrag">Saludo</span>. Lo que se obtiene es un <em>stub</em> (hablaremos en el siguiente apartado de esto) y hay que llamar otra vez a narrow para asegurarse de que se obtiene un objeto correcto.</li>


<li>L&iacute;nea [5]: Llamar al m&eacute;todo de negocio del bean.</li>


<li>L&iacute;nea [6]: Indicar que no vamos a usar m&aacute;s el bean.</li>


<li>L&iacute;nea [7]: Hay que capturar todas las posibles excepciones. Se trata de excepciones relacionadas con la conexi&oacute;n remota y con la creaci&oacute;n del bean.</li>

</ul>
<p>El resultado es tan poco espectacular como esto:</p>
<pre class="code">
Voy a llamar al bean
El bean saludo dice: Me alegro de volver a verte
Ya he llamado al bean
</pre>
<p>Un detalle importante es que para que funcione correctamente el programa, el cliente necesita las clases <span class="codefrag">SaludoHome.class</span> y <span class="codefrag">Saludo.class</span> correspondientes a las definiciones de las interfaces.</p>
</div>


<a name="N101A4"></a><a name="Tipos+de+beans"></a>
<h2 class="underlined_10">Tipos de beans</h2>
<div class="section">
<p>La tecnolog&iacute;a EJB define tres tipos de beans: beans de sesi&oacute;n, beans de entidad y beans dirigidos por mensajes.</p>
<p>Los <strong>beans de entidad</strong> representan un objeto concreto que tiene existencia en alguna base de datos de la empresa. Una instancia de un bean de entidad representa una fila en una tabla de la base de datos. Por ejemplo, podr&iacute;amos considerar el bean Cliente, con una instancia del bean siendo Eva Mart&iacute;nez (ID# 342) y otra instancia Francisco G&oacute;mez (ID# 120).</p>
<p>Los <strong>beans dirigidos por mensajes</strong> pueden escuchar mensajes de un servicio de mensajes JMS. Los clientes de estos beans nunca los llaman directamente, sino que es necesario enviar un mensaje JMS para comunicarse con ellos. Los beans dirigidos por mensajes no necesitan objetos EJBObject porque los clientes no se comunican nunca con ellos directamente. Un ejemplo de bean dirigido por mensajes podr&iacute;a ser un bean <span class="codefrag">ListenerNuevoCliente</span> que se activara cada vez que se env&iacute;a un mensaje comunicando que se ha dado de alta a un nuevo cliente.</p>
<p>Por &uacute;ltimo, un <strong>bean de sesi&oacute;n</strong> representa un proceso o una acci&oacute;n de negocio. Normalmente, cualquier llamada a un servicio del servidor deber&iacute;a comenzar con una llamada a un bean de sesi&oacute;n.  Mientras que un bean de entidad representa una cosa que se puede representar con un nombre, al pensar en un bean de sesi&oacute;n deber&iacute;as pensar en un verbo. Ejemplos de beans de sesi&oacute;n podr&iacute;an ser un carrito de la compra de una aplicaci&oacute;n de negocio electr&oacute;nico o un sistema verificador de tarjetas de cr&eacute;dito.</p>
<p>Vamos a describir con algo m&aacute;s de detalle estos tipos de bean.  Comenzamos con los beans de sesi&oacute;n para continuar con los de entidad y terminar con los dirigidos por mensajes.</p>
<a name="N101C5"></a><a name="Beans+de+sesi%C3%B3n"></a>
<h3 class="underlined_5">Beans de sesi&oacute;n</h3>
<p>Los beans de sesi&oacute;n representan sesiones interactivas con uno o m&aacute;s clientes. Los bean de sesi&oacute;n pueden mantener un estado, pero s&oacute;lo durante el tiempo que el cliente interact&uacute;a con el bean. Esto significa que los beans de sesi&oacute;n no almacenan sus datos en una base de datos despu&eacute;s de que el cliente termine el proceso. Por ello se suele decir que los beans de sesi&oacute;n no son persistentes.</p>
<p>A diferencia de los bean de entidad, los beans de sesi&oacute;n no se comparten entre m&aacute;s de un cliente, sino que existe una correspondencia uno-uno entre beans de sesi&oacute;n y clientes. Por esto, el contenedor EJB no necesita implementar mecanismos de manejo de concurrencia en el acceso a estos beans.</p>
<p>Existen dos tipos de beans de sesi&oacute;n: con estado y sin &eacute;l.</p>
<a name="N101D4"></a><a name="Beans+de+sesi%C3%B3n+sin+estado"></a>
<h4>Beans de sesi&oacute;n sin estado</h4>
<p>Los beans de sesi&oacute;n sin estado no se modifican con las llamadas de los clientes. Los m&eacute;todos que ponen a disposici&oacute;n de las aplicaciones clientes son llamadas que reciben datos y devuelven resultados, pero que no modifican internamente el estado del bean.  Esta propiedad permite que el contenedor EJB pueda crear una reserva (<em>pool</em>) de instancias, todas ellas del mismo bean de sesi&oacute;n sin estado y asignar cualquier instancia a cualquier cliente.  Incluso un &uacute;nico bean puede estar asignado a m&uacute;ltiples clientes, ya que la asignaci&oacute;n s&oacute;lo dura el tiempo de invocaci&oacute;n del m&eacute;todo solicitado por el cliente.</p>
<p>Una de las ventajas del uso de beans de sesi&oacute;n, frente al uso de clases Java u objetos RMI es que no es necesario escribir los m&eacute;todos de los beans de sesi&oacute;n de una forma segura para threads ( <em>thread-safe</em>), ya que el contenedor EJB se va a encargar de que nunca haya m&aacute;s de un thread accediendo al objeto. Para ello usa m&uacute;ltiples instancias del bean para responder a peticiones de los clientes.</p>
<p>Cuando un cliente invoca un m&eacute;todo de un bean de sesi&oacute;n sin estado, el contenedor EJB obtiene una instancia de la reserva.  Cualquier instancia servir&aacute;, ya que el bean no puede guardar ninguna informaci&oacute;n referida al cliente. Tan pronto como el m&eacute;todo termina su ejecuci&oacute;n, la instancia del bean est&aacute; disponible para otros clientes. Esta propiedad hace que los beans de sesi&oacute;n sin estado sean muy escalables para un gran n&uacute;mero de clientes. El contenedor EJB no tiene que mover sesiones de la memoria a un almacenamiento secundario para liberar recursos, simplemente puede obtener recursos y memoria destruyendo las instancias.</p>
<p>Los beans de sesi&oacute;n sin estado se usan en general para encapsular procesos de negocio, m&aacute;s que datos de negocio (tarea de los entity beans). Estos beans suelen recibir nombres como <span class="codefrag">ServicioBroker</span> o <span class="codefrag">GestorContratos</span> para dejar claro que proporcionan un conjunto de procesos relacionados con un dominio espec&iacute;fico del negocio.</p>
<p>Es apropiado usar beans de sesi&oacute;n sin estado cuando una tarea no est&aacute; ligada a un cliente espec&iacute;fico. Por ejemplo, se podr&iacute;a usar un bean sin estado para enviar un e-mail que confirme un pedido on-line o calcular unas cuotas de un pr&eacute;stamo.</p>
<p>Tambi&eacute;n puede usarse un bean de sesi&oacute;n sin estado como un puente de acceso a una base de datos o a un bean de entidad. En una arquitectura cliente-servidor, el bean de sesi&oacute;n podr&iacute;a proporcionar al interfaz de usuario del cliente los datos necesarios, as&iacute; como modificar objetos de negocio (base de datos o bean de entidad) a petici&oacute;n de la interfaz. Este uso de los beans de sesi&oacute;n sin estado es muy frecuente y constituye el denominado patr&oacute;n de dise&ntilde;o <em>session facade</em>.</p>
<p>Algunos ejemplos de bean de sesi&oacute;n sin estado podr&iacute;an ser:</p>
<ul>


<li>Un componente que comprueba si un s&iacute;mbolo de compa&ntilde;&iacute;a est&aacute; disponible en el mercado de valores y devuelve la &uacute;ltima cotizaci&oacute;n registrada.</li>


<li>Un componente que calcula la cuota del seguro de un cliente, bas&aacute;ndose en los datos que se le pasa del cliente.</li>


</ul>
<a name="N10208"></a><a name="Beans+de+sesi%C3%B3n+con+estado"></a>
<h4>Beans de sesi&oacute;n con estado</h4>
<p>En un bean de sesi&oacute;n con estado, las <em>variables de instancia</em> del bean almacenan datos espec&iacute;ficos obtenidos durante la conexi&oacute;n con el cliente. Cada bean de sesi&oacute;n con estado, por tanto, almacena el estado conversacional de un cliente que interact&uacute;a con el bean. Este estado conversacional se modifica conforme el cliente va realizando llamadas a los m&eacute;todos de negocio del bean. El estado conversacional no se guarda cuando el cliente termina la sesi&oacute;n.</p>
<p>La interacci&oacute;n del cliente con el bean se divide en un conjunto de pasos. En cada paso se a&ntilde;ade nueva informaci&oacute;n al estado del bean. Cada paso de interacci&oacute;n suele denominarse con nombres como <span class="codefrag">setNombre</span> o <span class="codefrag">setDireccion</span>, siendo <span class="codefrag">nombre</span> y <span class="codefrag">direccion</span> dos variables de instancia del bean.</p>
<p>Algunos ejemplos de beans de sesi&oacute;n con estado podr&iacute;an ser:</p>
<ul>


<li>Un ejemplo t&iacute;pico es un carrito de la compra, en donde el cliente va guardando uno a uno los &iacute;tem que va comprando.</li>


<li>Un enterprise bean que reserva un vuelo y alquila un coche en un sitio Web de una agencia de viajes.</li>


</ul>
<p>El estado del bean persiste mientras que existe el bean. A diferencia de los beans de entidad, no existe ning&uacute;n recurso exterior al contenedor EJB en el que se almacene este estado.</p>
<p>Debido a que el bean guarda el estado conversacional con un cliente determinado, no le es posible al contenedor crear un almac&eacute;n de beans y compartirlos entre muchos clientes. Por ello, el manejo de beans de sesi&oacute;n con estado es m&aacute;s pesado que el de beans de sesi&oacute;n sin estado.</p>
<p>En general, se deber&iacute;a usar un bean de sesi&oacute;n con estado si se cumplen las siguientes circunstancias:</p>
<ul>

<li>El estado del bean representa la interacci&oacute;n entre el bean y un cliente espec&iacute;fico.</li>

<li>El bean necesita mantener informaci&oacute;n del cliente a lo largo de un conjunto de invocaciones de m&eacute;todos.</li>

<li>El bean hace de intermediario entre el cliente y otros componentes de la aplicaci&oacute;n, presentando una vista simplificada al cliente.</li>

</ul>
<a name="N10246"></a><a name="Beans+de+entidad"></a>
<h3 class="underlined_5">Beans de entidad</h3>
<p>Los beans de entidad modelan conceptos o datos de negocio que puede expresarse como nombres. Esto es una regla sencilla m&aacute;s que un requisito formal, pero ayuda a determinar cu&aacute;ndo un concepto de negocio puede ser implementado como un bean de entidad. Los beans de entidad representan "cosas": objetos del mundo real como hoteles, habitaciones, expedientes, estudiantes, y dem&aacute;s. Un bean de entidad puede representar incluso cosas abstractas como una reserva. Los beans de entidad describen tanto el estado como la conducta de objetos del mundo real y permiten a los desarrolladores encapsular las reglas de datos y de negocio asociadas con un concepto espec&iacute;fico. Por ejemplo un bean de entidad <span class="codefrag">Estudiante</span> encapsula los datos y reglas de negocio asociadas a un estudiante. Esto hace posible manejar de forma consistente y segura los datos asociados a un concepto.</p>
<p>Los beans de entidad se corresponden con datos en un almacenamiento persistente (base de datos, sistema de ficheros, etc.). Las variables de instancia del bean representan los datos en las columnas de la base de datos. El contenedor debe sincronizar las variables de instancia del bean con la base de datos. Los beans de entidad se diferencian de los beans de sesi&oacute;n en que las variables de instancia se almacenan de forma persistente.</p>
<p>Aunque entraremos en detalle m&aacute;s adelante, es interesante adelantar que el uso de los beans de entidad desde un cliente conlleva los siguientes pasos:</p>
<ol>


<li>Primero el cliente debe obtener una referencia a la instancia concreta del bean de entidad que se est&aacute; buscando (el estudiante "Francisco L&oacute;pez") mediante un m&eacute;todo <em>finder</em>. Estos m&eacute;todos finder se encuentran definidos en la interfaz home e implementados en la clase bean. Los m&eacute;todos finder pueden devolver uno o varios beans de entidad.</li>


<li>El cliente interact&uacute;a con la instancia del bean usando sus m&eacute;todos <em>get</em> y <em>set</em>. El estado del bean se carga de la base de datos antes de procesar las llamadas a los m&eacute;todos. Esto se encarga de hacerlo el contenedor de forma autom&aacute;tica o el propio bean en la funci&oacute;n <span class="codefrag">ejbLoad()</span>.</li>


<li>Por &uacute;ltimo, cuando el cliente termina la interacci&oacute;n con la instancia del bean sus contenidos se vuelcan en el almacen persistente. O bien lo hace de forma autom&aacute;tica el contenedor o bien &eacute;ste llama al m&eacute;todo <span class="codefrag">ejbStore()</span>.</li>


</ol>
<p>Son muchas las ventajas de usar beans de entidad en lugar de acceder a la base de datos directamente. El uso de beans de entidad nos da una perspectiva orientada a objetos de los datos y proporciona a los programadores un mecanismo m&aacute;s simple para acceder y modificar los datos. Es mucho m&aacute;s f&aacute;cil, por ejemplo, cambiar el nombre de un estudiante llamando a <span class="codefrag">student.setName()</span> que ejecutando un comando SQL contra la base de datos. Adem&aacute;s, el uso de objetos favorece la reutilizaci&oacute;n del software. Una vez que un bean de entidad se ha definido, su definici&oacute;n puede usarse a lo largo de todo el sistema de forma consistente. Un bean <span class="codefrag">Estudiante</span> proporciona un forma completa de acceder a la informaci&oacute;n del estudiante y eso asegura que el acceso a la informaci&oacute;n es consistente y simple.</p>
<p>La representaci&oacute;n de los datos como beans de entidad puede hacer que el desarrollo sea m&aacute;s sencillo y menos costoso.</p>
<p>Los beans de entidad se diferencian de los beans de sesi&oacute;n principalmente en que son persistentes, permiten el acceso compartido, tienen clave primaria y pueden participar en relaciones con otros beans de entidad:</p>
<ul>


<li>

<p>
<strong>Persistencia</strong>
</p>

<p>Debido a que un bean de entidad se guarda en un mecanismo de almacenamiento se dice que es persistente. Persistente significa que el estado del bean de entidad existe m&aacute;s tiempo que la duraci&oacute;n de la aplicaci&oacute;n o del proceso del servidor J2EE. Un ejemplo de datos persistentes son los datos que se almacenan en una base de datos.</p>


<p>Los beans de entidad tienen dos tipos de persistencia: <strong>Persistencia Gestionada por el Bean</strong> (BMP, <em>Bean-Managed Persistence</em>) y <strong>Persistencia Gestionada por el Contenedor</strong> (CMP, <em>Container-Managed Persistence</em>). En el primer caso (BMP) el bean de entidad contiene el c&oacute;digo que accede a la base de datos.  En el segundo caso (CMP) la relaci&oacute;n entre las columnas de la base de datos y el bean se describe en el fichero de propiedades del bean, y el contenedor EJB se ocupa de la implementaci&oacute;n.</p>

</li>


<li>

<p>
<strong>Acceso compartido</strong>
</p>

<p>Los clientes pueden compartir beans de entidad, con lo que el contenedor EJB debe gestionar el acceso concurrente a los mismos y por ello debe usar transacciones. La forma de hacerlo depender&aacute; de la pol&iacute;tica que se especifique en los descriptores del bean.</p>

</li>


<li>

<p>
<strong>Clave primaria</strong>
</p>

<p>Cada bean de entidad tiene un identificador &uacute;nico. Un bean de entidad alumno, por ejemplo, puede identificarse por su n&uacute;mero de expediente. Este identificador &uacute;nico, o <em>clave primaria</em>, permite al cliente localizar a un bean de entidad particular.</p>

</li>


<li>

<p>
<strong>Relaciones</strong>
</p>

<p>De la misma forma que una tabla en una base de datos relacional, un bean de entidad puede estar relacionado con otros EJB. Por ejemplo, en una aplicaci&oacute;n de gesti&oacute;n administrativa de una universidad, el bean <span class="codefrag">alumnoEjb</span> y el bean <span class="codefrag">actaEjb</span> estar&iacute;an relacionados porque un alumno aparece en un acta con una calificaci&oacute;n determinada.</p>


<p>Las relaciones se implementan de forma distinta seg&uacute;n se est&eacute; usando la persistencia manejada por el bean o por el contenedor. En el primer caso, al igual que la persistencia, el desarrollador debe programar y gestionar las relaciones. En el segundo caso es el contenedor el que se hace cargo de la gesti&oacute;n de las relaciones.  Por ello, estas &uacute;ltimas se denominan a veces relaciones gestionadas por el contenedor.</p>

</li>

</ul>
<a name="N102C9"></a><a name="Beans+dirigidos+por+mensajes"></a>
<h3 class="underlined_5">Beans dirigidos por mensajes</h3>
<p>Son el tercer tipo de beans propuestos por la &uacute;ltima especificaci&oacute;n de EJB. Estos beans permiten que las aplicaciones J2EE reciban mensajes JMS de forma as&iacute;ncrona. As&iacute;, el hilo de ejecuci&oacute;n de un cliente no se bloquea cuando est&aacute; esperando que se complete alg&uacute;n m&eacute;todo de negocio de otro enterprise bean. Los mensajes pueden enviarse desde cualquier componente J2EE (una aplicaci&oacute;n cliente, otro enterprise bean, o un componente Web) o por una aplicaci&oacute;n o sistema JMS que no use la tecnolog&iacute;a J2EE.</p>
<p>La diferencia m&aacute;s visible con los beans de sesi&oacute;n y de entidad es que los clientes no acceden a los beans dirigidos por mensajes mediante interfaces (explicaremos esto con m&aacute;s detalle m&aacute;s adelante), sino que un bean dirigido por mensajes s&oacute;lo tienen una clase bean.</p>
<p>En muchos aspectos, un bean dirigido por mensajes es parecido a un bean de sesi&oacute;n sin estado.</p>
<ul>

<li>Las instancias de un bean dirigido por mensajes no almacenan ning&uacute;n estado conversacional ni datos de clientes.</li>

<li>Todas las instancias de los beans dirigidos por mensajes son equivalentes, lo que permite al contenedor EJB asignar un mensaje a cualquier instancia. El contenedor puede almacenar estas instancias para permitir que los streams de mensajes sean procesados de forma concurrente.</li>

<li>Un &uacute;nico bean dirigido por mensajes puede procesar mensajes de m&uacute;ltiples clientes.</li>

</ul>
<p>Las variables de instancia de estos beans pueden contener alg&uacute;n estado referido al manejo de los mensajes de los clientes. Por ejemplo, pueden contener una conexi&oacute;n JMS, una conexi&oacute;n de base de datos o una referencia a un objeto enterprise bean.</p>
<p>Cuando llega un mensaje, el contenedor llama al m&eacute;todo <span class="codefrag">onMessage</span> del bean. El m&eacute;todo <span class="codefrag">onMessage</span> suele realizar un casting del mensaje a uno de los cinco tipos de mensajes de JMS y manejarlo de forma acorde con la l&oacute;gica de negocio de la aplicaci&oacute;n. El m&eacute;todo onMessage puede llamar a m&eacute;todos auxiliares, o puede invocar a un bean de sesi&oacute;n o de entidad para procesar la informaci&oacute;n del mensaje o para almacenarlo en una base de datos.</p>
<p>Un mensaje puede enviarse a un bean dirigido por mensajes dentro de un contexto de transacci&oacute;n, por lo que todas las operaciones dentro del m&eacute;todo onMessage son parten de un &uacute;nica transacci&oacute;n.</p>
</div>


<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006-2007 Depto. CCIA</div>
</div>
</body>
</html>
