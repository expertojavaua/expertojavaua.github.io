<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Transacciones</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Componentes EJB" src="images/baner_j2ee_der.gif" title="Componentes EJB"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Componentes EJB</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Componentes EJB">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html" title="Introducci&oacute;n a los Enterprise Beans">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="Beans de sesi&oacute;n">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html" title="Beans de sesi&oacute;n">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html" title="Beans de sesi&oacute;n">Sesi&oacute;n 4</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 5</div>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html" title="Transacciones">Sesi&oacute;n 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html" title="EJB 3.0">Sesi&oacute;n 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html" title="JPA">Sesi&oacute;n 8</a>
</div>
<div class="menuitem">
<a href="roadmap.html" title="Roadmap EJB">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html" title="Introducci&oacute;n a los Enterprise Beans">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html" title="Beans de sesi&oacute;n">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html" title="Beans de sesi&oacute;n">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html" title="Beans de sesi&oacute;n con estado">Sesi&oacute;n 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html" title="Seguridad">Sesi&oacute;n 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html" title="Transacciones">Sesi&oacute;n 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html" title="EJB 3.0">Sesi&oacute;n 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html" title="JPA">Sesi&oacute;n 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion05-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Transacciones</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n+a+las+transacciones">Introducci&oacute;n a las transacciones</a>
<ul class="minitoc">
<li>
<a href="#Caracter%C3%ADsticas+de+las+transacciones">Caracter&iacute;sticas de las transacciones</a>
</li>
<li>
<a href="#Demarcaci%C3%B3n+de+la+transacci%C3%B3n">Demarcaci&oacute;n de la transacci&oacute;n</a>
</li>
</ul>
</li>
<li>
<a href="#Gesti%C3%B3n+de+transacciones+con+JDBC">Gesti&oacute;n de transacciones con JDBC</a>
</li>
<li>
<a href="#Gesti%C3%B3n+de+transacciones+con+JTA">Gesti&oacute;n de transacciones con JTA</a>
</li>
<li>
<a href="#Gesti%C3%B3n+de+transacciones+con+componentes+EJB">Gesti&oacute;n de transacciones con componentes EJB</a>
<ul class="minitoc">
<li>
<a href="#Un+ejemplo+con+EJBs">Un ejemplo con EJBs</a>
</li>
<li>
<a href="#Alcance+de+la+transacci%C3%B3n">Alcance de la transacci&oacute;n</a>
</li>
<li>
<a href="#Gesti%C3%B3n+declarativa+de+las+transacciones">Gesti&oacute;n declarativa de las transacciones</a>
<ul class="minitoc">
<li>
<a href="#Descriptor+del+despliegue">Descriptor del despliegue</a>
</li>
<li>
<a href="#Definici%C3%B3n+de+los+atributos+de+transacci%C3%B3n">Definici&oacute;n de los atributos de transacci&oacute;n</a>
</li>
</ul>
</li>
<li>
<a href="#Propagaci%C3%B3n+de+la+transacci%C3%B3n">Propagaci&oacute;n de la transacci&oacute;n</a>
</li>
</ul>
</li>
<li>
<a href="#Anotaciones+EJBGen+Weblogic+para+transacciones">Anotaciones EJBGen Weblogic para transacciones</a>
</li>
</ul>
</div>



<a name="N1000C"></a><a name="Introducci%C3%B3n+a+las+transacciones"></a>
<h2 class="underlined_10">Introducci&oacute;n a las transacciones</h2>
<div class="section">
<p>En los negocios, una transacci&oacute;n incluye un intercambio entre
dos partes. Cuando compras un peri&oacute;dico, intercambias dinero por un
objeto; cuando trabajas para una compa&ntilde;&iacute;a, intercambias
conocimiento y tiempo por dinero. Si nos encontramos en uno de
estos intercambios, siempre tenemos cuidado de asegurarnos que no
sucede nada extra&ntilde;o. Si le damos al quiosquero un billete de
5&euro;, esperamos que nos devuelva 4&euro; junto con el peri&oacute;dico,
que vale 1&euro;. Monitorizamos la seguridad de la transacci&oacute;n para
asegurarnos de que cumple todas las restricciones que conlleva.</p>
<p>En software de negocios, una transacci&oacute;n incluye el concepto de un
intercambio comercial. Una transacci&oacute;n de un sistema de negocios
(transacci&oacute;n para abreviar) es la ejecuci&oacute;n de una unidad-de-trabajo
que accede uno o m&aacute;s recursos compartidos, normalmente bases de
datos. Una unidad-de-trabajo es un conjunto de actividades que se
relacionan mutuamente y que deben ser realizadas completamente. Por
ejemplo, una operaci&oacute;n de reserva de un billete de avi&oacute;n en un sistema
inform&aacute;tico puede estar formada por la selecci&oacute;n del asiento a
reservar, el cargo en una tarjeta de cr&eacute;dito y la generaci&oacute;n de un
billete. Todas estas acciones forman una unidad-de-trabajo que no
puede romperse.</p>
<p>Las transacciones forman parte de distintos tipos de sistemas.  En
cada transacci&oacute;n el objetivo es el mismo: ejecutar una
unidad-de-trabajo que resulte en un intercambio fiable. He aqu&iacute;
algunos ejemplos de sistemas de negocios que usan transacciones:</p>
<ul>

<li>

<p>
<strong>Cajeros autom&aacute;ticos</strong>
</p>

<p>Los cajeros autom&aacute;ticos son un ejemplo t&iacute;pico de sistema en el
que es fundamental el uso de transacciones. Cuando sacas dinero del
cajero, por ejemplo, se debe chequear que tienes dinero suficiente
en la cuenta corriente, despu&eacute;s se debe entregar el dinero y por
&uacute;ltimo se debe realizar un cargo en la cuenta.</p>

</li>


<li>

<p>
<strong>Compra on-line</strong>
</p>

<p>En una compra on-line tambi&eacute;n se debe hacer un uso intensivo de
las transacciones. Cuando realizas una compra on-line debes de
proporcionar el n&uacute;mero de tarjeta de cr&eacute;dito, &eacute;ste debe validarse y
despu&eacute;s debe cargarse el precio de la compra. Luego se debe emitir
un pedido al almac&eacute;n para que realice el env&iacute;o de la compra. Todas
estas acciones deben ser una unidad-de-trabajo, una transacci&oacute;n que
se debe ejecutar de forma indivisible.</p>

</li>

</ul>
<p>Los sistemas que necesitan usar transacciones normalmente son
complejos y realizan operaciones que conllevan el uso grandes
cantidades de datos. Las transacciones deben por ello preservar la
integridad de los datos, lo que significa que todas las operaciones
que forman las transacciones deben funcionar perfectamente o la que la
transacci&oacute;n no se debe ejecutar en absoluto.</p>
<a name="N10035"></a><a name="Caracter%C3%ADsticas+de+las+transacciones"></a>
<h3 class="underlined_5">Caracter&iacute;sticas de las transacciones</h3>
<p>En el campo de la gesti&oacute;n de transacciones se han identificado
cuatro caracter&iacute;sticas que las transacciones deben cumplir para que
el sistema sea considerado seguro. Las transacciones deben ser
at&oacute;micas, consistentes, aisladas y duraderas (ACID, en ingl&eacute;s). A
continuaci&oacute;n describimos estos t&eacute;rminos:</p>
<ul>

<li>
<p>
<strong>At&oacute;mica</strong>
</p>

<p>Para ser at&oacute;mica, una transacci&oacute;n debe ejecutarse totalmente o
no ejecutarse en absoluto. Esto significa que todas las tareas
dentro de una unidad-de-trabajo deben ejecutarse sin error. Si
alguna de estas tareas falla, la transacci&oacute;n completa se debe
abortar y todos los cambios que se han realizado en los datos deben
deshacerse. Si todas las tareas se ejecutan correctamente, la
transacci&oacute;n se comete (commit), lo que significa que los cambios
relizados en los datos se hacen permanentes o duraderos.</p>

</li>


<li>
<p>
<strong>Consistente</strong>
</p>

<p>La consistencia es una caracter&iacute;stica transaccional que debe ser
impuesta tanto por el sistema transaccional como por el
desarrollador de la aplicaci&oacute;n. La consistencia se refiere a la
integridad del almac&eacute;n de datos. El sistema transaccional cumple su
obligaci&oacute;n de consistencia asegurando que una transacci&oacute;n es
at&oacute;mica, aislada y duradera. El desarrollador de la aplicaci&oacute;n debe
asegurarse que la base de datos tiene las restricciones apropiadas
(claves primarias, integridad referencial, y otras) y que la
unidad-de-trabajo, la l&oacute;gica de negocio, no resulta en datos
inconsistentes (esto es, los datos no se corresponden con lo que
representan del mundo real). En una transferencias entre cuentas,
por ejemplo, un cargo en una cuenta debe ser igual a un ingreso en
otra.</p>

</li>


<li>

<p>
<strong>Aislada</strong>
</p>

<p>Una transacci&oacute;n debe poder ejecutarse sin interferencia de otros
procesos o transacciones. En otras palabras, los datos a los que
accede una transacci&oacute;n no pueden ser modificados por ninguna otra
parte del sistema hasta que la transacci&oacute;n se completa.</p>

</li>


<li>

<p>
<strong>Duradera</strong>
</p>

<p>Durabilidad significa que todos los cambios en los datos
realizados durante el curso de una transacci&oacute;n deben escribirse en
alg&uacute;n tipo de almacenamiento f&iacute;sico antes de que la transacci&oacute;n
concluya con &eacute;xito. Esto asegura que los cambios no se pierden si
el sistema se cae.</p>

</li>

</ul>
<a name="N10068"></a><a name="Demarcaci%C3%B3n+de+la+transacci%C3%B3n"></a>
<h3 class="underlined_5">Demarcaci&oacute;n de la transacci&oacute;n</h3>
<p>Las aplicaciones transaccionales deben poder comenzar y concluir transacciones, y deben poder indicar qu&eacute; cambios deben hacerse permanentes o cu&aacute;les deben descartarse. Se denomina demarcaci&oacute;n de la transacci&oacute;n a la indicaci&oacute;n de los l&iacute;mites de la transacci&oacute;n dentro de un programa.</p>
<p>La arquitectura Java EE especifica dos tipos de demarcaci&oacute;n de transacciones: program&aacute;tica y declarativa. La demarcaci&oacute;n program&aacute;tica se realiza utilizando las funciones de JTA (Java Transaction Api) que marcan el comienzo -<em>begin</em>- y el final (con &eacute;xito -<em>commit</em>- o fracaso -<em>rollback</em>-) de una transacci&oacute;n. En la demaraci&oacute;n declarativa, sin embargo, no se definen expl&iacute;citamente el comienzo y la finalizaci&oacute;n de la transacci&oacute;n, sino que las transacciones est&aacute;n asociadas a m&eacute;todos (de los componentes EJB). El comienzo de ejecuci&oacute;n de un m&eacute;todo define el comienzo de una transacci&oacute;n y su finalizaci&oacute;n normal el final con &eacute;xito. El final con fracaso de una transacci&oacute;n se produce cuando se sale del m&eacute;todo por una excepci&oacute;n. En la demarcaci&oacute;n   declarativa es posible adem&aacute;s definir el tipo de transacci&oacute;n asociada a cada m&eacute;todo (lo veremos m&aacute;s adelante).</p>
<p>Un ejemplo de demarcaci&oacute;n programativa de transacci&oacute;n usando JTA es el siguiente c&oacute;digo:</p>
<pre class="code">try {

   userTran.begin(); //comienza la transaccion

   cliente.grabaPedido(pedido);                // operacion 1
   tarjetaCredito = cliente.tarjetaCredito();  // operacion 2
   tarjetaCredito.carga(pedido.precio);        // operacion 3
   almacen.descuenta(pedido);                  // operacion 4

   userTran.commit(); //fin de la transaccion
}
catch (Exception e} {
   userTran.rollback(); // se ha producido un error
}</pre>
<p>Si no sucede ning&uacute;n error entre el comienzo y el final de la transacci&oacute;n, la misma se realiza completamente haciendo una llamada al m&eacute;todo commit del gestor de la transacci&oacute;n. Si sucede alg&uacute;n error y alguna de las operaciones no concluye correctamente, la transacci&oacute;n se aborta y se realiza la llamada al m&eacute;todo rollback del gestor de la transacci&oacute;n.</p>
</div>


<a name="N10089"></a><a name="Gesti%C3%B3n+de+transacciones+con+JDBC"></a>
<h2 class="underlined_10">Gesti&oacute;n de transacciones con JDBC</h2>
<div class="section">
<p>Es posible gestionar las transacciones utilizando JDBC. Para ello, el objeto <span class="codefrag">java.sql.Connection</span> proporciona los siguientes m&eacute;todos:</p>
<ul>

<li>
<span class="codefrag">public void setAutoCommit(boolean)</span>
</li>

<li>
<span class="codefrag">public boolean getAutoCommit()</span>
</li>

<li>
<span class="codefrag">public void commit()</span>
</li>

<li>
<span class="codefrag">public void rollback()</span>
</li>

</ul>
<p>Para gestionar manualmente transacciones hay que obtener una conexi&oacute;n, llamar al m&eacute;todo <span class="codefrag">setAutoCommit(false)</span> para abrir la transacci&oacute;n y marcar el final de la misma con <span class="codefrag">commit()</span> o <span class="codefrag">rollback()</span>. El funcionamiento t&iacute;pico es el siguiente:</p>
<pre class="code">import java.sql.*;
import javax.sql.*;

DataSource ds = obtainDataSource();
Connection conn = ds.getConnection();
try {
   <strong>conn.setAutoCommit(false);</strong>
   // ...
   st = conn.prepareStatement("update 
         operation set ffinReal=now() where idOperacion=?");
   st.setString(1, idOperacion);
   st.executeUpdate();
   // .. otras modificaciones en otras tablas
   <strong>conn.commit();</strong>
} catch (SQLException sqle) {
   try {
      <strong>conn.rollback();</strong>
   } catch (SQLException e) {
      throw new RuntimeException("Error haciendo el rollback", e);
   }
   throw new DAOException("Error al realizar la devoluci&oacute;n", sqle);
} finally {
   try {
      if (st != null) st.close();
      if (conn != null) conn.close();
   } catch (SQLException sqlError) {
      throw new RuntimeException("Error cerrando las conexiones", sqlError);
   }
}</pre>
<p>Un problema de este enfoque es que obliga a incluir el manejo de las transacciones en los m&eacute;todos de los Data Access Object (ya que fuera de ellos no podemos acceder a la conexi&oacute;n de la base de datos), con lo que debemos escribir c&oacute;digo de l&oacute;gica de negocio en la capa de persistencia. Esto hace que nuestra capa de datos pierda flexibilidad.</p>
<p>Ser&iacute;a interesante hacer que los DAO &uacute;nicamente gestionen actualizaciones elementales y que puedan participar en transacciones declaradas fuera de ellos. La arquitectura Java EE proporciona dos formas de hacer esto: utilizando JTA (Java Transaction Api) o utilizando componentes EJB. </p>
</div>


<a name="N100C8"></a><a name="Gesti%C3%B3n+de+transacciones+con+JTA"></a>
<h2 class="underlined_10">Gesti&oacute;n de transacciones con JTA</h2>
<div class="section">
<p>Una alternativa al uso de las transacciones JDBC es JTA. Para utilizarla, es necesario un driver JDBC que implemente las interfaces <span class="codefrag">javax.sql.XADataSource</span>, <span class="codefrag">javax.sql.XAConnection</span> y <span class="codefrag">javax.sql.XAResource</span>. Es necesario tambi&eacute;n configurar una fuente de datos XA con el servidor de aplicaciones (ver la sesi&oacute;n de ejercicios) y darle un nombre JNDI.</p>
<p>Una vez definido el objeto <span class="codefrag">XADataSource</span> ya es posible trabajar con &eacute;l sin cambiar nada de c&oacute;digo en el programa, ya que funciona como una fuente de datos JDBC normal. La &uacute;nica diferencia es que el m&eacute;todo <span class="codefrag">getConnection()</span> de la fuente de datos devuelve un objeto <span class="codefrag">Connection</span> que implementa la interfaz <span class="codefrag">XAConnection</span> y que puede participar en las transacciones JTA.</p>
<p>El servidor de aplicaciones tambi&eacute;n define un objeto que implementa la interfaz <span class="codefrag">javax.transacion.UserTransaction</span> y que debemos obtener para controlar las transacciones. Esta interfaz proporciona los siguientes m&eacute;todos:</p>
<ul>

<li>
<span class="codefrag">public void begin()</span>
</li>

<li>
<span class="codefrag">public void commit()</span>
</li>

<li>
<span class="codefrag">public void rollback()</span>
</li>

<li>
<span class="codefrag">public int getStatus()</span>
</li>

<li>
<span class="codefrag">public void setRollbackOnly()</span>
</li>

<li>
<span class="codefrag">public void setTransactionTimeout(int)</span>
</li>

</ul>
<p>Para comenzar una transacci&oacute;n la aplicaci&oacute;n se debe llamar a <span class="codefrag">begin()</span>. Para finalizarla, la transacci&oacute;n debe llamar o bien a <span class="codefrag">commit()</span> o bien a <span class="codefrag">rollback()</span>.</p>
<p>Un ejemplo de uso para el servidor de aplicaciones WebLogic 9.2 es el siguiente:</p>
<pre class="code">import javax.transaction.*;
import javax.naming.*;

Context ctx = getInitialContext();
 
<strong>UserTransaction tx = (UserTransaction)
  ctx.lookup("javax.transaction.UserTransaction");</strong>

<strong>utx.begin();</strong>

try {
   // llamadas a los DAO
   operacionDao.devuelvePrestamo(idOperacion);
   if (usuarioTO.getEstado != EstadoUsuario.reserva) {
      listOp = operacionDao.
         .selectOperacionesActivas(TipoOperacion.prestamo,
                                   usuarioTO.login);
      if (listOp != null) 
         usuarioDao.cambiaEstadoUsuario(usuarioTO.login,
                                        EstadoUsuario.prestamo);
      else usuarioDao.cambiaEstadoUsuario(usuarioTO.login,
                                          EstadoUsuario.activo);
   <strong>utx.commit();</strong>
   }
} catch (Exception e) {
   try {
      <strong>utx.rollback();</strong>
   } catch (Exception e) {
      throw new RuntimeException("Error haciendo el rollback", e);
   }
   throw new BusinessException("Error al hacer la devoluci&oacute;n", e);
}</pre>
<p>La ventaja de este enfoque con respecto a la gesti&oacute;n de las transacciones dentro de los DAO es que libera a &eacute;stos de la gesti&oacute;n de transacciones y permite simplificar su c&oacute;digo. Las transacciones son ahora algo externo a los DAO y podemos manejarlas desde los objetos de negocio. </p>
<p>La utilizaci&oacute;n de JTA, sin embargo, s&oacute;lo es recomendable cuando se quiere tener un control programativo de las transacciones. Lo m&aacute;s com&uacute;n es definir los m&eacute;todos de negocio como m&eacute;todos de EJBs de sesi&oacute;n y dejar que sea el contenedor EJB el que se encarge de gestionar las transacciones de forma autom&aacute;tica. Lo vemos en la siguiente secci&oacute;n.</p>
</div>


<a name="N10130"></a><a name="Gesti%C3%B3n+de+transacciones+con+componentes+EJB"></a>
<h2 class="underlined_10">Gesti&oacute;n de transacciones con componentes EJB</h2>
<div class="section">
<p>Los componentes EJB gestionan de forma autom&aacute;tica las transacciones. Toda llamada a un m&eacute;todo de un componente EJB crea un contexto transaccional que es gestionado por el servidor de aplicaciones y que dura hasta que el m&eacute;todo ha terminado (con &eacute;xito o con fracaso, al lanzar una excepci&oacute;n).</p>
<p>Al igual que con JTA, el servidor de aplicaciones utiliza para gestionar las transacciones un sistema de <em>two phase commit</em> que permite que &eacute;stas sean distribuidas. Los recursos que participan en estas transacciones deben ser fuentes de datos XA. Los propios EJB (de sesi&oacute;n con estado, de entidad o de mensajes) implementan el protocolo XA y pueden participar en las transacciones distribuidas.</p>
<p>Un uso muy com&uacute;n de los EJB de sesi&oacute;n es la implementaci&oacute;n de objetos de negocio que definen transacciones que abarcan a m&aacute;s de un DAO. De esta forma, se libera a los DAO de la gesti&oacute;n de transacciones y su implementaci&oacute;n se hace m&aacute;s sencilla y flexible. Veremos con detalle este uso de los EJB en la sesi&oacute;n de ejercicios.</p>
<p>En los siguientes apartados vamos a usar un ejemplo de un m&eacute;todo de un EJB que a su vez llama a otros EJB para enfatizar el car&aacute;cter distribuido de las transacciones en EJB. Sin embargo, todas las caracter&iacute;sticas transaccionales que comentaremos se aplican tambi&eacute;n a los EJB que manejan DAOs.</p>
<a name="N10145"></a><a name="Un+ejemplo+con+EJBs"></a>
<h3 class="underlined_5">Un ejemplo con EJBs</h3>
<p>Vamos a ver un ejemplo de una aplicaci&oacute;n que gestiona reservas de crucero.</p>
<p>Suponemos un EJB de sesi&oacute;n con estado llamado <span class="codefrag">AgenteViaje</span> que contiene un m&eacute;todo llamado <span class="codefrag">reservaPasaje</span> con el que se realiza la reserva de un pasaje. Suponemos que las llamadas previas a otros m&eacute;todos del EJB han definido los campos <span class="codefrag">cliente</span>, <span class="codefrag">crucero</span> y <span class="codefrag">cabina</span>, y que lo &uacute;nico que tiene que hacer el m&eacute;todo es realizar la reserva y el cargo en la tarjeta de cr&eacute;dito. Ambas operaciones son gestionadas por componentes EJB con interfaces remotas <span class="codefrag">Reservas</span> y <span class="codefrag">PagosTarjeta</span>.</p>
<pre class="code">public class AgenteViaje implements SessionBean {
  private Cliente cliente;
  private Crucero crucero;
  private Cabina cabina;
  ...

  public TicketTO reservaPasaje(CreditCardTO tarjeta, double precio)
    throws EstadoConversacionalIncompleto {
                 
    if (cliente == null || crucero == null || cabina == null) {
      throw new EstadoConversacionalIncompleto();
    }
    try {
      // Se obtienen los home
      ReservasHome resHome = getEJB(jndiContext,
                                       "java:comp/env/ejb/ReservasHome",
                                       ReservasHome.class);
      PagosTarjetaHome ppHome = getEJB(jndiContext,
                                     "java:comp/env/ejb/PagosTarjetaHome",
                                     PagosTarjetaHome.class);

      // Se crean los ejb
      Reservas reservas =  resHome.create();
      PagosTarjeta pagos = ppHome.create();

      // Se llaman a los m&eacute;todos de la interfaz de negocio

      reservas.hazReserva(customer,cruise, cabin, price);
      pagos.procesaPago(customer, card, price);
      TicketTO ticket = new TicketTO(customer,cruise,cabin,price);
      return ticket;

    } catch(Exception e) {
        throw new EJBException(e);
    }
  }
...
}</pre>
<p>Si se genera alguna excepci&oacute;n en alguna de las llamadas del m&eacute;todo <span class="codefrag">reservaPasaje</span>, se captura y se lanza a su vez una excepci&oacute;n <span class="codefrag">EJBException</span>. Esta es una excepci&oacute;n de tipo <span class="codefrag">RuntimeException</span> y veremos que es la responsable de que la transacci&oacute;n haga un <em>rollback</em>.</p>
<p>Una primera medida de la fiabilidad del EJB
<span class="codefrag">AgenteViaje</span> es su atomicidad: &iquest;asegura que la transacci&oacute;n
se ejecuta completamente o no se ejecuta en absoluto?  Para responder
debemos concentrarnos en las tareas cr&iacute;ticas que modifican o crea
informaci&oacute;n nueva. En el m&eacute;todo <span class="codefrag">reservaPasaje()</span>, se crea un EJB <span class="codefrag">Reservas</span>, el EJB <span class="codefrag">PagosTarjeta</span>
realiza un cargo en una tarjeta de cr&eacute;dito, y se crea un objeto
<span class="codefrag">TicketTO</span>. Todas estas tareas deben tener &eacute;xito para que
la transacci&oacute;n completa lo tenga a su vez.</p>
<p>Para entender la importancia de la caracter&iacute;stica de atomicidad
podr&iacute;amos imaginar qu&eacute; suceder&iacute;a si cualquiera de estas tareas
fallara. Si, por ejemplo, la creaci&oacute;n de un EJB
<span class="codefrag">Reservas</span> fallara pero todas las otras tareas tuvieran
&eacute;xito, el cliente terminar&iacute;a probablemente expulsado del crucero o
compartiendo el camarote con un extra&ntilde;o. En lo que concierne a la
agencia de viajes, el m&eacute;todo <span class="codefrag">reservaPasaje()</span> habr&iacute;a sido
ejecutado con &eacute;xito porque se habr&iacute;a generado un
<span class="codefrag">TicketTO</span>. Si se genera un billete sin la creaci&oacute;n de una
reserva, el estado del sistema de negocio se convierte en
inconsistente con la realidad, porque el cliente ha pagado por un
billete pero la reserva no se ha registrado. De la misma forma, si el
EJB <span class="codefrag">PagosTarjeta</span> falla al cargar la tarjeta de cr&eacute;dito
del cliente, el cliente obtiene un crucero gratis. Seguro que &eacute;l se
quedar&aacute; contento, pero gerencia no. Por &uacute;ltimo, si el
<span class="codefrag">TicketTO</span> no se crea nunca, el cliente no tendr&aacute; ning&uacute;n
registro de la transacci&oacute;n y probablemente no podr&aacute; subir al
crucero.</p>
<p>Por ello, la &uacute;nica forma de que pueda completarse la operaci&oacute;n
<span class="codefrag">reservaPasaje()</span> es si todas sus partes cr&iacute;ticas se ejecutan
con &eacute;xito. Si algo va mal, el proceso completo debe abortarse. Abortar
una transacci&oacute;n requiere m&aacute;s que simplemente no finalizar las tareas;
adem&aacute;s, todas las tareas dentro de la transacci&oacute;n deben
deshacerse. Si, por ejemplo, la creaci&oacute;n de los EJB
<span class="codefrag">Reservas</span> y <span class="codefrag">PagosTarjeta</span> se realiza con
&eacute;xito, pero la creaci&oacute;n del <span class="codefrag">TicketTO</span> falla, los registros
<span class="codefrag">reservation</span> y <span class="codefrag">payment</span> no deben a&ntilde;adirse a la
base de datos.</p>
<p>Para que la operaci&oacute;n <span class="codefrag">reservaPasaje()</span> sea completamente segura debe cumplir los otros requisitos de una transacci&oacute;n: debe ser consistente, aislada y duradera.</p>
<p>Para mantener la consistencia de las operaciones desde el punto
de vista de la l&oacute;gica del negocio, es necesario que se cumplan las
otras tres propiedades y adem&aacute;s que el desarrollador de la
aplicaci&oacute;n sea estricto a la hora de aplicar las restricciones de
integridad en toda la implementaci&oacute;n de la aplicaci&oacute;n. Por ejemplo,
de nada servir&iacute;a que el sistema transaccional asegurase la
atomicidad de la operaci&oacute;n <span class="codefrag">reservaPasaje()</span> si el desarrollador no incluyera dentro del m&eacute;todo una llamada a la consulta de la tarjeta de cr&eacute;dito y devolviera directamente el TicketTO. Desde el punto de vista del negocio, la transacci&oacute;n habr&iacute;a fallado, ya que se ha emitido un ticket sin realizar un cobro.</p>
<p>El aislamiento de la operaci&oacute;n tiene que asegurar que otros
procesos no van a modificar los datos de los EJBs mientras que la
transacci&oacute;n est&aacute; desarroll&aacute;ndose.</p>
<p>Por &uacute;ltimo, la durabilidad de la transacci&oacute;n obliga a que todas
las operaciones hayan sido hechas persistentes antes de dar la
transacci&oacute;n por terminada.</p>
<p>Asegurarnos que las transacciones se adhieren a los principios
ACID requiere un dise&ntilde;o cuidadoso. El sistema tiene que monitorizar
el progreso de una transacci&oacute;n, para asegurarse de que todo
funciona correctamente, de que los datos se modifican de forma
correcta, de que las transacciones no interfieren entre ellas y de
que los cambios pueden sobrevivir a una ca&iacute;da del sistema.
Comprobar todas estas condiciones conlleva un mont&oacute;n de trabajo.
Afortunadamente, la arquitectura EJB soporta de forma autom&aacute;tica el
manejo de transacciones.</p>
<a name="N101C8"></a><a name="Alcance+de+la+transacci%C3%B3n"></a>
<h3 class="underlined_5">Alcance de la transacci&oacute;n</h3>
<p>El alcance de una transacci&oacute;n es un concepto crucial para
comprender las transacciones. En este contexto, el alcance una
transacci&oacute;n consiste en aquellos EJBs de entidad y de sesi&oacute;n que est&aacute;n
participando en una transacci&oacute;n particular.</p>
<p>En el m&eacute;todo <span class="codefrag">reservaPasaje()</span> del EJB
<span class="codefrag">AgenteViaje</span>, todos los EJBs que participan son parte del
mismo alcance de transacci&oacute;n. El alcance de la transacci&oacute;n comienza
cuando el cliente invoca el m&eacute;todo <span class="codefrag">reservaPasaje()</span> del EJB
<span class="codefrag">AgenteViaje</span>. Una vez que el alcance de la transacci&oacute;n ha
comenzado, &eacute;ste se propaga a los dos EJB que se crean:
<span class="codefrag">Reservas</span> EJB y <span class="codefrag">PagosTarjeta</span> EJB.</p>
<p>Como ya hemos comentado, una transacci&oacute;n es una unidad-de-trabajo
constituida por una o m&aacute;s tareas. En una transacci&oacute;n, todas las tareas
que forman la unidad-de-trabajo deben ser un &eacute;xito para que la
transacci&oacute;n en su totalidad tenga &eacute;xito; la transacci&oacute;n debe ser
at&oacute;mica. Si alguna tarea falla, las actualizaciones realizadas por las
otras tareas deben desacerse. En EJB, las tareas se expresan como
m&eacute;todos de los enterprise bean, y una unidad de trabajo consiste en un
conjunto de inv&oacute;caciones a m&eacute;todos los enterprise bean. El alcance de
la transacci&oacute;n incluye todos los EJB que participan en al unidad de
trabajo.</p>
<p>Es f&aacute;cil trazar el alcance de una transacci&oacute;n siguiendo el hilo de
ejecuci&oacute;n. Si la invocaci&oacute;n del m&eacute;todo <span class="codefrag">reservaPasaje()</span>
comienza una transacci&oacute;n, entoces de forma l&oacute;gica, la transacci&oacute;n
termina cuando el m&eacute;todo se completa.  El alcance de la transacci&oacute;n
<span class="codefrag">reservaPasaje()</span> incluir&iacute;a los EJB <span class="codefrag">AgenteViaje</span>,
<span class="codefrag">Reservas</span> y <span class="codefrag">PagosTarjeta</span>.</p>
<p>Una transacci&oacute;n puede terminar si se genera una excepci&oacute;n mientras
que el m&eacute;todo <span class="codefrag">reservaPasaje()</span> est&aacute; en ejecuci&oacute;n. La
excepci&oacute;n puede lanzarse desde uno de los otros EJBs o desde el mismo
m&eacute;todo <span class="codefrag">reservaPasaje()</span>. Para que el contenedor de EJB active la gesti&oacute;n de transacciones, se debe lanzar una excepci&oacute;n de tipo <span class="codefrag">RuntimeException</span>. En el caso del ejemplo anterior, se lanza la excepci&oacute;n <span class="codefrag">EJBException</span>, que es de tipo <em>runtime</em>.</p>
<p> La gesti&oacute;n de la transacci&oacute;n puede causar o no causar rollback (vuelta a los valores iniciales de los datos) dependiendo del tipo de transacci&oacute;n declarado. Lo veremos m&aacute;s adelante.</p>
<a name="N10211"></a><a name="Gesti%C3%B3n+declarativa+de+las+transacciones"></a>
<h3 class="underlined_5">Gesti&oacute;n declarativa de las transacciones</h3>
<p>Una de las ventajas principales de la arquitectura Enterprise
JavaBeans es que permite la gesti&oacute;n declarativa de transacciones.
Sin esta caracter&iacute;stica las transacciones deber&iacute;an controlarse
usando una demarcaci&oacute;n expl&iacute;cita de la transacci&oacute;n. Esto conlleva
el uso de APIs bastantes complejos como el Objecto Transaction
Service (OTS) de OMG, o su implementaci&oacute;n Java, el Java Transaction
Service (JTS) que soporta la ya vista JTA. La demarcaci&oacute;n expl&iacute;cita es dif&iacute;cil de usar correctamente para los desarrolladores, sobre todo si no est&aacute;n habituados a la programaci&oacute;n de sistemas transaccionales.</p>
<p>Adem&aacute;s, la demarcaci&oacute;n expl&iacute;cita requiere que el c&oacute;digo transaccional se escriba junto con la l&oacute;gica de negocio, lo que reduce la claridad del c&oacute;digo y, m&aacute;s importante, crea objetos distribuidos inflexibles. Una vez que la demarcaci&oacute;n de la transacci&oacute;n est&aacute; grabada en el objeto de negocio, los cambios en la conducta de transacci&oacute;n obligan a cambios en la misma l&oacute;gica de negocio.</p>
<p>Con la gesti&oacute;n declarativa de transacciones, la conducta
transaccional de los EJBs puede controlarse usando el descriptor
del despliegue, que establece atributos de transacci&oacute;n para los
m&eacute;todos individuales del enterprise bean. Esto significa que la
conducta transaccional de un EJB puede modificarse sin cambiar la
l&oacute;gica de negocio del EJB. Adem&aacute;s, un EJB desplegado en una
apliaci&oacute;n puede definirse con una conducta transaccional distinta
que la del mismo bean desplegado en otra aplicaci&oacute;n. La gesti&oacute;n
declarativa de las transacciones reduce la complejidad del manejo
de las transacciones para los desarrolladores de EJB y de
aplicaciones y hace m&aacute;s sencilla la creaci&oacute;n de aplicaciones
transaccionales robustas.</p>
<p>Cuando un EJB se despliega, podemos establecer su atributo de
transacci&oacute;n a uno de los siguientes valores:</p>
<ul>

<li>
<span class="codefrag">NotSupported</span>
</li>

<li>
<span class="codefrag">Supports</span>
</li>

<li>
<span class="codefrag">Required</span>
</li>

<li>
<span class="codefrag">RequiresNew</span>
</li>

<li>
<span class="codefrag">Mandatory</span>
</li>

<li>
<span class="codefrag">Never</span>
</li>

</ul>
<p>La especificaci&oacute;n EJB 2.0 aconseja que los beans de entidad con
persistencia gestionada por el contenedor usen s&oacute;lo los atributos
<span class="codefrag">Required</span>, <span class="codefrag">RequiresNew</span> y
<span class="codefrag">Mandatory</span>. Esta restricci&oacute;n asegura que todos los accesos
a bases de datos suceden en el contexto de una transacci&oacute;n, lo cual es
importante cuando el contenedor est&aacute; gestionando autom&aacute;ticamente la
persistencia.</p>
<p>Podemos establecer un atributo de transacci&oacute;n para el EJB
completo (en cuyo caso se aplica a todos los m&eacute;todos) o establecer
distintos atributos de transacci&oacute;n para los m&eacute;todos individuales.
Lo primero es mucho m&aacute;s sencillo y conlleva menos riesgo de
errores, pero lo segundo ofrece mayor flexibilidad. Los fragmentos
de c&oacute;digo de los siguientes apartados muestran c&oacute;mo establecer los
atributos de transacciones de un EJB en el descriptor del
despliegue del EJB.</p>
<a name="N1024D"></a><a name="Descriptor+del+despliegue"></a>
<h4>Descriptor del despliegue</h4>
<p>En el descriptor XML del despliegue, un elemento 
<span class="codefrag">container-transaction</span> especifica los atributos
de transacci&oacute;n para los EJBs descritos en el descriptor de
despliegue:</p>
<pre class="code">
&lt;ejb-jar&gt;
    ...
    &lt;assembly-descriptor&gt;
        ...
        &lt;container-transaction&gt;
            &lt;method&gt;
                &lt;ejb-name&gt;AgenteViajeEJB&lt;/ejb-name&gt;
                &lt;method-name&gt; * &lt;/method-name&gt;
            &lt;/method&gt;
            &lt;trans-attribute&gt;Required&lt;/trans-attribute&gt;
        &lt;/container-transaction&gt;
        &lt;container-transaction&gt;
            &lt;method&gt;
                &lt;ejb-name&gt;AgenteViajeEJB&lt;/ejb-name&gt;
                &lt;method-name&gt;listaCamarotesDisponibles&lt;/method-name&gt;
            &lt;/method&gt;
            &lt;trans-attribute&gt;Supports&lt;/trans-attribute&gt;
        &lt;/container-transaction&gt;
        ...
    &lt;/assembly-descriptor&gt;
    ...
&lt;/ejb-jar&gt;</pre>
<p>Este descriptor de despliegue especifica los atributos de
transacci&oacute;n para el EJB <span class="codefrag">AgenteViaje</span>. Cada elemento
<span class="codefrag">container-transaction</span> especifica un m&eacute;todo y el atributo
de transacci&oacute;n que deber&iacute;a aplicarse a ese m&eacute;todo. El primer elemento
<span class="codefrag">container-transaction</span> especifica que todos los m&eacute;todos
tengan por defecto un atributo de transacci&oacute;n de
<span class="codefrag">Required</span>; el car&aacute;cter <span class="codefrag">*</span> es un comod&iacute;n que
indica todos los m&eacute;todos del EJB <span class="codefrag">AgenteViaje</span>. El segundo
elemento <span class="codefrag">container-transaction</span>hace caso omiso del
atributo por defecto para especificar que el m&eacute;todo
<span class="codefrag">listaCamarotesDisponibles()</span> tendr&aacute; un atributo de transacci&oacute;n
<span class="codefrag">Supports</span>. Tenemos que especificar a qu&eacute; EJB nos estamos
refiriendo con el elemento <span class="codefrag">ejb-name</span>, ya que un descriptor
XML de despliegue puede contener muchos EJBs.</p>
<a name="N1027F"></a><a name="Definici%C3%B3n+de+los+atributos+de+transacci%C3%B3n"></a>
<h4>Definici&oacute;n de los atributos de transacci&oacute;n</h4>
<p>Vamos a definir ahora los atributos de transacci&oacute;n que hemos
declarado previamente. Tal y como comentamos arriba, los atributos
recomendados por la especificaci&oacute;n EJB 2.0 son <span class="codefrag">Required</span>,
<span class="codefrag">RequiresNew</span> y <span class="codefrag">Mandatory</span>
</p>
<ul>

<li>

<p>
<strong><span class="codefrag">Required</span></strong>
</p>

<p>Este atributo significa que el m&eacute;todo del enterprise bean debe
invocarse dentro del alcance de una transacci&oacute;n. Si el cliente o el
EJB que realiza la llamada es parte de una transacci&oacute;n el EJB con el
atributo <span class="codefrag">Required</span> autom&aacute;ticamente se incluye en el
alcance de esa transacci&oacute;n. Si, sin embargo, el cliente o EJB que
realiza la llamada no est&aacute; inclu&iacute;do en una transacci&oacute;n, el EJB con el
atributo <span class="codefrag">Required</span> comienza su propia transacci&oacute;n. Esta
nueva transacci&oacute;n concluye cuando el EJB termina.</p>

</li>


<li>

<p>
<strong><span class="codefrag">RequiresNew</span></strong>
</p>

<p>Este atributo significa que se debe comenzar siempre una nueva
transacci&oacute;n. Independi&eacute;ntemente de si el cliente o EJB que realiza
la llamada es parte de una transacci&oacute;n, un m&eacute;todo con el atributo
RequiresNew siempre comienza una nueva transacci&oacute;n. Si el cliente
que realiza la llamada ya est&aacute; incluido en una transacci&oacute;n, esa
transacci&oacute;n se suspende hasta que la llamada al m&eacute;todo con el
atributo RequiresNew finaliza. En ese momento la transacci&oacute;n
original vuelve a estar activa.</p>

</li>


<li>
<p>
<strong><span class="codefrag">Mandatory</span></strong>
</p>

<p>Este atributo significa que el m&eacute;todo del enterprise bean debe
siempre ser parte del alcance de la transacci&oacute;n del cliente que
realiza la llamada. Si este cliente o EJB no es parte de una
transacci&oacute;n, la invocaci&oacute;n fallar&aacute;, gener&aacute;ndose una excepci&oacute;n 
<span class="codefrag">javax.transaction.TransactionRequiredException</span> a los
clientes remotos o una excepci&oacute;n 
<span class="codefrag">javax.ejb.TransactionRequiredLocalException</span> a los
clientes locales.</p>

</li>

</ul>
<a name="N102C1"></a><a name="Propagaci%C3%B3n+de+la+transacci%C3%B3n"></a>
<h3 class="underlined_5">Propagaci&oacute;n de la transacci&oacute;n</h3>
<p>Para ilustrar el impacto de los atributos de transacci&oacute;n sobre los
m&eacute;todos del enterprise bean, miraremos una vez m&aacute;s al m&eacute;todo
<span class="codefrag">reservaPasaje()</span> del EJB <span class="codefrag">AgenteViaje</span>.</p>
<p>Para que <span class="codefrag">reservaPasaje()</span> se ejecute como una transacci&oacute;n con &eacute;xito, tanto la creaci&oacute;n del EJB <span class="codefrag">Reservas</span> como el cargo a la tarjeta de cr&eacute;dito deben tambi&eacute;n terminar con &eacute;xito. Esto significa que ambas operaciones deben incluirse en la misma transacci&oacute;n. Si alguna operaci&oacute;n falla, la transacci&oacute;n completa
falla. Podr&iacute;amos haber especificado un atributo de transacci&oacute;n
<span class="codefrag">Required</span> como el atributo por defecto para todos los EJBs
incluidos, porque ese atributo refuerza la pol&iacute;tica deseada de que
todos los EJBs deben ejecutarse dentro de una transacci&oacute;n y por ello
asegura la consistencia de los datos.</p>
<p>Como un monitor de transacciones, el servidor EJB vigila cada
llamada a un m&eacute;todo en la transacci&oacute;n. Si cualquiera de las
actualizaciones falla, todas las actualizaciones a todos los EJBs
ser&aacute;n recuperadas (<em>rolled back</em>). Si las actualizaciones se
realizan, la transacci&oacute;n se confirma (<em>commit</em>).</p>
<p>En los casos en los que el contenedor gestiona implicitamente la
transacci&oacute;n, las decisiones de commit y rollback se manejan de forma
autom&aacute;tica. Supongamos que el EJB <span class="codefrag">AgenteViaje</span> se crea y
se usa en el cliente como sigue:</p>
<pre class="code">
AgenteViaje agente = agenteHome.create(cliente);
agente.setCamaroteID(camarote_id);
agente.setCruceroID(crucero_id);
try {
    agent.reservaPasaje(card,price);
} catch(Exception e) {
    System.out.println("Transaction failed!");
}
</pre>
<p>M&aacute;s a&uacute;n, asumamos que el m&eacute;todo <span class="codefrag">reservaPasaje()</span> tienen
un atributo de transacci&oacute;n <span class="codefrag">RequiresNew</span>. En este caso, el
cliente que invocal el m&eacute;todo <span class="codefrag">reservaPasaje()</span> no es parte
de la transacci&oacute;n. Cuando se invoca a <span class="codefrag">reservaPasaje()</span> en el
EJB <span class="codefrag">AgenteViaje</span>, se crea una nueva transacci&oacute;n, tal y
como dicta el atributo <span class="codefrag">RequiresNew</span>. Esto significa que el
EJB <span class="codefrag">AgenteViaje</span> se registra en el gestor de transacciones
del servidor de EJB, el cual gestionar&aacute; la transacci&oacute;n
autom&aacute;ticamente. El gestor de transacciones coordina transacciones,
propagando el alcance de la transacci&oacute;n desde un EJB al siguiente para
asegurarse de que todos los EJBs tocados por una transacci&oacute;n se
incluyen en la unidad de trabajo de la transacci&oacute;n. De esta forma, el
gestor de transacciones puede monitorizar las actualizaciones
realizadas por cada enterprise bean y decidir, bas&aacute;ndose en el &eacute;xito
de estas actualizaciones, si hacer permanentes los cambios hechos por
todos los enterprise beans en las bases de datos o si echarlos atr&aacute;s y
deshacerlos. Si se lanza una excepci&oacute;n del sistema en el m&eacute;todo
<span class="codefrag">reservaPasaje()</span>, la transacci&oacute;n se deshace
autom&aacute;ticamente.</p>
<p>Cuando el m&eacute;todo <span class="codefrag">procesaPago()</span> se invoca dentro del
m&eacute;todo <span class="codefrag">reservaPasaje()</span>, el EJB <span class="codefrag">PagosTarjeta</span>
se registra en el gestor de transacciones bajo el contexto
transaccional que se cre&oacute; para el EJB <span class="codefrag">AgenteViaje</span>. Cuando
se crea el nuevo EJB <span class="codefrag">Reservas</span>, tambi&eacute;n se registra en
el gestor de transacciones bajo la misma transacci&oacute;n. Cuando se
registran todos los EJBs y se realizan todas las actualizaciones, el
gestor de transacciones chequea todo para asegurarse de que sus
actualizaciones funcionar&aacute;n. Si uno de los EJB devuelve un error o
falla, los cambios realizados por los EJB <span class="codefrag">PagosTarjeta</span>
o <span class="codefrag">Reservas</span> se deshacen por el gestionador de
transacciones.</p>
<p>Adem&aacute;s de gestionar las transacciones en su mismo entorno, un
servidor EJB puede cooordinarse con otros sistemas transaccionales.
Si, por ejemplo, el EJB <span class="codefrag">PagosTarjeta</span> viniera de un
servidor EJB distinto, los dos servidores EJB cooperar&iacute;an para
gestionar la transacci&oacute;n como una unidad-de-trabajo. Esto se llama una
transacci&oacute;n distribu&iacute;da.</p>
<p>Una transacci&oacute;n distribuida es mucho m&aacute;s complicada, y requiere
lo que se llama two-phase commit (2PC). 2PC es un mecanismo
que permite que una transacci&oacute;n sea gestionada a trav&eacute;s de
distintos servidores y recursos (por ejemplo, bases de datos y
proporcionadores JMS). Los detalles de un sistema 2PC est&aacute;n m&aacute;s
all&aacute; del alcance de este tema. No habr&aacute; que hacer ninguna
modificaci&oacute;n en el c&oacute;digo para que nuestros beans apliquen
transacciones distribuidas. Es un trabajo trasparente al
programador de EJB.</p>
</div>


<a name="N1032D"></a><a name="Anotaciones+EJBGen+Weblogic+para+transacciones"></a>
<h2 class="underlined_10">Anotaciones EJBGen Weblogic para transacciones</h2>
<div class="section">
<p>En Weblogic 9.2 se utiliza el par&aacute;metro  <span class="codefrag">transactionAtribute</span> en las anotaciones de los m&eacute;todos <span class="codefrag">LocalMethod</span> y <span class="codefrag">RemoteMethod</span> para indicar que el m&eacute;todo es transaccional.</p>
<p>Como valor del atributo se puede indicar:</p>
<ul>

<li>
<span class="codefrag">Constants.TransactionAttribute.UNSPECIFIED</span>
</li>

<li>
<span class="codefrag">Constants.TransactionAttribute.NOT_SUPPORTED</span>
</li>

<li>
<span class="codefrag">Constants.TransactionAttribute.SUPPORTS</span>
</li>

<li>
<span class="codefrag">Constants.TransactionAttribute.REQUIRED</span>
</li>

<li>
<span class="codefrag">Constants.TransactionAttribute.REQUIRES_NEW</span>
</li>

<li>
<span class="codefrag">Constants.TransactionAttribute.MANDATORY</span>
</li>

<li>
<span class="codefrag">Constants.TransactionAttribute.NEVER</span>
</li>

</ul>
<p>Estas constantes corresponden con las distintas posibilidades de gestionar las transacciones vistas anteriormente.</p>
<p>Tambi&eacute;n es posible declarar un tipo de gesti&oacute;n de transacciones por defecto para todos los m&eacute;todos de un EJB, declarando uno de los valores anteriores en el atributo <span class="codefrag">defaultTransaction</span> de la anotaci&oacute;n <span class="codefrag">Session</span> del EJB. </p>
</div>

<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006-2007 Depto. CCIA</div>
</div>
</body>
</html>
