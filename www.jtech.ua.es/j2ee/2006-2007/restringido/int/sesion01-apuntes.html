<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Integraci&oacute;n de aplicaciones</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Integraci&oacute;n de aplicaciones con SOA" src="images/baner_j2ee_der.gif" title="Integraci&oacute;n de aplicaciones con SOA"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Integraci&oacute;n de aplicaciones con SOA</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Integraci&oacute;n de aplicaciones con SOA</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Integraci&oacute;n de aplicaciones con SOA">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 1</div>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="Sesi&oacute;n 2: Arquitectura orientada a Servicios">Sesi&oacute;n 2</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion01-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Integraci&oacute;n de aplicaciones</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#%C2%BFQu%C3%A9+es+la+EAI%3F">&iquest;Qu&eacute; es la EAI?</a>
</li>
<li>
<a href="#Sistemas+de+Informaci%C3%B3n+de+Empresas+%28EIS%29">Sistemas de Informaci&oacute;n de Empresas (EIS)</a>
</li>
<li>
<a href="#Arquitectura+de+aplicaciones+existentes">Arquitectura de aplicaciones existentes</a>
</li>
<li>
<a href="#Arquitectura+de+aplicaciones+modernas">Arquitectura de aplicaciones modernas</a>
</li>
<li>
<a href="#Retos+que+plantea+la+EAI">Retos que plantea la EAI</a>
</li>
<li>
<a href="#Capas+en+la+integraci%C3%B3n+de+aplicaciones">Capas en la integraci&oacute;n de aplicaciones</a>
</li>
<li>
<a href="#Uso+de">Uso de middleware para EAI</a>
</li>
<li>
<a href="#Servicios+de+infraestructura+necesarios+para+la+integraci%C3%B3n">Servicios de infraestructura necesarios para la integraci&oacute;n</a>
</li>
<li>
<a href="#T%C3%A9cnicas+de+integraci%C3%B3n">T&eacute;cnicas de integraci&oacute;n</a>
</li>
<li>
<a href="#Opciones+alternativas+a+la+integraci%C3%B3n">Opciones alternativas a la integraci&oacute;n</a>
</li>
<li>
<a href="#Arquitectura+de+integraci%C3%B3n">Arquitectura de integraci&oacute;n</a>
</li>
</ul>
</div>


<p>Las empresas necesitan, cada vez m&aacute;s, un f&aacute;cil acceso a la informaci&oacute;n 
por parte de sus aplicaciones. Esta necesidad presenta nuevos retos para el 
desarrollo de aplicaciones. La facilidad de acceso a los datos es poco probable 
que se consiga mediante aplicaciones separadas (<em>stand-alone</em>) usadas por 
la mayor&iacute;a de las empresas, debido a la dificultad que representa el 
compartir datos entre ellas. Sin embargo, muchas empresas no pueden permitirse 
el lujo de retirar o reemplazar sus aplicaciones <em>stand-alone</em> de un d&iacute;a 
para otro debido a que juegan un papel cr&iacute;tico en el funcionamiento de 
la empresa, y a menudo no es rentable desarrollar de nuevo la aplicaci&oacute;n 
en su totalidad. Recordemos que una aplicaci&oacute;n <em>stand-alone</em> es aquella que 
se puede ejecutar sin necesidad de ning&uacute;n elemento soporte (por ejemplo un 
navegador).</p>


<p>Por otro lado, a medida que pasa el tiempo, las empresas necesitan introducir 
nuevas aplicaciones y sistemas. Estas nuevas soluciones se basan normalmente 
en arquitecturas modernas, que difieren de forma significativa de las arquitecturas 
usadas por aplicaciones que ya tienen a&ntilde;os de uso. A menudo las aplicaciones 
modernas se adquieren en forma de componentes, que se integran en una aplicaci&oacute;n 
m&aacute;s grande. Estas nuevas aplicaciones necesitan integrarse en el sistema 
existente para que la informaci&oacute;n que contienen est&eacute; disponible 
y sea accesible.</p>

<p>En estas situaciones, la integraci&oacute;n de aplicaciones corporativas (EAI) 
adquiere una gran importancia, permitiendo que una empresa integre sus aplicaciones 
y sistemas existentes y sea capaz de a&ntilde;adir nuevas tecnolog&iacute;as 
y aplicaciones al nuevo conjunto.</p>

<p>La integraci&oacute;n de aplicaciones no es una tarea f&aacute;cil; de hecho 
se ha convertido en uno de los problemas m&aacute;s dif&iacute;ciles con los 
que se enfrenta el desarrollo de aplicaciones para la empresa desde hace pocos 
a&ntilde;os. Los mayores retos se presentan en la integraci&oacute;n de diferentes 
dominios, arquitecturas y tecnolog&iacute;as. Adem&aacute;s, los requerimientos 
de los sistemas de informaci&oacute;n van creciendo significativamente y cambiando 
continuamente, por ello los proyectos de integraci&oacute;n deben realizarse 
en el menor tiempo posible, entregar sus resultados r&aacute;pidamente, y adaptarse 
a estos requerimientos siempre cambiantes.</p>

<p>Actualmente hay dos formas principales de integraci&oacute;n: primero es necesario 
permitir la integraci&oacute;n de aplicaciones dentro de una compa&ntilde;&iacute;a 
(intra-EAI), y en segundo lugar, podemos querer promover una integraci&oacute;n 
inter-EAI (<em>business-to-business</em>, B2B).</p>

<p>En esta primera charla presentamos los conceptos b&aacute;sicos de la integraci&oacute;n 
de aplicaciones corporativas. Comenzaremos definiendo el concepto de integraci&oacute;n, 
considerando los retos que representa, as&iacute; como los tipos, t&eacute;cnicas 
y tecnolog&iacute;as utilizadas para la integraci&oacute;n de aplicaciones corporativas. 
</p>          


<a name="N1002A"></a><a name="%C2%BFQu%C3%A9+es+la+EAI%3F"></a>
<h2 class="underlined_10">&iquest;Qu&eacute; es la EAI?</h2>
<div class="section">
<p>La integraci&oacute;n de aplicaciones corporativas (<em>Enterprise Application 
Integration</em>, EAI) es b&aacute;sicamente un nuevo nombre para el proceso 
de integraci&oacute;n en el que las empresas han estado trabajando durante a&ntilde;os. 
EAI hace referencia a una integraci&oacute;n global y sistem&aacute;tica.</p>
<p>Antes de definir de forma m&aacute;s precisa la EAI, consideraremos con m&aacute;s 
detalle c&oacute;mo surge la necesidad de integrar las aplicaciones de una empresa.</p>
<p>En el pasado, las aplicaciones se ideaban como soluciones individuales a problemas 
aislados. Los arquitectos software no pensaban en esas aplicaciones como partes 
de un sistema de informaci&oacute;n m&aacute;s amplio de la empresa. Esta es 
la raz&oacute;n de por qu&eacute; la mayor&iacute;a de aplicaciones antiguas 
permiten una interoperabilidad muy limitada con otras aplicaciones. Para modificar 
dichas aplicaciones y hacerlas m&aacute;s interoperables, se necesita un buen 
conocimiento del desarrollo de la aplicaci&oacute;n y de los procesos l&oacute;gicos 
que implementa. Incluso hoy en d&iacute;a, algunas aplicaciones se desarrollan 
sin tener en cuenta (o muy poco) c&oacute;mo conectarlas con otros sistemas. 
Por estas razones, EAI es relevante tanto para las aplicaciones ya existentes, 
como para aplicaciones modernas.</p>
<p>La importancia de la EAI radica en las expectativas del negocio. Desde el punto 
de vista del negocio, el objetivo es maximizar los beneficios de cada aplicaci&oacute;n 
y el sistema de informaci&oacute;n como un todo. Las aplicaciones separadas 
no pueden cumplir este requerimiento.</p>
<p>Parte del problema es que los datos se encuentran particionados y replicados 
entre las diferentes aplicaciones. Cada aplicaci&oacute;n modela los datos de 
forma diferente, de acuerdo con las necesidades de la aplicaci&oacute;n, no 
de la empresa. Esto hace que sea dif&iacute;cil "ensamblar" los datos 
de diferentes aplicaciones, ya que probablemente usar&aacute;n diferentes tecnolog&iacute;as, 
aplicaciones y bases de datos para acceder a ellos. En la Figura 1 se muestra 
un dominio t&iacute;pico de empresa. En este escenario, podemos encontrar "islas" 
de funciones y datos, y cada una de ellas existe con su dominio del problema 
de forma separada. </p>
<p>
	
<img alt="Figura 1. Dominio de negocio t&iacute;pico." content-width="8cm" src="imagenes/charla1/Figura1.gif">
</p>
<p>Las empresas necesitan modernizar y mejorar la funcionalidad de sus sistemas 
de informaci&oacute;n para seguir siendo competitivas (los gestores ven el sistema 
de informaci&oacute;n como una herramienta que pueden utilizar para maximizar 
los beneficios de la empresa).</p>
<p>Mejorar la funcionalidad de un sistema de informaci&oacute;n puede hacerse 
de varias maneras: (a) La forma m&aacute;s obvia consiste en reemplazar las 
aplicaciones antiguas por una soluci&oacute;n m&aacute;s reciente. Incluso aunque 
a primera vista parezca una soluci&oacute;n atractiva, es inaplicable en la 
mayor&iacute;a de los casos. Reemplazar sistemas existentes con nuevas soluciones 
siempre requiere m&aacute;s tiempo y dinero de lo que en principio estaba planificado, 
incluso teniendo en cuenta los escenarios m&aacute;s pesimistas. Incorporar 
todas las peculiaridades y casos especiales en el software requiere un conocimiento 
del sistema existente. Este conocimiento es mucho m&aacute;s f&aacute;cil de 
adquirir si la empresa tiene sus procesos del negocio bien documentados, cosa 
que no suele ocurrir en la pr&aacute;ctica. Adem&aacute;s, a menudo, no hay 
una &uacute;nica persona que conozca el proceso en su totalidad; (b) Otra alternativa 
es la de introducir soluciones comerciales. Esta soluci&oacute;n probablemente 
no sea factible, ya que cada empresa tiene una forma particular de realizar 
los negocios, y que las distingue. El adaptar soluciones comerciales a la empresa 
requiere tiempo, y tiempo significa dinero. Introducir nuevos sistemas requiere 
tambi&eacute;n entrenar y educar al personal. </p>
<p>Una alternativa factible para mejorar la funcionalidad del sistema de informaci&oacute;n 
consiste en conseguir una forma est&aacute;ndar para reusar sistemas existentes 
pero integr&aacute;ndolos en un sistema global de informaci&oacute;n de la empresa 
m&aacute;s amplio. En este sentido, EAI proporciona una metodolog&iacute;a est&aacute;ndar 
para la comunicaci&oacute;n entre aplicaciones y fuentes de datos. </p>
<p>Ahora daremos una definici&oacute;n m&aacute;s precisa del t&eacute;rmino EAI. 
Realmente, la <strong>definici&oacute;n de EAI</strong> var&iacute;a dependiendo del punto 
de vista:</p>
<p>Desde el <strong>punto de vista del negocio</strong>, EAI representa la ventaja competitiva que consigue una empresa cuando todas las aplicaciones est&aacute;n integradas 
en un sistema de informaci&oacute;n &uacute;nico, capaz de compartir informaci&oacute;n 
y soportar flujos de trabajo del negocio (<em>business workflow</em>). La informaci&oacute;n debe compartirse a menudo desde diferentes dominios y ser integrada en un proceso 
de negocio. Sin EAI, si bien la informaci&oacute;n requerida puede que exista 
y est&eacute; disponible en alg&uacute;n lugar y de alguna forma en una aplicaci&oacute;n, 
para los usuarios t&iacute;picos es pr&aacute;cticamente imposible tener acceso 
a ella <em>on-line</em>.</p>
<p>Desde el <strong>punto de vista t&eacute;cnico</strong>, EAI se refiere al proceso de 
integrar las diferentes aplicaciones y los datos sin tener que modificar demasiado 
las aplicaciones existentes. EAI debe realizarse utilizando m&eacute;todos y 
actividades que permitan que dicho proceso sea efectivo en t&eacute;rminos de 
coste y tiempo.</p>
<p>Existen muchos ejemplos reales de EAI, particularmente en la industria de la 
banca y servicios financieros, as&iacute; como en telecomunicaciones. Por ejemplo, 
AT&amp;T comenz&oacute; como un suministrador de servicios de telefon&iacute;a, 
a los que a&ntilde;adi&oacute; los servicios de televisi&oacute;n por cable 
y otros servicios inhal&aacute;mbricos. M&aacute;s tarde se convirti&oacute; 
en un suministrador de banda ancha. La compa&ntilde;&iacute;a ha crecido absorbiendo 
a otras compa&ntilde;&iacute;as y adquiriendo otros negocios. Como resultado 
de su crecimiento, y antes de sus planes actuales de dividirse en cuatro compa&ntilde;&iacute;as 
diferentes, AT&amp;T necesit&oacute; integrar sus servicios <em>on-line</em> a 
sus clientes. Tuvo que integrar sus presentaciones de facturas a todos los servicios, 
los pagos de los servicios, y la totalidad de los servicios a los clientes. 
Esto supuso una integraci&oacute;n del acceso a las aplicaciones existentes 
que proporcionaban dichos servicios.</p>
<p>En el proceso de integraci&oacute;n de procesos del negocio y los datos, EAI 
abarca tanto la distribuci&oacute;n de dichos procesos y datos, como el concepto 
de reutilizaci&oacute;n de m&oacute;dulos. Y lo que es m&aacute;s importante, 
EAI aborda esta integraci&oacute;n como un proceso separado de las diferentes 
aplicaciones. Es decir, alguien puede integrar varias aplicaciones, incluyendo 
las fuentes de datos subyacentes, sin tener que comprender o conocer los detalles 
propios de cada aplicaci&oacute;n. </p>
<p>No todas las empresas se benefician de igual forma del proceso de integraci&oacute;n. 
Por supuesto, cuando una empresa tiene &uacute;nicamente un n&uacute;mero limitado 
de sistemas, que comparten tecnolog&iacute;a y arquitectura, la integraci&oacute;n 
es mucho m&aacute;s f&aacute;cil. A la inversa, puede haber sistemas formados 
por grandes aplicaciones diferentes, distribuidas geogr&aacute;ficamente en 
varias plataformas, algunas de las cuales tienen funcionalidades comunes. En 
este caso, la empresa se beneficiar&aacute; considerablemente del proceso de 
integraci&oacute;n.</p>
<p>Adem&aacute;s, para realizar una integraci&oacute;n de forma exitosa es necesario 
evaluar el estado de las aplicaciones existentes, analizar los requerimientos 
del sistema, y comparar la situaci&oacute;n actual con las metas fijadas y los 
requerimientos actuales. Este estudio debe realizarse caso por caso, ya que 
no es f&aacute;cil definir procedimientos universales.</p>
<p>Puesto que hemos visto que la comprensi&oacute;n de los sistemas existentes 
es vital para una integraci&oacute;n efectiva, estudiaremos el concepto de sistemas 
de informaci&oacute;n, y analizaremos m&aacute;s de cerca la arquitectura de 
dichos sistemas.
</p>
</div>


<a name="N1007E"></a><a name="Sistemas+de+Informaci%C3%B3n+de+Empresas+%28EIS%29"></a>
<h2 class="underlined_10">Sistemas de Informaci&oacute;n de Empresas (EIS)</h2>
<div class="section">
<p>Antes de entrar en detalles sobre la EAI, es &uacute;til entender la definici&oacute;n 
de un sistema de informaci&oacute;n de empresa (<strong>EIS</strong>: <em>Enterprise Information 
System</em>). Una empresa requiere ciertos procesos de negocio y datos subyacentes 
para ejecutar dichos procesos. Un EIS abarca los procesos del negocio y la infraestructura 
para las tecnolog&iacute;as de informaci&oacute;n (<strong>IT</strong>: <em>Information 
Technology</em>). Los procesos del negocio incluyen aplicaciones para la gesti&oacute;n 
del procesamiento de n&oacute;minas, gesti&oacute;n de inventario, control de 
producci&oacute;n de fabricaci&oacute;n, y la contabilidad financiera.</p>
<p>Definimos un sistema de informaci&oacute;n de empresa como un sistema con una 
o varias aplicaciones que proporciona la estructura de informaci&oacute;n para 
la empresa. Un EIS proporciona un conjunto de servicios a sus usuarios, que 
pueden estar disponibles en distintos niveles de abstracci&oacute;n (por ejemplo 
a nivel de sistema, nivel de datos, o nivel de negocio).</p>
<p>En la Figura 2 se puede apreciar gr&aacute;ficamente esta situaci&oacute;n. 
En el entorno mostrado, las aplicaciones residen en un servidor de aplicaciones. 
Dicho servidor tiene una infraestructura particular dependiente del vendedor, 
contemplando en particular los servicios de procesamiento de transacciones, 
seguridad y balanceo de carga. Las aplicaciones incluidas en el servidor pueden 
ser suministradas por diferentes vendedores, o pueden desarrollarse en el departamento 
IT de la empresa. Las aplicaciones est&aacute;n escritas en varios lenguajes, 
como COBOL, C, y C++. Los clientes acceden a las diferentes aplicaciones mediante 
interfaces (<strong>API</strong>s: <em>Application Programming Interfaces</em>). Un API 
es alguna rutina que permite a un cliente realizar operaciones tales como crear 
una orden de compra o actualizar un registro de usuario. La interfaz de acceso 
a los datos permite acceder al almacenamiento de los datos (ficheros o base 
de datos relacional). Los interfaces de objetos del negocio son abstracciones 
que representan la l&oacute;gica espec&iacute;fica del negocio para acceder 
a las funciones y los datos.</p>
<p>
	
<img alt="Figura 2. Entorno Sistema de Informaci&oacute;n de Empresa." content-width="12cm" src="imagenes/charla1/Figura2.gif">
</p>
<p>Hay muchas y diferentes aplicaciones que pueden catalogarse como un EIS. Por 
ello los EIS var&iacute;an unos de otros, incluso dentro de la misma empresa. 
Una empresa puede desarrollar varios EISs a lo largo del tiempo, dependiendo 
de las necesidades particulares del momento. Por ejemplo, una empresa puede 
comenzar con un sistema de fabricaci&oacute;n. A medida que pasan los a&ntilde;os 
y la empresa crece, se a&ntilde;aden otros paquetes como contabilidad, atenci&oacute;n 
al cliente y recursos humanos. Algunos servicios puede incluirlos en la plataforma 
en donde residen las operaciones relacionadas con la fabricaci&oacute;n, sin 
embargo, otros requerir&aacute;n ser desarrollados con una plataforma o arquitecturas 
diferentes. La empresa no solamente a&ntilde;ade nuevos sistemas software, sino 
que adquiere <em>hardware</em> adicional que puede ser completamente diferente 
de su configuraci&oacute;n original. Es f&aacute;cil ver que cuando una empresa 
opera durante largo tiempo, puede estar usando EIS que han sido desarrolladas 
  e instaladas sobre diferentes plataformas y arquitecturas.</p>
</div>


<a name="N100AE"></a><a name="Arquitectura+de+aplicaciones+existentes"></a>
<h2 class="underlined_10">Arquitectura de aplicaciones existentes</h2>
<div class="section">
<p>Los proyectos EAI tienen que tratar con aplicaciones (sistemas de informaci&oacute;n) 
existentes. Algunas de las aplicaciones existentes son antiguas, basadas en 
tecnolog&iacute;as no consideradas actualmente como "estado del arte", 
con lenguajes de programaci&oacute;n en desuso, y sobre plataformas anteriores 
a las actuales, estas aplicaciones se conocen con el nombre de aplicaciones 
o sistemas <strong><em>legacy</em></strong>. Podemos considerar dos tipos de sistemas <em>legacy</em>: 
los sistemas monol&iacute;ticos tradicionales (basados principalmente en sistemas 
<em>mainframe</em>), y los sistemas cliente/servidor (basados mayormente en PC's). 
	</p>
<p>Una <strong>arquitectura monol&iacute;tica</strong> contiene la presentaci&oacute;n, 
la l&oacute;gica del negocio y los datos en la misma aplicaci&oacute;n. Normalmente 
se trata de aplicaciones con un dise&ntilde;o estructurado e implementadas con 
lenguajes estructurados como COBOL, Fortran y PL/1 entre otros. En la mayor&iacute;a 
de casos, los datos se almacenan en ficheros usando diferentes formatos binarios. 
Los sistemas contienen miles de l&iacute;neas de c&oacute;digo que han sido 
desarrolladas y mantenidas a lo largo de los a&ntilde;os por diferentes desarrolladores. 
Usualmente no se dispone de documentaci&oacute;n, y en el peor de los casos, 
tampoco del c&oacute;digo fuente. La mayor&iacute;a de dichos sistemas residen 
en ordenadores <em>mainframe</em>. Huelga decir que inicialmente no hab&iacute;a 
ning&uacute;n tipo de integraci&oacute;n entre las diferentes aplicaciones monol&iacute;ticas. 
Sin embargo, las soluciones de integraci&oacute;n sobre dichos sistemas se comenz&oacute; 
a realizar hace unas tres d&eacute;cadas. </p>
<p>Un primer intento de integraci&oacute;n consiste en enlazar las diferentes 
aplicaciones con una base de datos centralizada (ver Figura 3). Dicha base 
de datos normalmente no almacena todos los datos de todas las aplicaciones (debido 
a restricciones de capacidad y rendimiento), por lo tanto &eacute;stas todav&iacute;a 
necesitan de bases de datos locales. Este tipo de integraci&oacute;n requiere 
una re-programaci&oacute;n de cada aplicaci&oacute;n. </p>
<p>
	
<img alt="Figura 3. rquitectura mainframe." content-width="9cm" src="imagenes/charla1/Figura3.gif">
</p>
<p>Desde una perspectiva t&eacute;cnica, esta integraci&oacute;n no es demasiado 
dif&iacute;cil cuando solamente hay una plataforma en la empresa, y no hay demasiadas 
aplicaciones a integrar. Desafortunadamente, hay un gran n&uacute;mero de empresas 
que no pertenecen a esta categor&iacute;a.</p>
<p>Posteriormente, en la d&eacute;cada de los 80, el proceso de reemplazamiento 
de los <em>mainframes</em> por PCs lleva consigo algunos grandes cambios en las 
arquitecturas de las aplicaciones, pero complica todav&iacute;a m&aacute;s las 
cosas. No se dispone de estrategias para estandarizar las plataformas y tecnolog&iacute;as 
a usar, con lo que cada departamento es libre de realizar su elecci&oacute;n, 
usualmente basada en preferencias personales, y no en los objetivos de la empresa 
en su totalidad. Por un lado las necesidades de integraci&oacute;n se hicieron 
cada vez m&aacute;s crecientes, por otro lado, los PCs interconectados comenzaron 
a sustituir a los terminales "mudos". A medida que fue necesario compartir 
los datos entre los usuarios, las arquitecturas monol&iacute;ticas se volvieron 
inviables.</p>
<p>La soluci&oacute;n a estos problemas fue la arquitectura <strong>cliente/servidor</strong> 
que separa las aplicaciones en dos capas (ver Figura 1.4). En la mayor&iacute;a 
de los casos, la gesti&oacute;n de los datos se separ&oacute; del resto de la 
aplicaci&oacute;n (ver Figura 4a). Esto significaba que la l&oacute;gica del 
negocio y la interfaz del usuario todav&iacute;a permanec&iacute;a unida, y 
en demasiados casos, interconectadas. Debido a que el cliente realizaba la mayor 
parte del procesamiento implicado en la l&oacute;gica del negocio, a este tipo 
de aplicaciones cliente/servidor se les ha denominado <strong>clientes ricos</strong> 
(<em>fat clients</em>). Los datos usualmente resid&iacute;an en uno o varios servidores 
dedicados de gesti&oacute;n de base de datos (DBMS). Otra posibilidad para los 
sistemas cliente/servidor fue separar la l&oacute;gica del cliente y situarla 
en el servidor (ver Figura 4b). En este escenario, el c&oacute;digo en la 
parte del cliente es mucho m&aacute;s sencillo, y a dichos clientes se les ha 
llamado <strong>clientes ligeros</strong> (<em>thin clients</em>). La l&oacute;gica del 
negocio se almacenaba en el servidor de la base de datos (en forma de procedimientos 
con sentencias SQL), o en un servidor fuertemente acoplado a la base de datos. 
La mayor&iacute;a de los gestores de bases de datos soportan procedimientos 
almacenados, si bien hay variaciones en la sintaxis y en sus capacidades, creando 
as&iacute; otro problema potencial: el traslado de esta l&oacute;gica de un 
DBMS a otro es una tarea extremadamente ardua, si no pr&aacute;cticamente imposible. 
</p>
<p>
	
<img alt="Figura 4. Arquitectura cliente/servidor. (a) Cliente rico. (b) Cliente ligero" content-width="14cm" src="imagenes/charla1/Figura4.gif">
</p>
<p>La mayor parte de las nuevas aplicaciones, a partir de entonces se desarrollaron 
siguiendo la arquitectura cliente/servidor, pero las soluciones monol&iacute;ticas 
permanecieron, haciendo as&iacute; crecer la necesidad de integraci&oacute;n. 
Adem&aacute;s, la arquitectura cliente/servidor implica un estrecho acoplamiento 
entre la aplicaci&oacute;n y la base de datos. </p>
<p>El n&uacute;mero de aplicaciones diferentes en una misma empresa fue creciendo. 
Si bien diferentes aplicaciones resolv&iacute;an problemas diferentes, en muchos 
casos hab&iacute;a alg&uacute;n solape funcional entre ellas, con lo que se 
pod&iacute;a dar el caso de datos similares residentes en bases de datos diferentes, 
con nombres diferentes. Para una integraci&oacute;n efectiva, el acceso a los 
mismos datos no resuelve todos los problemas. Dicho acceso a los datos y su 
posible transferencia entre bases de datos no es suficiente debido a la dificultad 
que entra&ntilde;a el an&aacute;lisis de dichos datos para obtener informaci&oacute;n 
del negocio valiosa para el soporte de decisiones. Tampoco es posible reusar 
todas las funcionalidades de otras aplicaciones. Sin la reusabilidad de las 
funciones la &uacute;nica posibilidad consiste en implementar las funcionalidades 
en diferentes aplicaciones, incrementando la complejidad de nuevo (especialmente 
a la hora de mantener las aplicaciones). Duplicar la funcionalidad es necesario 
debido a que si accedemos a los datos en la base de datos directamente, evitamos 
implementar reglas del negocio en la aplicaci&oacute;n original; pero esto significa 
que tenemos que ser extremadamente cautos debido a que un acceso directo a la 
base de datos puede amenazar la integridad del sistema.</p>
<p>Para resolver el problema del an&aacute;lisis de grandes cantidades de datos 
almacenados en aplicaciones diferentes, y permitir el compartir funcionalidades 
de las aplicaciones, se utilizan los <em>datawarehouse</em> y los <em>sistemas 
ERP</em>.</p>
<p>A principios de los 90, la integraci&oacute;n es una cuesti&oacute;n relevante 
desde dos puntos de vista distintos. Por un lado tenemos el uso de <em>data warehouses</em>. 
Un <strong><em>data warehouse</em></strong> es un repositorio central para todos los datos 
significativos que las aplicaciones de una compa&ntilde;&iacute;a obtienen. 
Debido a la variedad de datos bien estructurados contenidos en ellos, los <em>data 
warehouses</em> fueron (y todav&iacute;a siguen siendo) efectivos como sistemas 
de soporte de decisiones <em>off-line</em>, y &uacute;tiles siempre que puedan 
obtenerse datos "en bruto" y analizarlos para derivar conclusiones 
a partir de ellos.</p>
<p>Los datos de las bases de datos de las aplicaciones se env&iacute;an al <em>data 
warehouse</em> a intervalos de tiempo predeterminados, normalmente una vez por 
d&iacute;a. Esto hace que los data <em>warehouses</em> no sean la elecci&oacute;n 
perfecta para la integraci&oacute;n, especialmente cuando no podemos permitirnos 
el trabajar con datos que pueden estar anticuados. Los procedimientos asociados 
con un sistema <em>data warehouse</em> se asemejan a los de la Figura 5, en 
donde los datos desde diferentes bases de datos son extra&iacute;dos, transformados 
y cargados en un data <em>warehouse</em> central. Las reglas para estas tres fases 
se definen como meta-datos. </p>
<p>
	
<img alt="Figura 5. Data warehouse" content-width="12cm" src="imagenes/charla1/Figura5.gif">
</p>
<p>Por otro lado, se comienzan a usar sistemas de planificaci&oacute;n de recursos 
de la empresa (<strong><em>Enterprise Resource Planning</em></strong>, ERP). Los sistemas 
ERP son sistemas de gesti&oacute;n de empresas, t&iacute;picamente implementados 
por un vendedor particular como un conjunto de aplicaciones integradas que cubren 
todas las facetas del negocio, incluyendo planificaci&oacute;n, fabricaci&oacute;n, 
ventas y marketing. La idea es usar los sistemas ERP para cubrir todas las necesidades 
de informaci&oacute;n de la empresa. Por desgracia, la experiencia ha demostrado 
que los sistemas ERP no pueden satisfacer las necesidades de informaci&oacute;n 
de una compa&ntilde;&iacute;a totalmente. Si bien el c&oacute;digo fuente est&aacute; 
disponible para algunos de ellos, los vendedores no quieren realizar cambios 
espec&iacute;ficos sobre ellos. Sin embargo, cada empresa tiene muchas particularidades 
que necesitan ser cubiertas sobre una base individual, adem&aacute;s de tener 
que reaccionar de forma r&aacute;pida para adaptarse a los cambios del mercado. 
Todo ello hace que se requieran modificaciones o a&ntilde;adidos sobre el sistema 
de informaci&oacute;n, y esperar las soluciones de los suministradores de los 
ERP no es pr&aacute;ctico. Algunos resultados de estudios de mercado sugieren 
que los sistemas ERP t&iacute;picamente cubren &uacute;nicamente un 25-40% de 
las necesidades de informaci&oacute;n de una empresa (el resto se cubre con 
otras aplicaciones software). </p>
<p>La situaci&oacute;n actual es que las empresas se encuentran con una mezcla 
disparatada de sistemas existentes heterog&eacute;neos de los cuales dependen 
sus negocios. Desgraciadamente esta mezcla de sistemas diferentes no ha sido 
dise&ntilde;ada de una manera unificada (solamente ha crecido, y continuar&aacute; 
creciendo). La heterogeneidad consume recursos de desarrollo. En vez de crear 
soluciones a problemas nuevos, muchos desarrolladores emplean una considerable 
cantidad de tiempo y recursos trabajando sobre soluciones viejas. Y tenemos 
que tener en cuenta, que el n&uacute;mero de computadores en una empresa suele 
ser finito.</p>
<p>Las aplicaciones m&aacute;s cr&iacute;ticas para la mayor parte de las empresas 
son las aplicaciones de procesamiento de transacciones. Suelen ser aplicaciones 
desarrolladas a lo largo de muchos a&ntilde;os, los desarrolladores han ido 
cambiando varias veces, y es dif&iacute;cil encontrar a alguien que las entienda 
en su totalidad. Algunas de ellas todav&iacute;a se ejecutan sobre sistemas 
<em>mainframe</em>. Las empresas son renuentes, comprensiblemente, a modificar 
o reemplazar dichas aplicaciones. El dilema entonces se convierte en c&oacute;mo 
modernizarlas sin comprometer las operaciones.</p>
</div>


<a name="N1013F"></a><a name="Arquitectura+de+aplicaciones+modernas"></a>
<h2 class="underlined_10">Arquitectura de aplicaciones modernas</h2>
<div class="section">
<p>Cualquier arquitectura de una aplicaci&oacute;n moderna debe satisfacer la 
  necesidad de un desarrollo r&aacute;pido de la soluci&oacute;n, posiblemente 
  mediante la composici&oacute;n de componentes <em>software. </em>Adem&aacute;s, 
  deber&iacute;a soportar propiedades tales como mantenibilidad, flexibilidad 
  y escalabilidad, entre otras. La soluci&oacute;n actual consiste en utilizar 
  arquitecturas multi-capa, la m&aacute;s com&uacute;n contiene tres capas (ver 
  Figura 6):</p>
<ul>
  
<li>Capa de <strong>presentaci&oacute;n</strong> o interfaz de usuario. Maneja servicios 
    tales como entrada, di&aacute;logos, y gesti&oacute;n de la visualizaci&oacute;n 
    de los datos</li>
  
<li>Capa intermedia o de <strong>l&oacute;gica del negocio</strong>. Proporciona los servicios 
    de la l&oacute;gica del negocio que son compartidos entre aplicaciones diferentes.</li>
  
<li>Capa de persistencia de <strong>datos</strong>. Proporciona una gesti&oacute;n de 
    los datos y otras funcionalidades relacionadas.</li>

</ul>
<p>
	
<img alt="Figura 6. Arquitectura de tres capas" content-width="11cm" src="imagenes/charla1/Figura6.gif">
</p>
<p>Cada capa, y en particular la capa de l&oacute;gica del negocio, puede subdividirse 
  en varias sub-capas dando lugar a la arquitectura l&oacute;gica multi-capa. 
  En la Figura 1.6 se pueden observar los elementos de la capa de l&oacute;gica 
  del negocio denominados <strong>componentes</strong>. </p>
<p>Un <strong>componente</strong> es un c&oacute;digo ejecutable que implementa una cierta 
  funcionalidad. Dicha funcionalidad es accesible para el resto de la arquitectura 
  mediante uno o m&aacute;s <em>interfaces</em>. Los componentes est&aacute;n fuertemente 
  encapsulados y ocultan sus detalles internos a sus clientes (otros componentes, 
  m&eacute;todos de objetos, procedimientos, funciones, etc.). La &uacute;nica 
  forma que tiene un cliente de acceder a una componente es a trav&eacute;s de 
  su interfaz.</p>
<p>Se puede acceder a la interfaz de una componente usando un alto nivel de abstracci&oacute;n, 
  de forma que no sea necesario preocuparse ni de su implementaci&oacute;n, ni 
  tampoco de su localizaci&oacute;n o forma de comunicaci&oacute;n. Un <em><strong>middleware</strong></em> 
  se ocupa de todos los detalles de la comunicaci&oacute;n permitiendo as&iacute; 
  la interoperabilidad entre componentes (ver Figura 7). </p>
<p>
	
<img alt="Figura 7. Interoperabilidad entre componentes" content-width="7cm" src="imagenes/charla1/Figura7.gif">
</p>
<p>Los componentes constituyen una forma de empaquetar c&oacute;digo ejecutable, 
  no son ninguna t&eacute;cnica de implementaci&oacute;n en s&iacute;, si bien 
  los componentes son a menudo confundidos con objetos. Es cierto que los componentes 
  y los objetos comparten algunos conceptos, como los interfaces y la encapsulaci&oacute;n. 
  Sin embargo, los componentes difieren de los objetos en que proporcionan una 
  funcionalidad m&aacute;s amplia y muy poca relaci&oacute;n con otros componentes. 
  Cualquier cliente puede usar los servicios del componente, no importa en qu&eacute; 
  lenguaje est&eacute; escrito, ni d&oacute;nde se encuentre f&iacute;sicamente, 
  o cual sea su estructura interna. No es necesario que los componentes sean implementados 
  con lenguajes orientados a objetos.</p>
<p>Los componentes pueden encontrarse en diferentes capas. Los componentes de 
  la interfaz de usuario difieren de los de la capa de l&oacute;gica del negocio, 
  puesto que solamente proporcionan alguna forma de representaci&oacute;n visual, 
  mientras que estos &uacute;ltimos proporcionan fundamentalmente servicios.</p>
<p>Los componentes se desarrollan usando modelos de componentes. Dichos modelos 
  proporcionan el entorno en el que se ejecutan los componentes. Modelos populares 
  de componentes para la capa de presentaci&oacute;n son los <em>JavaBeans</em>, 
  o <em>Microsoft ActiveX</em>. Componentes usuales de la capa de negocio incluyen 
  CORBA (<em>Common Object Request Broker Architecture</em>), y EJB (<em>Enterprise 
  Java Beans</em>).</p>
<p>Los beneficios de una arquitectura multi-capa son obvios y numerosos: integraci&oacute;n 
  y reusabilidad, encapsulaci&oacute;n, distribuci&oacute;n, particionamiento, 
  escalabilidad, desarrollo independiente, y desarrollo r&aacute;pido, entre otros. 
  Pero tambi&eacute;n presentan desventajas como los riesgos de seguridad, y la 
  gesti&oacute;n de los componentes. Adem&aacute;s, la arquitectura l&oacute;gica 
  tiene una arquitectura f&iacute;sica asociada, que puede corresponderse con 
  &eacute;sta o no (podemos ubicar cada capa l&oacute;gica en una f&iacute;sica, 
  o agrupar varias l&oacute;gicas en una sola capa f&iacute;sica, por ejemplo 
  para minimizar los tiempos de comunicaci&oacute;n entre sus componentes).</p>
<p>Un ejemplo de arquitectura multi-capa son los <strong>sistemas basados en web</strong>, 
  que presentan a menudo una capa separada de la presentaci&oacute;n denominada 
  capa de componentes <em>web</em>, para gestionar la l&oacute;gica de la presentaci&oacute;n 
  de la <em>web</em>. </p>
<p>Con el auge de la <em>web</em>, la integraci&oacute;n de aplicaciones adquiere 
  un mayor significado que va m&aacute;s all&aacute; de la mera combinaci&oacute;n 
  de aplicaciones en una empresa. Los servidores de la empresa actualmente, manejan 
  y mantienen grandes cantidades de datos y l&oacute;gica del negocio. Adem&aacute;s, 
  debido a que la <em>web</em> facilita el f&aacute;cil acceso a los servicios y 
  la informaci&oacute;n, se ha convertido en uno de los principales medios de 
  comunicaci&oacute;n. Una empresa debe ser capaz de hacer accesibles sus datos, 
  desde empleados internos a socios externos, suministradores y fabricantes. </p>
<p>Hasta ahora, las aplicaciones se clasifican como frontales de oficina (<em>front-offic</em>e) 
  e internas de la oficina (<em>back-office</em>). Las aplicaciones <em><strong>front-office</strong></em> 
  se utilizan para interactuar con el cliente o usuario final. Incluyen aplicaciones 
  para la gesti&oacute;n de las relaciones con los clientes y automatizaci&oacute;n 
  de las tareas de <em>marketing</em>. Las aplicaciones <em><strong>back-office</strong></em> 
  proporcionan la infraestructura de la informaci&oacute;n para ejecutar los procesos 
  <em>back-end</em> de una empresa. Las aplicaciones que proporciona un ERP son 
  buenos ejemplos de aplicaciones <em>back-office</em>. La integraci&oacute;n tradicional 
  se centra en integrar las aplicaciones <em>front-office</em> y <em>back-office</em>. Sin 
  embargo, esta integraci&oacute;n est&aacute; siendo condicionada por la <em>web</em> 
  incluyendo tambi&eacute;n a las aplicaciones <em>web</em>.</p>
<p>Ya que es un imperativo para un EIS cambiar a una arquitectura basada en <em>web</em>, 
  las aplicaciones de la misma necesitan ser desplegadas en plataformas de aplicaciones 
  est&aacute;ndar, cada vez m&aacute;s extensamente utilizadas. Actualmente los 
  servidores de empresa se consideran como plataformas adecuadas para desarrollar 
  aplicaciones <em>web</em>. Tal y como muestra la Figura 8, los servidores de 
  aplicaciones son particularmente apropiados para las &aacute;reas B2C (<em>business-to-customer</em>) 
  y B2B (<em>business-to-business</em>). El servidor de aplicaciones proporciona 
  un punto de integraci&oacute;n natural entre los sistemas de informaci&oacute;n 
  existentes en la empresa y las aplicaciones web. El servidor de aplicaciones 
  ayuda tambi&eacute;n en el manejo de transacciones y puede escalarse si es necesario. 
  La plataforma J2EE es una tecnolog&iacute;a a tener en cuenta para las empresas 
  y vendedores de aplicaciones.</p>
<p>
	
<img alt="Figura 8. ntegraci&oacute;n de aplicaciones dirigida por la Web" content-width="10cm" src="imagenes/charla1/Figura8.gif">
</p>
</div>


<a name="N101F1"></a><a name="Retos+que+plantea+la+EAI"></a>
<h2 class="underlined_10">Retos que plantea la EAI</h2>
<div class="section">
<p>Los EIS difieren significativamente, en t&eacute;rminos de nivel de soporte 
  tecnol&oacute;gico, restricciones administrativas y tecnol&oacute;gicas, capacidad 
  para integrarse con otros sistemas, y el grado de exposici&oacute;n de detalles 
  de bajo nivel. Por lo tanto, estos elementos constituyen los principales retos 
  que debe asumir la integraci&oacute;n de aplicaciones:</p>
<ul>
  
<li>
<strong>Nivel de soporte tecnol&oacute;gico</strong>: puede variar enormemente de 
    unas aplicaciones a otras. Tomemos por ejemplo, el soporte para transacciones 
    y seguridad. Algunos EIS pueden no ofrecer soporte para acceso transaccional, 
    o, si tienen alg&uacute;n tipo de soporte, est&aacute; muy limitado. Otros 
    EIS m&aacute;s avanzados ofrecen soporte para ambos servicios.</li>
  
<li>
<strong>Restricciones administrativas y tecnol&oacute;gicas</strong>: normalmente 
    los sistemas <em>legacy</em> suelen imponer restricciones de uso, debido a que 
    est&aacute;n estructuradas de forma m&aacute;s r&iacute;gida. Por ejemplo, 
    en un sistema de este tipo puede ser dif&iacute;cil crear nuevas cuentas de 
    usuario.</li>
  
<li>
<strong>Capacidad para integrarse con otros sistemas</strong>: los EIS pueden diferir 
    en t&eacute;rminos de sus modelos de programaci&oacute;n de aplicaciones y 
    clientes API, lo que hace dif&iacute;cil su integraci&oacute;n con otros EIS. 
    Estas diferencias existen debido a que dichas aplicaciones se han desarrollado 
    en momentos diferentes, utilizando las tecnolog&iacute;as m&aacute;s adecuadas 
    en dichos momentos. Y adem&aacute;s no se ha tenido en cuenta la interoperabilidad 
    con otros sistemas como un objetivo de dise&ntilde;o primario.</li>
  
<li>
<strong>Grado de exposici&oacute;n de detalles de bajo nivel</strong>: los APIs de 
    los clientes pueden diferir en los detalles de bajo nivel de transacciones 
    y seguridad que muestran a los desarrolladores de aplicaciones, y esto complica 
    la integraci&oacute;n de diferentes EIS. El desarrollador de aplicaciones 
    debe conocer los detalles de programaci&oacute;n de bajo nivel del API del 
    cliente para una integraci&oacute;n efectiva. Por ejemplo, supongamos que 
    un EIS define el API del cliente usando una librer&iacute;a C. Dicha librer&iacute;a 
    define m&eacute;todos que usan las aplicaciones cliente para gestionar las 
    transacciones y realizar un acceso transaccional a dicho EIS. La librer&iacute;a 
    puede contemplar mecanismos de comunicaci&oacute;n distribuidos entre las 
    aplicaciones cliente y los EIS. El desarrollador de aplicaciones tiene por 
    lo tanto, la tarea a&ntilde;adida de comprender esta librer&iacute;a C (y 
    los mecanismos de bajo nivel que contempla esta API), para usar el API del 
    cliente. Esta complejidad adicional incrementa el esfuerzo de la integraci&oacute;n 
    de aplicaciones.</li>

</ul>
<p>Dada la complejidad del desarrollo de aplicaciones y la integraci&oacute;n 
  de los EIS, es importante que los desarrolladores utilicen herramientas de desarrollo 
  est&aacute;ndares y entornos de integraci&oacute;n.</p>
<p>El acceso <strong>transaccional</strong> y la <strong>seguridad</strong> son cuestiones importantes 
  en t&eacute;rminos de integraci&oacute;n EIS. Las empresas llevan a cabo sus 
  negocios utilizando la informaci&oacute;n almacenada en sus EIS, el &eacute;xito 
  de una empresa depende de forma cr&iacute;tica de su informaci&oacute;n, as&iacute; 
  como de un acceso seguro a la misma.</p>
<p>Otro requerimiento importante es la <strong>escalabilidad</strong>, con el fin de permitir 
  que la empresa pueda ampliar sus relaciones con suministradores, compradores, 
  y socios. Para lograr esto, el uso de un <em>pooling</em> de conexiones se convierte 
  en un requerimiento importante para la integraci&oacute;n de sistemas.</p>
<p>Adicionalmente, las empresas deben considerar su inversi&oacute;n actual en 
  las aplicaciones existentes y un plan de integraci&oacute;n que resulte efectivo 
  en cuanto a coste. La mayor&iacute;a de las empresas y EIS han invertido cantidades 
  considerables en el c&oacute;digo de sus aplicaciones e infraestructura asociada. 
  Si bien reconocen la necesidad de migrar a una plataforma J2EE, deben lograr 
  esta integraci&oacute;n de forma incremental en lugar de en un solo paso. Una 
  migraci&oacute;n incremental les permite mantener un uso m&aacute;ximo de sus 
  sistemas existentes, pero a&ntilde;adiendo de forma gradual nuevas funcionalidades 
  como componentes J2EE, haciendo as&iacute; accesibles sus aplicaciones mediante 
  J2EE. Durante este proceso de migraci&oacute;n, pueden descargar sobre los vendedores 
  del servidor de aplicaciones la gesti&oacute;n de la complejidad de las transacciones 
  y la seguridad, y as&iacute; dejar que los desarrolladores del software se centren 
  en la resoluci&oacute;n de problemas del dominio del negocio.</p>
</div>


<a name="N1022D"></a><a name="Capas+en+la+integraci%C3%B3n+de+aplicaciones"></a>
<h2 class="underlined_10">Capas en la integraci&oacute;n de aplicaciones</h2>
<div class="section">
<p>La integraci&oacute;n de aplicaciones debe realizarse con un coste lo m&aacute;s 
  bajo posible y en un tiempo tambi&eacute;n corto, es decir, debe ser efectiva 
  en coste y tiempo. La arquitectura de integraci&oacute;n se construye paso a 
  paso y en varios niveles. La idea es dividir el problema de integraci&oacute;n 
  en varios sub-problemas. Comenzaremos construyendo la arquitectura por el nivel 
  inferior e iremos subiendo. Los procesos m&aacute;s importantes en la integraci&oacute;n 
  de aplicaciones son: </p>
<ul>
  
<li>Integraci&oacute;n de la plataforma (hardware).</li>
  
<li>Integraci&oacute;n a nivel de datos.</li>
  
<li>Integraci&oacute;n de la interfaz de la aplicaci&oacute;n.</li>
  
<li>Integraci&oacute;n de m&eacute;todos del negocio.</li>
  
<li>Integraci&oacute;n de la presentaci&oacute;n.</li>
  
<li>Integraci&oacute;n inter-EAI o integraci&oacute;n B2B.</li>

</ul>
<p>Omitir alguna capa acelera el proceso de integraci&oacute;n a corto plazo, 
  pero podemos estar seguros de que "pagaremos por ello" a largo plazo. 
  La capa de integraci&oacute;n de interfaz de la aplicaci&oacute;n y m&eacute;todos 
  del negocio se combinan a veces en una capa denominada integraci&oacute;n a 
  nivel de negocio. </p>
<p>
<strong>Integraci&oacute;n de la plataforma</strong>. Es el prerequisito para permitir 
  la integraci&oacute;n en su totalidad. El objetivo es alcanzar la interoperatividad 
  entre las diferentes plataformas, por ejemplo <em>mainframes</em> con distintos 
  sistemas operativos como VMV, OS/400, PC con <em>Windows</em>, Linux, estaciones 
  Solaris, AIX, etc. Actualmente la mayor&iacute;a de plataformas <em>hardware</em> 
  utilizan est&aacute;ndares abiertos, con lo que alcanzar la interoperatividad 
  de &eacute;stos no plantea demasiadas dificultades. Sin embargo, los problemas 
  se plantean con la integraci&oacute;n de plataformas ya no soportadas por sus 
  vendedores, y tambi&eacute;n cuando se han utilizado soluciones propietarias.</p>
<p>
<strong>Integraci&oacute;n a nivel de datos</strong>. A menudo la integraci&oacute;n 
  a nivel de datos es el punto de partida de la integraci&oacute;n. Esta capa 
  habilita el acceso a los datos compartidos por otras aplicaciones y permite 
  mover dichos datos entre diferentes almacenamientos de datos. La integraci&oacute;n 
  a nivel de datos puede complicarse bastante cuando se ven implicados cientos 
  de estos almacenamientos. Las dificultades t&iacute;picas son la no comprensi&oacute;n 
  de los esquemas, identificaci&oacute;n de los datos, garant&iacute;a de la consistencia, 
  etc. Adem&aacute;s, es necesario unificar el modelo de datos, resolviendo las 
  redundancias de datos y anomal&iacute;as sem&aacute;nticas introducidas durante 
  el desarrollo a lo largo de los a&ntilde;os.</p>
<p>
<strong>Integraci&oacute;n de la interfaz de la aplicaci&oacute;n</strong>. Esta capa 
  habilita una forma de integraci&oacute;n de alto nivel, en la que una aplicaci&oacute;n 
  usa alguna otra funcionalidad residente en otra aplicaci&oacute;n. Esto se consigue 
  usando las interfaces de programaci&oacute;n de aplicaciones (APIs) que cada 
  una de ellas expone a las dem&aacute;s. A menudo se utiliza alguna forma de 
  <em>middleware</em> para transferir las peticiones y resultados, como los orientados 
  a mensajes (MOM), procedimientos remotos (RPC), e incluso los <em>Object Request 
  Brokers</em> (ORB).</p>
<p>
<strong>Integraci&oacute;n de m&eacute;todos del negocio</strong>. Esta integraci&oacute;n 
  permite dar soporte a los procesos del negocio en la empresa mostr&aacute;ndo 
  los m&eacute;todos de alto nivel como abstracciones accesibles mediante interfaces. 
  Esta capa presenta el sistema de informaci&oacute;n de la empresa en su totalidad 
  tal y como quisi&eacute;ramos tenerlo (o tal y como quisi&eacute;ramos haberlo 
  desarrollado si pudi&eacute;semos reconstruirlo de nuevo con unos requerimientos 
  claros sobre lo que pretendemos obtener del sistema integrado, con el conocimiento 
  y soporte de las nuevas tecnolog&iacute;as). Esto significa que las interfaces 
  del sistema de informaci&oacute;n se basan en una arquitectura moderna. Pero 
  las funcionalidades no son reimplementadas; en su lugar usan las aplicaciones 
  existentes. Dichas aplicaciones se remodelan de tal forma que expongan la funcionalidad 
  de la capa de proceso del negocio y se incluyan en la nueva arquitectura. El 
  conseguir la integraci&oacute;n a nivel de negocio se asocia a menudo con el 
  proceso de reingenier&iacute;a del negocio y no es &uacute;nicamente un problema 
  t&eacute;cnico. Requiere la implementaci&oacute;n de varias capas como base 
  para integrar las aplicaciones en un nivel alto de abstracci&oacute;n.</p>
<p>
<strong>Integraci&oacute;n de la presentaci&oacute;n</strong>. Una vez que las aplicaciones 
  existentes se remodelan y encapsulan en la capa intermedia, en la que exponen 
  su funcionalidad a trav&eacute;s de interfaces de alto nivel, resulta crucial 
  que el usuario tambi&eacute;n observe una vista unificada del sistema de informaci&oacute;n. 
  Mediante el desarrollo de una capa de presentaci&oacute;n unificada, estaremos 
  ocultando el hecho de que las aplicaciones que se est&aacute;n ejecutando son 
  aplicaciones diferentes, algunas de ellas <em>legacy</em>, y otras desarrolladas 
  recientemente. De esta manera se mejora la eficiencia de los usuarios finales, 
  ya que no tienen que cambiar entre diferentes aplicaciones existentes y usar 
  diferentes interfaces de usuario. Adem&aacute;s, se proporciona una forma de 
  reemplazar parte de los sistemas <em>legacy</em> en el futuro sin influenciar 
  al resto de partes del sistema.</p>
<p>
<strong>Integraci&oacute;n inter-EAI o integraci&oacute;n B2B</strong>. Actualmente la 
  integraci&oacute;n de las aplicaciones de una compa&ntilde;&iacute;a puede no 
  resultar suficiente. Hay una necesidad creciente de permitir una integraci&oacute;n 
  entre empresas, a menudo referida como integraci&oacute;n B2B (<em>business-to-business</em>), 
  o tambi&eacute;n <em>e-business</em>. Por supuesto, el requerimiento para una 
  integraci&oacute;n eficiente B2B requiere una integraci&oacute;n de cada una 
  de las empresas a nivel de negocio en ambos sentidos.</p>
</div>


<a name="N10288"></a><a name="Uso+de"></a>
<h2 class="underlined_10">Uso de middleware para EAI</h2>
<div class="section">
<p>Se denomina <em>middleware</em> al software de los servicios del sistema que 
  se ejecuta entre la capa del sistema operativo y la capa de aplicaci&oacute;n. 
  Conecta dos o m&aacute;s aplicaciones, proporcionando interoperabilidad entre 
  ellas. El concepto de <em>middleware</em> cobra protagonismo hoy en d&iacute;a, 
  ya que todos los proyectos de integraci&oacute;n tienen que usar una o varias 
  soluciones diferentes <em>middleware</em>.</p>
<p>Usaremos el t&eacute;rmino <em>middleware</em> para denotar a aquellos productos 
  <em>software</em> que act&uacute;an como "pegamento" entre aplicaciones, 
  que sean distintos de simples funciones de importaci&oacute;n y exportaci&oacute;n 
  de datos que pudieran formar parte de las propias aplicaciones.</p>
<p>Todas las formas de <em>middleware</em> son &uacute;tiles para facilitar la comunicaci&oacute;n 
  entre diferentes aplicaciones <em>software.</em> El middleware introduce un nivel 
  de abstracci&oacute;n en la arquitectura del sistema, reduciendo as&iacute; 
  su complejidad considerablemente. Por otro lado, cada producto <em>middleware</em> 
  introduce una cierta sobrecarga en el sistema con respecto a la comunicaci&oacute;n, 
  lo cual puede afectar al rendimiento, la escalabilidad, y otros factores de 
  eficiencia. Esto es importante tenerlo en cuenta, particularmente si nuestros 
  sistemas son cr&iacute;ticos y son usados por un gran n&uacute;mero de clientes 
  concurrentemente.</p>
<p>Los productos <em>middleware</em> comprenden una amplia variedad de tecnolog&iacute;as, 
  incluyendo las siguientes:</p>
<p>
<strong>Tecnolog&iacute;as de acceso a bases de datos</strong>. Proporcionan acceso a 
  una base de datos a trav&eacute;s de una capa de abstracci&oacute;n que permite 
  cambiar el sistema de gesti&oacute;n de base de datos (DBMS) sin tener que modificar 
  el c&oacute;digo fuente de la aplicaci&oacute;n. En otras palabras, permiten 
  usar el mismo o similar c&oacute;digo para acceder a diferentes fuentes de bases 
  de datos. Las tecnolog&iacute;as de acceso a bases de datos difieren en la forma 
  de los interfaces que proporcionan. Pueden ofrecer acceso a las bases de datos 
  orientado a la funci&oacute;n o a objetos. Los representantes m&aacute;s conocidos 
  son JDBC y <em>Java Data Objects</em> (JDO) en la plataforma Java, y <em>Open Database 
  Connectivity</em> (ODBC) y <em>Active Data Objects</em> (ADO) en la plataforma 
  <em>Microsoft</em>.</p>
<p>
<strong><em>Middleware</em> orientado a mensajes</strong>. Tambi&eacute;n denominado MOM: 
  <em>Message Oriented Middleware</em>. Es una estructura cliente/servidor que incrementa 
  la interoperabilidad, flexibilidad y portabilidad de las aplicaciones. Permite 
  la comunicaci&oacute;n entre aplicaciones entre plataformas distribuidas y heterog&eacute;neas, 
  y reduce su complejidad debido a la ocultaci&oacute;n de los detalles de la 
  comunicaci&oacute;n y de las plataformas y protocolos implicados; la funcionalidad 
  del MOM es accedida mediante APIs. Las aplicaciones pueden por lo tanto intercambiar 
  datos sin necesidad de comprender los detalles del resto de aplicaciones, arquitecturas 
  y plataformas implicadas.</p>
<p>Geralmente MOM reside tanto en la parte del cliente como en la del servidor. 
  Proporciona comunicaci&oacute;n as&iacute;ncrona mediante el uso de colas de 
  mensajes para almacenar los mensajes temporalmente. La comunicaci&oacute;n puede 
  darse incluso aunque el receptor est&eacute; temporalmente no disponible, y 
  los mensajes pueden contener casi cualquier tipo de dato. Cada mensaje espera 
  en la cola y es entregado tan pronto como el receptor es capaz de aceptarlo. 
  La comunicaci&oacute;n as&iacute;ncrona tiene el inconveniente de que, ya que 
  el servidor no bloquea a los clientes, puede continuar aceptando peticiones 
  con el riesgo de producir una situaci&oacute;n de sobrecarga.</p>
<p>La Figura 9 muestra dos aplicaciones que usan MOM. Las aplicaciones acceden 
  a MOM a trav&eacute;s de un API, y son responsables de construir y analizar 
  los mensajes, pero MOM oculta todos los detalles de red y transporte.</p>
<p>
	
<img alt="Figura 9. Comunicaci&oacute;n de aplicaciones mediante MOM" content-width="11cm" src="imagenes/charla1/Figura9.gif">
</p>
<p>MOM es adecuado para comunicaci&oacute;n entre aplicaciones dirigida por eventos. 
  Tambi&eacute;n es adecuado para sistemas orientados a objetos. Los productos 
  MOM son propietarios y est&aacute;n disponibles desde mediados de los 80, de 
  forma que son incompatibles entre ellos. El uso de un &uacute;nico producto 
  tiene como consecuencia la dependencia de un vendedor espec&iacute;fico, lo 
  que puede influenciar negativamente la flexibilidad, portabilidad, mantenibilidad 
  e interoperabilidad de las aplicaciones. El mismo producto MOM debe poder ejecutarse 
  sobre cada una de las plataformas que est&aacute;n siendo integradas. Sin embargo, 
  no todos los productos MOM soportan todas las plataformas, sistemas operativos 
  y protocolos. La plataforma Java proporciona formas de conseguir una relativamente 
  alta independencia de un vendedor espec&iacute;fico mediante una interfaz com&uacute;n, 
  usada para acceder a todos los productos <em>middleware</em>: el servicio de mensajes 
  java (JMS).</p>
<p>
<strong>Llamadas a procedimientos remotos (RPC)</strong>. Las RPC: <em>Remote Procedure 
  Call</em> constituyen una infraestructura cliente/servidor orientada a mejorar 
  la interoperabilidad entre las aplicaciones desde plataformas heterog&eacute;neas. 
  Al igual que MOM, oculta los detalles de la comunicaci&oacute;n. La principal 
  diferencia con MOM es la forma de comunicaci&oacute;n, mientras que MOM soporta 
  comunicaci&oacute;n as&iacute;ncrona, RPC promueve la comunicaci&oacute;n s&iacute;ncrona 
  en forma de petici&oacute;n-espera, que bloquea al cliente hasta que el servidor 
  completa la respuesta. RPC previene la sobrecarga de la red (a diferencia de 
  MOM). Hay alguna implementaci&oacute;n as&iacute;ncrona de RPC disponible, pero 
  son la excepci&oacute;n y no la regla. En la Figura 10 se muestra un esquema 
  de dos aplicaciones que utilizan RPC.</p>
<p>&nbsp;</p>
<p>
	
<img alt="Figura 10. Comunicaci&oacute;n de aplicaciones mediante RPC" content-width="9cm" src="imagenes/charla1/Figura10.gif">
</p>
<p>RPC es adecuado para aplicaciones cliente/servidor el las que el cliente puede 
  realizar una petici&oacute;n y esperar a que el servidor emita la respuesta 
  antes de continuar el proceso. Adem&aacute;s, RPC requiere que el receptor de 
  la llamada est&eacute; disponible para aceptar la llamada remota. Si el receptor 
  falla, la llamada remota no tiene lugar, ya que las llamadas no se almacenan 
  temporalmente tal y como ocurre en MOM.</p>
<p>
<strong>Monitores de procesamiento de transacciones (TP)</strong>. Los TP: <em>Transaction 
  Processing monitors</em>, son importantes en aplicaciones con requisitos cr&iacute;ticos. 
  Representan la primera generaci&oacute;n de servidores de aplicaciones. Los 
  TP se basan en el concepto de transacciones, de forma que monitorizan y coordinan 
  las transacciones entre diferentes recursos. Si bien el nombre sugiere que esta 
  es su &uacute;nica tarea, tienen otras funcionalidades adicionales: gestionar 
  el rendimiento, y servicios de seguridad, tal y como muestra la Figura 11.</p>
<p>
	
<img alt="Figura 11. Comunicaci&oacute;n de aplicaciones mediante TP" content-width="10cm" src="imagenes/charla1/Figura11.gif">
</p>
<p>Los TP gestionan el rendimiento de las transacciones mediante t&eacute;cnicas 
  de balanceo de carga y de <em>poolling de recursos</em>, de forma que pueda existir 
  un gran n&uacute;mero de clientes accediendo concurrentemente y de forma eficiente 
  a los recursos de computaci&oacute;n. Por otro lado los servicios de seguridad 
  proporcionados por los TP permiten habilitar o deshabilitar accesos de clientes 
  a fuentes particulares de datos.</p>
<p>
<strong>Intermediarios de peticiones de objetos (ORB)</strong>. Los ORB: <em>Object Request 
  Brokers</em>, gestionan y soportan la comunicaci&oacute;n entre objetos distribuidos 
  o componentes sin necesidad de preocuparse por los detalles de la comunicaci&oacute;n. 
  Los detalles de implementaci&oacute;n de un ORB no est&aacute;n visibles para 
  los componentes. De esta forma se proporciona transparencia en la localizaci&oacute;n, 
  transparencia en el lenguaje de programaci&oacute;n, protocolo y sistema operativo.</p>
<p>La comunicaci&oacute;n se lleva a cabo a trav&eacute;s de interfaces, y normalmente 
  es s&iacute;ncrona. Proporcionan la ilusi&oacute;n de "localidad", 
  haciendo que todos los componentes parezcan locales, aunque en realidad est&eacute;n 
  en otra red. Simplifican el desarrollo de forma considerable pero pueden tener 
  una incidencia negativa en el rendimiento de la aplicaci&oacute;n.</p>
<p>La Figura 12 muestra dos componentes que se comunican mediante un ORB.</p>
<p>
	
<img alt="Figura 12. Comunicaci&oacute;n de aplicaciones mediante ORB" content-width="10cm" src="imagenes/charla1/Figura12.gif">
</p>
<p>Hay tres est&aacute;ndares principales para ORBs: (a) OMG CORBA, (b) Java RMI 
  y RMI-IIOP, y (c) <em>Microsoft</em> COM/DCOM/COM+.</p>
<p>Hay muchos productos que cumplen el est&aacute;ndar ORB. RMI-IIOP. RMI-IIOP utiliza el mismo 
  protocolo para comunicaciones entre componentes que CORBA ORB, de forma que 
  resulta interoperable con CORBA.</p>
<p>Solamente existe una implementaci&oacute;n del modelo <em>Microsoft</em>, el 
  cual difiere de los otros dos en algunos conceptos importantes. A&uacute;n as&iacute;, 
  la interoperabilidad entre RMI-IIOP y CORBA por un lado, y el modelo de <em>Microsoft</em> 
  por otro, es posible.</p>
<p>
<strong>Servidores de aplicaciones</strong>. Son la forma m&aacute;s reciente de <em>middleware</em>. 
  Manejan todas o la mayor&iacute;a de las interacciones entre la capa del cliente 
  y la capa de persistencia de datos. Proporcionan una colecci&oacute;n de servicios 
  <em>middleware</em> como los ORBs, MOM, gesti&oacute;n de transacciones, seguridad, 
  balanceo de carga y gesti&oacute;n de recursos. Adem&aacute;s incluyen una gesti&oacute;n 
  del entorno en el que se despliegan los componentes l&oacute;gicos del negocio: 
  el contenedor.</p>
<p>Los servidores de aplicaciones proporcionan una plataforma excelente para integraci&oacute;n. 
  Independientemente de que se use para integraci&oacute;n o para el desarrollo 
  de aplicaciones nuevas los servidores de aplicaciones son plataformas software. 
  Una <em>plataforma software</em> es una combinaci&oacute;n de tecnolog&iacute;as software 
  necesarias para ejecutar aplicaciones. En este sentido los servidores de aplicaciones, 
  o m&aacute;s espec&iacute;ficamente, la plataforma software que soportan, definen 
  la infraestructura de todas las aplicaciones desarrolladas y ejecutadas sobre 
  ellos. Los servidores de aplicaciones son la plataforma de integraci&oacute;n 
  a elegir para aplicaciones desarrolladas con una arquitectura multi capa. Ademas, los
  servidores de aplicaciones pueden soportar una plataforma 
  software estandarizada, abierta y generalmente aceptada.
</p>
<p>Los aspectos m&aacute;s importantes a tener en cuenta en una plataforma software son:
</p>
<ul>
  
<li>
<em>Aspectos t&eacute;cnicos</em>: incluyen las tecnolog&iacute;as software 
    que se incluyen en la plataforma, as&iacute; como interoperabilidad, escalabilidad, 
    portabilidad, disponibilidad, fiabilidad y seguridad, entre otras cuestiones.</li>
  
<li>
<em>Car&aacute;cter abierto</em>: existen diferentes soluciones, desde plataformas 
    cerradas asociadas a un vendedor particular, hasta plataformas totalmente 
    abiertas, en donde cada cosa, incluido el software es de libre distribuci&oacute;n 
    y puede cambiarse libremente.</li>
  
<li>
<em>Interoperabilidad</em>: es crucial para considerar la adopci&oacute;n 
    de una determinada plataforma, en particular la forma en que dicha plataforma 
    regula las adiciones y modificaciones de software. </li>
  
<li>
<em>Coste</em>: probablemente es el m&aacute;s dif&iacute;cil de evaluar debido 
    a que incluye los costes del servidor de aplicaciones, del hardware, del aprendizaje 
    de su uso, y el coste del mantenimiento de las aplicaciones.</li>
  
<li>
<em>Madurez</em>: es un indicador de cu&aacute;n estable es la plataforma. 
    Cuanto m&aacute;s madura sea, m&aacute;s habr&aacute; sido probada en entornos 
    reales, probando su idoneidad para aplicaciones a gran escala.</li>

</ul>
<p>En la Figura 13 se muestra c&oacute;mo puede usarse un servidor de aplicaciones 
  para integraci&oacute;n con aplicaciones corporativas existentes y EIS. Un servidor 
  de aplicaciones soporta un modelo basado en componentes para el desarrollo de 
  aplicaciones. Con este modelo, una aplicaci&oacute;n puede estar compuesta por 
  diferentes tipos de componentes, tales como componentes Web o componentes de 
  l&oacute;gica de negocio. El servidor de aplicaciones proporciona soporte para 
  el desarrollo de aplicaciones basadas en Web, transaccionales, seguras, distribuidas 
  y escalables. Los servicios para la ejecuci&oacute;n del sistema que proporciona 
  el servidor de aplicaciones se ocultan a los componentes de la aplicaci&oacute;n; 
  dichos servicios incluyen: soporte para transacciones, seguridad, balanceo de 
  carga, acceso a bases de datos, mensajer&iacute;a as&iacute;ncrona, comunicaciones 
  distribuidas, protocolos <em>web</em> y soporte XML.</p>
<p>
	
<img alt="Figura 13. Integraci&oacute;n de aplicaciones basada en un servidor    de aplicaciones" content-width="12cm" src="imagenes/charla1/Figura13.gif">
</p>
<p>Es posible desarrollar y desplegar aplicaciones sobre un servidor de aplicaciones 
  tales que puedan conectar m&uacute;ltiples EIS heterog&eacute;neos y aplicaciones 
  corporativas existentes. En este caso, los componentes Web y de l&oacute;gica 
  del negocio que se despliegan en la capa intermedia (o servidor de aplicaciones) 
  usan adaptadores para acceder a los datos y funciones asociadas con las aplicaciones 
  de estos EIS. Los componentes de aplicaciones desplegados en el servidor de 
  aplicaciones usan adaptadores s&iacute;ncronos para conectar y acceder a los 
  EIS. Tambi&eacute;n pueden usar un adaptador a un intermediario de mensajes 
  para realizar la integraci&oacute;n utilizando mensajer&iacute;a as&iacute;ncrona.</p>
<p>Las plataformas de integraci&oacute;n t&iacute;picamente tienen m&aacute;s 
  de una tecnolog&iacute;a <em>middleware</em>. De hecho es usual encontrar productos 
  <em>middleware</em> de diferentes vendedores en una misma plataforma de integraci&oacute;n. 
  Por ejemplo, en servidores de aplicaciones que cumplen J2EE, diferentes vendedores 
  incluyen diferentes tipos de <em>middleware</em> adicional. El servidor de aplicaciones 
  <em>WebSphere</em> de IBM, por ejemplo, incluye el motor de mensajes IBM MQSeries, 
  y el servidor <em>Bea</em> <em>Weblogic</em> incluye el monitor de transacciones 
  <em>Tuxedo</em>.</p>
</div>


<a name="N10395"></a><a name="Servicios+de+infraestructura+necesarios+para+la+integraci%C3%B3n"></a>
<h2 class="underlined_10">Servicios de infraestructura necesarios para la integraci&oacute;n</h2>
<div class="section">
<p>La infraestructura de integraci&oacute;n consiste en el conjunto de tecnolog&iacute;as 
  <em>middleware</em> que proporcionan los servicios necesarios para establecer 
  la comunicaci&oacute;n entre las aplicaciones. Para realizar una mejor selecci&oacute;n 
  de las tecnolog&iacute;as que se van a usar para la integraci&oacute;n, en primer 
  lugar nos centraremos en los servicios de infraestructura requeridos. Vamos 
  a identificar dichos servicios desde una perspectiva de alto nivel y los separemos 
  en capas horizontales y verticales. Los servicios de las capas horizontales 
  proporcionan servicios b&aacute;sicos de infraestructura &uacute;tiles para 
  la mayor&iacute;a de las aplicaciones existentes as&iacute; como aplicaciones 
  de nueva generaci&oacute;n. Los servicios de la capa vertical proporcionan funcionalidades 
  relacionadas con una tarea espec&iacute;fica que puede extenderse a trav&eacute;s 
  de varios servicios de la capa horizontal. </p>
<p>Los servicios de las capas horizontales incluyen: (a) Comunicaci&oacute;n; 
  (b) <em>Brokering</em> y <em>routing</em>; (c) L&oacute;gica del negocio. Los servicios 
  de las capas verticales son: Transacciones, Seguridad, Ciclo de vida, Nombrado, 
  Escalabilidad, Gesti&oacute;n, Reglas. Los servicios mencionados se pueden apreciar 
  en la Figura 14.</p>
<p>
	
<img alt="Figura 14. Relaciones entre los servicios de infraestructura    de integraci&oacute;n" content-width="10cm" src="imagenes/charla1/Figura14.gif">
</p>
<p>
<strong>Comunicaci&oacute;n</strong>. Proporciona transparencia para el acceso a diferentes 
  sistemas remotos y unifica la vista de los mismos. Asegura, por lo tanto, que 
  los desarrolladores no tiene que tratar con los detalles de comunicaci&oacute;n 
  a bajo nivel. Debido a que la capa de comunicaci&oacute;n no ejecuta l&oacute;gica 
  del negocio, permite una separaci&oacute;n entre los servicios de la capa del 
  negocio y la capa de comunicaci&oacute;n, aunque permite comunicaci&oacute;n 
  entre ellas.</p>
<p>Las tecnolog&iacute;as m&aacute;s utilizadas son las de acceso a base de datos, 
  como JDBC, tecnolog&iacute;as MOM, y tecnolog&iacute;as RPC. La capa de comunicaci&oacute;n 
  proporciona tambi&eacute;n transparencia en la localizaci&oacute;n.</p>
<p>
<strong><em>Brokering</em></strong> y <strong><em>Routing</em></strong>. Constituyen la implementaci&oacute;n 
  de la parte t&eacute;cnica de la integraci&oacute;n. No importa que tipo de 
  integraci&oacute;n se use, esta capa deber&aacute; adaptar las comunicaciones 
  entre las aplicaciones participantes en la integraci&oacute;n de forma que todas 
  ellas sean capaces de interoperar.</p>
<p>En primer lugar, esta capa tiene que proporcionar la forma de reunir los datos 
  requeridos desde m&uacute;ltiple fuentes, provenientes de aplicaciones existentes 
  y nuevas, y/o almacenamientos de datos. A esta responsabilidad se le denomina 
  agregaci&oacute;n, ya que los datos se obtienen de diferentes fuentes para representar 
  un concepto del negocio, como por ejemplo una factura. </p>
<p>En segundo lugar, estos datos deben procesarse, de forma que esta capa tendr&aacute; 
  que transformar y dividir los datos y mensajes en partes adecuadas para que 
  puedan procesarse por las aplicaciones individuales.</p>
<p>Finalmente, esta capa debe reunir los resultados de todas las aplicaciones 
  y presentarlos de forma consistente.</p>
<p>Para conseguir estos tres pasos, esta capa necesita informaci&oacute;n de meta-datos 
  que defina las aplicaciones participantes, m&eacute;todos, mensajes, e interfaces, 
  y la secuencia de operaciones implicadas. Esta capa tambi&eacute;n proporciona 
  formas de manejar eventos, que ser&aacute;n asociados con ciertas operaciones 
  a realizar.</p>
<p>No hay una &uacute;nica tecnolog&iacute;a <em>middleware</em> estandarizada que 
  proporciona todos los requerimientos necesarios para esta capa. De forma que 
  se usar&aacute;n varias tecnolog&iacute;as diferentes, incluyendo MOM, RPC, 
  ORBs, y servidores de aplicaciones.</p>
<p>
<strong>L&oacute;gica del negocio</strong>. Esta capa es la responsable de presentar 
  un interfaz de alto nivel que permita acceder a la informaci&oacute;n del 
  negocio para otras aplicaciones y para los usuarios, presentando los datos a 
  los usuarios en una forma comprensible.</p>
<p>Actualmente, esta capa es soportada por la capa de presentaci&oacute;n, normalmente 
  en forma de portales personalizados. </p>
<p>Adicionalmente a la entrega de datos y contenidos, esta capa est&aacute; conectada 
  a menudo con tecnolog&iacute;as de procesamiento de datos como OLAP (<em>Online 
  Analytical Processing</em>), <em>data mining</em> y sistemas de soporte de decisiones, 
  entre otros. Estas fuentes analizan los datos de la empresa y proporcionan informaciones 
  tales como estimaciones y pron&oacute;sticos.</p>
<p>
<strong>Transacciones</strong>. La infraestructura de integraci&oacute;n debe proporcionar 
  los medios para llevar a cabo las operaciones de la empresa de forma transaccional. 
  Por lo tanto debe ser capaz de invocar varias operaciones sobre diferentes sistemas 
  existentes y de nueva generaci&oacute;n como una operaci&oacute;n at&oacute;mica 
  que cumpla con las propiedades denominadas ACID (<em>Atomicity, Consistency, 
  Isolation and Durability</em>).</p>
<p>
<strong>Seguridad</strong>. Se debe proporcionar la forma de restringir el acceso al 
  sistema. La seguridad deber&iacute;a incluir a las tres capas horizontales. 
  El sistema de seguridad no deber&iacute;a basarse en diferentes <em>passwords</em> 
  para diferentes aplicaciones o incluso entre partes de la misma aplicaci&oacute;n. 
</p>
<p>
<strong>Ciclo de vida</strong>. Se trata de proporcionar formas de controlar el ciclo 
  de vida de las aplicaciones implicadas. Se deber&iacute;a permitir que las aplicaciones 
  existentes fuesen reemplazadas de una en una, sin influenciar al resto de aplicaciones 
  del sistema integrado. Hay que hacer hincapi&eacute; en que este reemplazamiento 
  deber&iacute;a ser posible paso a paso, cuando lo dicten las necesidades de 
  la empresa y cuando est&eacute;n disponibles los recursos suficientes. Tambi&eacute;n 
  se debe permitir que el reemplazo tenga lugar mientras el sistema permanece 
  <em>on-line</em>. Esta &uacute;ltima funcionalidad se consigue a menudo minimizado 
  las dependencias entre las aplicaciones y formas espec&iacute;ficas en las que 
  interoperan las aplicaciones.</p>
<p>
<strong>Nombrado</strong>. Un servicio unificado de nombres permitir&aacute; a la implementaci&oacute;n 
  transparencia en la localizaci&oacute;n y el reemplazo de un recurso por otro 
  si &eacute;ste es requerido. Normalmente se implementa con un producto de nombrado 
  y directorios que permite el almacenamiento y la b&uacute;squeda de informaci&oacute;n 
  relacionada mediante nombres. Idealmente, el servicio de nombres se debe unificar. 
</p>
<p>
<strong>Escalabilidad</strong>. Es una caracter&iacute;stica que debe tenerse en mente 
  a la hora de dise&ntilde;ar la infraestructura de integraci&oacute;n. Se debe 
  permitir el acceso a informaci&oacute;n sobre los clientes y proporcionar acceso 
  concurrente a las aplicaciones. Se deben incorporar soluciones que permitan 
  extender las demandas de carga del sistema. Puede ser un problema dif&iacute;cil 
  el proporcionar escalabilidad en un sistema integrado debido a que se deben 
  tener en cuenta aplicaciones existentes que probablemente no hayan sido dise&ntilde;adas 
  para el grado de escalabilidad que deseamos conseguir. Por ello, se deben implementar 
  algunos prototipos para probar qu&eacute; niveles de rendimiento se pueden esperar. 
  Tambi&eacute;n deber&iacute;an usarse herramientas de pruebas de carga que permitan 
  simular cargas elevadas y evaluar criterios de rendimiento.</p>
<p>
<strong>Gesti&oacute;n</strong>. Se deben proporcionar los mecanismos para gestionar 
  la infraestructura de integraci&oacute;n. El no hacerlo puede ocasionar dificultades 
  en la fase de mantenimiento. Se debe proporcionar una gesti&oacute;n de versiones 
  y configuraci&oacute;n sencilla. Una gesti&oacute;n declarativa permite el acceso 
  a cambios y actualizaci&oacute;n de par&aacute;metros sin necesidad de modificar 
  los fuentes y volver a desplegar las soluciones. Una gesti&oacute;n remota permite 
  llevar a cabo la gesti&oacute;n de la infraestructura de forma remota, minimizando 
  la necesidad de entrenamiento del personal en los lugares de trabajo.</p>
<p>
<strong>Reglas</strong>. Los servicios horizontales requieren reglas espec&iacute;ficas 
  para realizar la comunicaci&oacute;n, <em>brokering</em>, <em>routing</em>, y tareas 
  de l&oacute;gica del negocio. Estas reglas con deber&iacute;an estar codificadas 
  en el "interior" de las aplicaciones, sino que deber&iacute;an especificarse 
  de una forma declarativa formando parte de la infraestructura de integraci&oacute;n. 
  Esto incluye definiciones, formatos de datos, transformaciones de datos y flujos, 
  eventos, procesamiento de informaci&oacute;n y representaci&oacute;n de la informaci&oacute;n. 
  A menudo estas reglas se almacenan en un repositorio, lo cual proporciona un 
  almacenamiento centralizado evitando as&iacute; duplicaciones e inconsistencias.</p>
<p>Como hemos visto, los servicios de infraestructura pueden ser realizados por 
  diferentes tecnolog&iacute;as <em>middeware</em>. Al seleccionar y reunir tecnolog&iacute;as 
  diferentes hay que tener en cuenta su interoperabilidad. Alcanzar dicha interoperabilidad 
  entre tecnolog&iacute;as puede ser dif&iacute;cil, incluso para aquellas basadas 
  en est&aacute;ndares abiertos; para soluciones propietarias es todav&iacute;a 
  m&aacute;s dif&iacute;cil.</p>
<p>No solamente es una cuesti&oacute;n de si podemos alcanzar interoperabilidad, 
  sino cu&aacute;nto esfuerzo tenemos que invertir para conseguirlo. Por ello, 
  las empresas se inclinan cada vez m&aacute;s hacia plataformas software que 
  re&uacute;nen tecnolog&iacute;as compatibles. El uso de una plataforma software 
  normalmente ahorra mucho trabajo adicional. Actualmente hay tres plataformas 
  importantes:</p>
<ul>
  
<li>La plataforma Java 2, <em>Enterprise Edition</em> (J2EE)</li>
  
<li>CORBA</li>
  
<li>Microsoft.NET</li>

</ul>
<p>J2EE y CORBA tienen asociadas unas especificaciones y diferentes vendedores 
  ofrecen productos que cumplen dichas especificaciones. En este sentido son plataformas 
  abiertas, J2EE est&aacute; controlado por <em>Sun</em> y JCP (<em>Java Community 
  Process</em>), y CORBA por OMG. Por otro lado Microsoft.NET es una plataforma 
  propietaria y dirigida espec&iacute;ficamente a plataformas Windows. Las tres 
  plataformas proporcionan un conjunto de tecnolog&iacute;as, m&aacute;s o menos 
  apropiadas para integraci&oacute;n. </p>
<p>Todos los productos EAI incluyen un componente denominado <strong><em>integration 
  broker</em></strong> o intermediario de integraci&oacute;n. Un intermediario 
  de integraci&oacute;n es una abstracci&oacute;n utilizada para las tecnolog&iacute;as 
  que componen la infraestructura de integraci&oacute;n. El intermediario proporciona 
  los servicios horizontales y verticales que hemos identificado, y centraliza 
  la gesti&oacute;n de dichos servicios. </p>
<p>El intermediario de integraci&oacute;n se usa en todos los niveles de integraci&oacute;n, 
  facilitando el camino para construir las capas de integraci&oacute;n paso a 
  paso y reusar resultados previos, evitando cualquier dependencia de la comunicaci&oacute;n 
  punto a punto entre las aplicaciones.</p>
<p>La integraci&oacute;n punto a punto tiene los siguientes inconvenientes:</p>
<ul>
  
<li>El n&uacute;mero de conexiones entre aplicaciones puede llegar a ser muy 
    grande</li>
  
<li>Un elevado n&uacute;mero de dependencias entre aplicaciones requiere demasiado 
    esfuerzo de mantenimiento</li>
  
<li>El mantenimiento de los enlaces entre las aplicaciones puede llegar a ser 
    m&aacute;s costoso que el mantenimiento de las propias aplicaciones, haciendo 
    menos obvios los beneficios de la integraci&oacute;n</li>

</ul>
<p>El intermediario de integraci&oacute;n proporciona un mediador com&uacute;n, 
  al que todas las aplicaciones deben conectarse, reduciendo as&iacute; la multiplicidad 
  <em>n-a-n</em> de la integraci&oacute;n punto a punto, a <em>1-a-n</em>. Adem&aacute;s, 
  no solamente conecta las aplicaciones, sino que basa la integraci&oacute;n en 
  contratos entre aplicaciones. Estos contratos se expresan generalmente en forma 
  de <strong>interfaces de interoperabilidad</strong>. </p>
<p>Las interfaces de interoperabilidad definen qu&eacute; servicios pueden pedir 
  las aplicaciones clientes a las aplicaciones servidor. Dichas interfaces son 
  efectivamente contratos de larga duraci&oacute;n que definen el acoplamiento 
  entre aplicaciones integradas. En la medida en la que las interfaces permanecen 
  inalterables, podemos reemplazar partes o la totalidad de aplicaciones servidor 
  sin influenciar en nada en ninguna aplicaci&oacute;n cliente. La Figura 14 muestra 
  un intermediario de integraci&oacute;n y las interfaces de interoperabilidad.</p>
<p>
	
<img alt="Figura 15. Intermediario de   integraci&oacute;n e interfaces de interoperabilidad" content-width="10cm" src="imagenes/charla1/Figura15.gif">
</p>
</div>


<a name="N1046B"></a><a name="T%C3%A9cnicas+de+integraci%C3%B3n"></a>
<h2 class="underlined_10">T&eacute;cnicas de integraci&oacute;n</h2>
<div class="section">
<p>En primer lugar debemos seleccionar las aplicaciones que incluiremos en la 
  integraci&oacute;n, que deber&aacute; incluir dos tipos de aplicaciones: las 
  aplicaciones primarias y las subsidiarias. Las aplicaciones primarias de una 
  empresa son aquellas importantes para la compa&ntilde;ia en su totalidad, son 
  usadas por un gran n&uacute;mero de empleados, y est&aacute;n bajo el control 
  del departamento que desarrolla las aplicaciones inform&aacute;ticas. Las aplicaciones 
  subsidiarias son usadas normalmente por un &uacute;nico empleado, y probablemente 
  sin el conocimiento del departamento de desarrollo de inform&aacute;tica; se 
  trata de aplicaciones usadas diariamente pero no soportadas por las aplicaciones 
  primarias; ejemplo de dichas aplicaciones incluyen la impresi&oacute;n de circulares, 
  la generaci&oacute;n de informes espec&iacute;ficos, etc. El no incluir las 
  aplicaciones subsidiarias en la integraci&oacute;n puede dar lugar a varios 
  problemas (ya que sus usuarios continuar&aacute;n utiliz&aacute;ndolas), incluyendo 
  las tranferencias manuales de datos entre las aplicaciones primarias y subsidiarias 
  y el almacenamiento en computadores locales de datos importantes en varios formatos, 
  como procesadores de texto u hojas de c&aacute;lculo.</p>
<p>Una vez que hemos seleccionado las aplicaciones a integrar, debemos elegir 
  la aproximaci&oacute;n de integraci&oacute;n. Podemos distinguir dos aproximaciones 
  diferentes, cada una de las cuales tiene ventajas e inconvenientes:</p>
<ul>
  
<li>Aproximaci&oacute;n descendente (<em>top-down</em>)</li>
  
<li>Aproximaci&oacute;n ascendente (<em>botton-up</em>)</li>

</ul>
<p>
<strong>La aproximaci&oacute;n <em>botton-up</em></strong> se centra en problemas individuales 
  que surgen debido a la ausencia de integraci&oacute;n de las aplicaciones. Resuelve 
  los problemas espec&iacute;ficos a trav&eacute;s de proyectos de integraci&oacute;n 
  no coordinados, evitando las cuestiones de la arquitectura de integraci&oacute;n 
  global.</p>
<p>Esta aproximaci&oacute;n que sigue el patr&oacute;n de implementar soluciones 
  parciales conduce a soluciones r&aacute;pidas, pero que pueden ocultar problemas, 
  que con seguridad saldr&aacute;n a la luz posteriormente. Implementar una integraci&oacute;n 
  sin planificaci&oacute;n es una opci&oacute;n que solamente los m&aacute;s optimistas 
  deber&iacute;an contemplar, o bien aquellos que no tengan otra opci&oacute;n 
  debido a que los &oacute;rganos de gesti&oacute;n de la empresa ya han tomado 
  sus decisiones. Muchas veces, los &oacute;rganos de gesti&oacute;n de la empresa 
  ven al departamento de desarrollo de inform&aacute;tica como un &oacute;rgano 
  cuyo prop&oacute;sito es proporcionar una soluci&oacute;n en el m&iacute;nimo 
  tiempo posible y con unos costes m&iacute;nimos a corto plazo. Tambi&eacute;n 
  muchas veces, dichos &oacute;rganos de gesti&oacute;n de la empresa no quieren 
  ni o&iacute;r que una soluci&oacute;n total de integraci&oacute;n (con un 
  largo tiempo de desarrollo) podr&iacute;a proporcionar resultados mucho mejores 
  a largo plazo. Lo que complica todav&iacute;a m&aacute;s las cosas es que la 
  compa&ntilde;&iacute;a probablemente no se de cuenta a tiempo de esta realidad 
  y contin&uacute;e soportando el resto de proyectos de la misma forma, ocasionando 
  el alcanzar un punto sin retorno a medida que se van parcheando soluciones en 
  capas superiores. El sistema entonces alcanzar&aacute; un nivel de complejidad 
  no manejable.</p>
<p>En definitiva, la aproximaci&oacute;n <em>bottom-up</em> para integraci&oacute;n 
  probablemente conducir&aacute; a la compa&ntilde;&iacute;a un paso adelante 
  al principio, pero pronto tendr&aacute; necesidad de volver hacia atr&aacute;s 
  varios pasos. Por lo tanto esta aproximaci&oacute;n es altamente desaconsejable, 
  siendo mucho mejor la aproximaci&oacute;n <em>top-down</em>.</p>
<p>
<strong>La aproximaci&oacute;n <em>top-down</em></strong> es esencialmente una estrategia de integraci&oacute;n 
  definida. El comenzar la integraci&oacute;n simplemente conectando las aplicaciones 
  sin un buen plan y arquitectura, podr&iacute;a conducir casi con toda seguridad 
  a un gran n&uacute;mero de conexiones punto a punto que resultar&iacute;an dif&iacute;ciles 
  de gestionar y mantener. En su lugar, se define en primer lugar una arquitectura 
  del sistema integrado, y solamente entonces se empezar&aacute; a revisar las 
  aplicaciones existentes y decidir como pueden encajarse en la arquitectura de 
  integraci&oacute;n. Esta aproximaci&oacute;n presenta varias ventajas y nos 
  permitir&aacute; construir la arquitectura en la que se ubicar&aacute;n de igual 
  forma tanto las aplicaciones existentes como sistemas de nueva generaci&oacute;n. 
  Adem&aacute;s nos permitir&aacute; reemplazar y realizar reingenier&iacute;a 
  sobre sistemas existentes con nuevos desarrollos. Esta forma de pensar es lo 
  que se conoce como aproximaci&oacute;n <em>top-down</em>.</p>
<p>La aproximaci&oacute;n <em>top-down</em> centra su atenci&oacute;n en la integraci&oacute;n 
  como actividad global. Identifica una estrategia de integraci&oacute;n conjunta 
  que define todos los aspectos previsibles de los problemas del negocio relacionados 
  con la integraci&oacute;n, analiza las dependencias existentes, fija gu&iacute;as 
  de actuaci&oacute;n, y define prioridades. Gestiona la integraci&oacute;n como 
  un gran proyecto coordinado y comparte esfuerzos con todas las partes implicadas.</p>
<p>Deber&iacute;a quedar claro que la integraci&oacute;n no es solamente un problema 
  t&eacute;cnico. En lugar de eso, requiere tambi&eacute;n un buen nivel de organizaci&oacute;n 
  y gesti&oacute;n para que la integraci&oacute;n tenga &eacute;xito. Adem&aacute;s 
  resulta crucial que la compa&ntilde;ia inicie el proyecto de integraci&oacute;n 
  con los suficientes recursos, prioridades y autorizaci&oacute;n para ser capaz 
  de conseguir una buena coordinaci&oacute;n de las partes implicadas. </p>
<p>Para conseguir una buena coordinaci&oacute;n existen varias posibilidades, 
  una de las cuales consiste en introducir y organizar un nuevo servicio denominado 
  servicio de integraci&oacute;n, responsable de la integraci&oacute;n. Dicho 
  servicio deber&iacute;a tener tres responsabilidades principales:</p>
<ul>
  
<li>Definici&oacute;n de la arquitectura de integraci&oacute;n</li>
  
<li>Selecci&oacute;n de la infraestructura y tecnolog&iacute;as de la integraci&oacute;n</li>
  
<li>Desarrollo y mantenimiento de la documentaci&oacute;n de la integraci&oacute;n</li>

</ul>
</div>


<a name="N104BC"></a><a name="Opciones+alternativas+a+la+integraci%C3%B3n"></a>
<h2 class="underlined_10">Opciones alternativas a la integraci&oacute;n</h2>
<div class="section">
<p>La EAI no representa una soluci&oacute;n f&aacute;cil o r&aacute;pida hacia 
  un sistema de informaci&oacute;n integrado. Antes de decidirnos por la integraci&oacute;n 
  se deber&iacute;an examinar otras posibilidades. Generalmente, estas incluyen:</p>
<ul>
  
<li>Reemplazamiento</li>
  
<li>Extensi&oacute;n</li>

</ul>
<p>
<strong>Reemplazamiento de los sistemas</strong>. Con &aacute;nimo de ahorrar tiempo 
  y dinero, los gestores a menudo considerar&aacute;n el reemplazamiento total 
  o parcial de los sistemas existentes. El reemplazamiento requiere un claro "corte" 
  y parada del uso de las aplicaciones existentes y un cambio al nuevo sistema.</p>
<p>Para reemplazar las aplicaciones se puede optar por comprarlas o desarrollarlas, 
  bien por nosotros o por terceros. Los factores determinantes para elegir entre 
  comprar o desarrollar son esencialmente el tipo de aplicaci&oacute;n a reemplazar 
  y el grado en el que una aplicaci&oacute;n comercial podr&iacute;a satisfacer 
  nuestras necesidades. Si bien en teor&iacute;a, la compra es la soluci&oacute;n 
  preferida sobre el desarrollo al ser mucho m&aacute;s r&aacute;pida, tiene inconvenientes 
  importantes. Primero es poco probable que una aplicaci&oacute;n comercial cubra 
  las necesidades del negocio de forma tan eficiente o global como una soluci&oacute;n 
  desarrollada a medida. Y adem&aacute;s no podremos influenciar en el desarrollo 
  de la aplicaci&oacute;n o su modificaci&oacute;n de la misma forma que si se 
  trata de una soluci&oacute;n a medida.</p>
<p>Por otro lado, la flexibilidad de las aplicaciones a medida se consigue en 
  un tiempo mayor que el del desarrollo. Y adem&aacute;s las compa&ntilde;&iacute;as 
  actualmente rara vez cuentan con los recursos para realizar por s&iacute; mismas 
  largos desarrollos, y encargar el desarrollo a una empresa externa no necesariamente 
  acelera dicho desarrollo. </p>
<p>Otra cuesti&oacute;n importante (quiz&aacute; m&aacute;s importante que la 
  decisi&oacute;n desarrollar-comprar) es la de qu&eacute; aplicaciones se van 
  a reemplazar, si solamente parte de ellas (por ejemplo las aplicaciones <em>legacy</em>), 
  o todas.</p>
<p>Si reemplazamos parte de ellas, realmente no hemos solucionado el problema 
  original: la integraci&oacute;n. Por lo tanto, en t&eacute;rminos de integraci&oacute;n, 
  la &uacute;nica decis&oacute;n razonable es reemplazar el sistema de informaci&oacute;n 
  en su totalidad con una nueva soluci&oacute;n integrada.</p>
<p>Sin embargo, el total reemplazamiento del sistema no es aplicable en muchos 
  casos debido a:</p>
<ul>
  
<li>la necesidad de tiempo, recursos y conocimiento para crear el sistema desde 
    cero simplemente no es posible,</li>
  
<li>no existen herramientas comerciales (por ejemplo ERPs) que se adapten al 
    100% a nuestras necesidades (un estudio sugiere que suelen cubrir alrededor 
    de un 30% &oacute; 40% de las necesidades de la empresa, por lo que se est&aacute;n 
    introduciendo interfaces interoperables en este tipo de productos),</li>
  
<li>se necesitan tiempos y recursos adicionales para desplegar, transferir los 
    datos y entrenar a los usuarios que van a usar el nuevo sistema.</li>

</ul>
<p>
<strong>Extensi&oacute;n de los sistemas</strong>. Debido a las ajustadas agendas que 
  imponen los &oacute;rganos de gesti&oacute;n de la empresa, muchas veces los 
  desarrolladores optan por extender la funcionalidad de las aplicaciones existentes 
  en vez de integrarlas en su totalidad. Dichas extensiones no est&aacute;n centradas 
  en la arquitectura global de la aplicaci&oacute;n, sino que intentan modificar 
  aplicaciones existentes para que puedan acomodarse a los cambios. Las modificaciones 
  se llevan a cabo sin determinar en qu&eacute; modo se adec&uacute;an y contribuyen 
  a los requerimientos globales de la empresa y la arquitectura de informaci&oacute;n, 
  tratando cada aplicaci&oacute;n como un dominio separado.</p>
<p>La extensi&oacute;n de aplicaciones se usa frecuentemente, debido a que proporcionan 
  soluciones r&aacute;pidamente y con poco esfuerzo. Los escenarios m&aacute;s 
  obvios son el a&ntilde;adir un interfaz gr&aacute;fico de usuario a una aplicaci&oacute;n 
  <em>legacy</em>. M&aacute;s recientemente, un problema comparable es el relacionado 
  con la adici&oacute;n de un <em>front-end</em> basado en Web, y la implementaci&oacute;n 
  de colaboraciones B2B o B2C sobre las aplicaciones existentes. La Figura 15 
  muestra dos aplicaciones existentes que tienen implementado un intercambio de 
  datos. Una de las aplicaciones se extiende con un <em>front-end</em> basado en 
  Web que permite acceder a alguna de las funcionalidades mediante web. Adicionalmente, 
  se dispone de un "puente" (<em>bridge</em>) de bases de datos que permite 
  el acceso a los datos desde otras aplicaciones.</p>
<p>
	
<img alt="Figura 15. Extensi&oacute;n de aplicaciones" content-width="9cm" src="imagenes/charla1/Figura23.gif">
</p>
<p>Si bien esta arquitectura parece razonable, presenta varios inconvenientes 
  en t&eacute;rminos de integraci&oacute;n. La extensi&oacute;n anterior efectivamente 
  modifica la arquitectura de la aplicaci&oacute;n existente sin pensar en una 
  arquitectura global, pero presenta los mismos inconvenientes que la aproximaci&oacute;n 
  de integraci&oacute;n <em>botton-up</em>: fomenta las conexiones punto a punto 
  que son dif&iacute;ciles de mantener a largo plazo debido a que en este escenario 
  las aplicaciones est&aacute;n estrechamente acopladas (<em>tightly coupled</em>). 
  &Uacute;nicamente es cuesti&oacute;n de tiempo que la complejidad se vuelva 
  demasiado grande para gestionar todos los cambios requeridos.</p>
</div>


<a name="N10517"></a><a name="Arquitectura+de+integraci%C3%B3n"></a>
<h2 class="underlined_10">Arquitectura de integraci&oacute;n</h2>
<div class="section">
<p>La arquitectura de integraci&oacute;n especifica la estructura en su totalidad, 
  los componentes l&oacute;gicos y las relaciones l&oacute;gicas entre las diferentes 
  aplicaciones que queremos integrar.</p>
<p>Los dos objetivos esenciales de los sistemas de informaci&oacute;n integrados 
  que deben ser soportados por la infraestructura de integraci&oacute;n y por 
  la arquitectura para un desarrollo m&aacute;s sencillo son:</p>
<ul>
  
<li>Entradas de datos &uacute;nicas. Claramente, entradas de datos &uacute;nicas 
    aseguran que los datos son introducidos en el sistema &uacute;nicamente una 
    vez, garantizan la consistencia y minimizan los errores provocados por el 
    volver a teclear los datos y la gesti&oacute;n de almacenamientos locales 
    de los datos de la empresa.</li>
  
<li>Acceso a informaci&oacute;n con baja latencia. Tambi&eacute;n denominado 
    acceso a datos con latencia cero. Con ello nos aseguramos que los cambios 
    realizados en una parte del sistema de informaci&oacute;n son visibles en 
    todas las partes relacionadas de forma inmediata (o en el menor tiempo posible). 
  </li>

</ul>
<p>Ambos objetivos son dif&iacute;ciles de alcanzar. La dificultad con respecto 
  a las entradas de datos &uacute;nicas la plantean la existencia de aplicaciones 
  subsidiarias que los usuarios utilizan diariamente para proporcionar soluciones 
  a problemas diarios de los mismos. Con respecto a la baja latencia de acceso 
  a la informaci&oacute;n, es dif&iacute;cil de lograr debido a que la funcionalidad 
  requerida para realizar las tareas de la empresa est&aacute;n dispersas entre 
  aplicaciones diferentes, tanto conceptual como f&iacute;sicamente.</p>
<p>Resolver el problema de la dispersi&oacute;n entre aplicaciones puede lograrse 
  de diferentes formas. Hist&oacute;ricamente, este problema se ha tratado solamente 
  a nivel de datos, en donde soluciones t&iacute;picas incluyen la construcci&oacute;n 
  de bases de datos consolidadas y <em>warehouses</em>. Estas t&eacute;cnicas implican 
  recolectar peque&ntilde;as cantidades de datos de vez en cuando y almacen&aacute;ndolos 
  en la base de datos central en un formato adecuado para realizar an&aacute;lisis 
  y otras tareas. Esta aproximaci&oacute;n no soluciona el problema de la latencia 
  cero, debido a que en el mundo real las transferencias de datos solamente se 
  pueden realizar pocas veces a lo largo del d&iacute;a.</p>
<p>El acceso a los datos en tiempo real es mucho m&aacute;s dif&iacute;cil de 
  implementar, y m&aacute;s teniendo en cuenta que debemos tratar con muchas fuentes 
  de datos distribuidas. El acceso en tiempo real presenta limitaciones en cuanto 
  a rendimiento y escalabilidad.</p>
<p>La forma m&aacute;s eficiente de acceder a los datos es a trav&eacute;s de 
  la l&oacute;gica de la aplicaci&oacute;n. A continuaci&oacute;n analizaremos 
  una arquitectura multi-capa que permite alcanzar los objetivos mencionados. 
  Para ello nos centraremos en el concepto de <strong>componentes virtuales</strong>.</p>
<p>Un sistema de informaci&oacute;n basado en componentes virtuales es un sistema 
  que "parece" un sistema de informaci&oacute;n desarrollado nuevamente, 
  mientras que realmente est&aacute; reusando la funcionalidad de las aplicaciones 
  existentes.</p>
<p>Podemos pensar que un sistema de informaci&oacute;n basado en componentes es 
  un reemplazamiento de todas las aplicaciones existentes, pero que no tiene los 
  inconvenientes asociados con los reemplazamientos. Por otro lado, ya que se 
  reusan las aplicaciones existentes no se a&ntilde;aden costes y no se requiere 
  tanto tiempo adicional como en el reemplazamiento cl&aacute;sico de las aplicaciones.</p>
<p>El sistema de informaci&oacute;n basado en componentes es el objetivo &uacute;ltimo 
  de la EAI: permite el acceso a toda la informaci&oacute;n y el uso de cualquier 
  funcionalidad a trav&eacute;s de componentes virtuales, con ello se consigue, 
  adem&aacute;s obtener informaci&oacute;n con baja latencia y garantizar que 
  solamente necesitamos introducir la misma informaci&oacute;n en el sistema una 
  vez.</p>
<p>Los <strong>componentes virtuales</strong> son bloques de construcci&oacute;n sobre los 
  que basaremos la integraci&oacute;n. Encapsulan los detalles y m&eacute;todos 
  que las aplicaciones existentes usan para satisfacer las peticiones realizadas 
  sobre ellas. Por un lado, muestran la aplicaci&oacute;n existente a trav&eacute;s 
  de unos interfaces, y por otro lado, se comunican con la aplicaci&oacute;n existente 
  utilizando las facilidades que ya tiene implementadas.</p>
<p>La interoperabilidad entre componentes virtuales se consigue mediante el uso 
  de un intermediario de integraci&oacute;n. Los componentes virtuales deber&aacute;n 
  definir los contratos, o los <strong>interfaces de interoperabilidad</strong>, a trav&eacute;s 
  de los cuales se proporcionar&aacute; la funcionalidad al resto de componentes.</p>
<p>Los interfaces de los componentes introducir&aacute;n una aproximaci&oacute;n 
  basada en servicios para reusar la funcionalidad, y expondr&aacute;n todos ellos 
  un conjunto de servicios normalizados que diferir&aacute;n en complejidad y 
  abstracci&oacute;n. En cada nivel de integraci&oacute;n se construir&aacute;n 
  componentes virtuales m&aacute;s abstractos y complejos:</p>
<ul>
  
<li>A nivel de integraci&oacute;n de datos los componentes virtuales proporcionar&aacute;n 
    &uacute;nicamente acceso a los datos</li>
  
<li>A nivel de interfaz de aplicaciones permitir&aacute;n reusar adem&aacute;s 
    la funcionalidad de las aplicaciones existentes</li>
  
<li>A nivel de l&oacute;gica del negocio se proporcionar&aacute; acceso a funcionalidades 
    de alto nivel</li>
  
<li>A nivel de presentaci&oacute;n se a&ntilde;adir&aacute; una capa por encima 
    haciendo que el sistema de informaci&oacute;n integrado tenga una apariencia 
    de un sistema desarrollado nuevamente</li>

</ul>
<p>Los componentes virtuales implementar&aacute;n las funciones reusando las aplicaciones 
  existentes. Si una funci&oacute;n no puede implementarse &uacute;nicamente con 
  los sistemas existentes se puede a&ntilde;adir c&oacute;digo nuevo. De hecho, 
  desde el punto de vista de los clientes, los componentes virtuales no difieren 
  de los componentes nuevos. El concepto de componentes virtuales, por tanto nos 
  permitir&aacute;n mezclar aplicaciones existentes con aplicaciones nuevas de 
  muchas formas distintas.</p>
<p>Los componentes virtuales, junto con los interfaces abstractos de interoperabilidad 
  presentan una vista de la aplicaci&oacute;n que es independiente de la implementaci&oacute;n: 
  si mantenemos constante la interfaz abstracta, el resto de aplicaciones no tendr&aacute;n 
  conocimiento de los cambios realizados sobre la aplicaci&oacute;n original.</p>
<p>El sistema de informaci&oacute;n integrado estar&aacute; basado en una arquitectura 
  multi-capa, que separa los roles del sistema y define las siguientes capas:</p>
<ul>
  
<li>Interfaz de usuario</li>
  
<li>L&oacute;gica del negocio</li>
  
<li>Persistencia de datos</li>

</ul>
<p>Las aplicaciones existentes se situar&aacute;n en la capa de persistencia de 
  datos. En los tres primeros niveles de integraci&oacute;n (datos, interfaz de 
  aplicaci&oacute;n y m&eacute;todos de l&oacute;gica del negocio) construiremos 
  los componentes virtuales que proporcionar&aacute;n las interfaces de las aplicaciones 
  existentes. Estos componentes virtuales se desarrollar&aacute;n en la capa de 
  l&oacute;gica del negocio.</p>
<p>En el nivel de integraci&oacute;n de presentaci&oacute;n se a&ntilde;adir&aacute; 
  la nueva capa de presentaci&oacute;n desarrollada y se desplegar&aacute; sobre 
  la capa de interfaz de usuario. Para la comunicaci&oacute;n entre las capas 
  utilizaremos la infraestructura de integraci&oacute;n que proporciona el intermediario 
  de integraci&oacute;n. En la Figura 16 se muestra esta arquitectura multi-capa.</p>
<p>
	
<img alt="Figura 16. Arquitectura de integraci&oacute;n multi-capa de un sistema    de informaci&oacute;n basada en componentes" content-width="10cm" src="imagenes/charla1/Figura16.gif">
</p>
<p>Para desarrollar los componentes virtuales (que son los bloques principales 
  de construcci&oacute;n del sistema de informaci&oacute;n basado en componentes) 
  usaremos una t&eacute;cnica denominada "envoltura" de componentes 
  (<em>component wrapping</em>). Dicha t&eacute;cnica nos permite implementar la 
  funcionalidad de los componentes virtuales mediante el uso de aplicaciones existentes.</p>
<p>Los componentes virtuales no presentan demasiadas dificultades para su implementaci&oacute;n. 
  En particular, si las aplicaciones proporcionan ya algunos API's a trav&eacute;s 
  de los cuales podemos acceder a su funcionalidad, ni siquiera necesitamos realizar 
  cambios sobre las aplicaciones existentes.</p>
<p>Si las aplicaciones no proporcionan ning&uacute;n tipo de interfaces, o si 
  dichas interfaces no satisfacen nuestros requerimientos, entonces tendremos 
  que desarrollarlas, o comprarlas. Para ello tendremos que modificar las aplicaciones 
  existentes para a&ntilde;adir las interfaces necesarias. Denominaremos <em>wrapper</em> 
  a la interfaz de la aplicaci&oacute;n que vamos a a&ntilde;adir, mientras que 
  a la aplicaci&oacute;n modificada existente la denominaremos aplicaci&oacute;n 
  existente "envuelta" (<em>wrapped</em>).</p>
<p>La adici&oacute;n de <em><strong>wrappers</strong></em> puede realizarse de forma sencilla, 
  especialmente en soluciones desarrolladas en la misma empresa de las que se 
  dispone el c&oacute;digo fuente y documentaci&oacute;n asociada. Sin embargo, 
  con aplicaciones en las que no se dispone del c&oacute;digo fuente, y la documentaci&oacute;n 
  es limitada, realizar cambios en la aplicaci&oacute;n puede resultar dif&iacute;cil. 
  En este &uacute;ltimo caso, podemos considerar el acceder directamente a la 
  base de datos, o incluso utilizar la interfaz de usuario para acceder a la funcionalidad. 
  Existen t&eacute;cnicas como la captura de pantallas (<em>screen scraping</em>), 
  en las que los <em>wrappers</em> acceden a la funcionalidad de la aplicaci&oacute;n 
  a trav&eacute;s de la interfaz de usuario, permiti&eacute;ndonos acceder a la 
  informaci&oacute;n necesaria sin tener que modificar las aplicaciones.</p>
<p>Los <em>wrappers</em> proporcionan la siguiente arquitectura (ver Figura 17):</p>
<p>
	
<img alt="Figura 17. Componentes virtuales y wrappers" content-width="12cm" src="imagenes/charla1/Figura17.gif">
</p>
<p>La forma en la que implementemos los <em>wrappers</em> depender&aacute; de las 
  tecnolog&iacute;as seleccionadas. Normalmente usaremos el intermediario integraci&oacute;n 
  para obtener la comunicaci&oacute;n entre el componente virtual y el <em>wrapper</em>. 
  La comunicaci&oacute;n entre el <em>wapper</em> y la aplicaci&oacute;n existente 
  usar&aacute; soluciones propietarias. En ocasiones integraremos el <em>wrapper</em> 
  con la aplicaci&oacute;n existente utilizando c&oacute;digo fuente, comunicaci&oacute;n 
  entre procesos, o captura de pantallas (para as&iacute; simular la entrada de 
  datos del usuario, y leer las pantallas para obtener los resultados).</p>
<p>A continuaci&oacute;n analizaremos los niveles de integraci&oacute;n que deberemos 
  seguir para construir la arquitectura de integraci&oacute;n:</p>
<ul>
  
<li>Integraci&oacute;n a nivel de datos</li>
  
<li>Integraci&oacute;n a nivel de interfaz de la aplicaci&oacute;n</li>
  
<li>Integraci&oacute;n a nivel de la l&oacute;gica del negocio</li>
  
<li>Integraci&oacute;n a nivel de la presentaci&oacute;n</li>

</ul>
<p>
<strong>Integraci&oacute;n a nivel de datos</strong>. Se centra en el "movimiento" 
  de datos entre aplicaciones con el objetivo de compartir los mismos datos entre 
  diferentes aplicaciones. Este nivel de integraci&oacute;n no requiere cambios 
  en las aplicaciones. El problema de implementar la integraci&oacute;n de datos 
  se complica por el hecho de la complejidad de las bases de datos y su n&uacute;mero. 
  La integraci&oacute;n de datos se consigue siguiendo la siguiente secuencia 
  de pasos (ver Figura 18):</p>
<p>
	
<img alt="Figura 18.   Integraci&oacute;n a nivel de datos" content-width="14cm" src="imagenes/charla1/Figura18.gif">
</p>
<p>La primera tarea (identificar los datos) implica familiarizarnos con los datos 
  existentes en la compa&ntilde;&iacute;a. Para ello deberemos crear modelos de 
  datos de cada aplicaci&oacute;n para conocer c&oacute;mo se estructuran las 
  bases de datos. Y adem&aacute;s deberemos comprender con detalle c&oacute;mo 
  se gestionan estos datos por parte de la aplicaci&oacute;n, para lo que utilizaremos 
  los diccionarios de datos.</p>
<p>La segunda tarea (identificar los tipos de bases de datos) implica familiarizarnos 
  con la implementaci&oacute;n f&iacute;sica de la base de datos. Esta normalmente 
  pertenecer a uno de los tipos siguientes: relacional, orientada a objetos, jer&aacute;rquica. 
  Los sistemas <em>legacy</em> podr&iacute;an usar otros formatos basados en estructuras 
  propietarias de ficheros, u otras ampliamente usadas como: ISAM, VSAM, y CODASYL.</p>
<p>La tercera tarea (definici&oacute;n del modelo de datos) consiste en obtener 
  una representaci&oacute;n de alto nivel de todos los datos relevantes utilizados 
  por la organizaci&oacute;n. El modelo obtenido presenta los datos de la empresa 
  de una forma consistente, centr&aacute;ndose en la relaci&oacute;n entre los 
  datos de la empresa. Se trabajar&aacute; principalmente en la eliminaci&oacute;n 
  de elementos redundantes, en la detecci&oacute;n de aplicaciones independientes 
  con procesos separados y en la detecci&oacute;n de pasos innecesarios en la 
  transferencia de datos.</p>
<p>Finalmente, la cuarta tarea (implementaci&oacute;n de la integraci&oacute;n 
  de datos) consiste en la implementaci&oacute;n real de la integraci&oacute;n 
  de datos teniendo en cuenta las tareas anteriores. Debemos evitar la integraci&oacute;n 
  punto a punto, para lo cual utilizaremos un intermediario de integraci&oacute;n, 
  implementando uno o m&aacute;s componentes virtuales para cada base de datos 
  de las aplicaciones.</p>
<p>
<strong>Integraci&oacute;n a nivel de interfaz de la aplicaci&oacute;n</strong>. Se centra 
  en compartir las funcionalidades con los datos. Se consigue mediante el uso 
  de APIs, de forma que se consigue acceder a las funcionalidades sin necesidad 
  de usar la interfaz de usuario. Representaremos la funcionalidad de las aplicaciones 
  existentes mediante componentes virtuales que mostrar&aacute;n las operaciones 
  de las aplicaciones existentes a trav&eacute;s de sus interfaces interoperables, 
  accesibles a a trav&eacute;s de intermediario de integraci&oacute;n (ocultando 
  las diferencias de tecnolog&iacute;a).</p>
<p>Afortunadamente la integraci&oacute;n a nivel de interfaz no requiere que las 
  aplicaciones existentes dispongan de APIs implementados, ya que podemos utilizar 
  <em>wrappers</em>. Dichos <em>wrappers</em> se a&ntilde;adir&aacute;n mediante la 
  modificaci&oacute;n de c&oacute;digo fuente de las aplicaciones existentes, 
  o bien accediendo a la funcionalidad de dichas aplicaciones mediante la simulaci&oacute;n 
  de la interacci&oacute;n con el usuario.</p>
<p>Los pasos a seguir en este nivel son los siguientes (ver Figura 19).</p>
<p>
	
<img alt="Figura 19.   Integraci&oacute;n a nivel de interfaz" content-width="14cm" src="imagenes/charla1/Figura19.gif">
</p>
<p>En primer lugar debemos analizar las funcionalidades existentes a trav&eacute;s 
  de interfaces, lo cual nos responder&aacute; a la cuesti&oacute;n de si las 
  aplicaciones existentes proporcionan las interfaces requeridas y si estas interfaces 
  son adecuadas para acceder a las funcionalidades que se requieren. Si la respuesta 
  es positiva, continuaremos con el an&aacute;lisis de las tecnolog&iacute;as 
  usadas. Si es negativa deberemos a&ntilde;adir las interfaces que sean necesarias.</p>
<p>En el pasado, las interfaces se implementaban con tecnolog&iacute;as propietarias, 
  pero hoy en d&iacute;a han surgido diferentes est&aacute;ndares que pueden ser 
  utilizados. Las interfaces pueden proporcionar formas de comunicaci&oacute;n 
  s&iacute;ncrona o as&iacute;ncrona, y las aplicaciones que usan interfaces estadarizadas 
  utilizan a menudo <em>middleware</em> para proporcionar esta comunicaci&oacute;n. 
  Posibles soluciones <em>middleware</em> que resultan apropiadas para implementar 
  la interfaz de las aplicaciones incluyen: MOM, RPCs, ORBs, protocolos de comunicaci&oacute;n 
  (SOAP, HTTP, TCP/IP). </p>
<p>El &uacute;ltimo paso en este nivel es el ocultar las diferencias de tecnolog&iacute;as 
  utilizadas. Esto se consigue mediante el uso de componentes virtuales: una vez 
  que se han identificado las operaciones de las aplicaciones existentes a las 
  que necesitamos acceder mediante APIs, definimos las mismas (o ligeramente modificadas) 
  interfaces para los componentes virtuales; a continuaci&oacute;n usaremos la 
  tecnolog&iacute;a del intermediario de integraci&oacute;n para conseguir la 
  interoperabilidad, simplemente delegando las peticiones desde el componente 
  virtual a las interfaces espec&iacute;ficas de las aplicaciones existentes.</p>
<p>
<strong>Integraci&oacute;n a nivel de la l&oacute;gica del negocio</strong>. El objetivo 
  es desarrollar componentes virtuales que proporcionen las interfaces con los 
  m&eacute;todos de la l&oacute;gica del negocio de alto nivel que puedan considerarse 
  como servicios de la empresa. De esta forma se consigue una integraci&oacute;n 
  consistente en compartir la l&oacute;gica del negocio entre las aplicaciones.</p>
<p>Para conseguir el integraci&oacute;n a nivel de la l&oacute;gica del negocio, 
  en general, necesitaremos introducir varios niveles de componentes virtuales. 
  De esta forma, un componente virtual de un m&eacute;todo de l&oacute;gica del 
  negocio realizar&aacute; varias llamadas a componentes de interfaces de m&aacute;s 
  bajo nivel para realizar completar su tarea. Los pasos a seguir se muestran 
  en la Figura 20.</p>
<p>
	
<img alt="Figura 20.   Integraci&oacute;n a nivel de l&oacute;gica de negocio" content-width="14cm" src="imagenes/charla1/Figura20.gif">
</p>
<p>Para definir los interfaces de algo nivel se requiere un esfuerzo coordinado 
  de los analistas, dise&ntilde;adores y arquitectos. En t&eacute;rminos simples, 
  de lo que se trata es de definir un dise&ntilde;o global del sistema de informaci&oacute;n 
  tal y como quisi&eacute;ramos obtener si implement&aacute;ramos el sistema de 
  nuevo. No es una tarea f&aacute;cil y requiere un gran conocimiento y esfuerzo. 
  Sin embargo, si no podemos definir dicho dise&ntilde;o, significa que realmente 
  no podemos fijar los requerimientos fundamentales, metas y objetivos. Esto har&aacute; 
  que el proyecto de integraci&oacute;n probablemente falle incluso antes de que 
  haya comenzado.</p>
<p>El segundo paso consiste en realizar una correspondencia entre las operaciones 
  de negocio y los componentes virtuales que representan las aplicaciones existentes, 
  intentando reusar las funcionalidades de las aplicaciones existentes en la medida 
  de lo posible. La correspondencia a establecer deber&aacute; definir las transformaciones 
  necesarias que deber realizarse entre las llamadas a componentes virtuales de 
  bajo nivel, y otras restricciones como temporales y de sintaxis.</p>
<p>Finalmente se deben implementar los componentes virtuales de alto nivel. Es 
  importante tener en cuenta que los componentes virtuales de alto nivel desarrollados 
  utilizar&aacute;n componentes virtuales de bajo nivel implementados en los niveles 
  de interfaz y datos.</p>
<p>
<strong>Integraci&oacute;n a nivel de la presentaci&oacute;n</strong>. Hasta ahora hemos 
  conseguido compartir la l&oacute;gica del negocio, pero las aplicaciones existentes 
  seguir&aacute;n us&aacute;ndose de la misma forma que antes. Esto significa 
  que el usuario es completamente consciente de que se usan aplicaciones existentes 
  distintas y que requiere un cambio manual entre ellas. La integraci&oacute;n 
  a nivel de presentaci&oacute;n resuelve estos problemas. Se trata de definir 
  una interfaz de usuario com&uacute;n para el sistema de informaci&oacute;n integrado 
  a nivel de m&eacute;todos de negocio. La secuencia de actividades a realizar 
  es la siguiente (ver Figura 21)</p>
<p>
	
<img alt="Figura 21.   Integraci&oacute;n a nivel de presentaci&oacute;n" content-width="14cm" src="imagenes/charla1/Figura21.gif">
</p>
<p>Primero debemos seleccionar qu&eacute; interfaces de usuario necesita el sistema 
  de informaci&oacute;n integrado. Deberemos ser pr&aacute;cticos y seleccionar 
  primero aquellas parte que tienen mayor necesidad de interfaces de usuario.</p>
<p>La actividad de mayor envergadura a nivel de presentaci&oacute;n es el an&aacute;lisis 
  y dise&ntilde;o de un interfaz de usuario unificado para el sistema de informaci&oacute;n 
  integrado. Dicho sistema debe aparecer ante los usuarios finales como una aplicaci&oacute;n 
  desarrollada completamente nueva, de forma que los usuarios no deben ser capaces 
  de reconocer que las aplicaciones existentes est&aacute;n siendo usadas "por 
  debajo", y no deben tener contacto directo con dichas aplicaciones, que 
  ahora sirven como componentes virtuales en la capa media.</p>
<p>A continuaci&oacute;n debemos establecer la correspondencia entre las operaciones 
  de interfaz de usuario con los m&eacute;todos del negocio de la capa de l&oacute;gica 
  del negocio.</p>
<p>Finalmente tenemos que implementar la nueva capa de presentaci&oacute;n. Podemos 
  utilizar diferentes aproximaciones, entre ellas: clientes con interfaces gr&aacute;ficas, 
  clientes <em>web</em> o clientes "<em>thin</em>", o clientes universales 
  para diferentes tipos de tecnolog&iacute;as cliente (basados en <em>web</em>, 
  o m&oacute;viles entre otras).</p>
<p>Una implementaci&oacute;n exitosa de la capa de integraci&oacute;n de presentaci&oacute;n 
  resulta en una arquitectura multi-capa tal y como se muestra en la Figura 22.</p>
<p>
	
<img alt="Figura 22.   Arquitectura de integraci&oacute;n" content-width="14cm" src="imagenes/charla1/Figura22.gif">
</p>
<p>Los principales beneficios de la integraci&oacute;n a nivel de presentaci&oacute;n 
  son: proceso unificado del negocio, integraci&oacute;n de toda la aplicaci&oacute;n, 
  interfaz de usuario unificado, sistemas interconectados f&iacute;sica y l&oacute;gicamente, 
  informaci&oacute;n accesible completamente sin latencia, entradas de datos &uacute;nicas.</p>
</div>


<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006 Depto. CCIA</div>
</div>
</body>
</html>
