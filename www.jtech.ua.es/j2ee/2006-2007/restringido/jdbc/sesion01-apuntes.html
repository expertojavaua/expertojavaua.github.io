<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Introducci&oacute;n a JDBC. Consulta de una BD</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Bases de datos con JDBC" src="images/baner_j2ee_der.gif" title="Bases de datos con JDBC"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Bases de datos con JDBC</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Bases de datos con JDBC">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menupage">
<div class="menupagetitle">Sesion 1</div>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion01-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Introducci&oacute;n a JDBC. Consulta de una BD</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n+a+JDBC">Introducci&oacute;n a JDBC</a>
<ul class="minitoc">
<li>
<a href="#Drivers+de+acceso">Drivers de acceso</a>
<ul class="minitoc">
<li>
<a href="#Tipos+de+drivers">Tipos de drivers</a>
</li>
<li>
<a href="#Instalaci%C3%B3n+de+drivers">Instalaci&oacute;n de drivers</a>
</li>
</ul>
</li>
<li>
<a href="#Conexi%C3%B3n+a+la+BD">Conexi&oacute;n a la BD</a>
</li>
</ul>
</li>
<li>
<a href="#Consulta+a+una+base+de+datos+con+JDBC">Consulta a una base de datos con JDBC</a>
<ul class="minitoc">
<li>
<a href="#Creaci%C3%B3n+y+ejecuci%C3%B3n+de+sentencias+SQL">Creaci&oacute;n y ejecuci&oacute;n de sentencias SQL</a>
</li>
<li>
<a href="#Sentencias+de+consulta">Sentencias de consulta</a>
</li>
</ul>
</li>
</ul>
</div>

<a name="N1000C"></a><a name="Introducci%C3%B3n+a+JDBC"></a>
<h2 class="underlined_10">Introducci&oacute;n a JDBC</h2>
<div class="section">
<p>En la mayor&iacute;a de las aplicaciones que nos vamos a encontrar,
aparecer&aacute; una base de datos como fuente de informaci&oacute;n.
JDBC nos va a permitir acceder a bases de datos (BD) desde Java. Con
JDBC no es necesario escribir distintos programas para distintas BD,
sino que un &uacute;nico programa sirve para acceder a BD de distinta
naturaleza. Incluso, podemos acceder a m&aacute;s de una BD de distinta
fuente (Oracle, Access, MySql, etc.) en la misma aplicaci&oacute;n.
Podemos pensar en JDBC como el puente entre una base de datos y nuestro
programa Java. Un ejemplo sencillo puede ser un applet que muestra
din&aacute;micamente informaci&oacute;n contenida en una base de datos.
El applet utilizar&aacute; JDBC para obtener dichos datos.</p>
<p>El esquema a seguir en un programa que use JDBC es el siguiente:
<img alt="Esquema general de conexi&oacute;n con una base de datos" content-width="12cm" src="imagenes/figura1.jpg"></p>
<p>Un programa Java que utilice JDBC primero deber&aacute; establecer
una conexi&oacute;n con el SGBD. Para realizar dicha conexi&oacute;n
haremos uso de un driver espec&iacute;fico para cada SGBD que estemos
utilizando. Una vez establecida la conexi&oacute;n ya podemos
interrogar la BD con cualquier comando SQL (select, update, create,
etc.). El resultado de un comando <em>select</em> es un objeto de la
clase ResultSet, que contiene los datos que devuelve la consulta.
Disponemos de m&eacute;todos en <em>ResultSet </em>para manejar los
datos devueltos. Tambi&eacute;n podemos realizar cualquier
operaci&oacute;n en SQL (creaci&oacute;n de tablas, gesti&oacute;n de
usuarios, etc.).
<img alt="Conexi&oacute;n a trav&eacute;s del API y un driver de JDBC" content-width="12cm" src="imagenes/figura2.jpg"></p>
<p>Para realizar estas operaciones necesitaremos contar con un SGBD
(sistema gestor de bases de datos) adem&aacute;s de un driver
espec&iacute;fico para poder acceder a este SGBD.&nbsp;Vamos a utilizar
dos SGBD: MySQL (disponible para Windows y Linux, de libre
distribuci&oacute;n) y PostGres (s&oacute;lo para Linux, tambi&eacute;n
de libre distribuci&oacute;n).</p>
<a name="N1002C"></a><a name="Drivers+de+acceso"></a>
<h3 class="underlined_5">Drivers de acceso</h3>
<p>Los drivers para poder acceder a cada SGBD no forman parte de la
distribuci&oacute;n de Java por lo que deberemos obtenerlos por
separado. &iquest;Por qu&eacute; hacer uso de un driver?. El
principal problema que se nos puede plantear es que cada SGBD dispone
de su propio API (la mayor&iacute;a propietario), por lo que un cambio
en el SGBD implica una modificaci&oacute;n de nuestro c&oacute;digo. Si
colocamos una capa intermedia, podemos abstraer la conectividad, de tal
forma que nosotros utilizamos un objeto para la conexi&oacute;n, y el
driver se encarga de traducir la llamada al API. El driver lo suelen
distribuir las propias empresas que fabrican el SGBD. </p>
<a name="N10035"></a><a name="Tipos+de+drivers"></a>
<h4>Tipos de drivers</h4>
<p>Existe un est&aacute;ndar establecido que divide los drivers en cuatro
grupos:</p>
<ul>
  
<li>
<strong>Tipo 1: Puente JDBC-ODBC</strong>. ODBC (Open Database Connectivity) fue creado 
    para proporcionar una conexi&oacute;n a bases de datos en Microsoft Windows.
    ODBC permite acceso a bases de datos desde diferentes lenguajes de programaci&oacute;n, 
    tales como C y Cobol. El puente JDBC-ODBC permite enlazar Java con cualquier 
    base de datos disponible en ODBC. No se aconseja el uso de este tipo de driver 
    cuando tengamos que acceder a bases de datos de alto rendimiento, pues las 
    funcionalidades est&aacute;n limitadas a las que marca ODBC. Cada cliente 
    debe tener instalado el driver. J2SE incluye este driver en su versi&oacute;n 
    Windows y Solaris.

    <img alt="Configuraci&oacute;n de un driver de tipo 1" content-width="10cm" src="imagenes/driver1.jpg">
  </li>
  
<li>
<strong>Tipo 2: Parte Java, parte driver nativo</strong>. Es una combinaci&oacute;n 
    de implementaci&oacute;n Java y API nativo para el acceso a la base de datos. 
    Este tipo de driver es m&aacute;s r&aacute;pido que el anterior, pues no se 
    realiza el paso por la capa ODBC. Las llamadas JDBC se traducen en llamadas 
    espec&iacute;ficas del API de la base de datos. Cada cliente debe tener instalado 
    el driver. Tiene menor rendimiento que los dos siguientes y no se pueden usar 
    en Internet, ya que necesita el API de forma local.
    <img alt="Configuraci&oacute;n de un driver de tipo 2" content-width="10cm" src="imagenes/driver2.jpg">
   </li>
  
<li>
<strong>Tipo 3: Servidor intermediario de acceso a base de datos</strong>.
Este tipo de driver
proporciona una abstracci&oacute;n de la conexi&oacute;n. El cliente se
conecta a los SGBD
mediante un componente servidor intermedio, que act&uacute;a como una
puerta para m&uacute;ltiples servidores. La ventaja de este tipo de
driver es el nivel de abstracci&oacute;n. El servidor
de aplicaciones WebLogic incorpora este tipo de driver.
<img alt="Configuraci&oacute;n de un driver de tipo 3" content-width="10cm" src="imagenes/driver3.jpg">
  </li>
  
<li>
<strong>Tipo 4: Drivers Java</strong>. Este es el m&aacute;s directo. La
llamada JDBC se traduce
directamente en una llamada de red a la base de datos, sin
intermediarios. Proporcionan
mejor rendimiento. La mayor&iacute;a de SGBD proporcionan drivers de
este tipo.
<img alt="Configuraci&oacute;n de un driver de tipo 4" content-width="8cm" src="imagenes/driver4.jpg">
</li>

</ul>
<a name="N1006A"></a><a name="Instalaci%C3%B3n+de+drivers"></a>
<h4>Instalaci&oacute;n de drivers</h4>
<p> La distribuci&oacute;n de JDBC incorpora los drivers para el puente JDBC-ODBC 
  que nos permite acceder a cualquier BD que se gestione con ODBC. Para MySQL, 
  deberemos descargar e instalar el SGBD y el driver, que puede ser obtenido en 
  la direcci&oacute;n <a href="http://dev.mysql.com/doc/mysql/en/Java_Connector.html">http://dev.mysql.com/doc/mysql/en/Java_Connector.html</a>. 
  El driver para PostGres se obtiene en <a href="http://jdbc.postgresql.org">http://jdbc.postgresql.org</a>
</p>
<p>Para instalar el driver lo &uacute;nico que deberemos hacer es
incluir el fichero JAR que lo contiene en el CLASSPATH. Por ejemplo,
para MySQL:</p>
<pre class="code">
export CLASSPATH=$CLASSPATH:
        <strong>/directorio-donde-este/mysql-connector-java-3.0.15-ga-bin.jar</strong>

</pre>
<p>Con el driver instalado, podremos cargarlo desde nuestra
aplicaci&oacute;n simplemente cargando din&aacute;micamente la clase
correspondiente al driver:</p>
<pre class="code">Class.forName("<strong>com.mysql.jdbc.Driver</strong>");
</pre>
<p>El driver JDBC-ODBC se carga como se muestra a continuaci&oacute;n:</p>
<pre class="code">
Class.forName("<strong>sun.jdbc.odbc.JdbcOdbcDriver</strong>");
</pre>
<p>Y de forma similar para PostGres:</p>
<pre class="code">
Class.forName("<strong>org.postgresql.Driver</strong>");
</pre>
<p> La carga del driver se deber&iacute;a hacer siempre antes de
conectar con la BD. </p>
<p>Como hemos visto anteriormente, pueden existir distintos tipos de
drivers para la misma base de datos. Por ejemplo, a una BD en MySQL
podemos acceder mediante ODBC o mediante su propio driver.
Podr&iacute;amos pensar que la soluci&oacute;n m&aacute;s sencilla
ser&iacute;a utilizar ODBC para todos las conexiones a SGBD. Sin
embargo, dependiendo de la complejidad de la aplicaci&oacute;n a
desarrollar esto nos podr&iacute;a dar problemas. Determinados SGBD
permiten realizar operaciones (transacciones, mejora de rendimiento,
escabilidad, etc.) que se ven mermadas al realizar su conexi&oacute;n a
trav&eacute;s del driver ODBC. Por ello es preferible hacer uso de
driver espec&iacute;ficos para el SGBD en cuesti&oacute;n. </p>
<p>El ejemplo m&aacute;s claro de problemas en el uso de drivers es con
los <em>Applets</em>. Cuando utilicemos acceso a bases de datos mediante
JDBC desde un <em>Applet</em>, deberemos tener en cuenta que el <em>Applet</em>
se ejecuta en la m&aacute;quina del cliente, por lo que si la BD
est&aacute; alojada en nuestro servidor tendr&aacute; que establecer
una conexi&oacute;n remota. Aqu&iacute; encontramos el problema de que
si el <em>Applet</em> es visible desde Internet, es muy posible que el
puerto en el que escucha el servidor de base de datos puede estar
cortado por alg&uacute;n <em>firewall</em>, por lo que el acceso desde
el exterior no ser&iacute;a posible.</p>
<p>El uso del puente JDBC-ODBC tampoco es recomendable en <em>Applets</em>,
ya que requiere que cada cliente tenga configurada la fuente de datos
ODBC adecuada en su m&aacute;quina. Esto podemos controlarlo en el caso
de una intranet, pero en el caso de Internet ser&aacute; mejor utilizar
otros m&eacute;todos para la conexi&oacute;n.</p>
<p>En cuanto a las excepciones, debemos capturar la excepci&oacute;n <em>SQLException</em>
en casi todas las operaciones en las que se vea involucrado
alg&uacute;n objeto JDBC. </p>
<a name="N100C8"></a><a name="Conexi%C3%B3n+a+la+BD"></a>
<h3 class="underlined_5">Conexi&oacute;n a la BD</h3>
<p>Una vez cargado el driver apropiado para nuestro SGBD deberemos
establecer la conexi&oacute;n con la BD. Para ello utilizaremos el
siguiente m&eacute;todo:</p>
<pre class="code">

<strong>Connection</strong> con = DriverManager.<strong>getConnection</strong>(url);
<strong>Connection</strong> con = DriverManager.<strong>getConnection</strong>(url, login, password);
</pre>
<p>La conexi&oacute;n a la BD est&aacute; encapsulada en un objeto <span class="codefrag">Connection</span>.
Para su creaci&oacute;n debemos proporcionar la <em> url</em> de la BD
y, si la BD est&aacute; protegida con contrase&ntilde;a, el <em>login</em>
y <em> password</em> para acceder a ella. El formato de la <em> url</em>
variar&aacute; seg&uacute;n el driver que utilicemos. Sin embargo,
todas las <em>url</em> tendr&aacute;n la siguiente forma general: <em>jdbc</em>:&lt;<em>subprotocolo</em>&gt;:&lt;<em>nombre</em>&gt;,
con <em>subprotocolo</em> indicando el tipo de SGBD y con <em>nombre</em>
indicando el nombre de la BD y aportando informaci&oacute;n adicional
para la conexi&oacute;n. </p>
<p>Para conectar a una fuente ODBC de nombre <em>bd</em>, por ejemplo,
utilizaremos la siguiente URL:</p>
<pre class="code">
Connection con = DriverManager.getConnection("<strong>jdbc:odbc:bd</strong>");
</pre>
<p>En el caso de MySQL, si queremos conectarnos a una BD de nombre <em>bd</em>
alojada en la m&aacute;quina local (<em>localhost</em>) y con usuario <em>miguel</em>
y contrase&ntilde;a <em>m++24</em>, lo haremos de la siguiente forma:</p>
<pre class="code">Connection con = 
    DriverManager.getConnection("<strong>jdbc:mysql://localhost/bd</strong>", "miguel", "m++24");
</pre>
<p>En el caso de PostGres (notar que hemos indicado un puerto de
conexi&oacute;n, el 5432):</p>
<pre class="code">
Connection con = DriverManager.getConnection(
    "<strong>jdbc:postgresql://localhost:5432/bd</strong>", "miguel", "m++24");
</pre>
<p>Podemos depurar la conexi&oacute;n y determinar qu&eacute; llamadas
est&aacute; realizando JDBC. Para ello haremos uso de un par de
m&eacute;todos que incorpora <strong>DriverManager</strong>. En el siguiente
ejemplo se indica que las operaciones que realice JDBC se
mostrar&aacute;n por la salida est&aacute;ndar:</p>
<pre class="code">
DriverManager.<strong>setLogWriter</strong>(new PrintWriter(System.out, true));
</pre>
<p>Una vez realizada esta llamada tambi&eacute;n podemos mostrar
mensajes usando:</p>
<pre class="code">
DriverManager.<strong>println</strong>("Esto es un mensaje");
</pre>
</div>

<a name="N1014B"></a><a name="Consulta+a+una+base+de+datos+con+JDBC"></a>
<h2 class="underlined_10">Consulta a una base de datos con JDBC</h2>
<div class="section">
<a name="N10151"></a><a name="Creaci%C3%B3n+y+ejecuci%C3%B3n+de+sentencias+SQL"></a>
<h3 class="underlined_5">Creaci&oacute;n y ejecuci&oacute;n de sentencias SQL</h3>
<p>Una vez obtenida la conexi&oacute;n a la BD, podemos utilizarla para
realizar consultas, inserci&oacute;n y/o borrado de datos de dicha BD.
Todas estas operaciones se realizar&aacute;n mediante lenguaje SQL. La
clase <strong>Statement</strong> es la que permite realizar todas estas
operaciones. La instanciaci&oacute;n de esta clase se realiza haciendo
uso del siguiente m&eacute;todo que proporciona el objeto <strong>Connection</strong>:</p>
<pre class="code">

<strong>Statement</strong> stmt = con.createStatement();
</pre>
<p>Podemos dividir las sentencias SQL en dos grupos: las que actualizan
la BD y las que &uacute;nicamente la consultan. En las siguientes
secciones veremos c&oacute;mo podemos realizar estas dos acciones.</p>
<a name="N1016B"></a><a name="Sentencias+de+consulta"></a>
<h3 class="underlined_5">Sentencias de consulta</h3>
<p>Para obtener datos almacenados en la BD podemos realizar una
consulta SQL (<em>query</em>). Podemos ejecutar la consulta utilizando el
objeto <strong>Statement</strong>, pero ahora haciendo uso del m&eacute;todo <strong>executeQuery
</strong> al que le pasaremos una cadena con la consulta SQL. Los datos
resultantes nos los devolver&aacute; como un objeto <strong>ResultSet</strong>.</p>
<pre class="code">

<strong>ResultSet</strong> result = stmt.<strong>executeQuery</strong>(query);
</pre>
<p>La consulta SQL nos devolver&aacute; una tabla, que tendr&aacute;
una serie de campos y un conjunto de registros, cada uno de los cuales
consistir&aacute; en una tupla de valores correspondientes a los campos
de la tabla.&nbsp; </p>
<p> Los campos que tenga la tabla resultante depender&aacute;n de la
consulta que hagamos, de los datos que solicitemos que nos devuelva.
Por ejemplo, podemos solicitar que una consulta nos devuelva los campos
<em>expediente </em>y <em>nombre</em> de los alumnos o bien que nos
devuelva todos los campos de la tabla <em>alumnos</em>. </p>
<p>Veamos el funcionamiento de las consultas SQL mediante un ejemplo:</p>
<pre class="code">
String query = "SELECT * FROM ALUMNOS WHERE sexo = 'M'";
ResultSet result = stmt.executeQuery(query);
</pre>
<p>En esta consulta estamos solicitando todos los registros de la tabla
ALUMNOS
en los que el sexo sea <em>mujer </em>(M), pidiendo que nos devuelva
todos los
campos (indicado con *) de dicha tabla. Nos devolver&aacute; una tabla
como la
siguiente:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
    
<tr>
      
<td colspan="1" rowspan="1"><strong>exp</strong></td>
      <td colspan="1" rowspan="1"><strong>nombre</strong></td>
      <td colspan="1" rowspan="1"><strong>sexo</strong></td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1">1286</td>
      <td colspan="1" rowspan="1">Amparo</td>
      <td colspan="1" rowspan="1">M</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1">1287</td>
      <td colspan="1" rowspan="1">Manuela</td>
      <td colspan="1" rowspan="1">M</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1">1288</td>
      <td colspan="1" rowspan="1">Lucrecia</td>
      <td colspan="1" rowspan="1">M</td>
    
</tr>

</table>
<p>Estos datos nos los devolver&aacute; como un objeto <strong>ResultSet</strong>.
A continuaci&oacute;n veremos c&oacute;mo podemos acceder a los valores
de este objeto y c&oacute;mo podemos movernos por los distintos
registros.</p>
<p>El objeto <strong>ResultSet </strong>dispone de un <em>cursor</em> que
estar&aacute; situado en el registro que podemos consultar en cada
momento. Este <em>cursor</em> en un principio estar&aacute; situado en
una posici&oacute;n anterior al primer registro de la tabla. Podemos
mover el cursor al siguiente registro con el m&eacute;todo <strong>next</strong>
del <strong>ResultSet</strong>. La llamada a este m&eacute;todo nos
devolver&aacute; <strong>true</strong> mientras pueda pasar al siguiente
registro, y <strong>false </strong>en el caso de que ya estuvi&eacute;ramos en
el &uacute;ltimo registro de la tabla. Para la consulta de todos los
registros obtenidos utilizaremos normalmente un bucle como el siguiente:</p>
<pre class="code">
while(result.<strong>next</strong>()) {
      // Leer registro
}
</pre>
<p>Ahora necesitamos obtener los datos del registro que marca el <em>cursor</em>,
para lo cual podremos acceder a los campos de dicho registro. Esto lo
haremos utilizando los m&eacute;todos <strong>getXXXX(campo)</strong> donde <strong>XXXX</strong>
ser&aacute; el tipo de datos de Java en el que queremos que nos
devuelva el valor del campo. Hemos de tener en cuenta que el tipo del
campo en la tabla debe ser convertible al tipo de datos Java
solicitado. Para especificar el campo que queremos leer podremos
utilizar bien su nombre en forma de cadena, o bien su &iacute;ndice que
depender&aacute; de la ordenaci&oacute;n de los campos que devuelve la
consulta. Tambi&eacute;n debemos tener en cuenta que no podemos acceder
al mismo campo dos veces seguidas en el mismo registro. Si lo hacemos
nos dar&aacute; una excepci&oacute;n.</p>
<p>Los tipos principales que podemos obtener son los siguientes:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
    
<tr>
      
<td colspan="1" rowspan="1"><strong>getInt</strong></td>
      <td colspan="1" rowspan="1">Datos enteros</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><strong>getDouble</strong></td>
      <td colspan="1" rowspan="1">Datos reales</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><strong>getBoolean</strong></td>
      <td colspan="1" rowspan="1">Campos booleanos (si/no)</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><strong>getString</strong></td>
      <td colspan="1" rowspan="1">Campos de texto</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><strong>getDate</strong></td>
      <td colspan="1" rowspan="1">Tipo fecha (Devuelve <strong>Date</strong>)</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><strong>getTime</strong>
      </td>
      <td colspan="1" rowspan="1">Tipo hora (Devuelve<strong> Time</strong>)
      </td>
    
</tr>

</table>
<p>Si queremos imprimir todos los datos obtenidos de nuestra tabla
ALUMNOS del ejemplo podremos hacer lo siguiente:</p>
<pre class="code">
int exp;
String nombre;
String sexo;

while(result.next()){
    exp = result.getInt("exp");
    nombre = result.getString("nombre");
    sexo = result.getString("sexo");
    System.out.println(exp + "\t" + nombre + "\t" + sexo);
}
</pre>
<p>Cuando un campo de un registro de una tabla no tiene asignado
ning&uacute;n valor, la consulta de ese valor devuelve NULL. Esta
situaci&oacute;n puede dar problemas al intentar manejar ese dato. La
clase <strong>ResultSet</strong> dispone de un m&eacute;todo <strong>wasNull</strong> que
llamado despu&eacute;s de acceder a un registro nos dice si el valor
devuelto fue NULL. Esto no sucede as&iacute; para los datos
num&eacute;ricos, ya que devuelve el valor 0. Comprobemos qu&eacute;
sucede en el siguiente c&oacute;digo:</p>
<pre class="code">
String sexo;

while(result.next()){
    exp = result.getInt("exp");
    nombre = result.getString("nombre");
    sexo = result.getString("sexo");
    System.out.println(exp + "\t" + nombre.<strong>trim</strong>() + "\t" + sexo);
}
</pre>
<p>La llamada al m&eacute;todo <strong>trim</strong> devolver&aacute; una
excepci&oacute;n si el objeto <strong>nombre</strong> es NULL. Por ello podemos
realizar la siguiente modificaci&oacute;n: </p>
<pre class="code">
String sexo;

while(result.next()){
    exp = result.getInt("exp");
    System.out.print(exp + "\t");
    nombre = result.getString("nombre");	
    if (result.<strong>wasNull</strong>()) {
        System.out.print("Sin nombre asignado");
    else
        System.out.print(nombre.trim());
    sexo = result.getString("sexo");
    System.out.println("\t" + sexo);
}
</pre>
</div>


<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006-2007 Depto. CCIA</div>
</div>
</body>
</html>
