<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Lenguaje Java y Entorno de Desarrollo</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Java y Herramientas de Desarrollo" src="images/baner_j2ee_der.gif" title="Java y Herramientas de Desarrollo"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Java y Herramientas de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Java y Herramientas de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menupage">
<div class="menupagetitle">Sesion 1</div>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion01-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Lenguaje Java y Entorno de Desarrollo</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n+a+Java">Introducci&oacute;n a Java</a>
<ul class="minitoc">
<li>
<a href="#Variables+de+entorno+en+Java">Variables de entorno en Java</a>
</li>
<li>
<a href="#Compilar+y+ejecutar+clases">Compilar y ejecutar clases</a>
</li>
<li>
<a href="#Otros+programas+de+JDK">Otros programas de JDK</a>
</li>
<li>
<a href="#Ficheros+JAR">Ficheros JAR </a>
</li>
<li>
<a href="#Extensiones+de+Java">Extensiones de Java </a>
</li>
<li>
<a href="#B%C3%BAsqueda+de+clases+en+Java">B&uacute;squeda de clases en Java</a>
</li>
</ul>
</li>
<li>
<a href="#Entorno+de+desarrollo+Eclipse">Entorno de desarrollo Eclipse</a>
<ul class="minitoc">
<li>
<a href="#Instalaci%C3%B3n+y+ejecuci%C3%B3n">Instalaci&oacute;n y ejecuci&oacute;n</a>
</li>
<li>
<a href="#Configuraci%C3%B3n+visual">Configuraci&oacute;n visual</a>
</li>
<li>
<a href="#Configuraci%C3%B3n+general">Configuraci&oacute;n general</a>
</li>
<li>
<a href="#Primeros+pasos+con+Eclipse">Primeros pasos con Eclipse</a>
</li>
<li>
<a href="#Plugins+en+Eclipse">Plugins en Eclipse</a>
</li>
</ul>
</li>
<li>
<a href="#Componentes+de+un+programa+Java">Componentes de un programa Java</a>
<ul class="minitoc">
<li>
<a href="#Clases">Clases</a>
</li>
<li>
<a href="#Campos+y+variables">Campos y variables</a>
</li>
<li>
<a href="#M%C3%A9todos">M&eacute;todos</a>
</li>
<li>
<a href="#Constructores">Constructores</a>
</li>
<li>
<a href="#Paquetes">Paquetes</a>
</li>
<li>
<a href="#Modificadores+de+acceso">Modificadores de acceso</a>
</li>
<li>
<a href="#Otros+modificadores">Otros modificadores</a>
</li>
<li>
<a href="#Ejecuci%C3%B3n+de+clases%3A+m%C3%A9todo">Ejecuci&oacute;n de clases: m&eacute;todo main</a>
</li>
<li>
<a href="#Ejemplo+completo">Ejemplo completo</a>
</li>
<li>
<a href="#Herencia">Herencia</a>
</li>
<li>
<a href="#Punteros">Punteros this y super</a>
</li>
<li>
<a href="#Interfaces">Interfaces</a>
</li>
<li>
<a href="#Programas+B%C3%A1sicos+en+Java">Programas B&aacute;sicos en Java</a>
</li>
</ul>
</li>
</ul>
</div>


<p>Antes de concretar conceptos acerca del lenguaje Java, veremos algunas nociones 
  y conceptos sobre programaci&oacute;n orientada a objetos en general, y sobre dise&ntilde;o 
  de programas mediante dicho paradigma.</p>

  
<a name="N1000F"></a><a name="Introducci%C3%B3n+a+Java"></a>
<h2 class="underlined_10">Introducci&oacute;n a Java</h2>
<div class="section">
<p>
<strong>Java</strong> es un lenguaje de programaci&oacute;n creado por <em>Sun Microsystems</em>
         para poder funcionar en distintos tipos de procesadores. Su sintaxis es muy parecida a la de C o C++, e
	 incorpora como propias algunas
caracter&iacute;sticas que en otros lenguajes son extensiones: gesti&oacute;n de hilos, ejecuci&oacute;n 
    remota, etc.   </p>
<p>El c&oacute;digo Java, una   vez compilado, puede 
 llevarse sin modificaci&oacute;n alguna sobre   cualquier m&aacute;quina, 
 y ejecutarlo. Esto se debe a que el c&oacute;digo se ejecuta sobre una m&aacute;quina 
 hipot&eacute;tica o virtual, la <strong>Java   Virtual Machine</strong>, que se encarga 
 de interpretar el c&oacute;digo (ficheros compilados <span class="codefrag">.class</span>) y convertirlo   a c&oacute;digo particular 
 de la CPU que se est&eacute; utilizando (siempre que se soporte dicha m&aacute;quina
virtual).
</p>
<p>Cuando se programa con Java, se dispone de antemano de un conjunto de clases 
  ya implementadas. Estas clases (aparte de las que pueda hacer el usuario) forman 
  parte del propio lenguaje (lo que se conoce como <strong>API</strong> (<em>Application 
  Programming Interface</em>) de Java). </p>
<a name="N1002F"></a><a name="Variables+de+entorno+en+Java"></a>
<h3 class="underlined_5">Variables de entorno en Java</h3>
<p>Para su correcto funcionamiento, Java necesita tener establecidas algunas variables 
  de entorno: las variables <span class="codefrag">PATH</span> y <span class="codefrag">CLASSPATH</span>. </p>
<p>La variable de entorno del sistema <span class="codefrag">PATH</span> deber&aacute; contener la ruta 
  donde se encuentren los programas para compilar y ejecutar (comandos <span class="codefrag">javac</span> 
  y <span class="codefrag">java</span> de la distribuci&oacute;n JDK de Sun, respectivamente). Por ejemplo: 
</p>
<pre class="code">set PATH=%PATH%;C:\jdk1.4\bin		
(Windows)
export PATH=$PATH:/jdk1.4/bin		
(Linux)</pre>
<p>Con la variable <span class="codefrag">CLASSPATH</span> indicamos d&oacute;nde est&aacute;n las clases externas 
  a las de la API que necesitemos para compilar o ejecutar nuestro programa. Cualquier 
  clase necesaria que no pertenezca a la API debe estar inclu&iacute;da en el CLASSPATH 
  para poder compilar o ejecutar (aunque se encuentre en el mismo directorio que 
  la que compilamos). </p>
<p>Podemos incluir todas las clases que hay en un directorio (sin contar los subdirectorios) 
  poniendo la ruta (absoluta o relativa al directorio actual) del directorio. 
  Por ejemplo, si est&aacute;n en <span class="codefrag">\misclases</span> :&nbsp; </p>
<pre class="code">set CLASSPATH=%CLASSPATH%;C:\misclases	
(Windows)
export CLASSPATH=$CLASSPATH:/misclases	
(Linux)</pre>
<p>Si las clases pertenecen a un paquete concreto, se debe apuntar al directorio 
  a partir del cual comienzan los directorios del paquete. Por ejemplo, si la 
  clase <span class="codefrag">MiClase</span> est&aacute; en el paquete <span class="codefrag">unpaquete</span>, dentro de <span class="codefrag">\misclases</span> 
  (<span class="codefrag">\misclases\unpaquete\MiClase.java</span>):</p>
<pre class="code">set CLASSPATH=%CLASSPATH%;C:\misclases	
(Windows)
export CLASSPATH=$CLASSPATH:/misclases	
(Linux)</pre>
<p>Si las clases est&aacute;n empaquetadas en un fichero&nbsp;<em>JAR</em> (veremos 
  a continuaci&oacute;n qu&eacute; es un fichero JAR), se tendr&aacute; que hacer referencia 
  a dicho fichero. Por ejemplo: </p>
<pre class="code">set CLASSPATH=%CLASSPATH%;C:\misclases\misclases.jar
(Windows)
export CLASSPATH=$CLASSPATH:/misclases/misclases.jar
(Linux)</pre>
<p>Tambi&eacute;n podemos incluir en el CLASSPATH el directorio actual:</p>
<pre class="code">set CLASSPATH=%CLASSPATH%;.	
(Windows)
export CLASSPATH=$CLASSPATH:.
(Linux)</pre>
<p>Las expresiones %VARIABLE% (en Windows) o $VARIABLE en (Linux) se utilizan 
  para no sobreescribir el contenido anterior de la variable, sino a&ntilde;adirle lo 
  que se ponga adem&aacute;s de dicha expresi&oacute;n. Los distintos ficheros/directorios asignados 
  a cada variable se separan con ';' (en Windows) o con ':' (en Linux).&nbsp;</p>
<p>La forma de establecer las variables cambia en funci&oacute;n de la versi&oacute;n del sistema 
  operativo. Tambi&eacute;n podremos hacer estas variables permanentes modificando los 
  ficheros de configuraci&oacute;n oportunos (<span class="codefrag">autoexec.bat, .profile</span>, etc), o 
  mediante el panel de control en algunas versiones de Windows.</p>
<a name="N1008C"></a><a name="Compilar+y+ejecutar+clases"></a>
<h3 class="underlined_5">Compilar y ejecutar clases</h3>
<p> Si queremos compilar una clase, se compila con el comando <span class="codefrag">javac</span> (deberemos 
  asegurarnos de que dicho comando est&aacute; accesible en el PATH), seguido del nombre 
  de fichero a compilar:</p>
<pre class="code">javac NombreFichero.java</pre>
<p>Tras haber compilado el ejemplo se tendr&aacute; un fichero <span class="codefrag">NombreFichero.class</span>, 
  y se habr&aacute;n compilado y actualizado (si no lo estaban ya) todas las clases que 
  necesitara la clase compilada.&nbsp; </p>
<p>Una vez compilada la clase, para ejecutarla utilizamos el comando <span class="codefrag">java</span> 
  seguido del nombre de la clase (sin extensi&oacute;n): </p>
<pre class="code">java NombreClase</pre>
<p>Si se quisieran pasar par&aacute;metros al programa, se pasan despu&eacute;s de 
	la clase:</p>
<pre class="code">java NombreClase 20 56 Hola</pre>
<p>Tambi&eacute;n podemos ejecutar un fichero JAR, si contiene una clase principal. Para 
  ello pondremos:</p>
<pre class="code">java -jar Fichero.jar</pre>
<p>A la hora de compilar y ejecutar, es importante respetar las may&uacute;sculas y min&uacute;sculas 
  de los nombres de ficheros y clases, y asegurarnos antes de compilar o ejecutar 
  que el CLASSPATH est&aacute; correctamente establecido para encontrar todas las clases 
  necesarias.</p>
<a name="N100BE"></a><a name="Otros+programas+de+JDK"></a>
<h3 class="underlined_5">Otros programas de JDK</h3>
<p> Adem&aacute;s de los comandos <span class="codefrag">javac</span> y <span class="codefrag">java</span> comentados anteriormente, 
  existen otras aplicaciones &uacute;tiles distribuidas con JDK:</p>
<p> 
<strong>Java Web Start</strong>
</p>
<p>Java Web Start es una herramienta que permite ejecutar aplicaciones Java desde 
  Internet, sin m&aacute;s que pinchar en el enlace de la aplicaci&oacute;n, Java Web Start 
  la descarga a nuestra m&aacute;quina, con todos los componentes necesarios, y nos permite 
  ejecutarla como una aplicaci&oacute;n Java local.</p>
<p>   
	
<img alt="Figura 1. Java Web Start" content-width="8cm" height="317" src="imagenes/lenguaje/jws.gif" width="400"> 
</p>
<p>
<strong><span class="codefrag">javadoc</span></strong>
</p>
<p>
<span class="codefrag">javadoc</span> es una herramienta que permite generar las p&aacute;ginas HTML de documentaci&oacute;n 
  de los ficheros <span class="codefrag">.java</span> que le indiquemos</p>
<p>
<strong><span class="codefrag">appletviewer</span></strong>
</p>
<p>
<span class="codefrag">appletviewer</span>, como veremos m&aacute;s adelante, permite ejecutar applets sin 
  necesidad de disponer de un navegador Web, pas&aacute;ndole como par&aacute;metro la p&aacute;gina 
  HTML a ejecutar</p>
<p>
<strong><span class="codefrag">rmiregistry</span></strong>
</p>
<p>
<span class="codefrag">rmiregistry</span> lanza el registro de RMI, para poder comunicar con objetos 
  en remoto.</p>
<p>
<strong><span class="codefrag">rmid</span></strong>
</p>
<p>
<span class="codefrag">rmid</span> es un demonio que se encarga de la accesibilidad y disponibilidad 
  de los objetos en RMI.</p>
<a name="N1010B"></a><a name="Ficheros+JAR"></a>
<h3 class="underlined_5">Ficheros JAR </h3>
<p>Java dispone de una utilidad que permite empaquetar varias clases en un solo 
  fichero comprimido, de forma que hacemos al conjunto m&aacute;s portable, y se puede 
  acceder a las clases de la misma forma que si estuvieran sueltas en el disco. 
  Estos ficheros comprimidos tienen una extensi&oacute;n <span class="codefrag">.jar</span>, y su comportamiento 
  es similar al de un fichero ZIP o un fichero TAR. </p>
<p>Los ficheros JAR tienen varias ventajas: </p>
<ul>
  
<li> 
<strong>Seguridad</strong>: Los ficheros JAR pueden estar <em>firmados</em> digitalmente, 
    de forma que cuando el usuario conf&iacute;e en la firma podr&aacute; otorgar permisos 
    a la aplicaci&oacute;n.</li>
  
<li> 
<strong>Descarga</strong>: Al estar contenidas todas las clases en un &uacute;nico 
    fichero el tiempo de descarga disminuye, ya que no necesita establecer una 
    conexi&oacute;n por cada fichero por separado. Adem&aacute;s es posible <strong> 
    comprimir</strong> el contenido del fichero JAR siendo esto totalmente transparente 
    a la hora de usar las clases contenidas en &eacute;l.</li>
  
<li> 
<strong>Versiones</strong>: Los ficheros JAR permiten incluir informaci&oacute;n 
    sobre la versi&oacute;n. Adem&aacute;s podemos <strong>sellar</strong> los paquetes 
    contenidos en el fichero JAR, de forma que todo el contenido del paquete deber&aacute; 
    estar dentro del fichero JAR, asegurando as&iacute; la consistencia en las 
    versiones.</li>
  
<li> 
<strong>Portabilidad</strong>: Al ser el mecanismo de los ficheros JAR un est&aacute;ndar 
    de la plataforma Java estos ficheros ser&aacute;n portables a cualquier sistema 
    que cuente con Java. </li>

</ul>
<p>Los ficheros JAR utilizan el formato ZIP, por lo que podremos abrirlos con 
  cualquier aplicaci&oacute;n que trabaje con ficheros ZIP. De todas formas Java 
  incorpora una herramienta para trabajar con estos ficheros JAR, llamada <span class="codefrag">jar</span>. 
  Con ella podremos empaquetar o extraer el contenido de un fichero JAR, y realizar 
  otras operaciones propias de este formato. Para empaquetar una serie de ficheros 
  de entrada en un JAR haremos lo siguiente: </p>
<pre class="code">jar cvf fichero_jar ficheros_de_entrada</pre>
<p>Los par&aacute;metros utilizados significan los siguiente:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
    
<tr> 
      
<td colspan="1" rowspan="1"><span class="codefrag">c</span></td>
      <td colspan="1" rowspan="1">Indica que la acci&oacute;n a realizar es comprimir (empaquetar) una 
        serie de ficheros en un JAR.</td>
    
</tr>
    
<tr> 
      
<td colspan="1" rowspan="1"><span class="codefrag">v</span></td>
      <td colspan="1" rowspan="1">Verbose. Provoca que muestre por pantalla las operaciones que vaya realizando.</td>
    
</tr>
    
<tr> 
      
<td colspan="1" rowspan="1"><span class="codefrag">f</span></td>
      <td colspan="1" rowspan="1">Indica que la salida debe ir a un fichero en lugar de a la salida est&aacute;ndar. 
        Este fichero es el que especificamos como par&aacute;metro fichero_jar.</td>
    
</tr>

</table>
<p>Ahora podemos visualizar el contenido de nuestro fichero JAR cambiando el par&aacute;metro 
  de la acci&oacute;n a realizar por <span class="codefrag">t</span>. </p>
<pre class="code">jar tf fichero_jar</pre>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
    
<tr> 
      
<td colspan="1" rowspan="1"><span class="codefrag">t</span></td>
      <td colspan="1" rowspan="1">Indica que la acci&oacute;n a realizar es comprobar (test) el contenido 
        del JAR, mostrando todos los ficheros que contiene.</td>
    
</tr>

</table>
<p>Si hacemos esto veremos que adem&aacute;s de los ficheros especificados dentro 
  del JAR de ha incluido el fichero <span class="codefrag">META-INF/MANIFEST.MF</span>. Este fichero 
  de <em>manifiesto</em> est&aacute; incluido en todos los JAR, y contiene informaci&oacute;n 
  sobre su contenido. </p>
<p>Podemos ahora extraer todo el contenido del JAR cambiando el comando de acci&oacute;n 
  por <span class="codefrag">x</span>. </p>
<pre class="code">jar xvf fichero_jar</pre>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
    
<tr> 
      
<td colspan="1" rowspan="1"><span class="codefrag">x</span></td>
      <td colspan="1" rowspan="1">Indica que la acci&oacute;n a realizar es extraer el contenido del JAR.</td>
    
</tr>

</table>
<p>Con esto se extraer&aacute;n todos los ficheros, incluido el manifiesto, pudiendo 
  as&iacute; editar dicho fichero con cualquier editor ASCII. En este caso veremos 
  el manifiesto por defecto que se incluye en los ficheros JAR. Podemos a&ntilde;adir 
  l&iacute;neas al manifiesto , para ello deberemos crear un fichero con la informaci&oacute;n 
  que queramos a&ntilde;adir, e incluirlo al crear el JAR para que a la l&iacute;neas 
  por defecto, a&ntilde;ada los datos que nosotros hayamos incluido. Esto lo haremos 
  con: </p>
<pre class="code">jar cmf fichero_manifiesto fichero_jar ficheros_de_entrada</pre>
<p>Para trabajar con <em>manifiestos </em>tenemos los siguientes par&aacute;metros: 
	&nbsp;</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
	
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
	<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
    
<tr> 
      
<td colspan="1" rowspan="1"><span class="codefrag">M</span>&nbsp;</td>
      <td colspan="19" rowspan="1">Indica que no se debe incluir el manifiesto por defecto.</td>
    
</tr>
    
<tr> 
      
<td colspan="1" rowspan="1"><span class="codefrag">m</span></td>
      <td colspan="19" rowspan="1">Indica que se deben a&ntilde;adir las l&iacute;neas del fichero manifiesto 
        que especifique el usuario.</td>
    
</tr>

</table>
<p>Una vez tengamos nuestras clases empaquetadas en un fichero JAR, para utilizarlas 
  bastar&aacute; con tener incluido el fichero JAR en el CLASSPATH. De esta forma 
  las clases ser&aacute;s accesibles de la misma forma que si estuviesen directamente 
  en el CLASSPATH sin empaquetar. Para a&ntilde;adir un fichero JAR al CLASSPATH 
  tendremos que incluir el fichero JAR con su ruta absoluta en esta variable de 
  entorno:</p>
<pre class="code">SET CLASSPATH=%CLASSPATH%;c:\ruta\fichero.jar</pre>
<p>Tambi&eacute;n podemos indicar el CLASSPATH del fichero JAR directamente en 
  la l&iacute;nea de comandos al ejecutar nuestra aplicaci&oacute;n <span class="codefrag">ClasePrincipal</span>:</p>
<pre class="code">java -cp c:\ruta\fichero.jar ClasePrincipal</pre>
<p>En el caso de que empaquetemos una aplicaci&oacute;n, podremos definir una 
  clase principal de forma que el fichero JAR sea autoejecutable simplemente escribiendo: 
</p>
<pre class="code">java -jar fichero_jar</pre>
<p>Adem&aacute;s, en Windows al hacer doble click sobre este fichero JAR tambi&eacute;n 
  se ejecutar&aacute;, ya que este tipo de ficheros estar&aacute;n asociados con 
  el int&eacute;rprete Java. Para hacer este JAR ejecutable deberemos definir 
  cu&aacute;l es la clase principal que se va a ejecutar, cosa que haremos en 
  el fichero <em>manifiesto</em>. Para ello deberemos incluir un fichero <em> manifiesto</em> 
  que a&ntilde;ada la l&iacute;nea: </p>
<pre class="code">Main-Class: MiClasePrincipal</pre>
<p>En el caso de los <em>Applets</em>, para cargar un <em>Applet</em> desde un JAR 
  deberemos especificar el fichero JAR en el atributo ARCHIVE del tag APPLET, 
  como se muestra a continuaci&oacute;n: </p>
<pre class="code">&lt;applet code=MiApplet.class
		archive="AppletJAR.jar"&gt;
&lt;/applet&gt;</pre>
<a name="N10256"></a><a name="Extensiones+de+Java"></a>
<h3 class="underlined_5">Extensiones de Java </h3>
<p>A partir de JDK 1.2 se incorpora un mecanismo de extensiones que permite a&ntilde;adir 
  nuevas funcionalidades al n&uacute;cleo de la plataforma Java. Existen extensiones 
  desarrolladas por Sun, como Java 3D y Javamail, pero adem&aacute;s cualquier 
  usuario puede desarrollar sus propias extensiones. </p>
<p>El mecanismo de extensiones proporciona escalabilidad a Java, permitiendo hacer 
  que nuestra propia API est&eacute; disponible para cualquier aplicaci&oacute;n. 
</p>
<p>Las extensiones son grupos de paquetes y clases que a&ntilde;aden funcionalidades 
  a la plataforma Java, y que ser&aacute;n incluidas mediante el mecanismo de 
  extensiones de Java. Este mecanismo permite que las extensiones definidas sean 
  accesibles por cualquier aplicaci&oacute;n sin necesidad de establecer el CLASSPATH, 
  como si se tratase de las clases del n&uacute;cleo de Java. De hecho, estas 
  extensiones lo que hacen es extender la API del n&uacute;cleo. </p>
<p>Gracias a este mecanismo podremos obtener e instalar extensiones que ampl&iacute;en 
  la API del n&uacute;cleo de la plataforma Java, bien sean extensiones desarrolladas 
  por Sun o por terceros, o bien crear nuestras propias extensiones. Esto nos 
  permitir&aacute; ampliar la API seg&uacute;n nuestras necesidades, y adem&aacute;s 
  facilitar&aacute; la distribuci&oacute;n de nuestras propias librer&iacute;as 
  de clases, que cualquier usuario podr&aacute; instalar y utilizar f&aacute;cilmente 
  sin preocuparse del lugar donde ubicar las clases y de establecer las variables 
  de entorno necesarias. </p>
<p>Para la creaci&oacute;n de nuestras propias extensiones necesitaremos empaquetar 
  todas las clases de nuestra extensi&oacute;n en un fichero JAR. </p>
<p>Lo primero que deberemos hacer cuando queramos crear un extensi&oacute;n es 
  seleccionar todos los paquetes y clases que formar&aacute;n parte de la API 
  de nuestra extensi&oacute;n y empaquetarlos en un &uacute;nico fichero JAR. 
</p>
<p>Una vez tengamos el fichero JAR, deberemos a&ntilde;adirlo como extensi&oacute;n. 
  Para ello deberemos copiar el JAR dentro del directorio del JRE (Java Runtime 
  Environment), en el subdirectorio <span class="codefrag">lib/ext</span>. JDK incluye JRE como un subdirectorio 
  suyo, por lo que en este caso la ruta completa donde habr&aacute; que incluir 
  los JAR ser&aacute;: </p>
<pre class="code">{java.home}/jre/lib/ext/</pre>
<p>Con esto la extensi&oacute;n se habr&aacute; incluido en la plataforma Java 
  instalada en nuestra m&aacute;quina, permitiendo que cualquier programa Java 
  que se ejecute en ella pueda utilizarla directamente. Es lo que se conoce como 
  extensi&oacute;n <em>instalada</em>. </p>
<p>Existe otro tipo de extensiones, que no veremos, que se llaman <em>descargadas</em>. 
  Estas no se copian al directorio anteriormente citado, sino que se descargan 
  de internet (&uacute;tiles por ejemplo a la hora de trabajar con applets alojados en 
  un servidor remoto). </p>
<p>En la p&aacute;gina de Sun podemos encontrar una larga lista de extensiones 
  de Java desarrolladas por ellos, que podremos descargar e instalar ampliando 
  de esta manera la API de Java. Las principales extensiones disponibles son: 
</p>
<ul>
  
<li>
<strong>Java Communications</strong>: Esta API puede ser utilizada para hacer aplicaciones 
    de comunicaciones (voz, fax, etc) independientes de la plataforma. Nos permitir&aacute; 
    el acceso a los puertos serie y paralelo.</li>
  
<li>
<strong>Javamail</strong>: Proporciona una serie de clases que permitir&aacute;n construir 
    nuestro propio sistema de correo y mensajer&iacute;a utilizando tecnolog&iacute;a 
    Java. Incorpora un proveedor de servicio POP3.</li>
  
<li>
<strong>Java 3D</strong>: Nos permitir&aacute; incluir de forma sencilla e independiente 
    de la plataforma gr&aacute;ficos 3D en nuestras aplicaciones. Incorpora una 
    sencilla interfaz de alto nivel que nos permitir&aacute; definir mundos 3D 
    y controlar el render y la conducta de los objetos 3D.</li>
  
<li>
<strong>Java Media Framework</strong>: Permite incorporar a nuestras aplicaciones 
    y <em>Applets</em> elementos multimedia, como puede ser audio y video. Con esta 
    API podremos reproducir, capturar y trabajar con flujos (streaming) de varios 
    tipos de medios.</li>
  
<li>
<strong>Java Advanced Imaging</strong>: Esta API proporciona funcionalidades para 
    el procesamiento de im&aacute;genes con un alto rendimiento, de forma independiente 
    a la plataforma. Proporciona una interfaz orientada a objetos que permite 
    manipular im&aacute;genes de forma sencilla.</li>
  
<li>
<strong>JavaBeans Activation Framework</strong>: Permite averiguar el tipo de unos 
    datos determinados (por ejemplo una imagen), encapsular el acceso a estos 
    datos y averiguar las operaciones que podemos hacer con ellos, pudiendo instanciar 
    el <em>bean </em>correspondiente para realizar estas operaciones.</li>
  
<li>
<strong>Infobus</strong>: Permite la comunicaci&oacute;n entre JavaBeans, definiendo 
    una serie de interfaces entre los <em>beans </em>que colaboran y un protocolo 
    de comunicaciones para estas interfaces.</li>
  
<li>
<strong>Java Cryptography Extension</strong>: Consiste en una serie de paquetes que 
    proporcionan funcionalidades de encriptaci&oacute;n y generaci&oacute;n de 
    claves.</li>
  
<li>
<strong>JavaHelp</strong>: Permite a los desarrolladores incorporar ayuda en l&iacute;nea 
    a los programas que realicen, de forma independiente de la plataforma.</li>

</ul>
<a name="N102C1"></a><a name="B%C3%BAsqueda+de+clases+en+Java"></a>
<h3 class="underlined_5">B&uacute;squeda de clases en Java</h3>
<p>Con lo visto hasta ahora, cuando intentemos compilar o ejecutar un programa, 
  Java buscar&aacute; las clases necesarias en el siguiente orden: </p>
<ol>
  
<li> Clases principales de Java (que pertenezcan a la API, y que se encuentran 
    en los ficheros rt.jar, i18n.jar).</li>
  
<li> Extensiones instaladas</li>
  
<li> Classpath</li>

</ol>
</div>

<a name="N102D8"></a><a name="Entorno+de+desarrollo+Eclipse"></a>
<h2 class="underlined_10">Entorno de desarrollo Eclipse</h2>
<div class="section">
<p>Eclipse es una herramienta que permite integrar diferentes tipos de <strong>aplicaciones</strong>. 
  La aplicaci&oacute;n principal es el JDT (<em>Java Development Tooling</em>), un IDE 
  para crear programas en Java. Otras aplicaciones, que no vienen con la distribuci&oacute;n 
  est&aacute;ndar de Eclipse, se a&ntilde;aden al mismo en forma de <strong><em>plugins</em></strong>, y 
  son reconocidos autom&aacute;ticamente por la plataforma.</p>
<p>Adem&aacute;s, Eclipse tiene su propio mecanismo de gesti&oacute;n de <strong>recursos</strong>. Los 
  recursos son ficheros en el disco duro, que se encuentran alojados en un espacio 
  de trabajo (<em>workspace</em>), un directorio especial en el sistema. As&iacute;, si 
  una aplicaci&oacute;n de Eclipse modifica un recurso, dicho cambio es notificado al 
  resto de aplicaciones de Eclipse, para que lo tengan en cuenta.</p>
<a name="N102F4"></a><a name="Instalaci%C3%B3n+y+ejecuci%C3%B3n"></a>
<h3 class="underlined_5">Instalaci&oacute;n y ejecuci&oacute;n</h3>
<p>Para instalar Eclipse se <strong>requiere</strong>:</p>
<ul>
  
<li>Sistema operativo Windows, Linux, Solaris, QNX o Mac OS/X, con 256 MB de 
    RAM preferiblemente.</li>
  
<li>JDK o JRE versi&oacute;n 1.3 o posterior. Se recomienda al menos la versi&oacute;n 1.4.1.</li>
  
<li>Los archivos de eclipse para instalar (en un archivo ZIP, o como vengan 
    distribuidos)</li>

</ul>
<p>Para la <strong>instalaci&oacute;n</strong>, se siguen los pasos:</p>
<ul>
  
<li>Instalar JRE o JDK</li>
  
<li>Descomprimir los archivos de Eclipse al lugar deseado del disco duro (p. 
    ej, a <span class="codefrag">C:\eclipse</span>). El directorio en que se instale lo identificaremos 
    de ahora en adelante como <span class="codefrag">ECLIPSE_HOME</span>. En Windows Eclipse detecta 
    autom&aacute;ticamente un JRE o JDK instalado, aunque tambi&eacute;n se lo podemos proporcionar 
    copiando el directorio <span class="codefrag">jre</span> en <span class="codefrag">ECLIPSE_HOME</span>. Otra opci&oacute;n es proporcionar, 
    al ejecutar Eclipse, la ruta hacia JRE o JDK, mediante una opci&oacute;n <span class="codefrag">-vm</span>:</li>

</ul>
<pre class="code">eclipse -vm ruta_jdk_jre</pre>
<p>Para arrancar Eclipse se tiene el ejecutable <span class="codefrag">eclipse.exe</span> o <span class="codefrag">eclipse.sh</span> 
  en <span class="codefrag">ECLIPSE_HOME</span>. La pantalla inicial de Eclipse aparecer&aacute; tras unos segundos:</p>
<p>       
	
<img alt="Figura 1. Pantalla inicial de Eclipse" content-width="8cm" height="300" src="imagenes/lenguaje/eclipse_inicio.gif" width="400">
 </p>
<p>Veremos las opciones principales con detalle m&aacute;s adelante. De los men&uacute;s, entre 
  otros, pueden resultar interesantes:</p>
<ul>
  
<li>
<strong>File</strong>: 
    <ul>
      
<li>
<strong>New</strong>: para crear nuevos proyectos, paquetes, clases Java, etc.</li>
      
<li>
<strong>Import / Export</strong>: para importar o exportar recursos con un determinado 
        formato (por ejemplo, exportar un proyecto como un fichero JAR).</li>
    
</ul>
  
</li>
  
<li>
<strong>Project</strong>: 
    <ul>
      
<li>
<strong>Open / Close Project</strong>: para abrir o cerrar el proyecto actual</li>
      
<li>
<strong>Rebuild Project</strong>: recompila el proyecto actual</li>
      
<li>
<strong>Rebuild All</strong>: recompila todos los proyectos</li>
      
<li>
<strong>Generate Javadoc</strong>: genera el <em>javadoc</em> para las clases del 
        proyecto</li>
    
</ul>
  
</li>
  
<li>
<strong>Run</strong>:&nbsp; 
    <ul>
      
<li>
<strong>Run As</strong>: permite indicar c&oacute;mo queremos ejecutar un proyecto (por 
        ejemplo, como una aplicaci&oacute;n Java normal, como un applet, como un test 
        de JUnit, etc).</li>
      
<li>
<strong>Run</strong>: ejecuta el proyecto de la forma que hayamos indicado en 
        <em>Run As</em>. Permite seleccionar la clase principal a ejecutar, los 
        par&aacute;metros del <span class="codefrag">main(...)</span>, etc</li>
    
</ul>
  
</li>
  
<li>
<strong>Window</strong>: 
    <ul>
      
<li>
<strong>Open Perspective</strong>: para abrir una determinada perspectiva (por 
        ejemplo, la perspectiva <em>Java</em>, que ser&aacute; la que nos interese normalmente).</li>
      
<li>
<strong>Show View</strong>: permite a&ntilde;adir/quitar vistas a la perspectiva actual. 
        Lo veremos tambi&eacute;n m&aacute;s adelante.</li>
      
<li>
<strong>Preferences</strong>: opciones de configuraci&oacute;n general. Algunas de ellas 
        se explicar&aacute;n con detalle m&aacute;s adelante.</li>
    
</ul>
  
</li>

</ul>
<a name="N103AE"></a><a name="Configuraci%C3%B3n+visual"></a>
<h3 class="underlined_5">Configuraci&oacute;n visual</h3>
<p>
<strong>Perspectivas, vistas y editores</strong>
</p>
<p>El usuario trabaja con Eclipse mediante el entorno gr&aacute;fico que se le presenta. 
  Seg&uacute;n la perspectiva que elija, se establecer&aacute; la apariencia de dicho entorno. 
  Entendemos por <strong><em>perspectiva</em></strong> una colecci&oacute;n de <strong><em>vistas</em></strong> 
  y <strong><em>editores</em></strong>, con sus correspondientes acciones especiales en men&uacute;s 
  y barras de herramientas. Algunas vistas muestran informaci&oacute;n especial sobre 
  los recursos, y dependiendo de las mismas, en ocasiones s&oacute;lo se mostrar&aacute;n algunas 
  partes o relaciones internas de dichos recursos. Un editor trabaja directamente 
  sobre un recurso, y s&oacute;lo cuando grabe los cambios sobre el recurso se notificar&aacute; 
  al resto de aplicaciones de Eclipse sobre estos cambios. Las vistas especiales 
  se pueden conectar a editores (no a recursos), por ejemplo, la vista de estructura 
  (<em>outline view</em>) se puede conectar al editor Java. De este modo, una de 
  las caracter&iacute;sticas importantes de Eclipse es la flexibilidad para combinar 
  vistas y editores.</p>
<p>Si queremos <strong>abrir una determinada perspectiva</strong>, vamos a <em>Window -&gt; 
  Open Perspective</em>. Eligiendo luego <em>Other</em> podemos elegir entre todas 
  las perspectivas disponibles:</p>
<p>       
	
<img alt="Figura 2. Abrir una perspectiva en Eclipse" content-width="4cm" height="220" src="imagenes/lenguaje/eclipse_perspective.gif" width="200">
 </p>
<p>Para <strong>a&ntilde;adir vistas a una perspectiva</strong>, primero abrimos la perspectiva, 
  y luego vamos a <em>Window -&gt; Show View </em>y elegimos la que queramos cargar:</p>
<p>    
	
<img alt="Figura 3. Elegir una vista en una perspectiva" content-width="6cm" height="229" src="imagenes/lenguaje/eclipse_view.gif" width="300">
</p>
<p>
<strong>Apariencia</strong>
</p>
<p>Arrastrando la barra de t&iacute;tulo de una vista o editor, podemos moverlo a otro 
  lugar de la ventana (lo podremos colocar en las zonas donde el cursor del rat&oacute;n 
  cambie a una flecha negra), o tabularlo con otras vistas o editores (arrastrando 
  hasta el t&iacute;tulo de dicha vista o editor, el cursor cambia de aspecto, y se ve 
  como una lista de carpetas, soltando ah&iacute; la vista o editor que arrastramos, 
  se tabula con la(s) que hay donde hemos soltado).</p>
<a name="N103FB"></a><a name="Configuraci%C3%B3n+general"></a>
<h3 class="underlined_5">Configuraci&oacute;n general</h3>
<p>Desde el men&uacute; <strong>Window - Preferences </strong>podemos establecer opciones de configuraci&oacute;n 
  de los distintos aspectos de Eclipse:</p>
<p>    
	
<img alt="Figura 4. Configuraci&oacute;n general de Eclipse" content-width="8cm" height="342" src="imagenes/lenguaje/eclipse_pref_1.gif" width="400">
</p>
<p>
<strong>Establecer directorios para ficheros fuente o ficheros objeto</strong>
</p>
<p>Podemos elegir entre tener nuestro c&oacute;digo fuente en el mismo lugar que nuestras 
  clases objeto compiladas, o bien elegir directorios diferentes para fuentes 
  y objetos. Para ello tenemos, dentro del men&uacute; de configuraci&oacute;n anterior, la 
  opci&oacute;n <em>Java - New Project</em>. En el cuadro <em>Source and output folder</em> 
  podremos indicar si queremos colocarlo todo junto (marcando <em>Project</em>) 
  o indicar un directorio para cada cosa (marcando <em>Folders</em>, y eligiendo 
  el subdirectorio adecuado para cada uno):</p>
<p>       
	
<img alt="Figura 5. Establecimiento de los directorios fuente y objeto" content-width="8cm" height="250" src="imagenes/lenguaje/eclipse_pref_2.gif" width="400"> 
 </p>
<p>
<strong>Establecer la versi&oacute;n de JDK o JRE</strong>
</p>
<p>Para cambiar el compilador a una versi&oacute;n concreta de Java, elegimos la opci&oacute;n 
  de <em>Java</em> y luego <em>Compiler</em>. Pulsamos en la pesta&ntilde;a <em>Compliance 
  and Classfiles</em> y elegimos la opci&oacute;n <em>1.4</em> (o la que sea) de la lista 
  <em>Compiler compliance level</em>:</p>
<p>       
	
<img alt="Figura 6. Establecer la versi&oacute;n del compilador" content-width="8cm" height="309" src="imagenes/lenguaje/eclipse_pref_3.gif" width="400">
 </p>
<p>Tambi&eacute;n podemos utilizar JDK en lugar de JRE para ejecutar los programas. Para 
  ello vamos a <em>Java - Installed JREs</em>, elegimos la l&iacute;nea <em>Standard VM</em> 
  y pulsamos en <em>Edit </em>o en <em>Add</em>, seg&uacute;n si queremos modificar el que 
  haya establecido, o a&ntilde;adir nuevas opciones.</p>
<p>       
	
<img alt="Figura 7. Establecer el compilador, o a&ntilde;adir nuevos" content-width="8cm" height="255" src="imagenes/lenguaje/eclipse_pref_4.gif" width="400">
 </p>
<p>Se nos abre un cuadro de di&aacute;logo para editar valores. Pulsando en <em>Browse</em> 
  elegimos el directorio de JDK (por ejemplo, <span class="codefrag">C:\j2sdk1.4.0</span>).</p>
<p>       
	
<img alt="Figura 8. Editar los valores de JDK o JRE" content-width="8cm" height="353" src="imagenes/lenguaje/eclipse_pref_5.gif" width="400">
 </p>
<p>
<strong>Especificar variables de entorno (CLASSPATH)</strong>
</p>
<p>Podemos a&ntilde;adir variables de entorno en Eclipse, cada una conteniendo un directorio, 
  fichero JAR o fichero ZIP. Para a&ntilde;adir variables vamos a la opci&oacute;n&nbsp; <em>Java</em> 
  - <em>Classpath Variables</em>.</p>
<p>   
	
<img alt="Figura 9. Variables de classpath" content-width="8cm" height="250" src="imagenes/lenguaje/eclipse_pref_6.gif" width="400">
 </p>
<p>Pulsamos el bot&oacute;n de <em>New</em> para a&ntilde;adir una nueva, y le damos un nombre, 
  y elegimos el fichero JAR o ZIP (pulsando en <em>File</em>) o el directorio (pulsando 
  en <em>Folder</em>).</p>
<p>   
    
<img alt="Figura 10. Establecer el valor de la nueva variable" content-width="6cm" height="148" src="imagenes/lenguaje/eclipse_pref_7.gif" width="300">
 </p>
<a name="N104A8"></a><a name="Primeros+pasos+con+Eclipse"></a>
<h3 class="underlined_5">Primeros pasos con Eclipse</h3>
<p>
<strong>Espacio de trabajo</strong>
</p>
<p>Por defecto el espacio de trabajo (<em>workspace</em>) para Eclipse es el directorio 
  <span class="codefrag">ECLIPSE_HOME/workspace</span>. Podemos elegir un directorio arbitrario lanzando 
  eclipse con una opci&oacute;n <span class="codefrag">-data</span> que indique cu&aacute;l es ese directorio, por 
  ejemplo:</p>
<pre class="code">eclipse -data C:\misTrabajos</pre>
<p>Si no indicamos el espacio de trabajo mediante esta opci&oacute;n, Eclipse 
  nos preguntar&aacute; qu&eacute; espacio de trabajo queremos utilizar en la 
  siguiente ventana:</p>
<p>   

<img alt="Espacio de trabajo" content-width="6cm" height="172" src="imagenes/lenguaje/eclipse_workspace.gif" width="300">
 </p>
<p>Tambi&eacute;n podemos crear nuestros proyectos y trabajos fuera del <em>workspace</em> 
  si queremos, podemos tomarlo simplemente como un directorio opcional donde organizar 
  nuestros proyectos.</p>
<p>
<strong>Nuevo proyecto</strong>
</p>
<p>Lo primero que debemos hacer para empezar a desarrollar una nueva aplicaci&oacute;n 
  es crear un proyecto Java en Eclipse. Para ello seleccionamos la opci&oacute;n 
  del men&uacute; <em>File &gt; New &gt; Project ...</em>
</p>
<p>   

<img alt="Nuevo proyecto" content-width="8cm" height="300" src="imagenes/lenguaje/eclipse_proy_1.jpg" width="400">
 </p>
<p>Dentro de la ventana de nuevo proyecto, seleccionamos <em>Java Project </em>y 
  pulsamos <em>Next</em>. </p>
<p>   

<img alt="Nombre del proyecto" content-width="5cm" height="250" src="imagenes/lenguaje/eclipse_proy_2.jpg" width="250">
 </p>
<p>En la siguiente pantalla deberemos dar un nombre al proyecto para identificarlo 
  dentro de Eclipse. Por defecto crear&aacute; el directorio para este proyecto 
  dentro del espacio de trabajo de Eclipse. Si queremos crearlo en otro directorio 
  desmarcaremos la casilla <em>Use default</em>. </p>
<p>Cuando hayamos introducido esta informaci&oacute;n pulsamos sobre <em>Next</em>.</p>
<p>   

<img alt="Configuraci&oacute;n del directorio de trabajo" content-width="5cm" height="253" src="imagenes/lenguaje/eclipse_proy_3.jpg" width="250">
 </p>
<p>En la siguiente pantalla configuraremos la estructura de nuestro directorio 
  de desarrollo y las librer&iacute;as externas utilizadas. </p>
<p>Lo primero que vamos a hacer es configurar el directorio de fuentes, donde 
  se almacenar&aacute;n estos ficheros. En este ejemplo guardaremos los fuentes 
  en <span class="codefrag">src</span>. Pulsaremos sobre<em> Add folder...</em> para a&ntilde;adir 
  este directorio.</p>
<p>   

<img alt="Directorio de fuentes" content-width="5cm" height="254" src="imagenes/lenguaje/eclipse_proy_4.jpg" width="250">
 </p>
<p>Aparecer&aacute; la siguiente ventana. Como todav&iacute;a no existe el directorio 
  <span class="codefrag">src</span>, deberemos crearlo pulsando sobre <em>Create New Folder...</em>
</p>
<p>   

<img alt="Crear nuevo directorio" content-width="4cm" height="215" src="imagenes/lenguaje/eclipse_proy_5.jpg" width="174">
 </p>
<p>En la siguiente ventana introduciremos el nombre del directorio a crear (<span class="codefrag">src</span>), 
  y pulsamos sobre <em>OK</em> para que lo cree.</p>
<p>   

<img alt="Agregar directorio como directorio de fuentes" content-width="3cm" height="86" src="imagenes/lenguaje/eclipse_proy_6.jpg" width="155">
 </p>
<p>De esta forma volver&aacute; a la pantalla anterior donde tendremos ya el directorio 
  <span class="codefrag">src</span> creado. Seleccionamos este directorio y pulsamos sobre <em>OK</em> 
  para a&ntilde;adirlo como directorio de fuentes.</p>
<p>   

<img alt="Cambiar directorio de salida" content-width="4cm" height="215" src="imagenes/lenguaje/eclipse_proy_7.jpg" width="174">
 </p>
<p>Nos preguntar&aacute; si queremos eliminar el directorio ra&iacute;z del proyecto 
  como directorio de fuentes y utilizar s&oacute;lo <span class="codefrag">src</span> para tal 
  fin, y generar las clases compiladas en el directorio <span class="codefrag">bin</span>. Pulsaremos 
  sobre <em>Yes</em>.</p>
<p>   

<img alt="Directorio de trabajo configurado" content-width="5cm" height="73" src="imagenes/lenguaje/eclipse_proy_8.jpg" width="221">
 </p>
<p>De esta forma veremos en la pantalla de configuraci&oacute;n del proyecto el 
  directorio <span class="codefrag">src</span> como &uacute;nico directorio de fuentes de la aplicaci&oacute;n, 
  y <span class="codefrag">bin</span> como directorio de salida. Ahora vamos a cambiar a la pesta&ntilde;a 
  <em>Libraries</em> para configurar las librer&iacute;as externas que vamos a 
  necesitar tener en el <em>classpath</em> para nuestro proyecto.</p>
<p>   

<img alt="Configuraci&oacute;n de librer&iacute;as" content-width="5cm" height="254" src="imagenes/lenguaje/eclipse_proy_9.jpg" width="250">
 </p>
<p>En esta pesta&ntilde;a a&ntilde;adiremos librer&iacute;as JAR al <em>classpath</em> 
  pulsando sobre <em>Add External JARs ...</em>
</p>
<p>   

<img alt="A&ntilde;adir JAR externo" content-width="5cm" height="254" src="imagenes/lenguaje/eclipse_proy_10.jpg" width="250"> 
 </p>
<p>Deberemos seleccionar los ficheros JAR que queremos a&ntilde;adir al <em>classpath</em>. 
  Por ejemplo, si queremos desarrollar Servlets, deberemos incluir la librer&iacute;a 
  de servlets <span class="codefrag">servlet.jar</span> en esta lista.</p>
<p>   

<img alt="Seleccionar librer&iacute;as a agregar" content-width="6cm" height="210" src="imagenes/lenguaje/eclipse_proy_11.jpg" width="281">
 </p>
<p>Una vez tengamos esta librer&iacute;a incluida se mostrar&aacute; en la lista 
  como se puede ver a continuaci&oacute;n. Ahora ya podemos pulsar sobre <em>Finish</em> 
  para que se cree el proyecto con los datos que hemos introducido.</p>
<p>   

<img alt="Creaci&oacute;n de proyecto finalizada" content-width="5cm" height="253" src="imagenes/lenguaje/eclipse_proy_12.jpg" width="250">
 </p>
<p>
<strong>Crear directorios y ficheros</strong>
</p>
<p>Una vez creado el proyecto, podremos crear directorios y ficheros dentro de 
  nuestro directorio de desarrollo. Por ejemplo, si queremos crear una web para 
  nuestro proyecto, podremos crear un directorio <span class="codefrag">web</span> donde guardaremos 
  los documentos HTML.</p>
<p>Pulsando con el bot&oacute;n derecho sobre nuestro proyecto en el explorador 
  de paquetes se abrir&aacute; un men&uacute; contextual con el que podremos crear 
  un nuevo directorio. Para ello pulsaremos sobre la opci&oacute;n <em>New &gt; 
  Folder</em>.</p>
<p>   

<img alt="Crear nuevo directorio" content-width="8cm" height="300" src="imagenes/lenguaje/eclipse_dir_1.jpg" width="400">
 </p>
<p>Aparecer&aacute; la siguiente pantalla donde deberemos introducir el nombre 
  del directorio que vamos a crear. Por ejemplo podemos crear de esta forma el 
  directorio <span class="codefrag">web</span> donde introduciremos todos los ficheros HTML.</p>
<p>   

<img alt="Nombre del nuevo directorio" content-width="5cm" height="289" src="imagenes/lenguaje/eclipse_dir_2.jpg" width="219">
 </p>
<p>Una vez tengamos la estructura de directorios necesaria, podemos crear ficheros 
  gen&eacute;ricos de texto. De esta forma podremos crear por ejemplo cualquier 
  fichero HTML o XML que queramos a&ntilde;adir a la aplicaci&oacute;n. Para crear 
  un fichero gen&eacute;rico de texto pulsaremos sobre la opci&oacute;n <em>New 
  &gt; File </em>del men&uacute; contextual como se muestra a continuaci&oacute;n:</p>
<p>   

<img alt="Crear nuevo fichero" content-width="8cm" height="300" src="imagenes/lenguaje/eclipse_fich_1.jpg" width="400">
 </p>
<p>En la siguiente ventana introduciremos el nombre del fichero a crear. Por ejemplo, 
  podemos crear un fichero <span class="codefrag">web.xml</span>, con la configuraci&oacute;n de 
  nuestra aplicaci&oacute;n web.</p>
<p>   

<img alt="Nombre del nuevo fichero" content-width="5cm" height="289" src="imagenes/lenguaje/eclipse_fich_2.jpg" width="219">
 </p>
<p>Una vez creado el fichero, podremos abrirlo en el editor de texto de Eclipse 
  para escribir su contenido. Introduciremos en este editor el contenido de este 
  XML y grabaremos el fichero pulsando sobre el icono <em>Guardar</em>.</p>
<p>   

<img alt="Editar el fichero creado" content-width="8cm" height="300" src="imagenes/lenguaje/eclipse_fich_3.jpg" width="400">
 </p>
<p>De la misma forma podemos crear cualquier otro fichero de texto para nuestra 
  aplicaci&oacute;n, como p&aacute;ginas HTML y JSP. </p>
<p>
<strong>Crear una nueva clase</strong>
</p>
<p>Para crear una nueva clase en nuestra aplicaci&oacute;n pulsaremos sobre <em>New 
  &gt; Class</em>.</p>
<p>   

<img alt="Crear una nueva clase Java" content-width="8cm" height="279" src="imagenes/lenguaje/eclipse_class_1.jpg" width="400">
 </p>
<p>Se mostrar&aacute; la siguiente pantalla donde introduciremos los datos de 
  la nueva clase a crear. Deberemos introducir el paquete y el nombre de la clase. 
  Si queremos que la clase herede de otra, o implemente una serie de interfaces, 
  deberemos especificarlo en los campos <em>Superclass</em> e <em>Interfaces</em>. 
  Por ejemplo, si estamos desarrollando un Servlet deberemos heredar de la clase 
  <span class="codefrag">HttpServlet</span>. Para seleccionar est&aacute; superclase podemos pulsar 
  sobre el bot&oacute;n <em>Browse ...</em> junto al campo <em>Superclass</em>.</p>
<p>   

<img alt="Configuraci&oacute;n de la nueva clase" content-width="5cm" height="277" src="imagenes/lenguaje/eclipse_class_2.jpg" width="247"> 
 </p>
<p>Se mostrar&aacute; la siguiente ventana para explorar las clases. Introduciendo 
  en el campo de texto superior una parte del nombre de la clase que buscamos, 
  por ejemplo <em>'HttpServlet'</em>, nos mostrar&aacute; la lista de todas las 
  clases que coincidan con ese nombre. Seleccionaremos de la lista la clase que 
  buscamos (<span class="codefrag">HttpServlet</span>) y pulsamos <em>OK</em>.</p>
<p>   

<img alt="Explorar posibles superclases" content-width="3cm" height="240" src="imagenes/lenguaje/eclipse_class_3.jpg" width="150"> 
 </p>
<p>Entonces aparecer&aacute; el nombre completo de la clase seleccionada en el 
  campo <em>Superclass</em> de la ventana anterior. Ya podremos pulsar sobre <em>Finish</em> 
  para crear la clase.</p>
<p>   

<img alt="Creaci&oacute;n de la nueva clase finalizada" content-width="5cm" height="278" src="imagenes/lenguaje/eclipse_class_4.jpg" width="247"> 
 </p>
<p>Eclipse crear&aacute; autom&aacute;ticamente el esqueleto de esta clase y podremos 
  modificarlo en el editor. Este editor nos ofrecer&aacute; facilidades como autocompletar 
  los nombres de los m&eacute;todos, y revisar la sintaxis del c&oacute;digo conforme 
  lo escribimos. </p>
<p>En el caso de que estemos implementando un Servlet, deberemos sobrescribir 
  el m&eacute;todo <span class="codefrag">doGet</span> de esta clase. Para sobrescribir m&eacute;todos 
  de clases de las que heredamos abriremos el men&uacute; contextual sobre el 
  &aacute;rea de edici&oacute;n de c&oacute;digo, y seleccionamos la opci&oacute;n 
  <em>Source &gt; Override/Implement Methods ...</em>
</p>
<p>   

<img alt="Sobrescribir m&eacute;todos" content-width="8cm" height="300" src="imagenes/lenguaje/eclipse_class_5.jpg" width="400"> 
 </p>
<p>Entonces podremos seleccionar el m&eacute;todo <span class="codefrag">doGet</span> que es el 
  que nos interesa en este caso y pulsar <em>OK</em>.</p>
<p>   

<img alt="Seleccionar m&eacute;todo a sobrescribir" content-width="3cm" height="231" src="imagenes/lenguaje/eclipse_class_6.jpg" width="174"> 
 </p>
<p>Esto nos crear&aacute; el esqueleto de este m&eacute;todo, dentro del cual 
  tendremos que a&ntilde;adir el c&oacute;digo necesario. Podemos copiar el c&oacute;digo 
  que hemos visto para el servlet de ejemplo anterior.</p>
<p>Nos mostrar&aacute; subrayados con rojo los errores en el c&oacute;digo. Posiblemente 
  haya errores del tipo <em>"PrintWriter cannot be resolved"</em> debidos 
  a no haber importado el paquete necesario donde se encuentra esta clase. Para 
  solucionarlos podemos abrir un men&uacute; contextual pulsando con el bot&oacute;n 
  derecho sobre el elemento que da este error, y seleccionar la opci&oacute;n 
  <em>Source &gt; Add Import.</em> De esta forma Eclipse a&ntilde;adir&aacute; 
  autom&aacute;ticamente el <span class="codefrag">import</span> para este elemento a nuestra clase, 
  sin tener nosotros que buscar el paquete en el que se encontraba.</p>
<p>   

<img alt="Agregar imports" content-width="8cm" height="300" src="imagenes/lenguaje/eclipse_class_7.jpg" width="400">
 </p>
<p>Otra opci&oacute;n interesante de este men&uacute; contextual del editor de 
  c&oacute;digo es la opci&oacute;n <em>Source &gt; Format</em>, que dar&aacute; 
  formato autom&aacute;ticamente al c&oacute;digo a&ntilde;adiendo las sangr&iacute;as 
  necesarias para cada l&iacute;nea de c&oacute;digo, permiti&eacute;ndonos de 
  esta forma "limpiar" el c&oacute;digo de forma r&aacute;pida.</p>
<a name="N106C1"></a><a name="Plugins+en+Eclipse"></a>
<h3 class="underlined_5">Plugins en Eclipse</h3>
<p>Para <strong>instalar nuevos plugins</strong>, simplemente hay que copiarlos en el directorio 
  <span class="codefrag">ECLIPSE_HOME/plugins.</span> Despu&eacute;s habr&aacute; que reiniciar Eclipse para que pueda 
  tomar los nuevos plugins instalados.</p>
<p>   
	
<img alt="Figura 18. Plugins en Eclipse" content-width="8cm" height="300" src="imagenes/lenguaje/eclipse_plugins.gif" width="400">
 </p>
<p>Existen gran cantidad de plugins desarrollados. Aqu&iacute; contaremos algunos que 
  pueden ser de utilidad, como el plugin <strong>EclipseUML</strong> de Omondo para realizar 
  dise&ntilde;o UML (diagramas de clases, de paquetes, etc) en un determinado proyecto, 
  o el plugin <strong>Lomboz</strong> para realizar proyectos J2EE.</p>
</div>

<a name="N106E5"></a><a name="Componentes+de+un+programa+Java"></a>
<h2 class="underlined_10">Componentes de un programa Java</h2>
<div class="section">
<p>
En un programa Java
podemos distinguir varios elementos:</p>
<a name="N106EE"></a><a name="Clases"></a>
<h3 class="underlined_5">Clases</h3>
<p>Para definir una clase se utiliza la palabra reservada <span class="codefrag">class</span>,
  seguida del nombre de la clase:</p>
<pre class="code">class MiClase
{
  ...
}</pre>
<a name="N106FF"></a><a name="Campos+y+variables"></a>
<h3 class="underlined_5">Campos y variables</h3>
<p>Dentro de una clase, o de un m&eacute;todo, podemos definir campos o variables,
  respectivamente, que pueden ser de tipos simples, o clases complejas, bien de
  la API de Java, bien que hayamos definido nosotros mismos, o bien que hayamos
  copiado de otro lugar.&nbsp;</p>
<pre class="code">int a;
Vector v;
MiOtraClase mc;</pre>
<a name="N1070D"></a><a name="M%C3%A9todos"></a>
<h3 class="underlined_5">M&eacute;todos</h3>
<p>Los m&eacute;todos o funciones se definen de forma similar a como se hacen en C:
  indicando el tipo de datos que devuelven, el nombre del m&eacute;todo, y luego los
  argumentos entre par&eacute;ntesis:</p>
<pre class="code">void imprimir(String mensaje)
{
	... // C&oacute;digo del m&eacute;todo
}

Vector insertarVector(Object elemento, int posicion)
{
	... // C&oacute;digo del m&eacute;todo
}</pre>
<a name="N1071B"></a><a name="Constructores"></a>
<h3 class="underlined_5">Constructores</h3>
<p>Podemos interpretar los constructores como m&eacute;todos que se llaman igual que
  la clase, y que se ejecutan con el operador <span class="codefrag">new</span> para reservar memoria
  para los objetos que se creen de dicha clase:</p>
<pre class="code">MiClase()
{
	... // C&oacute;digo del constructor
}

MiClase(int valorA, Vector valorV)
{
	... // C&oacute;digo de otro constructor
}</pre>
<p>
  No tenemos que preocuparnos de liberar la memoria
del objeto al dejar de utilizarlo. Esto lo hace autom&aacute;ticamente
el <strong>garbage collector</strong>. A&uacute;n as&iacute;, podemos usar el m&eacute;todo
<span class="codefrag">finalize()</span> para liberar manualmente.</p>
<a name="N10735"></a><a name="Paquetes"></a>
<h3 class="underlined_5">Paquetes</h3>
<p>Las clases en Java se organizan (o pueden organizarse) en paquetes, de
  forma que cada paquete contenga un conjunto de clases. Tambi&eacute;n puede haber
  subpaquetes especializados dentro de un paquete o subpaquete, formando as&iacute;
  una jerarqu&iacute;a de paquetes, que despu&eacute;s se plasma en el disco duro en una
  estructura de directorios y subdirectorios igual a la de paquetes y
  subpaquetes (cada clase ir&aacute; en el directorio/subdirectorio correspondiente a
  su paquete/subpaquete).</p>
<p>Cuando queremos indicar que una clase pertenece a un determinado paquete o
  subpaquete, se coloca al principio del fichero la palabra reservada <span class="codefrag">package</span>
  seguida por los paquetes/subpaquetes, separados por '.' :</p>
<pre class="code">
<strong>package </strong>paq1.subpaq1;<strong>
</strong>...
class MiClase {
...</pre>
<p>Si queremos desde otra clase utilizar una clase de un paquete o subpaquete
  determinado (diferente al de la clase en la que estamos), incluimos una
  sentencia <span class="codefrag">import</span> antes de la clase (y despu&eacute;s de la l&iacute;nea <span class="codefrag">package</span>
  que pueda tener la clase, si la tiene), indicando qu&eacute; paquete o subpaquete
  queremos importar:</p>
<pre class="code">
<strong>import</strong> paq1.subpaq1.*;</pre>
<pre class="code">
<strong>import</strong> paq1.subpaq1.MiClase;</pre>
<p>La primera opci&oacute;n (*) se utiliza para importar todas las clases del
  paquete (se utiliza cuando queremos utilizar muchas clases del paquete, para
  no ir importando una a una). La segunda opci&oacute;n se utiliza para importar una
  clase en concreto.</p>
<p>Al importar, ya podemos utilizar el nombre de la clase importada
  directamente en la clase que estamos construyendo. Si no coloc&aacute;semos el <span class="codefrag">import</span>
  podr&iacute;amos utilizar la clase igual, pero al referenciar su nombre tendr&iacute;amos
  que ponerlo completo, con paquetes y subpaquetes:</p>
<pre class="code">MiClase mc;				// Si hemos hecho el 'import' antes</pre>
<pre class="code">paq1.subpaq1.MiClase mc;		// Si NO hemos hecho el 'import' antes</pre>
<p>Existe un paquete en la API de Java, llamado <span class="codefrag">java.lang</span>, que no es
  necesario importar. Todas las clases que contiene dicho paquete son
  directamente utilizables. Para el resto de paquetes (bien sean de la API o
  nuestros propios), ser&aacute; necesario importarlos cuando estemos creando una
  clase fuera de dichos paquetes.</p>
<p>Aunque para una clase simple o un programa
de uso interno sencillo no es necesario agrupar las clases en paquetes, s&iacute; es
recomendable asignar un nombre de paquete a cada clase de una aplicaci&oacute;n, para
evitar que luego Java no pueda encontrarlas, debido a que no tienen paquete
asignado.</p>
<a name="N1077D"></a><a name="Modificadores+de+acceso"></a>
<h3 class="underlined_5">Modificadores de acceso</h3>
<p>Tanto las clases como los campos y m&eacute;todos admiten modificadores de
  acceso, para indicar si dichos elementos tienen &aacute;mbito <em>p&uacute;blico, protegido
  </em>o <em>privado</em>. Dichos modificadores se marcan con las palabras
  reservadas <span class="codefrag">public, protected </span>y <span class="codefrag">private</span>, respectivamente, y se
  colocan al principio de la declaraci&oacute;n:</p>
<pre class="code">
<strong>public</strong> class MiClase {
...
<strong>protected</strong> int b;
...
<strong>private</strong> int miMetodo(int b) {
...</pre>
<p>El modificador <span class="codefrag">protected</span> implica que los elementos que lo llevan son 
  visibles desde la clase, sus subclases, y las dem&aacute;s clases del mismo paquete 
  que la clase. </p>
<p>Si no se especifica ning&uacute;n modificador, el elemento ser&aacute; considerado 
  de tipo <em>paquete</em>. Este tipo de elementos podr&aacute;n ser visibles 
  desde la clase o desde clases del mismo paquete.</p>
<p>Cada fichero Java que creemos debe tener una y s&oacute;lo una <strong>clase p&uacute;blica</strong>
  (que ser&aacute; la clase principal del fichero). Dicha clase debe llamarse igual
  que el fichero. Aparte, el fichero podr&aacute; tener otras clases internas, pero ya
  no podr&aacute;n ser p&uacute;blicas.</p>
<p>Por ejemplo, si tenemos un fichero <span class="codefrag">MiClase.java</span>,
  podr&iacute;a tener esta apariencia:</p>
<pre class="code">public class MiClase 
{
	...
}

class OtraClase
{
	...
}

class UnaClaseMas
{
	...
}</pre>
<a name="N107BB"></a><a name="Otros+modificadores"></a>
<h3 class="underlined_5">Otros modificadores</h3>
<p>Adem&aacute;s de los modificadores de acceso vistos antes, en clases, m&eacute;todos
  y/o campos se pueden utilizar tambi&eacute;n estos modificadores:</p>
<ul>


<li>

<span class="codefrag">abstract</span>: elemento base para la herencia (los objetos
subtipo deber&aacute;n definir este elemento). Se utiliza para definir clases
abstractas, y m&eacute;todos abstractos dentro de dichas clases, para que los
implementen las subclases que hereden de ella.</li>


<li>

<span class="codefrag">static</span>: elemento compartido por todos los objetos
de la misma clase. Con este modificador, no se crea una copia del elemento en
cada objeto que se cree de la clase, sino que todos comparten una sola copia en
memoria del elemento, que se crea sin necesidad de crear un objeto de la clase
que lo contiene.</li>


<li>

<span class="codefrag">final</span>: objeto final, no modificable ni heredable (se utiliza para definir
constantes)</li>


<li>

<span class="codefrag">synchronized</span>: para elementos a los que no se puede acceder al mismo tiempo
desde distintos hilos de ejecuci&oacute;n.</li>

</ul>
<p>Estos modificadores se colocan tras los modificadores de acceso:</p>
<pre class="code">public <strong>abstract</strong> class Ejemplo 		// Clase abstracta para heredar de ella
{
	public <strong>static final</strong> TAM = 10;	// Constante est&aacute;tica de valor 10

	public <strong>abstract</strong> void metodo();	// M&eacute;todo abstracto a implementar
	
	public <strong>synchronized</strong> void otroMetodo()
	{
		... // Aqu&iacute; dentro s&oacute;lo puede haber un hilo a la vez
	}
}</pre>
<p>NOTA IMPORTANTE: si tenemos un m&eacute;todo est&aacute;tico (<span class="codefrag">static</span>), dentro de
  &eacute;l s&oacute;lo podremos utilizar elementos est&aacute;ticos (campos o m&eacute;todos
  est&aacute;ticos), o bien campos y m&eacute;todos de objetos que hayamos creado dentro del
  m&eacute;todo. Por ejemplo, si tenemos:</p>
<pre class="code">public class UnaClase
{
	public int a;

	public static int metodo()
	{
		return a + 1;
	}
}</pre>
<p>dar&aacute; error, porque el campo <span class="codefrag">a</span> no es est&aacute;tico, y lo estamos
  utilizando dentro del m&eacute;todo est&aacute;tico. Para solucionarlo tenemos dos
  posibilidades: definir <span class="codefrag">a</span> como est&aacute;tico (si el dise&ntilde;o del programa lo
  permite), o bien crear un objeto de tipo <span class="codefrag">UnaClase</span> en el m&eacute;todo, y
  utilizar su campo <span class="codefrag">a</span> (que ya no har&aacute; falta que sea est&aacute;tico, porque
  hemos creado un objeto y ya podemos acceder a su campo <span class="codefrag">a</span>):</p>
<pre class="code">public class UnaClase
{
	public int a;

	public static int metodo()
	{
		UnaClase uc = new UnaClase();
		// ... Aqu&iacute; har&iacute;amos que uc.a tuviese el valor adecuado
		return uc.a + 1;
	}
}</pre>
<a name="N10813"></a><a name="Ejecuci%C3%B3n+de+clases%3A+m%C3%A9todo"></a>
<h3 class="underlined_5">Ejecuci&oacute;n de clases: m&eacute;todo main</h3>
<p>En las clases principales de una aplicaci&oacute;n (las clases que queramos
  ejecutar) debe haber un m&eacute;todo <span class="codefrag">main</span> con la siguiente estructura:</p>
<pre class="code">public static void main(String[] args)
{
	... // C&oacute;digo del m&eacute;todo
}</pre>
<p>Dentro pondremos el c&oacute;digo que queramos ejecutar desde esa clase. Hay que
  tener en cuenta que <span class="codefrag">main</span> es est&aacute;tico, con lo que dentro s&oacute;lo podremos
  utilizar campos y m&eacute;todos est&aacute;ticos, o bien campos y m&eacute;todos de objetos que
  creemos dentro del <span class="codefrag">main</span>.</p>
<a name="N1082F"></a><a name="Ejemplo+completo"></a>
<h3 class="underlined_5">Ejemplo completo</h3>
<p>Con todo lo anterior, podr&iacute;amos tener una clase como:</p>
<pre class="code">package paquete1.subpaquete1;

import otropaquete.MiOtraClase;
import java.util.Vector;

public class MiClase 
{
	public int a;
	public Vector v;
	private MiOtraClase mc;

	public MiClase()
	{
		... // C&oacute;digo del constructor
	}

	public MiClase(int valorA, Vector valorV)
	{
		... // C&oacute;digo de otro constructor
	}

	void imprimir(String mensaje)
	{
		... // C&oacute;digo del m&eacute;todo
	}

	public Vector insertarVector(Object elemento, int posicion)
	{
		... // C&oacute;digo del m&eacute;todo
	}
}</pre>
<p>Y podr&iacute;amos definir una <strong>instancia</strong>  de esa clase, y utilizar sus
  campos y m&eacute;todos. Para ello utilizamos el operador <span class="codefrag">new</span>:</p>
<pre class="code">import paquete1.subpaquete1.*;
import java.util.*;

public class OtraClase
{
	public void metodo()
	{
		MiClase mc;
		mc = new MiClase (1, new Vector());
		mc.a++;
		mc.insertarVector("hola", 0);
	}
	...
}</pre>
<a name="N1084A"></a><a name="Herencia"></a>
<h3 class="underlined_5">Herencia</h3>
<p>Cuando queremos que una clase herede de otra, se utiliza al declararla la palabra <span class="codefrag">extends</span> 
  tras el nombre de la clase, para decir de qu&eacute; 
    clase se hereda. Para hacer que <span class="codefrag">Pato </span>herede de <span class="codefrag">Animal</span>:</p>
<pre class="code">class Pato <strong>extends</strong> Animal</pre>
<p>Con esto autom&aacute;ticamente <span class="codefrag">Pato</span> tomar&iacute;a todo lo que tuviese <span class="codefrag">Animal</span>
(aparte, <span class="codefrag">Pato</span> puede a&ntilde;adir sus caracter&iacute;sticas propias). Si <span class="codefrag">Animal</span> fuese una clase abstracta,
<span class="codefrag">Pato </span>deber&iacute;a implementar los m&eacute;todos
abstractos que tuviese.</p>
<a name="N10876"></a><a name="Punteros"></a>
<h3 class="underlined_5">Punteros this y super</h3>
<p>
<span class="codefrag">this</span> se usa para hacer referencia a los miembros de
la propia clase. Se utiliza cuando hay otros elementos con el mismo nombre, para
 distinguir :</p>
<pre class="code">public class MiClase 
{
  int i;
  public MiClase (int i) 
  {
<strong>      this.i = i; 	// i de la clase = parametro i</strong>
  }
}</pre>
<p>
<span class="codefrag">super</span> se usa para llamar al mismo elemento en la clase padre. Si la clase
<span class="codefrag">MiClase</span> tiene un m&eacute;todo <span class="codefrag">Suma_a_i(...)</span>, lo llamar&iacute;amos desde esta
otra clase con:</p>
<pre class="code">public class MiNuevaClase extends MiClase 
{
  public void Suma_a_i (int j) 
  {
    i = i + (j / 2);
<strong>    super.Suma_a_i (j);</strong>
  }
}</pre>
<a name="N108A0"></a><a name="Interfaces"></a>
<h3 class="underlined_5">Interfaces</h3>
<p>Ya hemos visto c&oacute;mo definir clases normales, y clases abstractas. Si queremos definir
un interfaz, se utiliza la palabra reservada <span class="codefrag">interface</span>, en lugar de <span class="codefrag">class</span>,
y dentro declaramos (no implementamos), los m&eacute;todos que queremos que tenga la
interfaz:</p>
<pre class="code">public <strong>interface</strong> MiInterfaz 
{
	public void metodoInterfaz();
	public float otroMetodoInterfaz();
}</pre>
<p>Despu&eacute;s, para que una clase implemente los m&eacute;todos de esta interfaz, se
utiliza la palabra reservada <span class="codefrag">implements</span> tras el nombre de la clase:</p>
<pre class="code">public class UnaClase <strong>implements</strong> MiInterfaz 
{
	public void metodoInterfaz()
	{
		... // C&oacute;digo del m&eacute;todo
	}

	public float otroMetodoInterfaz()
	{
		... // C&oacute;digo del m&eacute;todo
	}
}</pre>
<p>Notar que si en lugar de poner <span class="codefrag">implements</span> ponemos <span class="codefrag">extends</span>, en
ese caso <span class="codefrag">UnaClase</span> deber&iacute;a ser un <span class="codefrag">interfaz</span>, que heredar&iacute;a del
interfaz <span class="codefrag">MiInterfaz</span> para definir m&aacute;s m&eacute;todos, pero no para implementar
los que tiene la interfaz. Esto se utilizar&iacute;a para definir interfaces partiendo
de un interfaz base, para a&ntilde;adir m&aacute;s m&eacute;todos a implementar.</p>
<p>Una clase puede heredar s&oacute;lo de otra &uacute;nica clase, pero puede implementar
cuantos interfaces necesite:</p>
<pre class="code">public class UnaClase <strong>extends</strong> MiClase <strong>implements</strong> MiInterfaz, MiInterfaz2, MiInterfaz3
{
	...
}</pre>
<a name="N108E3"></a><a name="Programas+B%C3%A1sicos+en+Java"></a>
<h3 class="underlined_5">Programas B&aacute;sicos en Java</h3>
<p>Veamos ahora algunos ejemplos de programas en Java.</p>
<ul>

<li>

<strong>Ejemplo</strong>: El siguiente ejemplo muestra un texto por pantalla (muestra
"Mi programa Java"): 

<pre class="code">/**
  * Ejemplo que muestra un texto por pantalla
  */
public class Ejemplo1
{
   public static void main(String[] args)
   {
      System.out.println ("Mi programa Java");
   }
}</pre>


</li>


<li>

<strong>Ejemplo</strong>: El siguiente ejemplo toma dos n&uacute;meros (un entero
y un real) y devuelve su suma: 

<pre class="code">/**
  * Ejemplo que suma dos numeros: un entero y un real
  */
public class Ejemplo2
{
	int n1;		// Primer numero (el entero)
	float n2;	// Segundo numero (el real)
	
	/**
	  * Constructor
	  */
	public Ejemplo2(int n1, float n2)
	{
		this.n1 = n1;
		this.n2 = n2;
	}
	
	/**
	  * Suma dos numeros y devuelve el resultado (real)
	  */
	public float suma()
	{
		return (n1 + n2);
	}
	
	/**
	  * Main
	  */
	public static void main(String[] args)
	{
		if (args.length &lt; 2)
		{
			System.out.println ("Uso: java Ejemplo2 &lt;n1&gt; &lt;n2&gt;");
			System.exit(-1);
		}

		// Tomamos los dos parametros
		int n1 = Integer.parseInt(args[0]);
		float n2 = Float.parseFloat(args[1]);

		// Creamos un objeto Ejemplo2 y le pedimos la suma de los valores
		Ejemplo2 e = new Ejemplo2(n1, n2);
		System.out.println ("Resultado: " + e.suma());
	}
}</pre>


</li>


<li>

<strong>Ejemplo</strong>: El siguiente ejemplo resuelve el
teorema de pit&aacute;goras (obtiene una hipotenusa a partir de dos catetos): 

<pre class="code">/**
  * Este ejemplo resuelve el teorema de Pit&aacute;goras:
  * hipotenusa = raiz (cateto1 * cateto1 + cateto2 * cateto2)
  */
public class Ejemplo3 
{
	// Primer Cateto
	public static final int CATETO1 = 20;

	// Segundo Cateto
	public static final int CATETO2 = 50;
	  
	/**
	  * Obtiene la hipotenusa de dos catetos que se pasan como parametro
	  */
	public static double hipotenusa(int cateto1, int cateto2) 
	{ 
		return Math.sqrt(Math.pow(cateto1, 2) + Math.pow(cateto2, 2)); 
	} 

	/**
	  * Main
	  */
	public static void main(String[] args) 
	{ 
		System.out.println ("La hipotenusa de los catetos indicados es:"); 
		double h = hipotenusa(CATETO1, CATETO2);
		System.out.println ("h = " + h);
	} 
}</pre>


</li>


<li>

<strong>Ejemplo</strong>: El siguiente ejemplo devuelve todos los n&uacute;meros
primos que encuentra hasta un n&uacute;mero determinado: 

<pre class="code">/**
  * Este ejemplo devuelve los numeros primos encontrados hasta un
  * cierto valor
  */
public class Ejemplo4
{	  
	/**
	  * Obtiene si un n&uacute;mero es primo o no
	  */
	public static boolean esPrimo (int valor) 
	{ 
		int i = 2;
		while (i &lt; valor)
		{
			if (valor % i == 0)
				return false;
			i++;
		}
		return true; 
	} 

	/**
	  * Main
	  */
	public static void main(String[] args) 
	{ 
		System.out.println ("Numeros primos hasta el " + args[0] + ":"); 
		for (int i = 1; i &lt; Integer.parseInt(args[0]); i++)
			if (esPrimo(i))
				System.out.print (" " + i);
		System.out.println ("\nFinalizado");
	} 
}</pre>


</li>


<li>

<strong>Ejemplo</strong>: El siguiente ejemplo muestra c&oacute;mo utilizar herencia
y clases abstractas. Define una clase abstracta Persona, de la que hereda
la clase Hombre. La clase Anciano a su vez hereda de la clase Hombre. En
la clase <span class="codefrag">Ejemplo5</span> se tiene el m&eacute;todo <span class="codefrag">main()</span>, que muestra resultados
de llamadas a todas las clases. Compilando esta clase se compila todo el
ejemplo: 

<pre class="code">/**
  * Ejemplo de herencias y clases abstractas
  */
public class Ejemplo5
{	 
	/**
	  * Main
	  */
	public static void main(String[] args)
	{
		Hombre h = new Hombre();
		Anciano a = new Anciano();
		Persona p = (Persona)a;
		
		System.out.println ("Edad del hombre: " + h.edad());		
		System.out.println ("Genero del anciano: " + a.genero());
		System.out.println ("Clase de la persona: " + p.clase());
	}
}</pre>


<pre class="code">/**
  * Ejemplo de herencias y clases abstractas
  */
public abstract class Persona
{	  
	/**
	  * Devuelve la clase a la que pertenecen las personas
	  */
	public String clase() 
	{ 
		return "mamiferos"; 
	} 

	/**
	  * Devuelve el genero de la persona
	  */
	public abstract String genero();

	/**
	  * Devuelve la edad de la persona
	  */
	public abstract String edad();
}</pre>


<pre class="code">/**
  * Ejemplo de herencias y clases abstractas
  */
public class Hombre extends Persona
{	 
	/* 
	   No hace falta definir el metodo clase(), porque ya esta
	   definido en la clase padre. Lo tendr&iacute;amos que definir si
	   queremos devolver algo distinto a lo que devuelve all&iacute;
	*/
	
	/**
	  * Devuelve el genero de la persona (este metodo si hay que
	  * definirlo porque es abstracto en la clase padre)
	  */
	public String genero()
	{
		return "masculino";
	}

	/**
	  * Devuelve la edad de la persona (este metodo si hay que definirlo
	  * porque es abstracto en la clase padre)
	  */
	public String edad()
	{
		return "40";
	}
}</pre>


<pre class="code">/**
  * Ejemplo de herencias y clases abstractas
  */
public class Anciano extends Hombre
{	 
	/* 
	   No hace falta definir ningun metodo, s&oacute;lo aquellos en los 
	   que queramos devolver cosas distintas. En este caso, la edad
	*/
	
	/**
	  * Devuelve la edad de la persona 
	  */
	public String edad()
	{
		return "75";
	}
}</pre>


</li>

</ul>
</div>


<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006 Depto. CCIA</div>
</div>
</body>
</html>
