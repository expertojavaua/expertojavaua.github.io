<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Flujos de E/S y Red</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Java y Herramientas de Desarrollo" src="images/baner_j2ee_der.gif" title="Java y Herramientas de Desarrollo"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Java y Herramientas de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Java y Herramientas de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 4</div>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion04-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Flujos de E/S y Red</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Entrada%2FSalida">Entrada/Salida</a>
<ul class="minitoc">
<li>
<a href="#Flujos+de+datos+de+entrada%2Fsalida">Flujos de datos de entrada/salida</a>
</li>
<li>
<a href="#Entrada%2C+salida+y+salida+de+error+est%C3%A1ndar">Entrada, salida y salida de error est&aacute;ndar</a>
</li>
<li>
<a href="#Acceso+a+ficheros">Acceso a ficheros</a>
</li>
<li>
<a href="#Acceso+a+los+recursos">Acceso a los recursos</a>
</li>
<li>
<a href="#Codificaci%C3%B3n+de+datos">Codificaci&oacute;n de datos</a>
</li>
<li>
<a href="#Serializaci%C3%B3n+de+objetos">Serializaci&oacute;n de objetos</a>
</li>
</ul>
</li>
<li>
<a href="#Red">Red</a>
<ul class="minitoc">
<li>
<a href="#Acceso+a+URLs">Acceso a URLs</a>
</li>
<li>
<a href="#Lectura+del+contenido">Lectura del contenido</a>
</li>
<li>
<a href="#Conexi%C3%B3n+con+la+URL">Conexi&oacute;n con la URL</a>
</li>
</ul>
</li>
</ul>
</div>


<a name="N1000C"></a><a name="Entrada%2FSalida"></a>
<h2 class="underlined_10">Entrada/Salida</h2>
<div class="section">
<p>Los programas muy a menudo necesitan enviar datos a un determinado destino, o
bien leerlos de una determinada fuente externa, como por ejemplo puede ser un
fichero para almacenar datos de forma permanente, o bien enviar datos a trav&eacute;s
de la red, a memoria, o a otros programas. Esta entrada/salida de datos en Java
la realizaremos por medio de <em>flujos (streams)</em> de datos, a trav&eacute;s de los
cuales un programa podr&aacute; recibir o enviar datos en serie.&nbsp;</p>
<a name="N10018"></a><a name="Flujos+de+datos+de+entrada%2Fsalida"></a>
<h3 class="underlined_5">Flujos de datos de entrada/salida</h3>
<p>Existen varios objetos que hacen de flujos de datos, y que se distinguen por
la finalidad del flujo de datos y por el tipo de datos que viajen a trav&eacute;s de
ellos. Seg&uacute;n el tipo de datos&nbsp; que transporten podemos distinguir:</p>
<ul>
  
<li>Flujos de caracteres</li>
  
<li>Flujos de <em>bytes</em>
</li>

</ul>
<p>Dentro de cada uno de estos grupos tenemos varios pares de objetos, de los 
  cuales uno nos servir&aacute; para leer del flujo y el otro para escribir en &eacute;l. Cada 
  par de objetos ser&aacute; utilizado para comunicarse con distintos elementos (memoria, 
  ficheros, red u otros programas). Estas clases, seg&uacute;n sean de entrada o salida 
  y seg&uacute;n sean de caracteres o de <em>bytes</em> llevar&aacute;n distintos sufijos, seg&uacute;n 
  se muestra en la siguiente tabla:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr> 
    
<th colspan="1" rowspan="1">&nbsp;</th>
    <th colspan="1" rowspan="1"><strong>Flujo de entrada / lector</strong></th>
    <th colspan="1" rowspan="1"><strong>Flujo de salida / escritor</strong></th>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Caract&eacute;res</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">_Reader</span></td>

    <td colspan="1" rowspan="1"><span class="codefrag">_Writer</span></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Bytes</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">_InputStream</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">_OutputStream</span></td>
  
</tr>


</table>
<p>Donde el prefijo se referir&aacute; a la fuente o sumidero de los datos que puede 
  tomar valores como los que se muestran a continuaci&oacute;n:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">File_</span></td>
    <td colspan="4" rowspan="1">Acceso a ficheros</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">Piped_</span></td>
    <td colspan="4" rowspan="1">Comunicaci&oacute;n entre programas mediante tuber&iacute;as (<em>pipes</em>)</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">String_</span></td>
    <td colspan="4" rowspan="1">Acceso a una cadena en memoria (solo caracteres)</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">CharArray_</span></td>
    <td colspan="4" rowspan="1">Acceso a un <em>array</em> de caracteres en memoria (solo 
      caracteres)</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">ByteArray_</span></td>
    <td colspan="4" rowspan="1">Acceso a un <em>array</em> de <em>bytes</em> en memoria (solo 
      <em>bytes</em>)</td>
  
</tr>

</table>
<p>Adem&aacute;s podemos distinguir los flujos de datos seg&uacute;n su prop&oacute;sito, pudiendo
ser:</p>
<ul>
  
<li>Canales de datos, simplemente para leer o escribir datos directamente en
    una fuente o sumidero externo.</li>
  
<li>Flujos de procesamiento, que adem&aacute;s de enviar o recibir datos realizan alg&uacute;n 
    procesamiento con ellos. Tenemos por ejemplo flujos que realizan un filtrado 
    de los datos que viajan a trav&eacute;s de ellos (con prefijo <span class="codefrag">Filter</span>), 
    conversores datos (con prefijo <span class="codefrag">Data</span>), <em>bufferes</em> de datos 
    (con prefijo <span class="codefrag">Buffered</span>), preparados para la impresi&oacute;n de elementos 
    (con prefijo <span class="codefrag">Print</span>), etc.</li>


</ul>
<p>Un tipo de filtros de procesamiento a destacar son aquellos que nos permiten 
  convertir un flujo de <em>bytes</em> a flujo de caracteres. Estos objetos son 
  <span class="codefrag">InputStreamReader</span> y <span class="codefrag">OutputStreamWriter</span>. Como podemos 
  ver en su sufijo, son flujos de caracteres, pero se construyen a partir de flujos 
  de <em>bytes</em>, permitiendo de esta manera acceder a nuestro flujo de <em>bytes</em> 
  como si fuese un flujo de caracteres.</p>
<p>Para cada uno de los tipos b&aacute;sicos de flujo que hemos visto existe una superclase, 
  de la que heredaran todos sus subtipos, y que contienen una serie de m&eacute;todos 
  que ser&aacute;n comunes a todos ellos. Entre estos m&eacute;todos encontramos los m&eacute;todos 
  b&aacute;sicos para leer o escribir caracteres o <em>bytes</em> en el flujo a bajo 
  nivel. En la siguiente tabla se muestran los m&eacute;todos m&aacute;s importantes de cada 
  objeto:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
	
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
	  
<td colspan="1" rowspan="1"><strong><span class="codefrag">InputStream</span></strong></td>
	  <td colspan="2" rowspan="1"><strong><span class="codefrag">read</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">reset</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">available</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">close</span></strong><span class="codefrag">()</span></td>

  
</tr>
  
<tr> 
	  
<td colspan="1" rowspan="1"><strong><span class="codefrag">OutputStream</span></strong></td>
	  <td colspan="2" rowspan="1"><strong><span class="codefrag">write</span></strong><span class="codefrag">(int b), </span><strong><span class="codefrag">flush</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">close</span></strong><span class="codefrag">()</span></td>
  
</tr>
  
<tr> 
	  
<td colspan="1" rowspan="1"><strong><span class="codefrag">Reader</span></strong></td>
	  <td colspan="2" rowspan="1"><strong><span class="codefrag">read</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">reset</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">close</span></strong><span class="codefrag">()</span></td>
  
</tr>
  
<tr> 
	  
<td colspan="1" rowspan="1"><strong><span class="codefrag">Writer</span></strong></td>
	  <td colspan="2" rowspan="1"><strong><span class="codefrag">write</span></strong><span class="codefrag">(int c), </span><strong><span class="codefrag">flush</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">close</span></strong><span class="codefrag">()</span></td>

  
</tr>

</table>
<p>A parte de estos m&eacute;todos podemos encontrar variantes de los m&eacute;todos de lectura 
  y escritura, otros m&eacute;todos, y adem&aacute;s cada tipo espec&iacute;fico de flujo contendr&aacute; 
  sus propios m&eacute;todos. Todas estas clases se encuentran en el paquete <span class="codefrag">java.io</span>. 
  Para m&aacute;s detalles sobre ellas se puede consultar la especificaci&oacute;n de la API 
  de Java.</p>
<a name="N101A0"></a><a name="Entrada%2C+salida+y+salida+de+error+est%C3%A1ndar"></a>
<h3 class="underlined_5">Entrada, salida y salida de error est&aacute;ndar</h3>
<p>Al igual que en C, en Java tambi&eacute;n existen los conceptos de entrada, salida,
y salida de error est&aacute;ndar. La entrada est&aacute;ndar normalmente se refiere a lo
que el usuario escribe en la consola, aunque el sistema operativo puede hacer
que se tome de otra fuente. De la misma forma la salida y la salida de error
est&aacute;ndar lo que hacen normalmente es mostrar los mensajes y los errores del
programa respectivamente en la consola, aunque el sistema operativo tambi&eacute;n
podr&aacute; redirigirlas a otro destino.</p>
<p>En Java esta entrada, salida y salida de error est&aacute;ndar se tratan de la misma 
  forma que cualquier otro flujo de datos, estando estos tres elementos encapsulados 
  en tres objetos de flujo de datos que se encuentran como propiedades est&aacute;ticas 
  de la clase <span class="codefrag">System</span>:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr> 
    
<td colspan="1" rowspan="1">&nbsp;</td>
    <td colspan="1" rowspan="1"><strong>Tipo</strong></td>
    <td colspan="1" rowspan="1"><strong>Objeto</strong></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Entrada est&aacute;ndar</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">InputStream</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">System.</span><strong><span class="codefrag">in</span></strong></td>

  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Salida est&aacute;ndar</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">PrintStream</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">System.</span><strong><span class="codefrag">out</span></strong></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Salida de error est&aacute;ndar</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">PrintStream</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">System.</span><strong><span class="codefrag">err</span></strong></td>
  
</tr>

</table>
<p>Para la entrada est&aacute;ndar vemos que se utiliza un objeto <span class="codefrag">InputStream</span> 
  b&aacute;sico, sin embargo para la salida se utilizan objetos <span class="codefrag">PrintWriter</span> 
  que facilitan la impresi&oacute;n de texto ofreciendo a parte del m&eacute;todo com&uacute;n de bajo 
  nivel <span class="codefrag">write</span> para escribir <em>bytes</em>, dos m&eacute;todos m&aacute;s: <span class="codefrag">print</span> 
  y <span class="codefrag">println</span>. Estas funciones nos permitir&aacute;n escribir cualquier cadena, 
  tipo b&aacute;sico, o bien cualquier objeto que defina el m&eacute;todo <span class="codefrag">toString</span> 
  que devuelva una representaci&oacute;n del objeto en forma de cadena. La &uacute;nica diferencia 
  entre los dos m&eacute;todos es que el segundo a&ntilde;ade autom&aacute;ticamente un salto de l&iacute;nea 
  al final del texto impreso, mientras que en el primero deberemos especificar 
  expl&iacute;citamente este salto.</p>
<p>Para escribir texto en la consola normalmente utilizaremos:</p>
<pre class="code">System.out.println("Hola mundo");</pre>
<p>En el caso de la impresi&oacute;n de errores por la salida de error de est&aacute;ndar,
deberemos utilizar:&nbsp;</p>
<pre class="code">System.err.println("Error: Se ha producido un error");</pre>
<p>Adem&aacute;s la clase <span class="codefrag">System</span> nos permite sustituir estos flujos por 
  defecto por otros flujos, cambiando de esta forma la entrada, salida y salida 
  de error est&aacute;ndar.</p>
<a name="N1023B"></a><a name="Acceso+a+ficheros"></a>
<h3 class="underlined_5">Acceso a ficheros</h3>
<p>Podremos acceder a ficheros bien por caracteres, o bien de forma binaria (por 
  <em>bytes</em>). Las clases que utilizaremos en cada caso son:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr> 
    
<td colspan="1" rowspan="1">&nbsp;</td>
    <td colspan="1" rowspan="1"><strong>Lectura</strong></td>
    <td colspan="1" rowspan="1"><strong>Escritura</strong></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Caracteres</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">FileReader</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">FileWriter</span></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Binarios</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">FileInputStream</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">FileOutputStream</span></td>
  
</tr>

</table>
<p>Para crear un lector o escritor de ficheros deberemos proporcionar al constructor 
  el fichero del que queremos leer o en el que queramos escribir. Podremos proporcionar 
  esta informaci&oacute;n bien como una cadena de texto con el nombre del fichero, o 
  bien construyendo un objeto <span class="codefrag">File</span> representando al fichero al que 
  queremos acceder. Este objeto nos permitir&aacute; obtener informaci&oacute;n adicional sobre 
  el fichero, a parte de permitirnos realizar operaciones sobre el sistema de 
  ficheros.</p>
<p>A continuaci&oacute;n vemos un ejemplo simple de la copia de un fichero car&aacute;cter a
car&aacute;cter:</p>
<pre class="code">public void copia_fichero() {
	int c;
	try {
		<strong>FileReader</strong> in = new <strong>FileReader</strong>("fuente.txt");
		<strong>FileWriter</strong> out = new <strong>FileWriter</strong>("destino.txt");
	
		while( (c = in.<strong>read</strong>()) != -1) {
			out.write(c);
		}
		
		in.<strong>close</strong>();
		out.<strong>close</strong>();
	
	} catch(<strong>FileNotFoundException</strong> e1) {
		System.err.println("Error: No se encuentra el fichero");
	} catch(<strong>IOException</strong> e2) {
		System.err.println("Error leyendo/escribiendo fichero");
	}
}</pre>
<p>
En el ejemplo podemos ver que para el acceso a un fichero es necesario
capturar dos excepciones, para el caso de que no exista el fichero al que
queramos acceder y por si se produce un error en la E/S.</p>
<p>Para la escritura podemos utilizar el m&eacute;todo anterior, aunque muchas veces 
  nos resultar&aacute; mucho m&aacute;s c&oacute;modo utilizar un objeto <span class="codefrag">PrintWriter </span>con 
  el que podamos escribir directamente l&iacute;neas de texto:</p>
<pre class="code">public void escribe_fichero() {
	<strong>FileWriter</strong> out = null;
	<strong>PrintWriter</strong> p_out = null;

	try {
		out = new <strong>FileWriter</strong>("result.txt");
		p_out = new <strong>PrintWriter</strong>(out);
		p_out.<strong>println</strong>(
			"Este texto ser&aacute; escrito en el fichero de salida");

	} catch(<strong>IOException</strong> e) {
		System.err.println("Error al escribir en el fichero");
	} finally {
		p_out.<strong>close</strong>();
	}
}</pre>
<a name="N102D3"></a><a name="Acceso+a+los+recursos"></a>
<h3 class="underlined_5">Acceso a los recursos</h3>
<p>Hemos visto como leer y escribir ficheros, pero cuando ejecutamos una aplicaci&oacute;n 
  contenida en un fichero JAR, puede que necesitemos leer recursos contenidos 
  dentro de este JAR. </p>
<p>Para acceder a estos recursos deberemos abrir un flujo de entrada que se encargue 
  de leer su contenido. Para ello utilizaremos el m&eacute;todo <span class="codefrag">getResourceAsStream</span> 
  de la clase <span class="codefrag">Class</span>:</p>
<pre class="code">InputStream in = getClass().<strong>getResourceAsStream</strong>("/datos.txt");</pre>
<p>De esta forma podremos utilizar el flujo de entrada obtenido para leer el contenido 
  del fichero que hayamos indicado. Este fichero deber&aacute; estar contenido 
  en el JAR de la aplicaci&oacute;n.</p>
<p>Especificamos el car&aacute;cter '<span class="codefrag">/</span>' delante del nombre del recurso 
  para referenciarlo de forma relativa al directorio ra&iacute;z del JAR. Si no 
  lo especific&aacute;semos de esta forma se buscar&iacute;a de forma relativa 
  al directorio correspondiente al paquete de la clase actual.</p>
<a name="N102F6"></a><a name="Codificaci%C3%B3n+de+datos"></a>
<h3 class="underlined_5">Codificaci&oacute;n de datos</h3>
<p>Si queremos guardar datos en un fichero binario deberemos 
  codificar estos datos en forma de <em>array</em> de <em>bytes</em>. Los flujos 
  de procesamiento <span class="codefrag">DataInputStream</span> y <span class="codefrag">DataOutputStream</span> 
  nos permitir&aacute;n codificar y descodificar respectivamente los tipos de 
  datos simples en forma de <em>array</em> de <em>bytes</em> para ser enviados 
  a trav&eacute;s de un flujo de datos. </p>
<p>Por ejemplo, podemos codificar datos en un <em>array</em> 
  en memoria (<span class="codefrag">ByteArrayOutputStream</span>) de la siguiente forma:</p>
<pre class="code">String nombre = "Jose";
String edad = 25;
<strong>ByteArrayOutputStream</strong> baos = new <strong>ByteArrayOutputStream</strong>();
<strong>DataOutputStream</strong> dos = new <strong>DataOutputStream</strong>(baos);

dos.<strong>writeUTF</strong>(nombre);
dos.<strong>writeInt</strong>(edad);
dos.close();
baos.close();

byte [] datos = baos.<strong>toByteArray</strong>();</pre>
<p>Podremos descodificar este <em>array</em> de <em>bytes</em> 
  realizando el procedimiento inverso, con un flujo que lea un <em>array</em> 
  de <em>bytes</em> de memoria (<span class="codefrag">ByteArrayInputStream</span>):</p>
<pre class="code">
<strong>ByteArrayInputStream</strong> bais = new <strong>ByteArrayInputStream</strong>(datos);
<strong>DataInputStream</strong> dis = new <strong>DataInputStream</strong>(bais);
String nombre = dis.<strong>readUTF</strong>();
int edad = dis.<strong>readInt</strong>();
</pre>
<p>Si en lugar de almacenar estos datos codificados en una 
  <em>array</em> en memoria queremos guardarlos codificados en un fichero, haremos 
  lo mismo simplemente sustituyendo el flujo canal de datos <span class="codefrag">ByteArrayOutputStream</span> 
  por un <span class="codefrag">FileOutputStream</span>. De esta forma podremos utilizar cualquier 
  canal de datos para enviar estos datos codificados a trav&eacute;s de &eacute;l.</p>
<a name="N10367"></a><a name="Serializaci%C3%B3n+de+objetos"></a>
<h3 class="underlined_5">Serializaci&oacute;n de objetos</h3>
<p>Si queremos enviar un objeto a trav&eacute;s de un flujo de datos, deberemos convertirlo 
  en una serie de <em>bytes</em>. Esto es lo que se conoce como serializaci&oacute;n 
  de objetos, que nos permitir&aacute; leer y escribir objetos. </p>
<p>Para leer o escribir objetos podemos utilizar los objetos <span class="codefrag">ObjectInputStream 
  </span> y <span class="codefrag">ObjectOutputStream</span> que incorporan los m&eacute;todos <span class="codefrag">readObject</span> 
  y <span class="codefrag">writeObject</span> respectivamente. Los objetos que escribamos en dicho 
  flujo deben tener la capacidad de ser <em>serializables</em>. </p>
<p>Ser&aacute;n <em>serializables </em>aquellos objetos que implementan la interfaz <span class="codefrag">Serializable</span>. 
  Cuando queramos hacer que una clase definida por nosotros sea <em>serializable 
  </em>deberemos implementar dicho interfaz, que no define ninguna funci&oacute;n, s&oacute;lo 
  se utiliza para identificar las clases que son <em>serializables</em>. Para que 
  nuestra clase pueda ser <em>serializable</em>, todas sus propiedades deber&aacute;n ser 
  de tipos de datos b&aacute;sicos o bien objetos que tambi&eacute;n sean<em><strong> </strong>serializables</em>. 

</p>
</div>

<a name="N1039E"></a><a name="Red"></a>
<h2 class="underlined_10">Red</h2>
<div class="section">
<p>En este apartado veremos como establecer una comunicaci&oacute;n en red mediante URLs. 
  En Java tambi&eacute;n se pueden establecer conexiones de red a m&aacute;s bajo 
  nivel mediante <em>sockets</em> (protocolos TCP y UDP), pero muchas veces los 
  puertos a los que accedemos se encuentran cortados por <em>firewalls</em> intermedios, 
  por lo que estos tipos de conexiones no ser&aacute;n adecuados para acceder 
  a servidores en Internet. </p>
<p>Adem&aacute;s las APIs de Java nos ofrecen numerosas facilidades para trabajar 
  con URLs que sigan protocolos est&aacute;ndar (como por ejemplo HTTP), tanto 
  en el lado del cliente como en el servidor, por lo que ser&aacute; recomendable 
  establecer la comunicaci&oacute;n entre nuestro cliente y nuestro servidor utilizando 
  estos protocolos.</p>
<p> Java nos permite adem&aacute;s utilizar mecanismos de comunicaci&oacute;n por red 
  de m&aacute;s alto nivel como por ejemplo RMI que nos permite invocar m&eacute;todos 
  de objetos remotos. Esto lo veremos con m&aacute;s detalle en m&oacute;dulos 
  posteriores. &nbsp;</p>
<a name="N103B3"></a><a name="Acceso+a+URLs"></a>
<h3 class="underlined_5">Acceso a URLs</h3>
<p>Una URL (<em>Uniform Resource Locator</em>) es una cadena utilizada para localizar 
  un recurso en Internet. Dentro de la URL podemos distinguir varias componentes:</p>
<pre class="code">protocolo://servidor[:puerto]/recurso</pre>
<p>Por ejemplo, en el caso de la direcci&oacute;n <span class="codefrag">http://www.ua.es/es/index.html</span> 
  lo que se har&aacute; ser&aacute; acceder al servidor <span class="codefrag">www.ua.es</span> mediante protocolo 
  HTTP y solicitar el recurso <span class="codefrag">/es/index.html</span>. El puerto por defecto 
  es el <span class="codefrag">80</span>, pero si el servidor Web atendiese en un puerto distinto 
  a este deber&iacute;amos especificarlo tambi&eacute;n en la URL.</p>
<p>En Java tenemos el objeto <span class="codefrag">URL </span>que se encargar&aacute; de representar 
  las URLs. Podemos construir un objeto <span class="codefrag">URL </span>a partir del nombre completo 
  de la URL:</p>
<pre class="code">
<strong>URL</strong> url = new <strong>URL</strong>("http://www.ua.es/es/index.html");</pre>
<p>Dado que muchas veces se especifican links relativos, ser&aacute; de ayuda contar 
  con un segundo constructor que nos permita crear URLs a partir de la direcci&oacute;n 
  base donde nos encontremos y de la direcci&oacute;n relativa solicitada:</p>
<pre class="code">
<strong>URL</strong> url = new <strong>URL</strong>(direccion_base, direccion_relativa);</pre>
<p>Aqu&iacute; la direcci&oacute;n relativa puede referirse a un recurso alojado en el servidor 
  donde nos encontremos o bien a un destino dentro de la web donde estamos, referenciado 
  mediante <span class="codefrag">#nombre_destino</span>.</p>
<p>Existen m&aacute;s constructores de esta clase, permiti&eacute;ndonos por ejemplo construir 
  una URL dando cada elemento (protocolo, servidor, puerto, recurso) por separado. 
  Siempre que creemos una URL deberemos capturar la excepci&oacute;n <span class="codefrag">MalformedURLException</span> 
  que se producir&aacute; en el caso de estar mal construida.</p>
<pre class="code">try {
	<strong>URL</strong> url = new <strong>URL</strong>("http://www.ua.es/es/index.html");
} catch(<strong>MalformedURLException</strong> e) {
	System.err.println("Error: URL mal construida");
}</pre>
<p>La clase <span class="codefrag">URL </span>proporciona m&eacute;todos para obtener informaci&oacute;n sobre 
  la URL que representa.</p>
<a name="N10410"></a><a name="Lectura+del+contenido"></a>
<h3 class="underlined_5">Lectura del contenido</h3>
<p>Para leer desde la direcci&oacute;n URL representada por el objeto deberemos obtener 
  un flujo de entrada provinente de ella. Para obtener este flujo utilizaremos 
  el m&eacute;todo <span class="codefrag">openStream</span> del objeto <span class="codefrag">URL</span>.</p>
<pre class="code">
<strong>InputStream</strong> in = url.<strong>openStream</strong>();</pre>
<p>Una vez obtenido este flujo de entrada podremos leer de &eacute;l o bien transformarlo 
  a otro tipo de flujo como por ejemplo a un flujo de caracteres o de procesamiento.</p>
<p>Esto puede ser suficiente en muchos casos, en los que s&oacute;lo necesitemos 
  leer el contenido de un recurso localizado mediante dicha URL. Por ejemplo, 
  si la URL corresponde a una p&aacute;gina web, al leer de ella obtendremos el 
  c&oacute;digo de dicha p&aacute;gina web.</p>
<p>Sin embargo, muchas veces necesitaremos poder enviar informaci&oacute;n al 
  servidor y acceder a una serie de propiedades sobre la respuesta que hemos obtenido 
  del mismo. Para hacer esto deberemos crear una conexi&oacute;n con la URL, y 
  utilizar esta conexi&oacute;n para enviar o recibir informaci&oacute;n.</p>
<a name="N10432"></a><a name="Conexi%C3%B3n+con+la+URL"></a>
<h3 class="underlined_5">Conexi&oacute;n con la URL</h3>
<p>Podemos crear una conexi&oacute;n con la URL utilizando el m&eacute;todo <span class="codefrag">openConnection</span> 
  del objeto <span class="codefrag">URL</span> que nos devolver&aacute; un objeto del tipo <span class="codefrag">URLConnection</span>. 
  Estableciendo una conexi&oacute;n podremos leer o escribir datos en la URL. </p>
<p>La clase <span class="codefrag">URLConnection</span> es una clase abstracta, que define de forma 
  gen&eacute;rica una conexi&oacute;n con una URL cualquiera. En realidad el objeto 
  que habremos obtenido ser&aacute; una subclase de <span class="codefrag">URLConnection</span> 
  especializada en el protocolo con el que estemos trabajando. Por ejemplo si 
  trabajamos con HTTP, en realidad habremos obtenido un objeto <span class="codefrag">HttpURLConnection</span>.</p>
<p>Cuando accedamos a una URL, primero se enviar&aacute; un mensaje de petici&oacute;n 
  al servidor al que hace referencia la URL para solicitar la informaci&oacute;n 
  deseada. En este mensaje de petici&oacute;n se podr&aacute;n incluir una serie 
  de propiedades con informaci&oacute;n y un bloque de contenido que queramos 
  enviar al servidor. En estas propiedades que incluimos como cabecera podremos 
  especificar por ejemplo informaci&oacute;n sobre el agente de usuario, como 
  el tipo de cliente que est&aacute; accediendo al servidor y el idioma de este 
  cliente. Adem&aacute;s podemos incluir cualquier contenido que queramos al cuerpo 
  del mensaje.</p>
<p>Una vez se env&iacute;e el mensaje de petici&oacute;n al servidor, &eacute;ste 
  nos devolver&aacute; un mensaje de respuesta. En esta respuesta podremos encontrar 
  tambi&eacute;n una serie de cabeceras con informaci&oacute;n sobre la misma, 
  y un bloque de contenido que anteriormente hemos visto c&oacute;mo leer.</p>
<p>Todo este proceso de composici&oacute;n del mensaje de petici&oacute;n, env&iacute;o 
  del mensaje, recepci&oacute;n del mensaje de respuesta, y an&aacute;lisis del 
  mismo lo realiza internamente la clase <span class="codefrag">URLConnection</span>. Nosotros 
  podremos utilizar esta clase para configurar el mensaje de petici&oacute;n y 
  obtener la informaci&oacute;n del mensaje de respuesta de forma sencilla.</p>
<p>Una vez creada la conexi&oacute;n, &eacute;sta pasar&aacute; por tres estados:</p>
<ul>
  
<li>
<strong>Configuraci&oacute;n</strong>: No se ha establecido la conexi&oacute;n, 
    todav&iacute;a no se ha enviado el mensaje de petici&oacute;n. Este ser&aacute; 
    el momento en el que deberemos a&ntilde;adir la informaci&oacute;n necesaria 
    a las cabeceras del mensaje de petici&oacute;n.
  </li>
  
<li>
<strong>Conectada</strong>: El mensaje de petici&oacute;n ya se ha enviado, 
    y se espera recibir una respuesta. En este momento podremos leer las cabeceras 
    o el contenido de la respuesta.

  </li>
  
<li>
<strong>Cerrada</strong>: La conexi&oacute;n se ha cerrado y ya no podemos 
    hacer nada con ella.</li>

</ul>
<p>La conexi&oacute;n nada m&aacute;s crearse se encuentra en estado de configuraci&oacute;n. 
  Pasar&aacute; autom&aacute;ticamente a estado conectada cuando solicitemos cualquier 
  informaci&oacute;n sobre la respuesta.</p>
<p>
<strong>Enviar o recibir datos</strong>
</p>
<p>Para enviar o recibir el contenido de los mensajes de petici&oacute;n y respuesta 
  respectivamente deberemos hacer lo siguiente:</p>
<ul>
  
<li> 
    
<p>Crear la conexi&oacute;n&nbsp;</p>
  
</li>

</ul>
<pre class="code">URLConnection con = url.<strong>openConnection</strong>();</pre>
<ul>
  
<li> 
    
<p>Si vamos a enviar datos a trav&eacute;s de ella, establecer 
      la capacidad de salida&nbsp;con: </p>
  
</li>

</ul>
<pre class="code">con.<strong>setDoOutput</strong>(true);</pre>
<ul>
  
<li> 
    
<p>Si vamos a escribir en la petici&oacute;n, obtener el flujo 
      de salida con: </p>

  
</li>

</ul>
<pre class="code">OutputStream out = con.<strong>getOutputStream</strong>();</pre>
<ul>
  
<li> 
    
<p>Si vamos a leer la respuesta, obtener el flujo de entrada 
      con: </p>
  
</li>

</ul>
<pre class="code">InputStream in = con.<strong>getInputStream</strong>();</pre>
<ul>
  
<li> 
    
<p>Leer o escribir en los flujos de entrada y de salida obtenidos 
      como vimos en cap&iacute;tulos anteriores. </p>
  
</li>

</ul>
<p>Al obtener los flujos para escribir o leer en la conexi&oacute;n estaremos 
  haciendo que pase a estado conectado, por lo que no podremos continuar configurando 
  las propiedades de la petici&oacute;n despu&eacute;s de hacer esto. Estas propiedades 
  de configuraci&oacute;n las deberemos establecer previamente a la apertura de 
  estos flujos, como veremos a continuaci&oacute;n.</p>
<p>
<strong>Mensaje de petici&oacute;n</strong>
</p>
<p>En fase de configuraci&oacute;n podremos a&ntilde;adir una serie de propiedades 
  al mensaje de petici&oacute;n para configurarlo. Estas propiedades ser&aacute;n 
  parejas <em>&lt;clave, valor&gt;</em>. Las a&ntilde;adiremos con el siguiente 
  m&eacute;todo:</p>
<pre class="code">con.<strong>setRequestProperty</strong>(nombre, valor);</pre>
<p>Por ejemplo, podemos mandar las siguiente cabeceras:</p>
<pre class="code">con.<strong>setRequestProperty</strong>("IF-Modified-Since", 
	"22 Sep 2002 08:00:00 GMT");
con.<strong>setRequestProperty</strong>("Content-Language", "es-ES");</pre>
<p>Con esto estaremos diciendo al servidor que queremos que nos devuelva una respuesta 
  s&oacute;lo si ha sido modificada desde la fecha indicada, y adem&aacute;s le 
  estamos comunicando datos sobre el cliente, como que el lenguaje del cliente 
  es espa&ntilde;ol de Espa&ntilde;a.</p>
<p>
<strong>Cabeceras de la respuesta</strong>
</p>
<p>Una vez hayamos terminado de configurar el mensaje de petici&oacute;n, podemos 
  pasar a estado conectado. En este estado, adem&aacute;s de leer el contenido 
  del mensaje de respuesta, podremos obtener informaci&oacute;n sobre esta respuesta 
  consultando una serie de cabeceras incluidas en este mensaje.</p>
<p>Tambi&eacute;n podemos utilizar este objeto para leer las cabeceras que nos 
  ha devuelto la respuesta. Nos ofrece m&eacute;todos para leer una serie de cabeceras 
  est&aacute;ndar de HTTP como los siguientes:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">getLength</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">content-length</span></td>
    <td colspan="2" rowspan="1">Longitud del contenido, o <span class="codefrag">-1</span> si la longitud es 
      desconocida</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">getType</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">content-type</span></td>
    <td colspan="2" rowspan="1">Tipo MIME del contenido devuelto</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">getEncoding</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">content-encoding</span></td>
    <td colspan="2" rowspan="1">Codificaci&oacute;n del contenido</td>

  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">getExpiration</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">expires</span></td>
    <td colspan="2" rowspan="1">Fecha de expiraci&oacute;n del recurso</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">getDate</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">date</span></td>
    <td colspan="2" rowspan="1">Fecha de env&iacute;o del recurso</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">getLastModified</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">last-modified</span></td>
    <td colspan="2" rowspan="1">Fecha de &uacute;ltima modificaci&oacute;n del recurso</td>

  
</tr>

</table>
<p>Puede ser que queramos obtener otras cabeceras, como por ejemplo cabeceras 
  propias no est&aacute;ndar. Para ello tendremos una serie de m&eacute;todos 
  que obtendr&aacute;n las cabeceras directamente por su nombre:</p>
<pre class="code">String valor = con.<strong>getHeaderField</strong>(nombre);
int valor = con.<strong>getHeaderFieldInt</strong>(nombre, default);
long valor = con.<strong>getHeaderFieldDate</strong>(nombre, default);</pre>
<p>De esta forma podemos obtener el valor de la cabecera o bien como una cadena, 
  o en los datos que sean de tipo fecha (valor <span class="codefrag">long</span>) o enteros tambi&eacute;n 
  podremos obtener su valor directamente en estos tipos de datos.</p>
<p>Podremos acceder a las cabeceras tambi&eacute;n a partir de su &iacute;ndice:</p>
<pre class="code">String valor = con.<strong>getHeaderField</strong>(int indice);
String nombre = con.<strong>getHeaderFieldKey</strong>(int indice);</pre>
<p>Podemos obtener de esta forma tanto el nombre como el valor de la cabecera 
  que ocupa un determinado &iacute;ndice.</p>
<p>Tanto los m&eacute;todos que obtienen un flujo para leer o escribir en la conexi&oacute;n, 
  como estos m&eacute;todos que acabamos de ver para obtener informaci&oacute;n 
  sobre la respuesta producir&aacute;n una transici&oacute;n al estado conectado.</p>
<p>
<strong>Ejemplo</strong>
</p>
<p>Vamos a ver un ejemplo de como enviar datos al servidor, y posteriormente leer 
  la respuesta. Cuando enviemos datos ser&aacute; conveniente proporcionar el 
  tama&ntilde;o y el tipo MIME de este contenido para que pueda ser interpretado 
  correctamente. Estos datos se incluir&aacute;n como propiedades de la petici&oacute;n.</p>
<pre class="code">// Creamos la URL
<strong>URL</strong> url = new <strong>URL</strong>("http://jtech.ua.es/chat/enviar");

// Creamos la conexion
<strong>URLConnection</strong> con = url.<strong>openConnection</strong>();

// Activamos la salida de datos en la conexi&oacute;n
con.<strong>setDoOutput</strong>(true);

// Escribimos los datos en un buffer en memoria
ByteArrayOutputStream baos = new ByteArrayOutputStream();
DataOutputStream dos = new DataOutputStream(baos);
dos.writeUTF(nick);
dos.writeUTF(msg);
dos.close();

// Establecemos las propiedades de tipo y tama&ntilde;o del contenido
con.<strong>setRequestProperty</strong>("Content-Length", String.valueOf(baos.size()));
con.<strong>setRequestProperty</strong>("Content-Type", "application/octet-stream");
   

// Abrimos el flujo de salida para enviar los datos al servidor
OutputStream out = con.<strong>getOutputStream</strong>();
baos.writeTo(out);

// Abrimos el flujo de entrada para leer la respuesta obtenida
InputStream in = con.<strong>getInputStream</strong>();</pre>
<p>&nbsp;</p>
<p>&nbsp; </p>
</div>


<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006 Depto. CCIA</div>
</div>
</body>
</html>
