<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Conceptos avanzados de AWT y Swing</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Java y Herramientas de Desarrollo" src="images/baner_j2ee_der.gif" title="Java y Herramientas de Desarrollo"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Java y Herramientas de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Java y Herramientas de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 6</div>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion06-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Conceptos avanzados de AWT y Swing</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Applets+y+seguridad">Applets y seguridad</a>
<ul class="minitoc">
<li>
<a href="#Applets">Applets</a>
</li>
<li>
<a href="#Algunas+notas+acerca+de+seguridad">Algunas notas acerca de seguridad</a>
</li>
</ul>
</li>
<li>
<a href="#Conceptos+avanzados+de+Swing">Conceptos avanzados de Swing</a>
<ul class="minitoc">
<li>
<a href="#Coordinaci%C3%B3n+de+acciones%3A+Action">Coordinaci&oacute;n de acciones: Action</a>
</li>
<li>
<a href="#Uso+de+bordes">Uso de bordes</a>
</li>
<li>
<a href="#Transferencia+de+datos">Transferencia de datos</a>
</li>
<li>
<a href="#Uso+de+iconos">Uso de iconos</a>
</li>
<li>
<a href="#Temporizadores">Temporizadores</a>
</li>
<li>
<a href="#Apariencia">Apariencia</a>
</li>
<li>
<a href="#Hilos+y+Swing">Hilos y Swing</a>
</li>
</ul>
</li>
</ul>
</div>


<p>Una vez vista una introducci&oacute;n a lo que las librer&iacute;as AWT y Swing pueden ofrecernos para construir aplicaciones gr&aacute;ficas, en este tema veremos algunos conceptos avanzados que nos ofrece la librer&iacute;a Swing.</p>

<p>Comenzaremos dando una breve introducci&oacute;n a otro tipo de aplicaciones que podemos construir con AWT y Swing, que son los applets. Despu&eacute;s, veremos algunas caracter&iacute;sticas adicionales que podemos utilizar con Swing a la hora de elaborar nuestras aplicaciones gr&aacute;ficas.</p>


<a name="N10012"></a><a name="Applets+y+seguridad"></a>
<h2 class="underlined_10">Applets y seguridad</h2>
<div class="section">
<a name="N10018"></a><a name="Applets"></a>
<h3 class="underlined_5">Applets</h3>
<p>Los ejemplos de aplicaciones gr&aacute;ficas vistos hasta ahora son propiamente <strong>aplicaciones</strong>, puesto que son instancias de la clase <strong>Frame </strong>o <strong>JFrame</strong>, y por tanto son ventanas que pueden ejecutarse independientemente.</p>
<p>Un <strong>applet </strong>es una aplicaci&oacute;n normalmente corta (aunque no hay l&iacute;mite de tama&ntilde;o), cuya principal funcionalidad es ser accesible a un servidor Internet (una aplicaci&oacute;n que pueda visualizarse desde un navegador).</p>
<p>La forma de definir un applet es muy similar a la definici&oacute;n de una aplicaci&oacute;n, salvo por algunas diferencias: </p>
<ul>
			
<li>No se hereda de <strong>Frame</strong> o <strong>JFrame</strong>, sino de <strong>Applet</strong> (clase <em>java.applet.Applet</em>) o <strong>JApplet</strong>
</li>
			
<li> No hay constructor, en su lugar hay un m&eacute;todo <strong>init()</strong> que veremos a continuaci&oacute;n</li>
			
<li> No hay m&eacute;todo <strong>main()</strong>, puesto que el applet no puede autoejecutarse. Lo que se ejecuta es la p&aacute;gina HTML para ver el applet en el navegador.</li>
		
</ul>
<p>El programa <strong>appletviewer </strong>es un navegador m&iacute;nimo distribuido con JDK, que espera como argumento un fichero HTML, que contendr&aacute; una marca indicando el c&oacute;digo que cargar&aacute; el <em>appletviewer</em>:</p>
<pre class="code">appletviewer &lt;fichero HTML&gt;</pre>
<p>El c&oacute;digo necesario para poder cargar un applet en una p&aacute;gina HTML es: </p>
<pre class="code">&lt;HTML&gt;
  &lt;BODY&gt;
  ...
  &lt;APPLET CODE = nombre_prog.class WIDTH = 300 HEIGHT = 100&gt;
  &lt;/APPLET&gt;
  ...
  &lt;/BODY&gt;
&lt;/HTML&gt;</pre>
<p>Donde se indican el fichero <em> .class</em> compilado del applet, la anchura y altura. Este c&oacute;digo se coloca en un fichero HTML y puede verse desde cualquier navegador que soporte Java, o con el programa <em>appletviewer</em>.</p>
<p>Tambi&eacute;n podemos utilizar la etiqueta OBJECT en lugar de APPLET, ya que esta &uacute;ltima est&aacute; desaconsejada:</p>
<pre class="code">&lt;HTML&gt;
  &lt;BODY&gt;
  ...
  &lt;OBJECT codetype="application/java" classid = "java:nombre_prog.class"
   WIDTH = 300 HEIGHT = 100&gt;
  &lt;/OBJECT&gt;
  ...
  &lt;/BODY&gt;
&lt;/HTML&gt;</pre>
<p>La clase <strong>Applet</strong> tiene unos m&eacute;todos predefinidos para controlar los applets, y que componen el <strong>ciclo de vida </strong>del applet:</p>
<ul>
			
<li> 
<strong>init ( )</strong>: este m&eacute;todo se llama cada vez que el appletviewer carga por primera vez la clase. En &eacute;l deben inicializarse las caracter&iacute;sticas del applet que se quieran (tama&ntilde;o, im&aacute;genes, controles, valores de variables, etc).</li>
			
<li> 
<strong>start ( )</strong>: llamada para arrancar el applet cada vez que es visitado. Normalmente no es necesario redefinir este m&eacute;todo. Por ejemplo, podr&iacute;a hacer falta redefinirlo si el applet est&aacute; haciendo una animaci&oacute;n, para detenerla si no tiene sentido hacerla cuando el usuario no la est&aacute; viendo. </li>
			
<li> 
<strong>stop ( )</strong>: llamada para detener la ejecuci&oacute;n del applet. Se llama cuando el applet desaparece de la pantalla. Al igual que lo anterior, normalmente no es necesario redefinir este m&eacute;todo.</li>
			
<li> 
<strong>destroy ( )</strong>: se llama cuando ya no se va a usar m&aacute;s el applet, y hay que liberar los recursos dispuestos por el mismo. </li>
		
</ul>
<p>
<strong>Applets Swing</strong>
</p>
<p>La &uacute;nica diferencia entre los applets construidos en <em>AWT</em> y los construidos con <em>Swing</em> es que &eacute;stos heredan de la clase <em>JApplet</em> en lugar de la clase <em>Applet</em>. Pero se tiene el inconveniente de que actualmente s&oacute;lo la utilidad <em>appletviewer</em> est&aacute; preparada para ejecutar applets de <em>Swing</em> con Java 1.2 o posteriores. Para el resto de navegadores deberemos contar con el Java Plug-in 1.1.1, que contiene la versi&oacute;n 1.0.3 de <em>Swing</em> . El resto de la estructura de los applets es la misma que para AWT.</p>
<p>
<strong>Ejemplo</strong>: Vemos uno de los ejemplos anteriores convertido en applet.</p>
<p>
<img alt="" content-width="10cm" height="195" src="imagenes/awtswing/AWTejemplo2.jpg" width="495"></p>
<p>Vemos aqu&iacute; el c&oacute;digo:</p>
<pre class="code">import java.awt.*;
import java.applet.*;
import java.awt.event.*;

/**
  * Este es un ejemplo de applet similar al ejemplo de AWT del contador
  * Se modifica un contador bien pulsando un boton,
  * bien modificando el valor a mano, bien mediante un desplegable
  */
public class EjemploApplet extends Applet
{
<strong>	// Contador a modificar</strong>
	TextField txtCont;
	
<strong>	/**
	  * Inicializa el applet
	  */</strong>
	public void init()
	{		
		setLayout(new BorderLayout());
	
<strong>		// ****** Panel con el contador ******</strong>
		
		Panel panelCont = new Panel();		
		final Label lblCont = new Label("Contador:");
		lblCont.addMouseListener(new MouseAdapter()
		{
			// Al entrar en la etiqueta hacemos que cambie su texto
			public void mouseEntered(MouseEvent e)
			{
				lblCont.setText("En etiqueta!");
			}

			public void mouseExited(MouseEvent e)
			{
				lblCont.setText("Contador:");
			}
		});
		txtCont = new TextField("0");
		panelCont.add(lblCont);
		panelCont.add(txtCont);
		
<strong>		// ****** Panel para el boton ******</strong>
		
		Panel panelBoton = new Panel();		
		Label lblBoton = new Label("Incrementar Contador:");
		Button btn = new Button("Incrementar");
		btn.addActionListener(new ActionListener()
		{
			// Al pulsar el boton incrementamos en 1 el contador
			public void actionPerformed(ActionEvent e)
			{
				txtCont.setText("" + (Integer.parseInt(txtCont.getText()) + 1));
			}
		});
		panelBoton.add(lblBoton);
		panelBoton.add(btn);
		
<strong>		// ****** Panel para el desplegable ******</strong>
		
		Panel panelChoice = new Panel();		
		Label lblChoice = new Label("Establecer Contador:");
		final Choice ch = new Choice();
		for (int i = 0; i &lt; 10; i++)
			ch.addItem("" + i);
		ch.addItemListener(new ItemListener()
		{
			// Al elegir una opcion, se asigna ese valor al contador
			public void itemStateChanged(ItemEvent e)
			{
				txtCont.setText(ch.getSelectedItem());
			}
		});
		panelChoice.add(lblChoice);
		panelChoice.add(ch);


<strong>		// Colocamos los paneles</strong>
		add(panelCont, "South");
		add(panelBoton, "West");
		add(panelChoice, "East");
	}
	
<strong>	/**
	  * Pinta el applet
	  */</strong>
	public void paint (Graphics g)
	{
	}
}</pre>
<p>y aqu&iacute; la p&aacute;gina HTML con el applet:</p>
<pre class="code">&lt;HTML&gt;
&lt;BODY&gt;
&lt;APPLET CODE="EjemploApplet.class" WIDTH="500" HEIGHT="100"&gt;
&lt;/APPLET&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</pre>
<a name="N100E8"></a><a name="Algunas+notas+acerca+de+seguridad"></a>
<h3 class="underlined_5">Algunas notas acerca de seguridad</h3>
<p>Java realiza un importante control de seguridad en los programas, que impide que programas escritos en dicho lenguaje puedan da&ntilde;ar nuestra informaci&oacute;n (virus), accedan a informaci&oacute;n privada, o realicen cualquier otra actividad da&ntilde;ina.</p>
<p>B&aacute;sicamente, la seguridad gira en torno a programas externos que se ejecuten en nuestra m&aacute;quina, es decir, <em>Applets. </em>En principio, en <strong> JDK 1.0</strong> Java &uacute;nicamente aplicaba una serie de restricciones de seguridad sobre los Applets. Proporcionaba a estos programas un acceso restringido a los recursos de nuestro sistema. En <strong> JDK 1.1</strong> se incorporan los llamados <em> Applets</em> <em>firmados</em>. En los <em>Applets</em> que tengan una <em>firma</em> de confianza, se relajar&aacute;n las restricciones de seguridad, seg&uacute;n las necesidades del <em> Applet</em> en cuesti&oacute;n. Esto permitir&aacute; incorporar m&aacute;s capacidades a los <em>Applets</em>, que podr&aacute;n ser utilizadas siempre que el usuario conf&iacute;e en la <em>firma</em> y acepte otorgar al <em> Applet</em> los permisos que solicita. En <strong> JDK 1.2</strong> se producen grandes cambios en el sistema de seguridad. Ahora ya no s&oacute;lo se aplican las restricciones de seguridad a c&oacute;digo remoto, sino que pueden ser aplicadas a <strong> cualquier programa</strong> Java, ya sea local o remoto. Las clases Java se organizan en una serie de <em>dominios</em>, de forma que cada <em>dominio</em> tiene una serie de permisos propios. Uno de estos <em>dominios </em>ser&aacute;n los <em>Applets</em>, que tendr&aacute;n una serie de restricciones de seguridad como en versiones anteriores. Las aplicaciones por defecto no tienen restricciones, pero podemos pon&eacute;rselas.</p>
<p>
<strong>Restricciones de seguridad en Applets</strong>
</p>
<p>Si dej&aacute;semos que un Applet accediese a todos los recursos de nuestra m&aacute;quina podr&iacute;a ser muy peligroso, ya que cualquiera simplemente colgando un <em> Applet</em> en su p&aacute;gina podr&iacute;a tener libertad para hacer casi cualquier cosa dentro de los ordenadores de todo aquel que visite la web. Por esto los <em> Applets</em> cuentan con una serie de restricciones importantes:</p>
<ul>
			
<li>No pueden acceder a m&eacute;todos nativos.</li>
			
<li>No pueden leer ni escribir en ficheros de la m&aacute;quina local donde se ejecute. S&oacute;lo puede acceder a ficheros si proporciona la URL absoluta del fichero.</li>
			
<li>No pueden establecer conexiones de red a ning&uacute;n <em>host</em> distinto al <em>host</em> desde el que nos hemos descargado el <em>Applet</em>.</li>
			
<li>No pueden ejecutar programas en la m&aacute;quina donde se est&aacute; ejecutando.</li>
			
<li>No pueden leer las propiedades del sistema.</li>
			
<li>Las ventanas que muestran los <em> Applets</em> tienen una apariencia distinta a las ventanas del sistema operativo.</li>
		
</ul>
<p>Podremos cambiar la configuraci&oacute;n de forma que se eliminen algunas de estas restricciones, estableciendo los permisos necesarios para ello. De la misma forma, aunque las aplicaciones no tengan por defecto estas restricciones de seguridad, podremos hacer que tambi&eacute;n se vean sujetas a ellas.</p>
<p>
<strong>Ficheros de pol&iacute;ticas de seguridad</strong>
</p>
<p>Los ficheros de pol&iacute;tica (<em>policy</em>) establecen la pol&iacute;ticas de seguridad (permisos) que se llevar&aacute;n a cabo en los programas Java que utilicemos. Estos ficheros son ficheros de texto que pueden ser editados con cualquier editor ASCII o bien con la herramienta incluida en la distribuci&oacute;n de JDK para tal fin: <em>Policy Tool</em>.</p>
<p>Para ejecutar la aplicaci&oacute;n <em>Policy Tool </em>deberemos introducir en la l&iacute;nea de comando:</p>
<pre class="code">policytool</pre>
<p>
<img alt="" content-width="11cm" height="306" src="imagenes/awtswing/policy.gif" width="559"></p>
<p>Desde esta aplicaci&oacute;n podremos crear ficheros de pol&iacute;ticas, que luego podremos emplear para imponerlos sobre determinadas aplicaciones.</p>
<p>
<strong>Asociaci&oacute;n de ficheros de pol&iacute;ticas con aplicaciones o applets</strong>
</p>
<p>Cuando se ejecuta una aplicaci&oacute;n o <em>Applet</em> con un manejador de seguridad, los ficheros de pol&iacute;ticas que se cargan son los definidos en el fichero de propiedades de seguridad que se encuentra en el directorio <strong>{java.home}/lib/security/java.security</strong>.</p>
<p>Para utilizar el fichero de pol&iacute;ticas que hayamos definido, podemos optar bien por a&ntilde;adirlo a este fichero de propiedades de seguridad, o bien a&ntilde;adirlo como propiedad del sistema el ejecutar el int&eacute;rprete Java, utilizando para ello el siguiente par&aacute;metro:</p>
<pre class="code">appletviewer <strong>-J-Djava.security.policy=mipolitica</strong> MiApplet</pre>
<p>De esta manera estamos forzando a que se utilice la pol&iacute;tica definida en el fichero <strong>mipolitica</strong>.</p>
<p>En una aplicaci&oacute;n Java por defecto no se instala ning&uacute;n gestor de seguridad. Si queremos imponer restricciones de seguridad podemos forzar que se cargue un gestor de seguridad por defecto llamando al interprete con el par&aacute;metro:</p>
<pre class="code">java <strong>-Djava.security.manager</strong> MiAplicacion</pre>
<p>Podemos adem&aacute;s especificar el fichero de pol&iacute;ticas que queremos que utilice el gestor de seguridad cargado, esto lo haremos de la siguiente forma:</p>
<pre class="code">java -Djava.security.manager 
		<strong>-Djava.security.policy=mipolitica </strong>MiAplicacion</pre>
<p>
<strong>Gestores de seguridad</strong>
</p>
<p>El gestor de seguridad (<strong>SecurityManager</strong>) ser&aacute; el objeto encargado de determinar si cierta operaci&oacute;n es permitida o no, impidiendo su realizaci&oacute;n en tal caso. Cuando una aplicaci&oacute;n carga un gestor de seguridad todas las acciones que vaya a realizar sujetas a posibles restricciones de seguridad se comprobar&aacute;n en dicho gestor antes de ser realizadas.</p>
<p>En el caso de los <em>Applets</em> es el navegador el encargado de instalar en ellos el gestor de seguridad por defecto, por lo que siempre estar&aacute;n sujetos a restricciones de seguridad.</p>
<p>En las aplicaciones independientes no se carga por defecto ning&uacute;n gestor de seguridad, pero podremos hacer que se cargue bien indic&aacute;ndolo en la l&iacute;nea de comando como hemos visto en el punto anterior, o bien desde el mismo c&oacute;digo de nuestra aplicaci&oacute;n.</p>
<p>El gestor de seguridad por defecto (clase <strong>SecurityManager</strong>) ser&aacute; el gestor que carguen los <em>Applets</em>, o las aplicaciones cuando lo especifiquemos en la l&iacute;nea de comando. Este gestor de seguridad seguir&aacute; la pol&iacute;tica de seguridad indicada en los ficheros de pol&iacute;ticas que hayamos especificado (tanto en el fichero de propiedades de seguridad como en la l&iacute;nea de comandos).</p>
<p>Adem&aacute;s, podemos crear nuestro propio gestor de seguridad, heredando de <em>SecurityManager</em> y redefiniendo los m&eacute;todos que consideremos necesarios (se tienen varios m&eacute;todos <em>checkXXXX(...)</em> que comprueban varias tareas diferentes). Podemos establecer y obtener el gestor actualmente instalado con los m&eacute;todos <strong>setSecurityManager(...) </strong>y <strong>getSecurityManager(...)</strong> de la clase <em>System</em>, respectivamente, aunque s&oacute;lo podremos establecer un gestor de seguridad para los programas que no tengan uno ya establecido. Esto se hace para evitar que se pueda alterar el gestor asignado a un Applet, por ejemplo.</p>
</div>

<a name="N101DB"></a><a name="Conceptos+avanzados+de+Swing"></a>
<h2 class="underlined_10">Conceptos avanzados de Swing</h2>
<div class="section">
<p>Adem&aacute;s de lo visto anteriormente, Swing ofrece otras posibilidades propias, que no tiene AWT. Algunas de ellas son:</p>
<ul>
		
<li>Uso de <strong>acciones</strong>, objetos <strong>Action</strong> que coordinan tareas realizadas por distintos elementos.</li>
		
<li>Incorporaci&oacute;n de funciones de <strong>accesibilidad</strong>, que permitan que las personas con alg&uacute;n tipo de discapacidad o minusval&iacute;a puedan utilizar perfectamente los programas Swing.</li>
		
<li>Uso de <strong>bordes</strong>, elementos que bordean los controles y ofrecen un mejor aspecto visual a la aplicaci&oacute;n.</li>
		
<li>Uso de <strong>iconos</strong>: algunos componentes permiten que se les indique un icono a mostrar, mediante la clase <strong>ImageIcon</strong>.</li>
		
<li>Uso de la <strong>apariencia</strong> (<em>look and feel</em>): podemos indicar qu&eacute; aspecto queremos que tenga la aplicaci&oacute;n: espec&iacute;fico de Windows, de Motif, etc.</li>
		
<li>Uso de <strong>hilos</strong> para gestionar eventos: algunos eventos pueden bloquear componentes durante mucho tiempo, y es mejor separar el tratamiento del evento en un hilo para liberar el componente. Sin embargo, si dejamos que dicho hilo se ejecute libremente, e interact&uacute;a con controles de la aplicaci&oacute;n, se pueden producir inconsistencias. Para evitar eso, Swing permite ejecutar hilos adecuadamente, en consonancia con el resto de la aplicaci&oacute;n gr&aacute;fica.</li>
		
<li>Uso de <strong>temporizadores</strong>: con la clase <strong>Timer</strong> podemos definir acciones que queremos ejecutar en un momento determinado o con una periodicidad determinada.</li>
	
</ul>
<p>A continuaci&oacute;n veremos con algo m&aacute;s de detalle algunas de estas caracter&iacute;sticas</p>
<a name="N10220"></a><a name="Coordinaci%C3%B3n+de+acciones%3A+Action"></a>
<h3 class="underlined_5">Coordinaci&oacute;n de acciones: Action</h3>
<p>Si en una aplicaci&oacute;n Swing tenemos dos componentes que realizan el mismo <strong>evento de acci&oacute;n</strong>, quiz&aacute; nos convenga utilizar un objeto <strong>Action</strong> para realizar dicha tarea. Estos objetos son<em> ActionListeners</em> que centralizan y coordinan un disparo del evento que pueda venir de varias fuentes.</p>
<p>Por ejemplo, imaginemos que queremos copiar el contenido de un cuadro de texto en otro, y queremos copiarlo tanto si pulsamos <em>Intro</em> sobre el cuadro de texto, como si pulsamos sobre un bot&oacute;n <em>Copiar</em> de la aplicaci&oacute;n. Por una parte, definimos los controles: el cuadro de texto desde donde copiar, el cuadro de texto donde copiar, y el bot&oacute;n:</p>
<pre class="code">JTextField txt = new JTextField();
JTextField txtRes = new JTextField();
JButton btn = new JButton("Copiar");</pre>
<p>Por otra parte definimos el objeto de tipo <em>Action</em>. Hay que tener en cuenta que <em>Action</em> es una interfaz. Hay una clase abstracta llamada <em>AbstractAction</em> (tambi&eacute;n dentro de <em>javax.swing</em>) que implementa dicha interfaz. As&iacute; que para crear el <em>Action</em> crearemos una clase que herede de esta (para implementar ya los m&eacute;todos de <em>Action</em>), y redefinimos el m&eacute;todo <em>actionPerformed(...)</em> que se ejecutar&aacute; cuando se dispare el evento, bien por el cuadro de texto, bien por el bot&oacute;n:</p>
<pre class="code">class MiAction extends AbstractAction
{
	public MiAction()
	{
	}
		
	public void actionPerformed(ActionEvent e)
	{
		txtRes.setText(txt.getText());
	}
}</pre>
<p>El evento simplemente copia el texto de un cuadro a otro. Una vez definida la acci&oacute;n, la asociamos a los controles como un <em>ActionListener</em> m&aacute;s: </p>
<pre class="code">MiAction ac = new MiAction();
txt.addActionListener(ac);
btn.addActionListener(ac);</pre>
<p>
<strong>Ejemplo</strong>: un ejemplo de lo explicado en este apartado: </p>
<pre class="code">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class EjemploAction extends JFrame
{
<strong>	// Cuadro de texto</strong>
	JTextField txt;
	
<strong>	// Boton</strong>
	JButton btn;
	
<strong>	// Cuadro de texto resultado</strong>
	JTextField txtRes;
	
<strong>	// Constructor</strong>
	public EjemploAction()
	{
		getContentPane().setSize(200, 200);
		
		Action ac = new MiAction();
		
		txt = new JTextField();
		btn = new JButton("Copiar");
		txtRes = new JTextField();
		
		txt.addActionListener(ac);
		btn.addActionListener(ac);
		
		add(txt, BorderLayout.NORTH);
		add(btn, BorderLayout.CENTER);
		add(txtRes, BorderLayout.SOUTH);
	}

<strong>	// Funcion principal</strong>
	public static void main (String[] args)
	{
		EjemploAction ea = new EjemploAction();
		ea.addWindowListener(new WindowAdapter()
		{
			public void windowClosing(WindowEvent e)
			{
				System.exit(0);
			}
		});
		ea.pack();
		ea.show();
	}

<strong>	// Clase que implementa la accion</strong>
	class MiAction extends AbstractAction
	{
<strong>		// Constructor</strong>
		public MiAction()
		{
		}
		
<strong>		// Evento de disparo de accion</strong>
		public void actionPerformed(ActionEvent e)
		{
			txtRes.setText(txt.getText());
		}
	}
}</pre>
<p>
<strong>Teclas de m&eacute;todo abreviado</strong>
</p>
<p>Tambi&eacute;n podemos hacer que al pulsar una tecla sobre un componente se ejecute una acci&oacute;n. Para ello lo que hacemos es:</p>
<ul>
  			
<li>Mapear en el componente cada tecla de m&eacute;todo abreviado con un nombre de acci&oacute;n</li>
  			
<li>Mapear el nombre de acci&oacute;n con un objeto de tipo <em>Action</em> que desarrolle la acci&oacute;n en concreto.</li>
		
</ul>
<p>Por ejemplo, si queremos que al pulsar F1 sobre un <em>JPanel</em> nos aparezca un mensaje de ayuda, har&iacute;amos algo como lo siguiente:</p>
<pre class="code">JPanel p = new JPanel();
MiObjetoAction moa = new MiObjetoAction();
...
p.getInputMap().put(KeyStroke.getKeyStroke("F1"), "accion1");
p.getActionMap().put("accion1", moa);</pre>
<p>Primero utilizamos <em>getInputMap(...)</em> para mapear la entrada de teclado con un nombre de acci&oacute;n (en este caso, la pulsaci&oacute;n de la tecla <em>F1</em> con la acci&oacute;n que llamamos <em>accion1</em>). Para comparar pulsaciones de teclas utilizamos la clase <em>KeyStroke </em>y su m&eacute;todo <em>getKeyStroke. </em>Despu&eacute;s con <em>getActionMap</em> asociamos el nombre de acci&oacute;n anterior (<em>accion1</em>) con un objeto <em>Action</em> que internamente har&aacute; la acci&oacute;n que queramos (en este caso, mostrar la ayuda). En el ejemplo se supone que la clase <em>MiObjetoAction</em> se encarga de hacer esa tarea, aunque no se muestre.</p>
<p>El m&eacute;todo <em>getInputMap</em> acepta un par&aacute;metro entero para indicar cu&aacute;ndo queremos que se dispare el evento: si cuando tenga el foco el componente, o el contenedor que lo contiene, o la ventana que lo contiene.</p>
<a name="N102C8"></a><a name="Uso+de+bordes"></a>
<h3 class="underlined_5">Uso de bordes</h3>
<p>Podemos definir qu&eacute; bordes queremos que tenga cualquier subtipo de <em>JComponent</em>, aunque en general, para controles diferentes a un <em>JPanel</em> o <em>JLabel</em> Sun advierte que puede que no se representen bien dichos bordes. En esos casos, se puede colocar el componente dentro de un <em>JPanel</em>, y asignar el borde al <em>JPanel</em>.</p>
<p>Para colocar un borde en un componente utilizamos el m&eacute;todo <strong>setBorder(...)</strong> del componente. Dicho m&eacute;todo acepta un par&aacute;metro de tipo <em>Border</em>, que es una interfaz. Para indicar qu&eacute; tipo de borde queremos como par&aacute;metro, podemos utilizar la clase <strong>javax.swing.BorderFactory</strong>, y crear uno de los subtipos de bordes que permiten sus m&eacute;todos. Aqu&iacute; mostramos gr&aacute;ficamente algunos de ellos:</p>
<p>
<img alt="" content-width="8cm" height="153" src="imagenes/awtswing/SWbordes1.gif" width="385"></p>
<p>
<img alt="" content-width="8cm" height="227" src="imagenes/awtswing/SWbordes2.gif" width="383"></p>
<p>
<img alt="" content-width="8cm" height="50" src="imagenes/awtswing/SWbordes3.gif" width="382"></p>
<p>
<img alt="" content-width="8cm" height="50" src="imagenes/awtswing/SWbordes4.gif" width="382"></p>
<p>Por ejemplo, si queremos a&ntilde;adir un borde de l&iacute;nea rojo a un panel, pondr&iacute;amos:</p>
<pre class="code">JPanel p = new JPanel();
p.setBorder(BorderFactory.createLineBorder(Color.red));</pre>
<p>Adem&aacute;s de la gran cantidad de bordes disponibles, tambi&eacute;n podemos definirnos nuestros propios bordes, creando una subclase de <em>AbstractBorder</em>, y definiendo los m&eacute;todos necesarios.</p>
<a name="N1031A"></a><a name="Transferencia+de+datos"></a>
<h3 class="underlined_5">Transferencia de datos</h3>
<p>Podemos transferir informaci&oacute;n entre controles de una misma aplicaci&oacute;n, y tambi&eacute;n entre aplicaciones Java distintas, e incluso entre aplicaciones Java y programas nativos. Para transferir esta informaci&oacute;n podemos:</p>
<ul>
			
<li>Arrastrar y soltar (<em>drag &amp; drop</em>) la informaci&oacute;n a transferir de un lugar a otro</li>
  			
<li>Copiar/Cortar y pegar la informaci&oacute;n de un lugar a otro.</li>
		
</ul>
<p>Algunos controles Swing nos permiten realizar estas tareas en ellos (consultar el tutorial de Sun sobre Swing para m&aacute;s informaci&oacute;n). Por ejemplo, podemos sacar elementos de una lista (<em>JList</em>) y colocarlos en un cuadro de texto (<em>JTextField</em>).</p>
<p>Si queremos arrastrar (<em>drag</em>) elementos de un control de Swing que permita arrastre, tenemos que llamar a su m&eacute;todo <strong>setDragEnabled(...)</strong> pas&aacute;ndole como par&aacute;metro <em>true</em> para habilitar el arrastre. Para el resto de operaciones (soltar, copiar, cortar y pegar), no es necesario habilitar nada m&aacute;s.</p>
<p>Volviendo al ejemplo propuesto, imaginemos que queremos colocar en un cuadro de texto el elemento que seleccionemos de una lista, arrastrando y soltando. En este caso, primero definimos el cuadro de texto y la lista:</p>
<pre class="code">JTextField txt = new JTextField();

DefaultListModel dlm = new DefaultListModel();
dlm.addElement("Elemento 1");
dlm.addElement("Elemento 2");

JList lst = new JList(dlm);</pre>
<p>Y despu&eacute;s habilitamos el arrastre en la lista:</p>
<pre class="code">lst.setDragEnabled(true);</pre>
<p>
<strong>Ejemplo</strong>: un ejemplo de lo explicado en este apartado: </p>
<pre class="code">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class EjemploDrop extends JFrame
{
<strong>	// Cuadro de texto</strong>
	JTextField txt;
	
<strong>	// Lista</strong>
	JList lst;
		
<strong>	// Constructor</strong>
	public EjemploDrop()
	{
		getContentPane().setSize(200, 200);
			
		txt = new JTextField();

		DefaultListModel dlm = new DefaultListModel();
		dlm.addElement("Elemento 1");
		dlm.addElement("Elemento 2");
		lst = new JList(dlm);
		lst.setDragEnabled(true);
				
		add(txt, BorderLayout.NORTH);
		add(lst, BorderLayout.CENTER);
	}

<strong>	// Funcion principal</strong>
	public static void main (String[] args)
	{
		EjemploDrop ed = new EjemploDrop();
		ed.addWindowListener(new WindowAdapter()
		{
			public void windowClosing(WindowEvent e)
			{
				System.exit(0);
			}
		});
		ed.pack();
		ed.show();
	}
}</pre>
<a name="N10368"></a><a name="Uso+de+iconos"></a>
<h3 class="underlined_5">Uso de iconos</h3>
<p>Algunos controles Swing como <em>JLabel, JButton</em> o <em>JTabbedPane</em> permiten enriquecer su apariencia a&ntilde;adiendo iconos en ellos, utilizando la interfaz <em>Icon</em>. Para utilizarla, se proporciona una implementaci&oacute;n de la misma en la clase <strong>ImageIcon</strong>, que permite cargar iconos desde im&aacute;genes JPG, GIF o PNG. Normalmente se utiliza esta clase para crear iconos.</p>
<p>Por ejemplo, si queremos crear una etiqueta con un icono de un fichero GIF determinado, creamos la etiqueta con un constructor donde indicamos el texto de la etiqueta, su icono y la alineaci&oacute;n horizontal:</p>
<pre class="code">JLabel lbl = new JLabel("Nombre", new ImageIcon("icono.gif"), SwingConstants.CENTER);</pre>
<a name="N10385"></a><a name="Temporizadores"></a>
<h3 class="underlined_5">Temporizadores</h3>
<p>Un temporizador (<strong>javax.swing.Timer</strong>) es un objeto que permite indicar cu&aacute;ndo queremos disparar un evento de acci&oacute;n, y si queremos dispararlo repetidas veces o s&oacute;lo una vez. Se suele utilizar para tareas que se deben ejecutar en momentos puntuales, independientemente del flujo del programa.</p>
<p>Para definir temporizadores, utilizamos el constructor de <em>Timer</em> al que se le pasan dos par&aacute;metros:</p>
<ul>
			
<li>El tiempo en ms desde que se lanza el <em>Timer</em> hasta que se disparar&aacute;</li>
			
<li>Un objeto de tipo <em>ActionListener</em> que contendr&aacute; el m&eacute;todo <em>actionPerformed(...)</em> que se disparar&aacute; cuando pase el tiempo indicado.</li>
		
</ul>
<p>Por ejemplo, el siguiente Timer Saca un mensaje por un cuadro de texto 1 segundo despu&eacute;s de crearse: </p>
<pre class="code">Timer t = new Timer(1000, new ActionListener()
{
	public void actionPerformed(ActionEvent e)
	{
		txt.setText("Hola");
	}
});
t.start();</pre>
<p>Cuando llamamos al m&eacute;todo <strong>start()</strong> del <em>Timer</em>, &eacute;ste se activa, y pasado un segundo desde la activaci&oacute;n, mostrar&aacute; el mensaje de texto por un cuadro de texto <em>txt</em> que se supone creado previamente.</p>
<p>Por defecto, los <em>Timers</em>  ejecutan su tarea peri&oacute;dicamente (en el ejemplo anterior, cada segundo sacar&iacute;a el mensaje). Si s&oacute;lo queremos hacerlo una vez,  llamamos al m&eacute;todo <strong>setRepeats(...) </strong>del <em>Timer</em> pas&aacute;ndole como par&aacute;metro <em>false</em>. </p>
<pre class="code">...
t.setRepeats(false);
t.start();</pre>
<p>
<strong>Ejemplo</strong>: Vemos un ejemplo de uso de iconos y temporizadores. Se muestra una etiqueta con un icono de un reloj, y por otro lado un temporizador actualiza cada segundo el valor de un contador que se muestra en otra etiqueta:</p>
<p>
<img alt="" content-width="6cm" height="197" src="imagenes/awtswing/SWejemplo2.jpg" width="296"></p>
<pre class="code">import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

/**
  * Este ejemplo muestra algunas caracteristicas adicionales de Swing
  * como son el uso de iconos, y de timers (para un segundero)
  */
public class EjemploSwing2 extends JFrame
{
<strong>	// Etiqueta con el contador</strong>
	JLabel lblCont;
	 
<strong>	/**
	  * Constructor
	  */</strong>
	public EjemploSwing2()
	{
		setSize(300, 200);
		getContentPane().setLayout(new GridLayout(1, 2));
		
<strong>		// Etiqueta con icono</strong>
		JLabel lblEtiq = new JLabel("Contador:", new ImageIcon("clock.gif"), SwingConstants.CENTER);

<strong>		// Etiqueta para los segundos</strong>
		lblCont = new JLabel("0");

<strong>		// Timer: cada segundo incrementa el contador</strong>
		Timer t = new Timer(1000, new ActionListener()
		{
			public void actionPerformed(ActionEvent e)
			{
				lblCont.setText("" + (Integer.parseInt(lblCont.getText()) + 1));
			}
		});
		t.setRepeats(true);
		t.start();
			
		add(lblEtiq);
		add(lblCont);
		
<strong>		// Evento para cerrar la ventana</strong>
		addWindowListener(new WindowAdapter()
		{
			public void windowClosing (WindowEvent e)
			{
				System.exit(0);
			}
		});
	}
	
<strong>	/**
	  * Main
	  */</strong>
	public static void main (String[] args)
	{
		EjemploSwing2 e = new EjemploSwing2();
		e.show();
	}
}</pre>
<p>Como icono se emplea esta imagen:</p>
<p>
<img alt="" content-width="0.22cm" height="11" src="ejemplos/awtswing/clock.gif" width="11"></p>
<a name="N10401"></a><a name="Apariencia"></a>
<h3 class="underlined_5">Apariencia</h3>
<p>Como se ha comentado, la apariencia de un programa Java no se limita al sistema operativo en el que estemos, sino que podemos hacer que nuestro programa tenga apariencia Windows, Linux, y cualquier otra apariencia de la que podamos disponer.</p>
<p>Para cambiar la apariencia tenemos la clase <strong>UIManager</strong>, y su m&eacute;todo <strong>setLookAndFeel(...)</strong>. Por ejemplo, si queremos hacer que nuestro programa tenga la apariencia propia de Java, haremos algo como:</p>
<pre class="code">public static void main(String[] args)
{
	...
	try
	{
	UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
	} catch (Exception ex) { ... }
}</pre>
<p>La llamada a este m&eacute;todo puede provocar una excepci&oacute;n, si la clase de <em>look and feel</em> que queremos cargar no se encuentra.</p>
<p>Si disponemos de alg&uacute;n tipo de apariencia que nos hayamos descargado (normalmente se descargan en ficheros JAR que hay que incluir en el CLASSPATH), la a&ntilde;adimos pas&aacute;ndole como par&aacute;metro el nombre completo de la apariencia. Por ejemplo, as&iacute; se cargar&iacute;a una apariencia de Linux GTK, o una de Windows, respectivamente:</p>
<pre class="code">UIManager.setLookAndFeel("com.sun.java.swing.plaf.gtk.GTKLookAndFeel");
UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");</pre>
<a name="N10425"></a><a name="Hilos+y+Swing"></a>
<h3 class="underlined_5">Hilos y Swing</h3>
<p>Se debe tener cuidado a la hora de utilizar hilos en programas Swing. En general, una vez que se crea un componente, s&oacute;lo se puede acceder a &eacute;l (para obtener datos o modificarlos) desde el c&oacute;digo de los eventos que tenga asociados (lo que se llama <em>event-dispatching thread</em>). En caso contrario, podr&iacute;an provocarse inconsistencias que ocasionaran que el programa no funcionara correctamente.</p>
<p>Por esta raz&oacute;n, cuando necesitamos acceder a un componente desde fuera del c&oacute;digo del evento, podemos optar por varias alternativas:</p>
<ul>
			
<li>
				
<p>Si queremos actualizar un componente, podemos utilizar los m&eacute;todos <strong>invokeLater()</strong> o <strong>invokeAndWait()</strong> de la clase <strong>javax.swing.SwingUtilities</strong>. En ambos casos, se pasa como par&aacute;metro el objeto hilo que queremos ejecutar:</p>

<pre class="code">Thread t = new Thread(...);
...
SwingUtilities.invokeLater(t);
SwingUtilities.invokeAndWait(t);</pre>
				
<p>La diferencia entre uno y otro m&eacute;todo es que <em>invokeLater()</em> devuelve el control inmediatamente al programa principal para que siga ejecutando (y lanzar&aacute; el hilo cuando pueda), e <em>invokeAndWait()</em> detiene el programa principal hasta que se pueda lanzar el hilo. Se recomienda en la medida de lo posible utilizar el primero de ellos. El m&eacute;todo <em>run()</em> del hilo deber&aacute; tener todo el acceso a los componentes que se requiera.</p>
			
</li>
			
<li>
				
<p>Si queremos actualizar un componente en un instante determinado, o cada cierto tiempo, podemos usar los <strong>Timers </strong>vistos anteriormente, de forma que el <em>actionPerformed(...)</em> del <em>Timer</em> tendr&aacute; el c&oacute;digo que acceda a los componentes.</p>
			
</li>
		
</ul>
</div>


<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006 Depto. CCIA</div>
</div>
</body>
</html>
