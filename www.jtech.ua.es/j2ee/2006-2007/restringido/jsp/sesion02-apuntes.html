<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Procesamiento de peticiones</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servlets y JSP" src="images/baner_j2ee_der.gif" title="Servlets y JSP"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servlets y JSP</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servlets y JSP</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servlets y JSP">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 2</div>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="sesion09-apuntes.html">Sesion 9</a>
</div>
<div class="menuitem">
<a href="sesion10-apuntes.html">Sesion 10</a>
</div>
<div class="menuitem">
<a href="sesion11-apuntes.html">Sesion 11</a>
</div>
<div class="menuitem">
<a href="sesion12-apuntes.html">Sesion 12</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="sesion09-ejercicios.html">Sesion 9</a>
</div>
<div class="menuitem">
<a href="sesion10-ejercicios.html">Sesion 10</a>
</div>
<div class="menuitem">
<a href="sesion11-ejercicios.html">Sesion 11</a>
</div>
<div class="menuitem">
<a href="sesion12-ejercicios.html">Sesion 12</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion02-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Procesamiento de peticiones</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Peticiones%3A+HttpServletRequest">Peticiones: HttpServletRequest</a>
</li>
<li>
<a href="#Respuestas%3A+HttpServletResponse">Respuestas: HttpServletResponse</a>
</li>
<li>
<a href="#Procesamiento+de+peticiones+GET+y+POST">Procesamiento de peticiones GET y POST</a>
<ul class="minitoc">
<li>
<a href="#Procesamiento+secuencial+de+peticiones">Procesamiento secuencial de peticiones</a>
</li>
</ul>
</li>
<li>
<a href="#Manejo+de+formularios">Manejo de formularios</a>
<ul class="minitoc">
<li>
<a href="#Ejemplo">Ejemplo</a>
</li>
</ul>
</li>
<li>
<a href="#Pruebas+de+servlets+con+Cactus">Pruebas de servlets con Cactus</a>
</li>
</ul>
</div>


<p>Un servlet maneja peticiones de los clientes a trav&eacute;s de su m&eacute;todo <strong><span class="codefrag">service</span></strong>. Con &eacute;l se pueden manejar peticiones HTTP (entre otras), reenviando las peticiones a los m&eacute;todos apropiados que las manejan. Por ejemplo, una petici&oacute;n GET puede redirigirse a un m&eacute;todo <span class="codefrag">doGet</span>. Veremos ahora los elementos principales que intervienen en una interacci&oacute;n v&iacute;a HTTP. </p>

<a name="N10016"></a><a name="Peticiones%3A+HttpServletRequest"></a>
<h2 class="underlined_10">Peticiones: HttpServletRequest</h2>
<div class="section">
<p>Como hemos visto anteriormente, los objetos <strong><span class="codefrag">ServletRequest </span></strong>se emplean para obtener informaci&oacute;n sobre la petici&oacute;n de los clientes. M&aacute;s en concreto, el subtipo <strong><span class="codefrag">HttpServletRequest </span></strong>se utiliza en las peticiones HTTP. Proporciona acceso a los datos de las cabeceras HTTP, cookies, par&aacute;metros pasados por el usuario, etc, sin tener que parsear nosotros a mano los datos de formulario de la petici&oacute;n. </p>
<p>La clase dispone de muchos m&eacute;todos, pero destacamos los siguientes: </p>
<ul>
		
<li>
			
<p>Para <strong>obtener los valores de los par&aacute;metros</strong> pasados por el cliente, se tienen los m&eacute;todos:</p>

<pre class="code">Enumeration getParameterNames()
String      getParameter (String nombre)
String[]    getParameterValues (String nombre)</pre>
           
			
<p>Con <strong><span class="codefrag">getParameterNames() </span></strong>se obtiene una lista con los nombres de los par&aacute;metros enviados por el cliente. Con <strong><span class="codefrag">getParameter() </span></strong>se obtiene el valor del par&aacute;metro de nombre <span class="codefrag">nombre</span>. Si un par&aacute;metro tiene varios valores (por ejemplo, si tenemos un array de cuadros de texto con el mismo nombre en un formulario), se pueden obtener todos separados con <strong><span class="codefrag">getParameterValues()</span></strong>. Los nombres de los par&aacute;metros normalmente s&iacute; distinguen may&uacute;sculas de min&uacute;sculas, deberemos tener cuidado al indicarlos.</p>
		
</li>
		
<li>
			
<p>Para <strong>obtener la cadena de una petici&oacute;n GET</strong>, se tiene el m&eacute;todo:</p>
			
<pre class="code">String getQueryString()</pre>
			
<p>que devuelve todos los par&aacute;metros de la petici&oacute;n en una cadena, que deberemos parsear nosotros como nos convenga.</p>
		
</li>
		
<li>
			
<p>Para <strong>obtener datos de peticiones POST, PUT o DELETE</strong>, se tienen los m&eacute;todos:</p>

<pre class="code">BufferedReader     getReader()
ServletInputStream getInputStream()</pre>
			
<p>Con <strong><span class="codefrag">getReader() </span></strong>se obtiene un <span class="codefrag">BufferedReader </span>para peticiones donde esperemos recibir texto. Si esperamos recibir datos binarios, se debe emplear <strong><span class="codefrag">getInputStream()</span></strong>. Si lo que esperamos recibir son par&aacute;metros por POST igual que se har&iacute;a por GET, es mejor utilizar los m&eacute;todos <span class="codefrag">getParameterXXXX(...)</span> vistos antes.</p>
		
</li>
		
<li>
			
<p>Para <strong>obtener informaci&oacute;n sobre la l&iacute;nea de petici&oacute;n</strong>, se tienen los m&eacute;todos:</p>

<pre class="code">String getMethod()
String getRequestURI()
String getProtocol()</pre>
			
<p>Con <strong><span class="codefrag">getMethod() </span></strong>obtenemos el comando HTTP solicitado (GET, POST, PUT, etc), con <strong><span class="codefrag">getRequestURI()</span></strong> obtenemos la parte de la URL de petici&oacute;n que est&aacute; detr&aacute;s del <span class="codefrag">host</span> y el puerto, pero antes de los datos del formulario. Con <strong><span class="codefrag">getProtocol() </span></strong>obtenemos el protocolo empleado (<span class="codefrag">HTTP/1.1</span>, <span class="codefrag">HTTP/1.0</span>, etc).</p>
		
</li>
	
</ul>
</div>
           

<a name="N100A0"></a><a name="Respuestas%3A+HttpServletResponse"></a>
<h2 class="underlined_10">Respuestas: HttpServletResponse</h2>
<div class="section">
<p>Los objetos <strong><span class="codefrag">ServletResponse </span></strong>se emplean para enviar el resultado de procesar una petici&oacute;n a un cliente. El subtipo <strong><span class="codefrag">HttpServletResponse </span></strong>se utiliza en las peticiones HTTP. Proporciona acceso al canal de salida por donde enviar la respuesta al cliente. </p>
<p>La clase dispone de muchos m&eacute;todos, pero destacamos: </p>
<pre class="code">Writer              getWriter()
ServletOutputStream getOutputStream()</pre>
<p>Con <strong><span class="codefrag">getWriter() </span></strong>se obtiene un <span class="codefrag">Writer </span>para enviar texto al cliente. Si queremos enviar datos binarios, se debe emplear <strong><span class="codefrag">getOutputStream()</span></strong>.</p>
<p>Si queremos especificar informaci&oacute;n de cabecera, debemos establecerla ANTES de obtener el <span class="codefrag">Writer</span> o el <span class="codefrag">ServletOutputStream</span>. Hemos visto en alg&uacute;n ejemplo el m&eacute;todo <strong><span class="codefrag">setContentType() </span></strong>para indicar el tipo de contenido. Veremos las cabeceras con m&aacute;s detenimiento m&aacute;s adelante.</p>
</div>


<a name="N100D4"></a><a name="Procesamiento+de+peticiones+GET+y+POST"></a>
<h2 class="underlined_10">Procesamiento de peticiones GET y POST</h2>
<div class="section">
<p>Como se ha visto anteriormente, el m&eacute;todo <strong><span class="codefrag">doGet()</span></strong> se emplea para procesar peticiones GET. Para realizar nuestro propio procesamiento de petici&oacute;n, simplemente sobreescribimos este m&eacute;todo en el servlet: </p>
<pre class="code">public void doGet(HttpServletRequest request, 
                  HttpServletResponse response) 
throws ServletException, IOException
{
	// ... codigo para una peticion GET
}</pre>
<p>Podemos utilizar los m&eacute;todos del objeto <span class="codefrag">HttpServletRequest</span> vistos antes. As&iacute; podremos, entre otras cosas:</p>
<ul>
		
<li>
			
<p>Acceder a elementos de la petici&oacute;n, como valores de par&aacute;metros:</p>
			
<pre class="code">String nombreUsuario = request.getParameter("nombre");</pre>
		
</li>
        
<li>
			
<p>Acceder a los par&aacute;metros en la cadena de la petici&oacute;n y procesarlos como queramos:</p>

<pre class="code">String query = request.getQueryString();
...</pre>
		
</li>
        
<li>
			
<p>Obtener un canal de entrada (<span class="codefrag">Reader </span>o <span class="codefrag">InputStream</span>) con que leer los datos de la petici&oacute;n:<span class="codefrag"> </span>
</p>

<pre class="code">BufferedReader r = request.getReader();
...</pre>
			
<p>Esta, sin embargo, no es una buena idea para tomar par&aacute;metros de peticiones u otras cosas. Se suele emplear sobre todo para transferencias de ficheros, pero hay que tener en cuenta que si obtenemos un canal de entrada, luego no podremos obtener par&aacute;metros u otros valores con m&eacute;todos <span class="codefrag">getParameter() </span>y similares.</p>
		
</li>
        
<li>etc.</li>
	
</ul>
<p>Tambi&eacute;n podemos utilizar los m&eacute;todos del objeto <strong>HttpServletResponse</strong> para, entre otras cosas:</p>
<ul>
		
<li>
			
<p>Establecer valores de la cabecera (antes que cualquier otra acci&oacute;n sobre la respuesta):</p>
			
<pre class="code">response.setContentType("text/html");</pre>
		
</li>
		
<li>
			
<p>Obtener el canal de salida por el que enviar la respuesta:</p>

<pre class="code">PrintWriter out = response.getWriter();
out.println ("Enviando al cliente");</pre>
		
</li>
        
<li>
			
<p>Redirigir a otra p&aacute;gina:</p>
			
<pre class="code">response.sendRedirect("http://localhost:8080/pag.html");</pre>
		
</li>
        
<li> etc.</li>
	
</ul>
<p>De forma similar, el m&eacute;todo <strong><span class="codefrag">doPost()</span></strong>, se emplea para procesar peticiones POST. Igual que antes, debemos sobreescribir este m&eacute;todo para definir nuestro propio procesamiento de la petici&oacute;n:</p>
<pre class="code">public void doPost(HttpServletRequest request, 
                   HttpServletResponse response) 
throws ServletException, IOException
{
	// ... codigo para una peticion POST
}</pre>
<p>Las posibilidades de los par&aacute;metros <span class="codefrag">HttpServletRequest</span> y <span class="codefrag">HttpServletResponse</span> son las mismas que para GET. Normalmente muchos servlets definen el mismo c&oacute;digo para uno y otro m&eacute;todo (hacen que <span class="codefrag">doPost() </span>llame a <span class="codefrag">doGet()</span> y definen all&iacute; el c&oacute;digo, o al rev&eacute;s), pero conviene tenerlos separados para poder tratar independientemente uno y otro tipo de peticiones si se quiere.</p>
<a name="N10161"></a><a name="Procesamiento+secuencial+de+peticiones"></a>
<h3 class="underlined_5">Procesamiento secuencial de peticiones</h3>
<p>Los servlets normalmente pueden gestionar m&uacute;ltiples peticiones de clientes concurrentemente. Pero puede suceder que, si los m&eacute;todos que definimos acceden a un recurso compartido, no nos interese que varios clientes accedan a dicho recurso simult&aacute;neamente. Para solucionar este problema, podemos definir bloques de c&oacute;digo <span class="codefrag">synchronized</span>, o bien hacer que el servlet s&oacute;lo atienda una petici&oacute;n cada vez. </p>
<p>Para esto &uacute;ltimo, lo &uacute;nico que hay que hacer es que el servlet, adem&aacute;s de heredar de <span class="codefrag">HttpServlet</span>, implemente la interfaz <strong>SingleThreadModel</strong>. Esto no supone definir m&aacute;s m&eacute;todos, simplemente a&ntilde;adimos el <span class="codefrag">implements</span> necesario al definir la clase Servlet, y ya est&aacute;: </p>
<pre class="code">public class MiServlet 
extends HttpServlet implements SingleThreadModel
{
	... 
}</pre>
</div>
           

<a name="N1017F"></a><a name="Manejo+de+formularios"></a>
<h2 class="underlined_10">Manejo de formularios</h2>
<div class="section">
<p>Los datos que se env&iacute;an como par&aacute;metros en una petici&oacute;n (tras el interrogante si es una petici&oacute;n GET, o por otro lado si es POST) se llaman <strong>datos de formulario</strong>. Una vez enviados estos datos como petici&oacute;n, &iquest;c&oacute;mo se extraen en el servidor?  </p>
<p> Si trabaj&aacute;ramos con CGI, los datos se tomar&iacute;an de forma distinta si fuese una petici&oacute;n GET o una POST. Para una GET, por ejemplo, tendr&iacute;amos que tomar la cadena tras la interrogaci&oacute;n, y parsearla convenientemente, separando los bloques entre '&amp;', y luego separando el nombre del par&aacute;metro de su valor a partir del '='. Tambi&eacute;n hay que descodificar los valores: los alfanum&eacute;ricos no cambian, pero los espacios se han convertido previamente en '+', y otros caracteres se convierten en '%XX%'. </p>
<p>Con servlets todo este an&aacute;lisis se realiza de forma autom&aacute;tica. La clase <span class="codefrag">HttpServletRequest</span> dispone de m&eacute;todos que devuelven la informaci&oacute;n que nos interesa ya procesada, e independientemente de si es una petici&oacute;n GET o POST. Hemos visto antes los m&eacute;todos: </p>
<pre class="code">Enumeration getParameterNames()
String      getParameter (String nombre)
String[]    getParameterValues (String nombre)</pre>
<a name="N10198"></a><a name="Ejemplo"></a>
<h3 class="underlined_5">Ejemplo</h3>
<p>Veamos un ejemplo: supongamos que tenemos este formulario: </p>
<pre class="code">&lt;html&gt;
&lt;body&gt;
&lt;form action="/appforms/servlet/ejemplos.ServletForm"&gt;
	Valor 1: &lt;input type="text" name="texto1"&gt;
	&lt;br&gt;
	Valor2: 
	&lt;select name="lista"&gt;
	&lt;option name="lista" value="Opcion 1"&gt;Opcion 1&lt;/option&gt;
	&lt;option name="lista" value="Opcion 2"&gt;Opcion 2&lt;/option&gt;
	&lt;option name="lista" value="Opcion 3"&gt;Opcion 3&lt;/option&gt;
	&lt;/select&gt;
	&lt;br&gt;
	Valores 3: 
	&lt;br&gt;
	&lt;input type="text" name="texto2"&gt;
	&lt;input type="text" name="texto2"&gt;
	&lt;input type="text" name="texto2"&gt;

	&lt;input type="submit" value="Enviar"&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p>Al validarlo se llama al servlet <span class="codefrag">ServletForm</span>, que muestra una p&aacute;gina HTML con los valores introducidos en los par&aacute;metros del formulario: </p>
<pre class="code">package ejemplos;

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class ServletForm extends HttpServlet
{
<strong>	// Metodo para GET
</strong>	
	public void doGet(HttpServletRequest request, 
	                  HttpServletResponse response) 
	throws ServletException, IOException
	{
		response.setContentType("text/html");
		
		PrintWriter out = response.getWriter();

<strong>		// Mostramos los datos del formulario
</strong>
		out.println ("&lt;HTML&gt;");			
		out.println ("&lt;BODY&gt;");			
		out.println ("&lt;H1&gt;Datos del formulario&lt;/H1&gt;");
		out.println ("&lt;BR&gt;");

		String valor1 = 
			request.getParameter("texto1");
		String valor2 = 
			request.getParameter("lista");
		String[] valor3 = 
			request.getParameterValues("texto2");
		
		out.println ("Valor 1:" + valor1);
		out.println ("&lt;BR&gt;");
		out.println ("Valor 2:" + valor2);
		out.println ("&lt;BR&gt;");
		out.println ("Valor 3:");
		out.println ("&lt;BR&gt;");
		if (valor3 != null)
			for (int i = 0; i &lt; valor3.length; i++)
			{
				out.println (valor3[i]);
				out.println ("&lt;BR&gt;");
			}

		out.println ("&lt;/BODY&gt;");
		out.println ("&lt;/HTML&gt;");
	}	

<strong>	// Metodo para POST
</strong>	
	public void doPost(HttpServletRequest request, 
	                   HttpServletResponse response) 
	throws ServletException, IOException
	{
		doGet(request, response);
	}	
}</pre>
<p>Para probar el ejemplo que viene en las plantillas, cargamos la URL:</p>
<pre class="code">http://localhost:8080/appforms/index_form.html</pre>
</div>


<a name="N101C1"></a><a name="Pruebas+de+servlets+con+Cactus"></a>
<h2 class="underlined_10">Pruebas de servlets con Cactus</h2>
<div class="section">
<p>Ya vimos en el m&oacute;dulo de servidores web c&oacute;mo configurar la aplicaci&oacute;n para poder realizar pruebas con Cactus en sus diferentes elementos. Una vez la tenemos configurada... &iquest;c&oacute;mo escribimos el caso de prueba para un servlet?</p>
<p>Para escribir un caso de prueba, debemos seguir los siguientes pasos</p>
<ol>
	    
<li>Importar los paquetes de JUnit y Cactus
	    <pre class="code">import org.apache.cactus.*;
import junit.framework.*;</pre>
	    
</li>
	    
<li>Extender un clase de prueba de Cactus (otra posibilidad menos recomendable es reusar un prueba JUnit).<br>
	    Necesitamos crear una clase que herede de uno de las casos de prueba Cactus, dependiendo de lo que estemos probando.
	    <ul>
	        
<li>
<strong>Para servlets:</strong>: <span class="codefrag">ServletTestCase</span>: debemos extender esta clase para probar codigo que utiliza los objetos del API de los <em>Servlets</em> (<span class="codefrag">HttpServletRequest</span>, <span class="codefrag">HttpServletResponse</span>, <span class="codefrag">HttpSession</span>, <span class="codefrag">ServletConfig</span>, <span class="codefrag">ServletContext</span>, ...), como los <em>Servlets</em> o aquellas clases que accedan al contenedor web (como un objeto <em>DAO</em> que utiliza un conexi&oacute;n a la base de datos definida en un <em>DataSource</em>). Por ejemplo:
	        <pre class="code">public class TestSampleServlet extends ServletTestCase
{</pre>
	        
</li>
	        
<li>
<strong>Para p&aacute;ginas JSP:</strong>: <span class="codefrag">JspTestCase</span>: si queremos probar objetos del API <em>JSP</em> (<span class="codefrag">PageContext</span>, <span class="codefrag">JspWriter</span>, ...) como <em>Taglibs</em>. Por ejemplo:
	        <pre class="code">public class TestSampleTag extends JspTestCase
{</pre>
<p>Veremos alg&uacute;n ejemplo de estas pruebas m&aacute;s adelante, cuando veamos las p&aacute;ginas JSP.</p>
</li>
	        
<li>
<strong>Para filtros:</strong>: <span class="codefrag">FilterTestCase</span>: si queremos probar objetos del API  de <em>Filtros</em> (<span class="codefrag">FilterChain</span>, <span class="codefrag">FilterConfig</span>, <span class="codefrag">HttpServletRequest</span>, <span class="codefrag">HttpServletResponse</span>, ...) como <em>Filtros</em>. Por ejemplo:
	        <pre class="code">public class TestSampleFilter extends FilterTestCase
{</pre>
</li>
	    
</ul>
	    
<p>La clase de prueba, como en JUnit, deber&aacute; estar en el mismo paquete que la clase a probar (aunque su c&oacute;digo fuente lo pondremos dentro de la carpeta fuente <span class="codefrag">test</span>, en lugar de <span class="codefrag">src</span>, donde estar&aacute; el fuente del servlet a probar).</p>
	    
</li>
	    
<li>[Opcional] M&eacute;todos <span class="codefrag">setUp()</span> y <span class="codefrag">tearDown()</span>
<br>
	    Igual que con JUnit, podemos definir estos m&eacute;todos los cuales se ejecutan antes y despu&eacute;s de cada caso de prueba. Sin embargo, mientras que JUnit los ejecuta en el lado del cliente, en Cactus se ejecutan en el servidor. Esto significa que podemos acceder a los objetos del API definidos en el paso anterior. Dicho de otro modo, podemos realizar cosas como explorar par&aacute;metros de la petici&oacute;n, o establecer atributos, o explorar cabeceras, antes de llamar a los casos de prueba, etc...
	    </li>
	    
<li>[Opcional] M&eacute;todos <span class="codefrag">begin()</span> y <span class="codefrag">end()</span>
<br>
	    Estos son los m&eacute;todos equivalentes a <span class="codefrag">setUp()</span> y <span class="codefrag">tearDown()</span>, pero ejecutados en el lado del cliente. Por lo tanto se ejecutan en el lado del cliente antes de cada prueba.
	    </li>
	    
<li>M&eacute;todos <span class="codefrag">testXXX()</span>
<br>
	    Como en JUnit, el m&eacute;todo <span class="codefrag">main</span> de una prueba es el m&eacute;todo <span class="codefrag">testXXX()</span>. La diferencia estriba en que en Cactus estos m&eacute;todos se ejecutan en el contenedor. Cada caso de prueba <span class="codefrag">XXX</span> debe definir su m&eacute;todo <span class="codefrag">testXXX()</span>
<br>
	    En los m&eacute;todos <span class="codefrag">testXXX()</span> podremos:
	    <ul>
	        
<li>Instanciar la clase a probar (tambi&eacute;n podemos refactorizar esta instancia fuera del m&eacute;todo y definirla como una variable de instancia de clase)</li>
	        
<li>Configurar cualquier objeto de servidor del dominio (poner variables en la sesi&oacute;n, etc...). De hecho, las clases Cactus que hemos heredado en el paso 2 contiene diversas variables de instancia se inicializan con objetos validos.</li>
	        
<li>Llamar al m&eacute;todo a probar</li>
	        
<li>Realizar aserciones JUnit (<span class="codefrag">asserts(..)</span>, <span class="codefrag">assertEquals(...)</span>, <span class="codefrag">fail(...)</span>, ...) para verificar que la prueba ha funcionado correctamente.</li>
	    
</ul>
	    
</li>
	    
<li>[Opcional] M&eacute;todos <span class="codefrag">beginXXX()</span>
<br>
	    Para cada caso de prueba XXX, podemos definir los correspondientes m&eacute;todos  <span class="codefrag">beginXXX()</span>. Se utilizan para inicializar par&aacute;metros relacionados con HTTP (par&aacute;metros HTTP, cookies, cabeceras HTTP, URL a simular, ...). Posteriormente podremos acceder a estos valores en los m&eacute;todos <span class="codefrag">testXXX()</span> mediante las llamadas a las diferentes API de <span class="codefrag">HttpServletRequest</span> (como <span class="codefrag">getQueryString()</span>, <span class="codefrag">getCookies()</span>, <span class="codefrag">getHeader()</span>, ...).<br>
	    La firma del m&eacute;todo begin es:
	<pre class="code">
	public void beginXXX(WebRequest laRequest)
	{
	  [...]
	}
	</pre>
	donde utilizaremos el objeto <span class="codefrag">laRequest</span> para poner todos los par&aacute;metros relacionados con HTTP.<br>
	Los m&eacute;todos <span class="codefrag">beginXXX()</span> se ejecutan en el lado del cliente, antes de ejecutar los m&eacute;todos <span class="codefrag">testXXX()</span> en el servidor, y por lo tanto no se tiene acceso a las variables de clase que representan a los objetos del API (sus valores son nulos) 
	    </li>
	    
<li>[Opcional] M&eacute;todos <span class="codefrag">endXXX()</span>
<br>
	    Para cada caso de prueba XXX, podemos definir los correspondientes m&eacute;todos  <span class="codefrag">endXXX()</span>. Se utilizan para verificar los par&aacute;metros HTTP devueltos por los casos de prueba (como el contenido devuelto por la respuesta HTTP, cualquier cookie devuelta, cabeceras HTTP, etc...).<br>
	    Para versiones de Cactus hasta la 1.1, la firma del m&eacute;todo es la siguiente:
	<pre class="code">
	public void endXXX(HttpURLConnection theConnection)
	{
	  [...]
	}
	</pre>
	y algunos m&eacute;todos de ayuda (clase <span class="codefrag">AssertUtils</span>) para extraer el contenido de la respuesta y las cookies.<br>
	Sin embargo, a partir de Cactus 1.2, esta firma ha quedado "deprecated". Ahora existen 2 posibles firmas para el m&eacute;todo <span class="codefrag">end</span>, dependiendo de si necesitamos realizar comprobaciones complejas del contenido de vuelta. Para comprobaciones complejas, utilizaremos la integraci&oacute;n con el framework <em>HttpUnit</em>. Para comprobaciones sencillas, el objeto <span class="codefrag">WebResponse</span>.<br>
	Los m&eacute;todos <span class="codefrag">endXXX()</span> se ejecutan en el lado del cliente, tras ejecutar los m&eacute;todos <span class="codefrag">testXXX()</span> en el servidor, y por lo tanto no se tiene acceso a las variables de clase que representan a los objetos del API (sus valores son nulos) 
	    </li>
	
</ol>
<p>A continuaci&oacute;n se muestra un peque&ntilde;o ejemplo que prueba un <em>Servlet</em>:</p>
<pre class="code">import java.io.*;
import org.apache.cactus.*;

public class PruebaServletTest extends ServletTestCase 
{
	public void beginXXX(WebRequest theRequest)
	{
	    <strong>// Inicializa los par&aacute;metros HTTP relacionados</strong>
	    theRequest.setURL("jakarta.apache.org", "/mywebapp", "/test/test.jsp",
	        null, null);
	    theRequest.addCookie("cookiename", "cookievalue");
	}
	
	public void testXXX()
	{
		<strong>//Servlet a probar</strong>
	    PruebaServlet servlet = new PruebaServlet();
	    servlet.init(config);
	
	    <strong>// Llama al metodo a probar, por ejemplo, doGet</strong>
	    try
	    {
	    	servlet.doGet(request, response);
	    } catch (Exception ex) {}
	
	    <strong>// Realiza algunas asercion en el lado del servidor</strong>
	    assertEquals("someValue", session.getAttribute("someAttribute"));
	    assertEquals("jakarta.apache.org", request.getServerName());
	}
	
	public void endXXX(WebResponse theResponse)
	{
	    <strong>// Aserta la respuesta HTTP</strong>
	    Cookie cookie = theResponse.getCookie("someCookie");
	    assertEquals("someValue2", cookie.getValue());
	
	    assertEquals("some content here", theResponse.getText());
	}
	</pre>
</div>


<p class="pageBreakAfter"></p>
           

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006 Depto. CCIA</div>
</div>
</body>
</html>
