<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Filtros y Wrappers</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servlets y JSP" src="images/baner_j2ee_der.gif" title="Servlets y JSP"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servlets y JSP</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servlets y JSP</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servlets y JSP">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="sesion09-apuntes.html">Sesion 9</a>
</div>
<div class="menuitem">
<a href="sesion10-apuntes.html">Sesion 10</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 11</div>
</div>
<div class="menuitem">
<a href="sesion12-apuntes.html">Sesion 12</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="sesion09-ejercicios.html">Sesion 9</a>
</div>
<div class="menuitem">
<a href="sesion10-ejercicios.html">Sesion 10</a>
</div>
<div class="menuitem">
<a href="sesion11-ejercicios.html">Sesion 11</a>
</div>
<div class="menuitem">
<a href="sesion12-ejercicios.html">Sesion 12</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion11-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Filtros y Wrappers</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#%C2%BFQu%C3%A9+es+un+filtro%3F">&iquest;Qu&eacute; es un filtro?</a>
</li>
<li>
<a href="#Funcionalidades+de+los+filtros">Funcionalidades de los filtros</a>
</li>
<li>
<a href="#Aplicaciones+de+los+filtros">Aplicaciones de los filtros</a>
</li>
<li>
<a href="#Configuraci%C3%B3n+de+un+filtro">Configuraci&oacute;n de un filtro</a>
</li>
<li>
<a href="#Implementaci%C3%B3n+b%C3%A1sica+de+un+filtro">Implementaci&oacute;n b&aacute;sica de un filtro</a>
</li>
<li>
<a href="#Acceso+al+contexto">Acceso al contexto</a>
</li>
<li>
<a href="#Ciclo+de+vida+de+un+filtro">Ciclo de vida de un filtro</a>
</li>
<li>
<a href="#Wrappers">Wrappers</a>
<ul class="minitoc">
<li>
<a href="#%C2%BFQu%C3%A9+es+un+wrapper%3F">&iquest;Qu&eacute; es un wrapper?</a>
</li>
<li>
<a href="#Implementaci%C3%B3n+de+un+wrapper">Implementaci&oacute;n de un wrapper</a>
</li>
<li>
<a href="#Utilizaci%C3%B3n+de+un+wrapper">Utilizaci&oacute;n de un wrapper</a>
</li>
</ul>
</li>
<li>
<a href="#Ejemplos+de+filtros">Ejemplos de filtros</a>
<ul class="minitoc">
<li>
<a href="#Acceso+restringido">Acceso restringido</a>
</li>
<li>
<a href="#Ranking+de+p%C3%A1ginas+m%C3%A1s+visitadas">Ranking de p&aacute;ginas m&aacute;s visitadas</a>
</li>
<li>
<a href="#Extracci%C3%B3n+autom%C3%A1tica+de+informaci%C3%B3n">Extracci&oacute;n autom&aacute;tica de informaci&oacute;n</a>
</li>
</ul>
</li>
</ul>
</div>


<p>Hasta ahora hemos visto la forma en la que los servlets nos permiten encapsular 
el mecanismo de petici&oacute;n/respuesta. Se identifica al servlet como un
recurso dentro del sitio web, y cuando desde el cliente solicitamos dicho
 recurso, se ejecutar&aacute; el c&oacute;digo que hayamos definido dentro 
del m&eacute;todo de servicio del servlet.</p>
   

<p>La limitaci&oacute;n de los servlets es justamente esa, que un servlet 
se invocar&aacute; s&oacute;lo cuando solicitemos dicho servlet desde el cliente.
Pero, &iquest;y si queremos procesar cualquier petici&oacute;n que se haga
a cierta parte o toda nuestra aplicaci&oacute;n web?</p>
   

<p>Si s&oacute;lo contamos con servlets, para solucionar esto podr&iacute;amos 
optar por alguna de las siguientes opciones por ejemplo:</p>
   

<ul>
    
<li>Crear un servlet central que invocaremos siempre desde el cliente
    pas&aacute;ndole como par&aacute;metro el recurso que deseamos obtener. 
Tiene el     inconveniente de que no es transparente para desarrollador del 
contenido de     nuestra aplicaci&oacute;n web, ya que deber&aacute; definir 
todos los enlaces del sitio     para que vayan al servlet.</li>
    
<li>Introducir al comienzo de todos los servlets de nuestra aplicaci&oacute;n 
una     llamada a cierta funci&oacute;n que haga el procesamiento que queremos 
realizar.     Esto no nos servir&iacute;a para el contenido est&aacute;tico 
de la aplicaci&oacute;n web.     Adem&aacute;s tampoco es transparente ya 
que el desarrollador de los servlets     deber&aacute; realizar una llamada 
a este c&oacute;digo. Otro inconveniente es que     estaremos repitiendo c&oacute;digo
com&uacute;n en varios elementos, lo cual va en     contra de la modularidad.</li>
    
<li>Configurar el servidor web (si nos lo permite) para que cualquier
    petici&oacute;n de recurso sea redirigida a un servlet que la procese. 
Esta ser&iacute;a     la soluci&oacute;n m&aacute;s apropiada, pero tendremos 
el problema de que si el servlet     internamente quiere hacer la petici&oacute;n 
del recurso al servidor, volver&aacute; a     redireccionarlo a si mismo, 
por lo que podemos entrar en un bucle infinito.     Por lo tanto, surgir&aacute;n 
problemas con la identificaci&oacute;n de los recursos.</li>
   

</ul>
   

<p>Como vemos, por ahora este problema no tiene ninguna soluci&oacute;n totalmente
 satisfactoria. Para ello, a partir de la versi&oacute;n 2.3 de servlets, 
aparecen los denominados filtros.</p>
   

<a name="N10024"></a><a name="%C2%BFQu%C3%A9+es+un+filtro%3F"></a>
<h2 class="underlined_10">&iquest;Qu&eacute; es un filtro?</h2>
<div class="section">
<p>Un filtro es un componente que intercepta cualquier petici&oacute;n que 
se realice a un determinado grupo de recursos de nuestra aplicaci&oacute;n 
web, y la respuesta que se vaya a devolver al cliente por parte del servidor.</p>
<p>Normalmente los filtros no generar&aacute;n por si mismos la respuesta, 
como es el caso de los servlets, sino que simplemente la modificar&aacute;n 
si es necesario. Podr&aacute;n modificar tanto la petici&oacute;n HTTP, como 
la respuesta o las cabeceras de la misma.</p>
<p>Una ventaja importante de los filtros es que nos ayudar&aacute;n a modularizar 
la aplicaci&oacute;n, ya que son componentes independientes que actuar&aacute;n 
sobre cualquier grupo de recursos, no teniendo dichos recursos porque conocer 
la existencia de estos filtros. De esta forma este filtrado de las peticiones 
y respuestas a nuestro servidor se realiza de un forma totalmente transparente 
en todos los niveles, tanto para el cliente como para los desarrolladores 
del contenido del sitio web (servlets, JSPs, p&aacute;ginas est&aacute;tica, 
y cualquier otro recurso).</p>
<p>Esta independencia implica por lo tanto que los filtros podr&aacute;n ser
reutilizados    para cualquier elemento del sitio web, sin necesidad de incluir
c&oacute;digo com&uacute;n    en todos los elementos que queramos que realicen
dicha funcionalidad. </p>
</div>

<a name="N10037"></a><a name="Funcionalidades+de+los+filtros"></a>
<h2 class="underlined_10">Funcionalidades de los filtros</h2>
<div class="section">
<p>Un filtro podr&aacute; acceder a la petici&oacute;n de un determinado recurso
antes de que dicho recurso sea invocado, momento en el que podremos procesar
o modificar dicha petici&oacute;n.</p>
<p>Una vez se ha invocado la petici&oacute;n, podremos procesar o modificar 
la respuesta que nos ha devuelto el servidor.</p>
<p>Adem&aacute;s, podremos tener m&uacute;ltiples filtros actuando sobre determinados
grupos de recursos. De esta forma un recurso podr&aacute; no ser filtrado,
o ser filtrado por uno o m&aacute;s filtros. Cuando tenemos varios filtros,
se organizar&aacute;n en forma de cadena en el orden que nosotros especifiquemos,
y cada uno procesar&aacute; el resultado del anterior.</p>
</div>

<a name="N10047"></a><a name="Aplicaciones+de+los+filtros"></a>
<h2 class="underlined_10">Aplicaciones de los filtros</h2>
<div class="section">
<p>Hemos descrito lo que es un filtro, pero entenderemos m&aacute;s claramente 
los filtros si vemos una serie de posibles aplicaciones que les podemos dar:</p>
<ul>
    
<li>Autentificaci&oacute;n de usuarios: Podemos definir un filtro que 
act&uacute;e sobre     cierta zona restringida de nuestra aplicaci&oacute;n 
web. Si el usuario est&aacute;     registrado el filtro dejar&aacute; ver 
el contenido tal cual, si no le redirigir&aacute;     a la p&aacute;gina con
el formulario de registro de usuarios.</li>
    
<li>Transformaci&oacute;n con hojas XSL-T: Si tenemos una serie de p&aacute;ginas 
escritas     en XML, y una serie de hojas de transformaci&oacute;n XSL-T para
generar c&oacute;digo     para distintos navegadores, podremos definir un
filtro que act&uacute;e sobre el     conjunto de documentos XML, y aplique 
una transformaci&oacute;n seg&uacute;n el tipo de     navegador que hizo la
petici&oacute;n. Devolver&aacute; al cliente la respuesta     transformada, 
adaptada al navegador adecuado.</li>
    
<li>Transformaci&oacute;n de im&aacute;genes: Igual que transformamos 
documentos XML,     tambi&eacute;n podemos aplicar los filtros a determinados 
formatos de im&aacute;genes, y     transformar dichas im&aacute;genes din&aacute;micamente 
a un formato m&aacute;s adecuado.</li>
    
<li>Encriptaci&oacute;n de datos: Podemos utilizar un filtro para que 
encripte la     salida de cualquier recurso al que se acceda. El cliente deber&aacute;
ser capaz     de desencriptarlo para poder visualizar dicho contenido.</li>
    
<li>Compresi&oacute;n de datos: De forma similar al punto anterior, podemos
     comprimir los datos que genera el servidor.</li>
    
<li>Registro de acceso a recursos: Se puede contabilizar mediante un
filtro la     cantidad de accesos a cada recurso de nuestra web. Como todas
las peticiones     pasan a trav&eacute;s de &eacute;l, simplemente tendr&aacute; 
que incrementar la cantidad de     visitas al recurso que se solicite en cada
momento. </li>
    
<li>Log de accesos: Podemos tambi&eacute;n elaborar un fichero de log 
de accesos a     la web, para conocer los datos de todos los accesos que se
han realizado.</li>
   

</ul>
</div>

<a name="N10069"></a><a name="Configuraci%C3%B3n+de+un+filtro"></a>
<h2 class="underlined_10">Configuraci&oacute;n de un filtro</h2>
<div class="section">
<p>Para que un filtro intercepte las peticiones a determinados recursos, deberemos
   configurar la aplicaci&oacute;n web para que esto sea as&iacute;. La forma
de    configurar los filtros es similar a la configuraci&oacute;n de los
servlets.</p>
<p>Los filtros, al igual que los servlets, ser&aacute;n clases Java que definamos, 
   y que tendremos normalmente en el directorio <span class="codefrag">WEB-INF/classes</span> de 
nuestra    aplicaci&oacute;n web, o subdirectorios de este si est&aacute; 
en alg&uacute;n    subpaquete. La configuraci&oacute;n de los filtros deber&aacute; 
establecerse    en el fichero de configuraci&oacute;n de nuestra aplicaci&oacute;n 
web, <span class="codefrag">WEB-INF/web.xml</span>.  </p>
<p>Es importante recordar que en este fichero de configuraci&oacute;n, por 
ser    un lenguaje definido mediante un DTD en XML, se debe respetar el orden 
en el    que aparecen los distintos elementos. Los elementos para la configuraci&oacute;n 
   de filtros deben ir tras los elementos <span class="codefrag">context-param</span>, y antes de <span class="codefrag">listener</span>    y <span class="codefrag">servlet</span>. </p>
<p>Primero deberemos declarar los filtros incluidos en nuestra aplicaci&oacute;n 
   web. Para ello deberemos utilizar el elemento <span class="codefrag">filter</span> que se define 
de    la siguiente forma en el DTD:</p>
<pre class="code">&lt;!ELEMENT <strong>filter</strong> (icon?, filter-name, display-name?, 
			description?, filter-class, init-param*)&gt;</pre>
<p>Un ejemplo de uso de este elemento en el fichero de configuraci&oacute;n 
<span class="codefrag">web.xml</span>    es el siguiente:</p>
<pre class="code">&lt;<strong>filter</strong>&gt;
	&lt;<strong>filter-name</strong>&gt;Filtro de ejemplo&lt;/<strong>filter-name</strong>&gt;
	&lt;<strong>filter-class</strong>&gt;FiltroEjemplo&lt;/<strong>filter-class</strong>&gt;
	&lt;<strong>init-param</strong>&gt;
		&lt;<strong>param-name</strong>&gt;fichero_log&lt;/<strong>param-name</strong>&gt;
		&lt;<strong>param-value</strong>&gt;log.txt&lt;/<strong>param-name</strong>&gt;
	&lt;/<strong>init-param</strong>&gt;
&lt;/<strong>filter</strong>&gt;</pre>
<p>Es muy similar a la forma de declarar un servlet. Asignamos un nombre al
filtro,    que ser&aacute; asociado a la clase en la que est&aacute; implementado 
dicho    filtro. En este caso la clase es <span class="codefrag">FiltroEjemplo</span>, por lo que 
tendremos    que tener el fichero <span class="codefrag">FiltroEjemplo.class</span> en el directorio 
<span class="codefrag">WEB-INF/classes</span>    de nuestra aplicaci&oacute;n.</p>
<p>A continuaci&oacute;n podemos declarar una serie de par&aacute;metros de
entrada    para el filtro, de forma que para variar estos datos no tengamos 
que modificar    y recompilar la clase del filtro, sino que simplemente deberemos 
modificar el    valor del par&aacute;metro en este fichero de configuraci&oacute;n. 
Podremos    no tener ning&uacute;n par&aacute;metro, tener uno, o tantos como
queramos.</p>
<p>Una vez declarados los filtros deberemos mapearlos a los recursos. Las 
peticiones    que se hagan al servidor a estos recursos, ser&aacute;n interceptadas 
por nuestro    filtro. Podemos mapear filtros a recursos de distintas formas, 
con la etiqueta    <span class="codefrag">filter-mapping</span> que se define de la siguiente forma 
en el DTD:</p>
<pre class="code">&lt;!ELEMENT <strong>filter-mapping</strong> (filter-name, (url-pattern | servletname))&gt;</pre>
<p>Ejemplos de utilizaci&oacute;n de las dos formas posibles de mapeado son 
los    siguientes:</p>
<pre class="code">&lt;<strong>filter-mapping</strong>&gt;
	&lt;<strong>filter-name</strong>&gt;Filtro de ejemplo&lt;/<strong>filter-name</strong>&gt;
	&lt;<strong>servlet-name</strong>&gt;Servlet interceptado&lt;/<strong>servlet-name</strong>&gt;
&lt;/<strong>filter-mapping</strong>&gt;

&lt;<strong>filter-mapping</strong>&gt;
	&lt;<strong>filter-name</strong>&gt;Filtro de ejemplo&lt;/<strong>filter-name</strong>&gt;
	&lt;<strong>url-pattern</strong>&gt;/*&lt;/<strong>url-pattern</strong>&gt;
&lt;/<strong>filter-mapping</strong>&gt;</pre>
<p>La primera forma nos sirve para mapearlo a un servlet, dado el nombre del
servlet    al que lo vamos a asociar. La segunda forma asocia el filtro a
todos los elementos    cuya URL cumpla el patr&oacute;n dado:</p>
<pre class="code">
<strong>/*</strong>                  Se asocia con todos los elementos de nuestra aplicaci&oacute;n web.
<strong>/zona_restringida/*</strong> Se asocia con todos los elementos en el directorio de nombre    
                    zona_restringida, y con los de sus subdirectorios.
<strong>/web/*</strong>              Se asocia con todos los elementos en el directorio de nombre    
                    web, y con los de sus subdirectorios.
...</pre>
<p>Podemos asociar varios filtros a un mismo recurso, si dicho recurso aparece 
   mapeado para varios filtros. En este caso tendremos una cadena de varios 
filtros    cuando se produzca una petici&oacute;n a este recurso.</p>
<p>
<img alt="Encadenamiento de filtros" content-width="9cm" height="335" src="imagenes/filtros/chain.gif" width="472">
</p>
</div>

<a name="N10125"></a><a name="Implementaci%C3%B3n+b%C3%A1sica+de+un+filtro"></a>
<h2 class="underlined_10">Implementaci&oacute;n b&aacute;sica de un filtro</h2>
<div class="section">
<p>Los filtros se definen mediante la interfaz <span class="codefrag">Filter</span>, contenida en 
el    paquete <span class="codefrag">javax.servlet</span>. Por lo tanto, para crear un filtro deberemos 
crear    una clase que implemente dicha interfaz:</p>
<pre class="code">import javax.servlet.*;
import javax.servlet.http.*;

class MiFiltro <strong>implements Filter</strong> {
	FilterConfig config;</pre>
<p>Dentro de este clase, el m&eacute;todo b&aacute;sico que deberemos implementar 
ser&aacute; el m&eacute;todo    <span class="codefrag">doFilter</span>, al que se llamar&aacute; 
cada vez que dicho filtro intercepte una    petici&oacute;n a recursos:</p>
<pre class="code">	public void <strong>doFilter</strong>(ServletRequest request, 
				ServletResponse response, FilterChain chain) 
			throws IOException, ServletException {
		...</pre>
<p>Vemos que a este m&eacute;todo se le pasa como par&aacute;metro la petici&oacute;n 
y la respuesta, de forma que podamos procesarlas o modificarlas seg&uacute;n 
la funcionalidad que queramos que implemente el filtro. Hemos de fijarnos 
que toma una petici&oacute;n y respuesta gen&eacute;rica, no se limita &uacute;nicamente 
a peticiones y respuestas HTTP.</p>
<p>Adem&aacute;s tambi&eacute;n se nos proporciona un objeto que representa 
la cadena de filtros. Con &eacute;l podremos pasar la petici&oacute;n y la 
respuesta interceptadas al siguiente filtro de la cadena, o bien al recurso 
destino en caso de que ya no hubiese m&aacute;s filtros. Esto lo haremos con
una llamada a:</p>
<pre class="code">		...
		chain.<strong>doFilter</strong>(request, response);
		... // En este punto el servidor ya habr&aacute; producido 
		    //la respuesta en response

	}</pre>
<p>Justo despu&eacute;s de haber llamado a este m&eacute;todo, ya se habr&aacute; 
producido la respuesta, ya que con &eacute;l estamos indicando que se ejecuten 
todos los filtros que siguen al nuestro en la cadena, y en &uacute;ltimo lugar
el recurso solicitado.</p>
<p>Por lo tanto, todas las modificaciones que queramos hacer en la petici&oacute;n 
que va a llegar al recurso las deberemos hacer antes de la llamada a este 
m&eacute;todo, mientras que todo procesamiento que queramos hacer de la respuesta 
se har&aacute; despu&eacute;s de esta llamada, que ser&aacute; cuando se haya
generado.</p>
<p>Tambi&eacute;n podemos hacer que no se llegue a llamar, si queremos que 
nuestro filtro de la respuesta por si solo, sin acceder al recurso que se 
hab&iacute;a pedido. Esto lo haremos por ejemplo cuando queramos prohibir 
el acceso a un recurso.</p>
<p>Otros m&eacute;todos que debemos definir en un filtro son:</p>
<pre class="code">	public void <strong>init</strong>(FilterConfig config) throws ServletException {
		// C&oacute;digo de inicializaci&oacute;n del filtro
		this.config = config;
		...

	}

	public void <strong>destroy</strong>() {
		// Libera recursos del filtro
		config = null;
		...
	}

	...

}</pre>
<p>  Que ser&aacute;n llamados en la inicializaci&oacute;n y en la destrucci&oacute;n 
  de este componente  respectivamente.  </p>
</div>

<a name="N1016F"></a><a name="Acceso+al+contexto"></a>
<h2 class="underlined_10">Acceso al contexto</h2>
<div class="section">
<p>Acabamos de ver que cuando se inicializa el filtro se llama a su m&eacute;todo <span class="codefrag">init</span>. En esta llamada se proporciona un objeto <span class="codefrag">FilterConfig</span> 
que contiene    informaci&oacute;n sobre los par&aacute;metros del filtro, 
que vimos en el apartado de configuraci&oacute;n,    y adem&aacute;s nos permite
acceder a la informaci&oacute;n global de contexto.</p>
<p>Para leer los par&aacute;metros del filtro especificados en el descriptor 
de    despliegue de la aplicaci&oacute;n web (fichero <span class="codefrag">web.xml</span> en Tomcat 
como    hemos visto), este objeto proporciona el siguiente m&eacute;todo:</p>
<pre class="code">String valor = config.<strong>getInitParameter</strong>(nombre_param);</pre>
<p>Esta llamada nos devolver&aacute; una cadena con el valor del par&aacute;metro, 
   o null en el caso de que el par&aacute;metro indicado no existiese. Si 
queremos    obtener la lista de par&aacute;metros definidos en el descriptor 
de despliegue,    podemos usar el siguiente m&eacute;todo:</p>
<pre class="code">Enumeration parametros = config.<strong>getInitParameterNames</strong>();</pre>
<p>Con esto obtendremos una enumeraci&oacute;n de todos los nombres de par&aacute;metros 
   definidos. </p>
<p>Este objeto tambi&eacute;n nos permite obtener el nombre del filtro, que 
se    habr&aacute; definido en el descriptor de despliegue, con el m&eacute;todo:</p>
<pre class="code">String nombre = config.<strong>getFilterName</strong>();</pre>
<p>Este objeto adem&aacute;s nos permitir&aacute; acceder al objeto de contexto 
   global del contenedor de servlets, mediante el m&eacute;todo:</p>
<pre class="code">ServletContext context = config.<strong>getServletContext</strong>();</pre>
<p>Obtenemos este objeto con el cual podremos acceder a los atributos globales 
   definidos en nuestra aplicaci&oacute;n web, y adem&aacute;s nos proporciona 
   una serie de m&eacute;todos que nos permitir&aacute;n realizar en filtros 
las    mismas operaciones que pod&iacute;amos hacer en los servlets. </p>
<p>Ser&aacute; importante acceder a este objeto desde los filtros, ya que 
si queremos    realizar redirecciones, o acceso a recursos est&aacute;ticos 
por ejemplo, necesitaremos    contar con dicho objeto.</p>
</div>

<a name="N101B3"></a><a name="Ciclo+de+vida+de+un+filtro"></a>
<h2 class="underlined_10">Ciclo de vida de un filtro</h2>
<div class="section">
<p>Justo despu&eacute;s del despliegue de la aplicaci&oacute;n web, y antes 
de    que se produzca cualquier petici&oacute;n a un recurso, el contenedor 
localizar&aacute;    los filtros que deben ser aplicados a cada recurso. Instanciar&aacute;
los filtros    que hayamos declarado, y tras ello llamar&aacute; al m&eacute;todo <span class="codefrag">init</span>    de cada filtro para inicializarlo. </p>
<p>Si hacemos que este m&eacute;todo <span class="codefrag">init</span> lance una excepci&oacute;n 
<strong>UnavailableExeption    </strong>estaremos indicando que el filtro no puede funcionar
correctamente. Esta    excepci&oacute;n tiene un m&eacute;todo <span class="codefrag">isPermament</span> que indicar&aacute;    si el fallo es permanente o puede recuperarse
pasado un tiempo. De no ser permanente    el contenedor intentar&aacute; volver
a instanciar el filtro m&aacute;s adelante.    Podemos establecer en la excepci&oacute;n
un tiempo estimado que puede tardar    en estar disponible, para informar
al contenedor de cuando puede volver a intentar    instanciarlo.</p>
<p>Al m&eacute;todo <span class="codefrag">init</span> se le proporcionar&aacute; el objeto <span class="codefrag">FilterConfig</span>, 
   con la informaci&oacute;n de los par&aacute;metros y nombre del filtro 
obtenidos    del descriptor de despliegue, adem&aacute;s de una referencia 
al objeto <span class="codefrag">ServletContext</span>    de la aplicaci&oacute;n web, como hemos 
visto en el apartado anterior.</p>
<p>Una vez terminada la fase de inicializaci&oacute;n, el servidor ya podr&aacute; 
   empezar a recibir peticiones. Cuando se produzca una petici&oacute;n, el
contenedor    localizar&aacute; el primer filtro asociado a dicho recurso, 
y llamar&aacute;    a su m&eacute;todo <span class="codefrag">doFilter</span> proporcionando los 
objetos <span class="codefrag">ServletRequest</span>,    <span class="codefrag">ServletResponse</span>, y <span class="codefrag">FilterChain</span>. 
Una vez hecho esto ser&aacute;    responsabilidad de nuestro filtro tratar 
estos objetos, y decidir si pasar el    procesamiento al siguiente filtro 
de la cadena.</p>
<p>Cuando lleguemos al ultimo filtro de la cadena, al llamar a <span class="codefrag">doChain</span> 
   se invocar&aacute; directamente el recurso que se solicitaba en la petici&oacute;n.</p>
<p>Si durante <span class="codefrag">doFilter</span> lanzamos una excepci&oacute;n <span class="codefrag">UnavailableException</span>, 
  el contenedor no intentar&aacute; seguir procesando la cadena de filtros. Si 
  hemos indicado que es no permanente, tras un rato reintentar&aacute; procesar 
  la cadena entera.</p>
<p>Antes de poder hacer que el filtro deje de estar en servicio, llamar&aacute; 
  a su m&eacute;todo <span class="codefrag">destroy</span> para que libere los recursos que sea necesario.
</p>
</div>



<a name="N101FC"></a><a name="Wrappers"></a>
<h2 class="underlined_10">Wrappers</h2>
<div class="section">
<p>Hasta ahora hemos visto como interceptar la petici&oacute;n que se realiza
   a un determinado recurso de nuestra web mediante filtros, pero, &iquest;y
si    queremos interceptar la respuesta que nos devuelve el servidor para
analizarla    o modificarla?</p>
<p>Cuando desde nuestro filtro pasemos el procesamiento de la petici&oacute;n
   al siguiente elemento de la cadena (<span class="codefrag">doFilter</span>), delegaremos en este
siguiente    elemento el procesamiento de la petici&oacute;n y la generaci&oacute;n
de la    respuesta. Supongamos que este elemento es el recurso final que
se hab&iacute;a    solicitado. En este caso el contenido de este recurso
ser&aacute; escrito en    el objeto respuesta, lo cual producir&aacute; que
dicho contenido sea devuelto    al cliente.</p>
<p>Sin embargo, nosotros no queremos que sea devuelto directamente al cliente,
   sino que queremos procesarla previamente en nuestro filtro antes de devolverla.
   Con este objeto <span class="codefrag">ServletResponse</span> (<span class="codefrag">HttpServletResponse</span>) no
podremos hacer esto,    ya que cuando se escribe en &eacute;l lo que se hace
es devolver la respuesta    al cliente, y una vez escrita no podemos acceder
nuevamente a ella ni modificarla.</p>
<p>La soluci&oacute;n a nuestro problema es sustituir el objeto respuesta
que    proporcionamos al siguiente elemento de la cadena por un objeto de
respuesta    creado por nosotros.</p>
<a name="N10217"></a><a name="%C2%BFQu%C3%A9+es+un+wrapper%3F"></a>
<h3 class="underlined_5">&iquest;Qu&eacute; es un wrapper?</h3>
<p>Un <em>wrapper</em> es un objeto que envuelve al objeto original, de forma
que no se    acceda directamente al objeto original sino al <em>wrapper</em>.
El <em>wrapper</em> implementar&aacute;    la misma interfaz del objeto al
que envuelve, de forma que externamente se trabajar&aacute;    con &eacute;l
de la misma forma, por lo que podemos sustituir el original por    el <em>wrapper</em>
siendo esto transparente a los sucesivos elementos que vayan a manipular
   este objeto.</p>
<p>Cuando se llame a un m&eacute;todo del <em>wrapper</em> podr&aacute;, o
bien redirigir    la llamada al correspondiente m&eacute;todo del objeto
original al que envuelve,    o bien tratar por si mismo la llamada a dicho
m&eacute;todo. De esta forma,    podremos redefinir el comportamiento que
tendr&aacute;n determinadas operaciones.</p>
<p>Encontramos para nuestro fin <em>wrappers</em> para la petici&oacute;n y la respuesta: 
  <span class="codefrag">ServletRequestWrapper</span> (<span class="codefrag">HttpServletRequestWrapper</span>) y <span class="codefrag">ServletResponseWrapper</span> 
  (<span class="codefrag">HttpServletResponseWrapper</span>). Con ellos podremos crear implementaciones 
  propias del objeto petici&oacute;n y respuesta que envuelvan a los originales, 
  pudiendo de esta forma redefinir el comportamiento de determinadas operaciones.</p>
<p>Nos centraremos en el <em>wrapper</em> de la respuesta. Con &eacute;l podemos
evitar    que la respuesta se envie directamente al cliente. En lugar de
esto, cuando    se escriba la salida en este objeto <em>wrapper</em> de la
respuesta podemos hacer que    guarde dicha salida en un buffer interno.
Una vez procesados todos los elementos    de la cadena que est&aacute;n despu&eacute;s
de nuestro filtro (tras llamar    a <span class="codefrag">doFilter</span>), se habr&aacute; escrito
la salida generada en el <em>buffer</em> del <em>wrapper</em>.    En este momento
podemos analizar esta salida, modificarla si es necesario, y    enviarla
a trav&eacute;s del objeto respuesta original.</p>
<a name="N10257"></a><a name="Implementaci%C3%B3n+de+un+wrapper"></a>
<h3 class="underlined_5">Implementaci&oacute;n de un wrapper</h3>
<p>Para implementar un wrapper deberemos crearnos una subclase de la clase del 
  <em>wrapper</em> adecuado para nuestro caso (petici&oacute;n o respuesta), y redefinir 
  en esta subclase las operaciones cuyo comportamiento queramos cambiar. El funcionamiento 
  por defecto de las operaciones que no redefinamos ser&aacute; redirigir la petici&oacute;n 
  al m&eacute;todo correspondiente del objeto (petici&oacute;n o respuesta) original.</p>
<p>Vamos a ver esto con un ejemplo de implementaci&oacute;n de un wrapper
de la    respuesta que guarda en un buffer la respuesta generada por el servidor,
para    poder ser procesada por nuestro filtro.</p>
<p>Puesto que queremos envolver la respuesta, tendremos que crearnos una
subclase    de <span class="codefrag">ServletResponseWrapper</span>:</p>
<pre class="code">public class GenericResponseWrapper extends <strong>HttpServletResponseWrapper</strong> {</pre>
<p>Dentro de esta clase deberemos tener el buffer donde vayamos a escribir
la    salida. Dado que en la salida se puede escribir tanto como flujo de
bytes como    de caract&eacute;res, para que sea m&aacute;s gen&eacute;rico
convendr&aacute;    crear el buffer como array de bytes, de forma que se
pueda escribir en &eacute;l    de las dos formas:</p>
<pre class="code">	private ByteArrayOutputStream output;</pre>
<p>En el constructor de la clase simplemente deberemos proporcionar el objeto
respuesta  original (al cual estaremos envolviendo). Lo que hacemos aqu&iacute;
es utilizar  el constructor de la superclase proporcion&aacute;ndole la respuesta
original,  de forma que se encargue de redirigir a &eacute;l las operaciones
predeterminadas.  Adem&aacute;s deberemos crear nuestro buffer de bytes donde
se escribir&aacute;  la respuesta:  </p>
<pre class="code">	public GenericResponseWrapper(<strong>HttpServletResponse</strong> response) { 
		super(response); 
		output = new ByteArrayOutputStream(); 
	} </pre>
<p>Proporcionaremos adem&aacute;s un m&eacute;todo para obtener los datos escritos
   en el buffer:  </p>
<pre class="code">	public byte[] getData() { 
		rreturn output.toByteArray(); 
	} </pre>
<p>Cuando alguien quiera devolver una respuesta al cliente lo que har&aacute;
   ser&aacute; obtener el flujo de salida del objeto respuesta y escribir
en &eacute;l.    Por defecto este flujo envia los datos al cliente. Sin embargo
podemos evitar    que esto ocurra haciendo que los flujos que devuelva sirvan
para escribir en    el buffer, y no para enviar la respuesta al cliente.
Se puede enviar la respuesta    de dos formas: mediante un flujo de bytes
(<span class="codefrag">getOutputStream</span>), o mediante un flujo    de car&aacute;cteres (<span class="codefrag">getWriter</span>),
por lo que deberemos redefinir ambos m&eacute;todos.</p>
<pre class="code">	public ServletOutputStream getOutputStream() { 
		return new FilterServletOutputStream(output); 
	}  
        
	public PrintWriter getWriter() { 
		return new PrintWriter(getOutputStream(), true); 
	} 
}</pre>
<p>En el caso del flujo de bytes, deberemos devolverlo como un <span class="codefrag">ServletOutputStream</span>.
   Por lo tanto tendremos que crearnos un tipo propio de <span class="codefrag">ServletOutputStream</span>
que    escriba en nuestro buffer:</p>
<pre class="code">public class FilterServletOutputStream extends <strong>ServletOutputStream</strong> { 
	private DataOutputStream stream;
                
	public FilterServletOutputStream(OutputStream output) {
		stream = new DataOutputStream(output);
	}
        
	public void write(int b) throws IOException {
   		stream.write(b);
   	}

	public void write(byte[] b) throws IOException {
   		stream.write(b);
   	}

	public void write(byte[] b, int off, int len) throws IOException {
   		stream.write(b, off, len);
   	}
}</pre>
<p>Este ser&aacute; el flujo que utilicemos para escribir la respuesta en
forma    de bytes en nuestro buffer interno. </p>
<p>Aunque a primera vista parezca compleja la creaci&oacute;n de dicho <em>wrapper</em>,
   tiene la ventaja de ser reutilizable para cualquier aplicaci&oacute;n
en la    que necesitemos interceptar la respuesta generada por el servidor.</p>
<a name="N102B2"></a><a name="Utilizaci%C3%B3n+de+un+wrapper"></a>
<h3 class="underlined_5">Utilizaci&oacute;n de un wrapper</h3>
<p>Para utilizar el <em>wrapper</em> que hemos creado, deberemos instanciarlo
a partir    del objeto de respuesta original que le ha sido proporcionado
a nuestro filtro.    Esto lo haremos antes de que se haya generado el contenido
del recurso solicitado,    es decir, antes de llamar a <span class="codefrag">doFilter</span>. </p>
<pre class="code">public void <strong>doFilter</strong>(ServletRequest request,
			ServletResponse response, FilterChain chain) 
{
	...
	GenericResponseWrapper wrapper = new GenericReponseWrapper(response);</pre>
<p>Una vez hemos creado nuestro propio objeto respuesta que envuelve a la
respuesta    original, podemos utilizarlo para que el servidor escriba el
contenido del recurso    solicitado en &eacute;l. Para esto realizaremos
la llamada a <span class="codefrag">doFilter</span> proporcionando    como respuesta este <em>wrapper</em>
que hemos creado:</p>
<pre class="code">	chain.<strong>doFilter</strong>(request, <strong>wrapper</strong>);</pre>
<p>Una vez ejecutado este m&eacute;todo se habr&aacute; generado la respuesta
   en el objeto de respuesta proporcionado, en este caso habr&aacute; sido
en nuestro    <em>wrapper</em>. Por lo tanto podemos obtener y procesar la
respuesta seg&uacute;n la    funci&oacute;n de nuestro filtro:</p>
<pre class="code">	byte [] datos = wrapper.getData();

	... // Procesar datos segun la funcion del filtro</pre>
<p>Por &uacute;ltimo, para que el cliente pueda ver esta respuesta, deberemos
   escribirla en el objeto respuesta original:</p>
<pre class="code">	OutputStream out = response.<strong>getOutputStream</strong>();
	out.write(datos);
	out.close();
}</pre>
<p>Con esto vemos que habremos podido procesar la salida generada en nuestro
filtro,    y enviarla al cliente para que pueda ser visualizada correctamente.</p>
</div>

<a name="N102F4"></a><a name="Ejemplos+de+filtros"></a>
<h2 class="underlined_10">Ejemplos de filtros</h2>
<div class="section">
<p>Vamos a ver a continuaci&oacute;n una serie de ejemplos de usos comunes
de    los filtros, y c&oacute;mo implementar&iacute;amos dichos filtros,
utilizando    distintos elementos que hemos visto durante el curso.</p>
<a name="N102FD"></a><a name="Acceso+restringido"></a>
<h3 class="underlined_5">Acceso restringido</h3>
<p>Una primera aplicaci&oacute;n sencilla de los filtros es prohibir el acceso
   a cierta parte de nuestra web. Cuando un usuario intente acceder a dicha
parte,    se comprobar&aacute; si este usuario est&aacute; registrado. Si
lo est&aacute;    se le dejar&aacute; pasar normalmente, pero si no se prohibir&aacute;
el acceso,    redireccionando a la p&aacute;gina de login de usuarios.</p>
<pre class="code">public class RestringirAcceso implements <strong>Filter</strong> {</pre>
<p>Cuando se invoca el filtro querr&aacute; decir que un usuario intenta
acceder    a la zona restringida.</p>
<pre class="code">    public void <strong>doFilter</strong>(ServletRequest request,
			ServletResponse response, FilterChain chain) 
    {
        // Se intenta acceder a la zona restringida</pre>
<p>Comprobamos si el usuario est&aacute; registrado en el servidor. Para
ello    utilizamos la informaci&oacute;n de sesi&oacute;n, donde almacenaremos
el login    del usuario en caso de estar registrado.</p>
<pre class="code">        // Solo podemos comprobar la sesi&oacute;n 
        // en el caso de tener una petici&oacute;n HTTP

        if(request instanceof <strong>HttpServletRequest</strong> &amp;&amp; 
            response instanceof <strong>HttpServletResponse</strong>) 
        {

<strong>            HttpServletRequest</strong> http_request = 
                       (<strong>HttpServletRequest</strong>)request;
<strong>            HttpServletResponse</strong> http_response = 
                       (<strong>HttpServletResponse</strong>)response;

            // * Comprobamos si el usuario se ha registrado *
            // En nuestra aplicaci&oacute;n si el usuario 
            // se ha registrado habremos establecido
            // el atributo usuario de la sesion al 
            // nombre del usuario, si no ser&aacute; null.

            if(http_request.getSession().getAttribute("usuario")!=null)</pre>
<p>Si hay un login almacenado, procesamos la petici&oacute;n de forma normal.</p>
<pre class="code">            {
                // Continuamos de forma normal con la petici&oacute;n
                chain.<strong>doFilter</strong>(request, response);
            }</pre>
<p>Si no, redireccionamos a la p&aacute;gina de login, para que el usuario
se    registre.</p>
<pre class="code">            else 
            {
                // Redireccionamos a la p&aacute;gina de login
                response.<strong>sendRedirect</strong>("/ejemplo/login.jsp");
            }
        } else {
            // Si no es una petici&oacute;n HTTP 
            // simplemente procesamos la petici&oacute;n

            chain.<strong>doFilter</strong>(request, response);
        }
    }
}</pre>
<a name="N10348"></a><a name="Ranking+de+p%C3%A1ginas+m%C3%A1s+visitadas"></a>
<h3 class="underlined_5">Ranking de p&aacute;ginas m&aacute;s visitadas</h3>
<p>Otra posible aplicaci&oacute;n es registrar el n&uacute;mero de visitas
que    se hacen a cada p&aacute;gina, de forma que podremos obtener un listado
de las    p&aacute;ginas favoritas de los usuarios dentro de nuestro sitio
web. Para ello    instalaremos un filtro que intercepte las peticiones a
cualquier p&aacute;gina.    Cada vez que el filtro se invoque, querr&aacute;
decir que se ha visitado una    p&aacute;gina. Lo que deberemos hacer en
este momento es:</p>
<p>Determinar la direcci&oacute;n de la p&aacute;gina que se ha solicitado</p>
<pre class="code">public class Ranking implements <strong>Filter</strong> {

    // Objeto que encapsula la conexi&oacute;n a la BD de p&aacute;ginas
    BDPaginas bdPaginas = null;
    public void <strong>doFilter</strong>(ServletRequest request,
			ServletResponse response, FilterChain chain) 
    {
        // Solo podemos ver el recurso solititado en el 
        // caso de tener una petici&oacute;n HTTP

        if(request instanceof <strong>HttpServletRequest</strong>) 
        {
<strong>            HttpServletRequest</strong> http_request = 
                            (<strong>HttpServletRequest</strong>)request;

            // Miramos que recurso est&aacute; siendo solicitado
            String uri = http_request.<strong>getRequestURI</strong>();</pre>
<p>Tendremos una base de datos con una entrada para cada p&aacute;gina, donde
   se contabilizan el n&uacute;mero de visitas. Si no existe entrada para
la p&aacute;gina    visitada, la crearemos con una visita.</p>
<pre class="code">            if(bdPaginas.existePagina(uri)
            {
                // La p&aacute;gina ya esta registrada en la BD 
                // y solo tenemos que incrementar su contador
                bdPaginas.incrementaContador(uri);
            } </pre>
<p>Si ya existe entrada para esta p&aacute;gina en la BD, incrementaremos
el n&uacute;mero    de visitas.</p>
<pre class="code">            else 
            {
                // La p&aacute;gina se est&aacute; visitando por primera vez
                // Debemos registrarla en la BD 
                // con contador a 1 (1 visita)

                bdPaginas.insertaPagina(uri);
            }
        }   </pre>
<p>Procesamos la petici&oacute;n de forma normal.</p>
<pre class="code">        chain.<strong>doFilter</strong>(request, response);
    }</pre>
<p>En los m&eacute;todos <strong>init</strong> y <strong>destroy</strong> abriremos 
  y cerraremos respectivamente la conexi&oacute;n con nuestra base de datos. De 
  este forma evitamos tener que estar abriendo y cerrando una conexi&oacute;n 
  para cada petici&oacute;n.</p>
<pre class="code">    public void <strong>init</strong>(FilterConfig config) {
        bdPaginas = new BDPaginas();
        bdPaginas.conectar();
    }

    public void <strong>destroy</strong>() {
        bdPaginas.cerrar();
    }
}   </pre>
<a name="N10396"></a><a name="Extracci%C3%B3n+autom%C3%A1tica+de+informaci%C3%B3n"></a>
<h3 class="underlined_5">Extracci&oacute;n autom&aacute;tica de informaci&oacute;n</h3>
<p>Imaginemos que en el ranking queremos, adem&aacute;s de la direcci&oacute;n,
   registrar el t&iacute;tulo de la p&aacute;gina. A partir de la informaci&oacute;n
   de la petici&oacute;n y la respuesta ordinaria no podemos obtener dicha
informaci&oacute;n,    ya que se refiere al contenido de la p&aacute;gina.
Para ello tendremos que    utilizar un wrapper, que obtenga la respuesta
generada por el servidor, de manera    que podamos analizarla y extraer de
ella el t&iacute;tulo de la p&aacute;gina.</p>
<pre class="code">public class RankingTitulo implements <strong>Filter</strong> {
    // Objeto que encapsula la conexi&oacute;n a la BD de p&aacute;ginas
    BDPaginas bdPaginas = null;
    public void <strong>doFilter</strong>(ServletRequest request,
			ServletResponse response, FilterChain chain) 
    {
        // Solo podemos ver el recurso solititado en el caso 
        // de tener una petici&oacute;n HTTP

        if(request instanceof <strong>HttpServletRequest</strong> &amp;&amp; 
            response instanceof <strong>HttpServletResponse</strong>) 
        {

<strong>            HttpServletRequest</strong> http_request = 
                       (<strong>HttpServletRequest</strong>)request;
<strong>            HttpServletResponse</strong> http_response = 
                       (<strong>HttpServletResponse</strong>)response;

            // Miramos que recurso est&aacute; siendo solicitado
            String uri = http_request.<strong>getRequestURI</strong>();

            if(bdPaginas.existePagina(uri)
            {
                // La p&aacute;gina ya esta registrada en la BD 
                // y solo tenemos que incrementar su contador
                bdPaginas.incrementaContador(uri);
            } </pre>
<p>Cuando se visite una p&aacute;gina por primera vez, para registrarla en
la    base de datos tendremos que obtener la informaci&oacute;n del t&iacute;tulo.
Creamos un wrapper, y procesamos la petici&oacute;n utilizando dicho wrapper
   como objeto respuesta.</p>
<pre class="code">            else 
            {
                // La p&aacute;gina se est&aacute; visitando por primera vez
                // Debemos obtener su titulo para registrarla en la BD

                // Envolvemos la respuesta con nuestro wrapper generico
                GenericResponseWrapper wrapper = 
                       new GenericResponseWrapper(http_response);

                // Procesamos la petici&oacute;n
                chain.doFilter(http_request, wrapper); </pre>
<p>Una vez hecho esto, tendremos en el wrapper el contenido de la p&aacute;gina 
  generado. Podemos obtenerlo y analizarlo, buscando en &eacute;l la etiqueta 
  <span class="codefrag">&lt;title&gt;</span>.</p>
<pre class="code">                // En este momento ya diponemos 
                // de la respuesta en el wrapper

                // La analizamos para obtener el 
                // valor de su etiqueta &lt;title&gt;

                byte [] datos = wrapper.getData();
                HtmlParser parser = new HtmlParser(datos);
                String titulo = parser.getTitle();</pre>
<p>Una vez obtenido el t&iacute;tulo, podremos registrar en la base de datos
la    entrada de la p&aacute;gina.</p>
<pre class="code">                // Ahora podemos registrar ya la p&aacute;gina con sus datos
                bdPaginas.insertaPagina(uri, titulo); </pre>
<p>Por &uacute;ltimo, tendremos que hacer que la respuesta del wrapper pase
al    cliente, envi&aacute;ndola al objeto respuesta original.</p>
<pre class="code">                // Por &uacute;ltimo, debemos devolver 
                // la respuesta al cliente de forma
                // que pueda visualizar el recurso solicitado
                OutputStream out = response.<strong>getOutputStream</strong>();
                out.write(datos);
                out.close();
            }
        } else {
            // Si no es HTTP procesamos la petici&oacute;n de forma ordinaria
            chain.doFilter(request, response);
        }
    }

    public void <strong>init</strong>(FilterConfig config) {
        bdPaginas = new BDPaginas();
        bdPaginas.conectar();
    }

    public void <strong>destroy</strong>() {
        bdPaginas.cerrar();
    }
}   </pre>
</div>


<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006 Depto. CCIA</div>
</div>
</body>
</html>
