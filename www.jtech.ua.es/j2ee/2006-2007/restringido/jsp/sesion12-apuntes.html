<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Comunicaci&oacute;n con clientes ricos y AJAX</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servlets y JSP" src="images/baner_j2ee_der.gif" title="Servlets y JSP"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servlets y JSP</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servlets y JSP</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servlets y JSP">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="sesion09-apuntes.html">Sesion 9</a>
</div>
<div class="menuitem">
<a href="sesion10-apuntes.html">Sesion 10</a>
</div>
<div class="menuitem">
<a href="sesion11-apuntes.html">Sesion 11</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 12</div>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="sesion09-ejercicios.html">Sesion 9</a>
</div>
<div class="menuitem">
<a href="sesion10-ejercicios.html">Sesion 10</a>
</div>
<div class="menuitem">
<a href="sesion11-ejercicios.html">Sesion 11</a>
</div>
<div class="menuitem">
<a href="sesion12-ejercicios.html">Sesion 12</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion12-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Comunicaci&oacute;n con clientes ricos y AJAX</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Servlets+y+clientes+ricos">Servlets y clientes ricos</a>
<ul class="minitoc">
<li>
<a href="#HTTP+Tunneling">HTTP Tunneling</a>
</li>
<li>
<a href="#Paso+de+objetos">Paso de objetos</a>
</li>
<li>
<a href="#Env%C3%ADo+de+datos+en+la+petici%C3%B3n">Env&iacute;o de datos en la petici&oacute;n</a>
</li>
</ul>
</li>
<li>
<a href="#Servlets+y+Javascript%3A+AJAX">Servlets y Javascript: AJAX</a>
<ul class="minitoc">
<li>
<a href="#Petici%C3%B3n+HTTP+desde+Javascript">Petici&oacute;n HTTP desde Javascript</a>
</li>
<li>
<a href="#Lectura+de+la+respuesta">Lectura de la respuesta</a>
</li>
<li>
<a href="#Aplicaciones+de+AJAX">Aplicaciones de AJAX</a>
</li>
</ul>
</li>
</ul>
</div>


<a name="N1000C"></a><a name="Servlets+y+clientes+ricos"></a>
<h2 class="underlined_10">Servlets y clientes ricos</h2>
<div class="section">
<p>Vamos a ver a continuaci&oacute;n c&oacute;mo establecer una comunicaci&oacute;n entre clientes
ricos y <em>servlets</em> utilizando el protocolo HTTP. Este protocolo es la interfaz
que nos ofrecen los servidores para comunicarnos con los componentes web que contengan,
por lo tanto podremos utilizarlo desde un cliente rico Java para comunicarnos con
los <em>servlets</em> o JSP alojados en el servidor. Adem&aacute;s tiene la ventaja de que al 
ser un protocolo web est&aacute;ndar nos va a permitir realizar las comunicaciones sin problemas,
ya que los firewalls intermedios normalmente dejar&aacute;n pasar las conexiones de este tipo. 
Aunque los navegadores web normalmente utilizan este protocolo simplemente para obtener
contenido HTML, a continuaci&oacute;n veremos que podemos utilizarlo para intercambiar cualquier
tipo de contenido.</p>
<a name="N1001B"></a><a name="HTTP+Tunneling"></a>
<h3 class="underlined_5">HTTP Tunneling</h3>
<p>Si queremos establecer una comunicaci&oacute;n entre un cliente rico y un <em>servlet</em>, 
deberemos establecer desde el cliente una conexi&oacute;n con la URL en la que est&aacute; publicado
el <em>servlet</em>. La informaci&oacute;n se intercambiar&aacute; a trav&eacute;s de la conexi&oacute;n HTTP con 
dicha URL, y esto es lo que se denomina <em>HTTP tunneling</em>. Lo que haremos 
ser&aacute; construir en el cliente un objeto <span class="codefrag">URL</span> con la URL del servlet 
que queramos utilizar, y abrir una conexi&oacute;n con dicha URL para realizar la 
petici&oacute;n y recibir el resultado generado por el servlet. Al realizar la conexi&oacute;n
en conveniente indicar que no utilice la cach&eacute;, para que siempre se solicite al 
servidor que genere nuevamente el contenido:</p>
<pre class="code">URLConnection con = url.<strong>openConnection</strong>();
con.<strong>setUseCaches</strong>(false);</pre>
<p>Ahora podemos establecer las cabeceras de la petici&oacute;n que queramos. De 
esta forma podemos proporcionar informaci&oacute;n sencilla mediante pares <em>(clave, valor)</em>:</p>
<pre class="code">con.<strong>setRequestProperty</strong>("header", "valor");</pre>
<p>Entonces ya podemos crear la conexi&oacute;n con la URL:</p>
<pre class="code">InputStream in = con.<strong>getInputStream</strong>();</pre>
<p>Es en este momento cuando se establece la conexi&oacute;n con el servlet
  y    &eacute;ste genera el resultado. Mediante el flujo de entrada que
obtenemos      podremos leer desde nuestro applet el contenido generado.
Este flujo de  entrada    podr&aacute; ser de cualquier tipo, seg&uacute;n
el tipo de contenido  generado    por el servlet. Podemos leer directamente
la secuencia de bytes,  transformarlo    a un flujo de car&aacute;cteres, o bien
a un flujo de procesamiento m&aacute;s complejo (por ejemplo <span class="codefrag">DataInputStream</span>). </p>
<a name="N10058"></a><a name="Paso+de+objetos"></a>
<h3 class="underlined_5">Paso de objetos</h3>
<p>Tambi&eacute;n podremos hacer que el servlet nos devuelva objetos. Si
el servlet    serializa un objeto y lo escribe en la respuesta (utilizando
un <span class="codefrag">ObjectOutputStream</span>), desde el cliente podremos utilizar un 
<span class="codefrag">ObjectInputStream</span> para leer dicho objeto:</p>
<pre class="code">ObjectInputStream ois = new ObjectInputStream(in);
MiClase obj = (MiClase)ois.<strong>readObject</strong>();</pre>
<p>Por &uacute;ltimo, una vez leido todo el contenido, cerraremos el flujo
  de    entrada:</p>
<pre class="code">in.<strong>close</strong>();</pre>
<p>Para que el servlet devuelva un objeto deber&aacute; especificar como
tipo    del contenido generado el siguiente tipo MIME:</p>
<pre class="code">application/x-java-serialized-object</pre>
<p>Y lo &uacute;nico que tendr&aacute; que hace entonces ser&aacute; obtener
  un    <span class="codefrag">ObjectOutputStream</span> a partir del flujo de salida de la respuesta,
  y escribir    el objeto en &eacute;l:</p>
<pre class="code">MiClase result = generaObjetoResultante();
response.<strong>setContentType</strong>("application/x-java-serialized-object");
ObjectOutputStream oos = new ObjectOutputStream(response.getOutputStream());
oos.<strong>writeObject</strong>(result);
oos.<strong>flush</strong>();</pre>
<p>Hemos visto que el applet podr&aacute; realizar una petici&oacute;n 
  al    servlet, y como resultado podr&aacute; devolvernos cualquier tipo
de  datos,    pudiendo incluso enviarnos un objeto. A continuaci&oacute;n veremos
que tambi&eacute;n es posible enviar datos desde el cliente al servidor utilizando
esta petici&oacute;n HTTP.</p>
<a name="N10096"></a><a name="Env%C3%ADo+de+datos+en+la+petici%C3%B3n"></a>
<h3 class="underlined_5">Env&iacute;o de datos en la petici&oacute;n</h3>
<p>Para poder enviar informaci&oacute;n al servidor podremos utilizar el bloque de contenido
del mensajes de petici&oacute;n HTTP. Para ello la conexi&oacute;n que abrimos con la
 URL debe ser de lectura/escritura:</p>
<pre class="code">URLConnection con = url.<strong>openConnection</strong>();
con.<strong>setUseCaches</strong>(false);
con.<strong>setDoOutput</strong>(true);</pre>
<p>A continuaci&oacute;n crearemos un array de bytes donde escribiremos la
  informaci&oacute;n que enviaremos al servidor:</p>
<pre class="code">ByteArrayOutputStream baos = new ByteArrayOutputStream();</pre>
<p>Podemos usar distintos tipos de flujos sobre este objeto, seg&uacute;n
  vayamos a escribir car&aacute;cteres (<span class="codefrag">PrintWriter</span>), datos 
  codificados en binario (<span class="codefrag">DataOutputStream</span>) u objetos serializados
(<span class="codefrag">ObjectOutputStream</span>), por ejemplo.</p>
<p>Una vez escrito este contenido, deberemos establecer una cabecera con
la longitud    de dicho contenido:</p>
<pre class="code">con.setRequestProperty("<strong>Content-Length</strong>", String.valueOf(baos.size()));</pre>
<p>Por cuesti&oacute;n de compatibilidad entre navegadores, ser&aacute; conveniente
     establecer manualmente el tipo de contenido: </p>
<pre class="code">connection.setRequestProperty("<strong>Content-Type</strong>", 
                              "application/x-java-serialized-object");</pre>
<p>Tipos MIME que podemos utilizar comunmente para intercambiar informaci&oacute;n son:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">application/x-www-form-urlencoded</span></td>
<td colspan="1" rowspan="1">Se env&iacute;an los datos codificados de la misma forma en la que son codificados por un formulario HTML con m&eacute;todo POST.</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">text/plain</span></td>
<td colspan="1" rowspan="1">Se env&iacute;a como contenido texto ASCII.</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">application/octet-stream</span></td>
<td colspan="1" rowspan="1">Se env&iacute;a como contenido datos binarios. Dentro de la secuencia de bytes podremos codificar la informaci&oacute;n como queramos. Por ejemplo, podemos codificar de forma binaria un objeto serializado, utilizando un <span class="codefrag">DataOutputStream</span>.</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">application/x-java-serialized-object</span></td>
<td colspan="1" rowspan="1">Se env&iacute;a como contenido un objeto Java serializado.</td>

</tr>

</table>
<p>En este momento ya podremos enviar los datos al flujo
  de    salida de la conexi&oacute;n:</p>
<pre class="code">baos.writeTo(connection.<strong>getOutputStream</strong>());</pre>
<p>Una vez hecho esto ya podemos obtener el flujo de entrada de la conexi&oacute;n,
     para realizar la petici&oacute;n y obtener contenido que genera el servlet como respuesta, 
     de la misma forma que lo haciamos en el caso anterior.</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Si no abrimos el flujo de entrada (ni intentamos consultar ninguna otra propiedad
de las respuesta que genera el <em>servlet</em>), la petici&oacute;n no se llegar&aacute; a realizar
y por lo tanto el <em>servlet</em> no recibir&aacute; los datos que hayamos escrito para ser 
enviados)
</div>
</div>
</div>

<a name="N1012C"></a><a name="Servlets+y+Javascript%3A+AJAX"></a>
<h2 class="underlined_10">Servlets y Javascript: AJAX</h2>
<div class="section">
<p>AJAX (<em>Asynchronous Javascript And Xml</em>) no es una tecnolog&iacute;a, sino una 
t&eacute;cnica de desarrollo que combina una serie de tecnolog&iacute;as para hacer que un navegador 
en el lado del cliente pueda obtener informaci&oacute;n del servidor sin tener que recargar 
la p&aacute;gina que se est&eacute; mostrando. Las tecnolog&iacute;as que se utilizan son:</p>
<ul>

<li>
<strong>HTML</strong> y <strong>CSS</strong> para presentar la informaci&oacute;n.</li>

<li>
<strong>XML</strong> para intercambiar informaci&oacute;n con el servidor.</li>

<li>
<strong>DOM</strong> y <strong>Javascript</strong> para analizar esta informaci&oacute;n.</li>

</ul>
<p>Esta t&eacute;cnica consistir&aacute; en hacer una petici&oacute;n HTTP utilizando el objeto 
<span class="codefrag">XMLHttpRequest</span> de <em>Javascript</em>. Con esto obtendremos del 
servidor un documento XML con la informaci&oacute;n requerida, que podremos analizar 
con el DOM (tambi&eacute;n de <em>Javascript</em>) Una vez tengamos los datos obtenidos 
del servidor, podemos actualizarlos en el documento HTML utilizando nuevamente 
el DOM.</p>
<a name="N1015C"></a><a name="Petici%C3%B3n+HTTP+desde+Javascript"></a>
<h3 class="underlined_5">Petici&oacute;n HTTP desde Javascript</h3>
<p>Lo primero que deberemos hacer es obtener el objeto <span class="codefrag">XMLHttpRequest</span> que nos permita hacer una petici&oacute;n HTTP desde <em>Javascript</em>. Deberemos distinguir entre IE y Firefox:</p>
<pre class="code">function verMensajes() {
   //Preparar objeto para lanzar peticion   
   if (window.XMLHttpRequest) {		//Firefox,etc
      peticion = new XMLHttpRequest();     
   } else if (window.ActiveXObject) {   //Explorer   
      peticion = new ActiveXObject("Microsoft.XMLHTTP");
   }</pre>
<p>Una vez obtenido este objeto, deberemos especificar a qu&eacute; funci&oacute;n se deber&aacute; llamar cuando se reciba la respuesta HTTP del servidor. Especificaremos esta funci&oacute;n <em>callback</em> de la siguiente forma:</p>
<pre class="code">   //a quien llamar cuando el servidor responda
   peticion.onreadystatechange = atenderPeticion;</pre>
<p>Por &uacute;ltimo, efectuaremos la petici&oacute;n propiamente dicha, especificando el tipo de petici&oacute;n, la URL a la que vamos a conectar, y si la llamada es as&iacute;ncrona. Si no fuese as&iacute;ncrona, el programa quedar&iacute;a bloqueado hasta recibir la respuesta. Por lo tanto, deberemos poner este &uacute;ltimo par&aacute;metro siempre a <span class="codefrag">true</span> para evitar que la web queda bloqueada mientras se obtiene la informaci&oacute;n:</p>
<pre class="code">   //lanzar la peticion propiamente dicha
   peticion.open("GET", "http://localhost:7001/ChatXml/chat/listaMensajesXml.jsp", true);
   peticion.send(null);
}</pre>
<p>NOTA: Por motivo de seguridad, s&oacute;lo se permitir&aacute; hacer peticiones mediante el objeto <span class="codefrag">XMLHttpRequest</span> al servidor del que se ha descargado esta p&aacute;gina.</p>
<p>Una vez se reciba la respuesta, se llamar&aacute; a la funci&oacute;n especificada como <em>callback</em>. Deberemos fijarnos en el estado en el que se encuentra la petici&oacute;n:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>
<td colspan="1" rowspan="1"><span class="codefrag">0</span></td><td colspan="1" rowspan="1">No inicializada</td>
</tr>

<tr>
<td colspan="1" rowspan="1"><span class="codefrag">1</span></td><td colspan="1" rowspan="1">Cargando</td>
</tr>

<tr>
<td colspan="1" rowspan="1"><span class="codefrag">2</span></td><td colspan="1" rowspan="1">Cargada</td>
</tr>

<tr>
<td colspan="1" rowspan="1"><span class="codefrag">3</span></td><td colspan="1" rowspan="1">Interactiva</td>
</tr>

<tr>
<td colspan="1" rowspan="1"><span class="codefrag">4</span></td><td colspan="1" rowspan="1">Completada</td>
</tr>

</table>
<p>El significado de cada uno de estos estados es:</p>
<ul>

<li>
<strong>No inicializada.</strong> Se ha creado el objeto de la petici&oacute;n HTTP pero &eacute;sta todav&iacute;a no se ha efectuado.</li>

<li>
<strong>Cargando.</strong> Se ha realizado la petici&oacute;n HTTP y se est&aacute; esperando a recibir la respuesta.</li>

<li>
<strong>Cargada.</strong> La respuesta HTTP se ha recibido, pero todav&iacute;a no se puede acceder al modelo DOM que representa al documento obtenido.</li>

<li>
<strong>Interactiva.</strong> El modelo DOM se ha empezado a construir pero todav&iacute;a no est&aacute; completo. Podremos consultar las partes del modelo que ya se hayan construido.</li>

<li>
<strong>Completada.</strong> El modelo DOM del documento obtenido est&aacute; completo.</li>

</ul>
<p>S&oacute;lo nos interesar&aacute; el caso en el que la petici&oacute;n haya sido completada. Adem&aacute;s tambi&eacute;n deberemos comprobar que la respuesta del servidor no nos haya devuelto un c&oacute;digo de error. Si todo ha ido bien, el estado de la respuesta deber&iacute;a ser <span class="codefrag">200 OK</span>:</p>
<pre class="code">function atenderPeticion() {
   if (peticion.readyState == 4) {
      //analizar respuesta
      if (peticion.status!=200) {
         alert("ha habido un error");
         return;
      }</pre>
<p>En este punto tendremos el contenido de la respuesta en las propiedades <span class="codefrag">peticion.responseText</span> y <span class="codefrag">peticion.responseXML</span>. La primera de ellas nos ofrecer&aacute; la respuesta como una cadena de texto, mientras que la segunda es un objeto del tipo <span class="codefrag">XMLDocument</span> al que podremos acceder mediante el DOM.</p>
<a name="N101FF"></a><a name="Lectura+de+la+respuesta"></a>
<h3 class="underlined_5">Lectura de la respuesta</h3>
<p>Normalmente utilizaremos <span class="codefrag">responseText</span> cuando queramos incluir directamente en el HTML el contenido devuelto por el servidor, y <span class="codefrag">responseXML</span> cuando estemos intercambiando estructuras de datos.</p>
<p>A continuaci&oacute;n se muestra un ejemplo en el que se analiza el documento XML obtenido para incluir la informaci&oacute;n formateada en el HTML:</p>
<pre class="code">      //mostrar mensajes   
      var areaMensajes = document.getElementById("mensajesChat");   
	  var textoHTML = "";

	  docXml = peticion.responseXML;
	  var raiz = docXml.getElementsByTagName('mensajes');
	  mensajes = raiz[0].getElementsByTagName('mensaje');
	  for(i=0;i&lt;mensajes.length;i++) {
	  	  var nick = mensajes[i].getElementsByTagName('nick').item(0).firstChild.data;
	  	  var texto = mensajes[i].getElementsByTagName('texto').item(0).firstChild.data;
	  	  textoHTML += "&lt;strong&gt;&amp;lt;" + nick + "&amp;gt;&lt;/strong&gt; " + texto + "&lt;br/&gt;";
	  }
	  
      areaMensajes.innerHTML = textoHTML;
   }
}</pre>
<p>En el caso de este ejemplo, para intercambiar la informaci&oacute;n estar&iacute;amos utilizando un documento XML con el siguiente formato:</p>
<pre class="code">&lt;mensajes&gt;
&lt;mensaje&gt;
  &lt;nick&gt;Ana&lt;/nick&gt;
  &lt;texto&gt;Hola&lt;/texto&gt;
&lt;/mensaje&gt;
&lt;mensaje&gt;
  &lt;nick&gt;Jose&lt;/nick&gt;
  &lt;texto&gt;Que tal?&lt;/texto&gt;
&lt;/mensaje&gt;
&lt;/mensajes&gt;</pre>
<p>Podremos invocar la funci&oacute;n que efectua la petici&oacute;n HTTP de diferentes formas. Podemos utilizar un temporizador para hacer que la informaci&oacute;n se actualice peri&oacute;dicamente, o bien podemos hacer que se invoque como respuesta a alg&uacute;n evento del usuario (por ejemplo cuando pulse un bot&oacute;n).</p>
<a name="N10220"></a><a name="Aplicaciones+de+AJAX"></a>
<h3 class="underlined_5">Aplicaciones de AJAX</h3>
<p>Esta t&eacute;cnica tiene numerosas aplicaciones, como por ejemplo:</p>
<ul>

<li>
<em>Validaci&oacute;n de formularios</em>: Podremos validar la informaci&oacute;n introducida en un formulario en el lado del servidor antes de enviarlo. Por ejemplo, al registrarnos en una web podemos comprobar si un <em>login</em> ya est&aacute; utilizado.</li>

<li>
<em>Autocompletar campos</em>: Mientras escribimos en un campo de un formulario, podemos consultar en el servidor las coincidencias con lo que llevamos escrito para que nos muestre una lista con las posibilidades existentes.</li>

<li>
<em>Mostrar datos actualizados</em>: Podemos mantener informaci&oacute;n de &uacute;ltima hora en la web sin tener que recargar. Por ejemplo, podemos ver el marcador de un partido de f&uacute;tbol que se est&aacute; jugando en este momento, la clasificaci&oacute;n de la F&oacute;rmula 1, o informaci&oacute;n de la bolsa.</li>


</ul>
</div>



<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006 Depto. CCIA</div>
</div>
</body>
</html>
