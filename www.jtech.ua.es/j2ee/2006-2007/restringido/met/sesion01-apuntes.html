<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Metodolog&iacute;as &Aacute;giles</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario en Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Metodologias de Desarrollo" src="images/baner_j2ee_der.gif" title="Metodologias de Desarrollo"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Metodolog&iacute;as de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Metodolog&iacute;as de Desarrollo</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Metodolog&iacute;as de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 1</div>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="Sesi&oacute;n 2: Programaci&oacute;n eXtrema">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html" title="Sesi&oacute;n 3: Modelado &Aacute;gil">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html" title="Sesi&oacute;n 4: Pr&aacute;cticas &Aacute;giles">Sesi&oacute;n 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion01-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Metodolog&iacute;as &Aacute;giles</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n">Introducci&oacute;n</a>
</li>
<li>
<a href="#Ciclo+de+Vida+Cl%C3%A1sico">Ciclo de Vida Cl&aacute;sico</a>
</li>
<li>
<a href="#Desarrollo+Iterativo">Desarrollo Iterativo</a>
</li>
<li>
<a href="#Movimiento+%C3%81gil">Movimiento &Aacute;gil</a>
<ul class="minitoc">
<li>
<a href="#El+Manifiesto+%C3%81gil">El Manifiesto &Aacute;gil</a>
</li>
<li>
<a href="#Los+Principios+%C3%81giles">Los Principios &Aacute;giles</a>
</li>
</ul>
</li>
<li>
<a href="#Conceptos+%C3%81giles">Conceptos &Aacute;giles</a>
</li>
<li>
<a href="#Entorno+%C3%81gil">Entorno &Aacute;gil</a>
</li>
<li>
<a href="#Metodolog%C3%ADa+%C3%81giles">Metodolog&iacute;a &Aacute;giles</a>
<ul class="minitoc">
<li>
<a href="#En+Resumen">En Resumen</a>
</li>
<li>
<a href="#Scrum">Scrum</a>
</li>
<li>
<a href="#Desarrollo+de+Software+Adaptativo+%28ASD%29">Desarrollo de Software Adaptativo (ASD)</a>
</li>
<li>
<a href="#Lean+Development+%28LD%29">Lean Development (LD)</a>
</li>
<li>
<a href="#Metodolog%C3%ADas+Crystal">Metodolog&iacute;as Crystal</a>
</li>
<li>
<a href="#M%C3%A9todo+de+Desarrollo+de+Sistemas+Din%C3%A1mico+%28DSDM%29">M&eacute;todo de Desarrollo de Sistemas Din&aacute;mico (DSDM)</a>
</li>
<li>
<a href="#Proceso+Unificado+%28UP%29">Proceso Unificado (UP)</a>
</li>
<li>
<a href="#Feature-Driven+Development+%28FDD%29">Feature-Driven Development (FDD)</a>
</li>
</ul>
</li>
<li>
<a href="#Metodolog%C3%ADas+%C3%81giles+vs+Orientadas+a+la+Planificaci%C3%B3n">Metodolog&iacute;as &Aacute;giles vs Orientadas a la Planificaci&oacute;n</a>
</li>
<li>
<a href="#Roadmap">Roadmap</a>
<ul class="minitoc">
<li>
<a href="#Puntos+Destacados">Puntos Destacados</a>
</li>
<li>
<a href="#Para+Saber+M%C3%A1s">Para Saber M&aacute;s</a>
<ul class="minitoc">
<li>
<a href="#Bibliograf%C3%ADa">Bibliograf&iacute;a</a>
</li>
<li>
<a href="#Enlaces">Enlaces</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>


<a name="N1000E"></a><a name="Introducci%C3%B3n"></a>
<h2 class="underlined_10">Introducci&oacute;n</h2>
<div class="section">
<p>Dentro del sector que nos movemos, donde los proyectos que se realizan muy pocas veces acaparan el calificativo de proyecto a largo plazo, las metodolog&iacute;as que se deben aplicar deben dejar de lado los formalismos de metodolog&iacute;as cl&aacute;sicas de desarrollo para guiarse por los resultados a corto/medio plazo, pero sin perder de vista la calidad.</p>
<p>El mercado actual es impredecible, y no podemos saber como evolucionar&aacute;n con el tiempo las aplicaciones. las condiciones del mercado cambian, tambi&eacute;n lo hacen las necesidades de nuestros clientes. Si nuestra fase de requisitos se alarga podemos provocar la perdida del principio de oportunidad por parte de nuestro cliente.</p>
<p> Dado este dinamismo, existe una tendencia a la perdida de la formalidad y el rigor, buscando el equilibrio entre una documentaci&oacute;n extensa respecto a una documentaci&oacute;n &uacute;til.</p>
<p>Dada esta necesidad, durante los &uacute;ltimos 5 a&ntilde;os han ido apareciendo diferentes metodolog&iacute;as, conocidas como <em>&aacute;giles</em>, que dan mayor valor al individuo, a la colaboraci&oacute;n con el cliente y al desarrollo incremental del software con iteraciones muy cortas. Este enfoque est&aacute; mostrando su efectividad en proyectos con requisitos muy inestables y cuando se exige reducir dr&aacute;sticamente los tiempos de desarrollo pero manteniendo una alta calidad. Las metodolog&iacute;as &aacute;giles est&aacute;n revolucionando la manera de producir software, y a la vez generando un amplio debate entre sus seguidores y quienes por escepticismo o convencimiento no las ven como alternativa para las metodolog&iacute;as tradicionales.
</p>
<p>Pero antes de ver est&aacute;s nuevas metodolog&iacute;as, entremos en antecedentes y demos un peque&ntilde;o repaso al ciclo de vida cl&aacute;sico de desarrollo del software.</p>
</div>


<a name="N10027"></a><a name="Ciclo+de+Vida+Cl%C3%A1sico"></a>
<h2 class="underlined_10">Ciclo de Vida Cl&aacute;sico</h2>
<div class="section">
<p>El ciclo de vida cl&aacute;sico, tambi&eacute;n conocido como
modelo secuencial o en cascada, consta de las siguientes fases:</p>
<ol>
	
<li>
<strong>An&aacute;lisis</strong> de los <strong>requisitos</strong>: Los servicios, restricciones y objetivos son establecidos con los usuarios del sistema. Se busca hacer esta definici&oacute;n en	detalle.</li>
	
<li>
<strong>Dise&ntilde;o</strong> de software: Se divide el sistema en sistemas de software o hardware. Se establece la arquitectura total del sistema. Se identifican y describen las abstracciones y relaciones de los componentes del sistema.</li>
	
<li>
<strong>Implementaci&oacute;n</strong> y pruebas unitarias: Construcci&oacute;n de los m&oacute;dulos y unidades de software. Se realizan pruebas de cada unidad.</li>
	
<li>Integraci&oacute;n y <strong>aceptaci&oacute;n</strong> del sistema: Se integran todas las unidades. Se prueban en conjunto. Se entrega el conjunto probado al cliente.</li>
	
<li>
<strong>Despliegue</strong> y mantenimiento: Generalmente es la fase 	m&aacute;s larga. El sistema es puesto en marcha y se realiza la correcci&oacute;n de errores descubiertos. Se realizan mejoras de implementaci&oacute;n. Se identifican nuevos requisitos.</li>

</ol>
<p>Cada fase tiene como resultado documentos que deben ser aprobados por el usuario. Adem&aacute;s, una fase no comienza hasta que termine la fase anterior y generalmente se incluye la correcci&oacute;n de los problemas encontrados en fases previas. La interacci&oacute;n entre fases puede observarse en la siguiente figura. 
</p>
<p>

<img alt="Fases del Ciclo de Vida Cl&aacute;sico" content-width="11cm" src="imagenes/s1/cascada.gif" width="474">
</p>
<p></p>
<p>En la pr&aacute;ctica, este modelo no es lineal, e involucra varias iteraciones e interacci&oacute;n entre las distintas fases de desarrollo. Algunos problemas que se observan en el modelo de cascada son:</p>
<ul>
	
<li>Las iteraciones son costosas e implican rehacer trabajo debido a la producci&oacute;n y aprobaci&oacute;n de documentos.</li>
	
<li>Aunque son pocas iteraciones, es normal congelar parte del desarrollo y continuar con las siguientes fases.</li>
	
<li>Los problemas se dejan para su posterior resoluci&oacute;n, lo que lleva a que estos sean ignorados o corregidos de una forma poco elegante.</li>
	
<li>Existe una alta probabilidad de que el software no cumpla con	los requisitos del usuario por el largo tiempo de entrega del	producto.</li>
	
<li>Es inflexible a la hora de evolucionar para incorporar nuevos requisitos. Es dif&iacute;cil responder a cambios en los requisitos.</li>

</ul>
<p>Este modelo s&oacute;lo debe usarse si se entienden a plenitud los requisitos, y estos no van a ser modificados. Pero, hemos de tener en cuenta que:
</p>
<div class="frame note">
<div class="label">Importante</div>
<div class="content">La &uacute;nica constante en los proyectos de software es el cambio</div>
</div>
</div>


<a name="N1007B"></a><a name="Desarrollo+Iterativo"></a>
<h2 class="underlined_10">Desarrollo Iterativo</h2>
<div class="section">
<p>El desarrollo evolutivo e iterativo, en contraste con el desarrollo secuencial o en cascada, implica la programaci&oacute;n y prueba de sistemas parciales mediante ciclos repetitivos, de modo que los cambios son "f&aacute;cilmente" asimilados. Tambi&eacute;n asumen que el desarrollo comienza incluso antes de que todos los requisitos hayan sido detallados. El elemento clave para aclarar y refinar las especificaciones, que no dejan de cambiar y/o evolucionar, es la <em>retroalimentaci&oacute;n</em>.</p>
<p>Debemos confiar en peque&ntilde;as pero r&aacute;pidas iteraciones de desarrollo,
retroalimentaci&oacute;n y adaptaci&oacute;n del software para refinar los requisitos y el dise&ntilde;o. El resultado de cada iteraci&oacute;n es un trozo de sistema que est&aacute; probado, integrado y que se puede utilizar, y para ello cada iteraci&oacute;n incluye su propio an&aacute;lisis de requisitos, dise&ntilde;o, implementaci&oacute;n y prueba. 
</p>
<p>El hecho de que con cada iteraci&oacute;n tengamos una visi&oacute;n parcial del sistema que se puede utilizar no significa que est&eacute; listo para entrar en producci&oacute;n. Es importante destacar que ya en la primera iteraci&oacute;n se genera c&oacute;digo, el cual es utilizable. No obstante, el sistema no cumplir&aacute; los requisitos m&iacute;nimos hasta que hayan pasado muchas iteraciones, por ejemplo, 10 o 15 iteraciones. 
</p>
<p>Las iteraciones <strong>timeboxed</strong> se caracterizan por fijar la duraci&oacute;n de cada una de las iteraciones y no permitir modificarla. La duraci&oacute;n total de un proyecto tambi&eacute;n puede ser <em>timeboxed</em>. Si finalmente llegamos a la conclusi&oacute;n de que las peticiones (el &aacute;mbito) para la iteraci&oacute;n no se pueden cumplir dentro del <em>timebox</em>, entonces en vez de alargar la finalizaci&oacute;n de la iteraci&oacute;n, se debe reducir el &aacute;mbito (recolocando las peticiones con menor prioridad de nuevo en la lista de peticiones), para que el sistema parcial siga creciendo y siempre finalice en un estado estable y probado en la fecha final de la iteraci&oacute;n originalmente planeada.</p>
<p>As&iacute; pues, el sistema crece de forma incremental con el tiempo, iteraci&oacute;n
tras iteraci&oacute;n, por ello esta aproximaci&oacute;n se conoce como <em>desarrollo iterativo e incremental</em>. 
</p>
<p>

<img alt="Ciclo de Vida Iterativo" content-width="16cm" src="imagenes/s1/iterativo.gif" width="597">
</p>
<p>Existe una tendencia a minimizar los tiempos de an&aacute;lisis en beneficio de reducir tiempos de desarrollo. Ya antes hemos comentado que el cliente quiere ver, tocar, el producto cuanto antes.</p>
</div>


<a name="N100AC"></a><a name="Movimiento+%C3%81gil"></a>
<h2 class="underlined_10">Movimiento &Aacute;gil</h2>
<div class="section">
<p>Los m&eacute;todos de desarrollo &aacute;gil promueven un desarrollo evolutivo y plazos de entrega con periodos de tiempo cortos y fijos, mediante una planificaci&oacute;n din&aacute;mica, realizando entregas incrementales, e incluye otras pr&aacute;cticas que incentivan la agilidad (respuesta r&aacute;pida y flexible al cambio). Si los m&eacute;todos &aacute;giles tienen un lema es "abrazar los cambios" (<em>embrace change</em>).</p>
<p>Un proceso es &aacute;gil cuando el desarrollo de software es <strong>incremental</strong> (entregas peque&ntilde;as de software, con ciclos r&aacute;pidos), <strong>cooperativo</strong> (cliente y desarrolladores trabajan juntos constantemente con una cercana comunicaci&oacute;n), <strong>sencillo</strong> (el m&eacute;todo en s&iacute; mismo es f&aacute;cil de aprender y modificar, bien documentado), y <strong>adaptable </strong>(permite realizar cambios de &uacute;ltimo momento). Es decir, se trata de una <em>ingeniera del software ligera</em> que mantiente las m&iacute;nimas actividades b&aacute;sicas de la ingenieria del software que conducen a la construcci&oacute;n y entrega del proyecto.</p>
<p>La filosofia &aacute;gil promueve equipos de proyecto peque&ntilde;os y con alta motivaci&oacute;n, donde el cliente forma parte del equipo de desarrollo, formando un equipo auto-organizado y que controla su propio destino. Un equipo &aacute;gil fomenta la comunicaci&oacute;n y la colaboraci&oacute;n entre todos los que trabajan en &eacute;l.</p>
<p>En 2001 un grupo de expertos interesados en los m&eacute;todo iterativos y &aacute;giles se reunieron para encontrar un fondo com&uacute;n, definiendo los valores y  principios que permitir&iacute;an a los equipos de desarrollo trabajar de una forma veloz y sensible al cambio. De aqu&iacute; naci&oacute; la Alianza &aacute;gil (<a class="external" href="http://www.agilealliance.com/">www.agilealliance.com</a>) con un manifiesto (declaraci&oacute;n p&uacute;blica de principios e intenciones) y una serie de principios.
</p>
<p>El manifiesto y los principios han sido, y son, la base de las metodolog&iacute;as &aacute;giles, de modo que la gesti&oacute;n &aacute;gil de proyectos, el modelado &aacute;gil, las t&eacute;cnicas &aacute;giles, etc... son una consecuencia de dicha reuni&oacute;n.
</p>
<a name="N100D7"></a><a name="El+Manifiesto+%C3%81gil"></a>
<h3 class="underlined_5">El Manifiesto &Aacute;gil</h3>
<div class="frame note">
<div class="label">El Manifiesto &Aacute;gil (The Agile Manifesto)</div>
<div class="content">
Estamos destapando mejores modos de desarrollar software al construirlo por nuestra cuenta y ayudar a otros a hacerlo. A trav&eacute;s de este trabajo hemos llegado a valorar:.
<br>&nbsp;
<br>

<em><strong>Individualidades e interacciones</strong> frente a procesos y herramientas</em>
<br>

<em><strong>Software que funciona</strong> frente documentaci&oacute;n comprensible</em>
<br>

<em><strong>Colaboraci&oacute;n del cliente</strong> frente a la negociaci&oacute;n de un contrato</em>
<br>

<em><strong>Respuesta al cambio</strong> frente al seguimiento estricto de un planning</em>
<br>&nbsp;
<br>
Esto significa que mientras los elementos de la derecha nos aportan valor, hemos de valorar m&aacute;s los elementos de la izquierda (en negrita).<br>&nbsp;
<br>
Firmado por <em>Kent Beck, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland y Dave Thomas</em>.<br>&nbsp;
<br>
Ver <a class="external" href="http://www.agilemanifesto.org/">www.agilemanifesto.org</a>

</div>
</div>
<p>A continuaci&oacute;n se detalla el manifiesto:</p>
<ul>
<li>
<em><strong>Individualidades e interacciones</strong> frente a procesos y herramientas</em>
</li>
</ul>
<p>La gente, y su interacci&oacute;n, es el principal factor de &eacute;xito de un proyecto software. Si se sigue un buen proceso de desarrollo, pero el equipo falla, el &eacute;xito no est&aacute; asegurado; sin embargo, si el equipo funciona, es m&aacute;s f&aacute;cil conseguir el objetivo final, aunque no se tenga un proceso bien definido.</p>
<p>Un buen desarrollador no es necesariamente un gran programador. Un buen desarrollador puede ser un programador decente que trabaja bien con otros. Trabajar bien con otros desarrolladores, interactuar y comunicarse, son destrezas tan o m&aacute;s importantes que el propio nivel de programaci&oacute;n. As&iacute; pues, no se necesitan desarrolladores brillantes, sino desarrolladores que se adapten bien al trabajo en equipo.</p>
<p>As&iacute; mismo, las herramientas (compiladores, depuradores, control de versiones, etc.) son importantes para mejorar el rendimiento del equipo, pero el disponer m&aacute;s recursos que los estrictamente necesarios tambi&eacute;n puede afectar negativamente.<br>En cuanto a las herramientas, un buen consejo es empezar poco a poco. No hemos de asumir que una herramienta que no hemos probado se nos queda peque&ntilde;a. En vez de comprar la herramienta m&aacute;s nueva, completa y cara, busca una gratuita y utilizala hasta que compruebes que se te ha quedado peque&ntilde;a. Antes de comprar las licencias de equipo para la mejor herramienta CASE, utiliza pizarras y grafos en papel hasta que compruebes que necesitas m&aacute;s. Por lo tanto, no asumas que la mejor y m&aacute;s grande herramienta automaticamente te ayudar&aacute; a ser mejor. Normalmente, entorpecen m&aacute;s de lo que ayudan.</p>
<p>Como conclusi&oacute;n, comentar que es m&aacute;s importante construir un buen equipo que construir el entorno. Muchas veces se comete el error de construir primero el entorno y esperar que el equipo se adapte autom&aacute;ticamente. Es mejor crear el equipo y que &eacute;ste configure su propio entorno de desarrollo en base a sus necesidades.
</p>
<ul>
<li>
<em><strong>Software que funciona</strong> frente documentaci&oacute;n comprensible</em>
</li>
</ul>
<p>Aunque se parte de la base de que el software sin documentaci&oacute;n es un desastre, la regla a seguir es "no producir documentos a menos que sean necesarios de forma inmediata para tomar un decisi&oacute;n importante". Por descontado, el equipo se ve en la necesidad de producir documentos legibles por humanos que describa el sistema y las decisiones tomadas durante el dise&ntilde;o, ya que el c&oacute;digo no el el medio ideal para comunicar la estructura y las intenciones del sistema.</p>
<p>Sin embargo, demasiada documentaci&oacute;n es peor que poca. Los documentos enormes consumen mucho tiempo en su creaci&oacute;n e incluso m&aacute;s tiempo en tenerlos actualizados. Si no se mantienen sincronizados con el codigo se convierten en grandes y complicadas mentiras, fomentando dudas y confusion en su empleo.</p>
<p>Siempre es una buena idea escribir y mantener un documento estructural y de intenciones (<em>libro blanco</em>), pero dicho documento debe ser <em>corto</em> y <em>notable</em>, donde corto significa no m&aacute;s de 20 p&aacute;ginas, y notable que trata las intenciones de dise&ntilde;o trabajadas y &uacute;nicamente las estructuras de m&aacute;s alto nivel del sistema.</p>
<p>Y si todo lo que tenemos es un libro blanco, &iquest;c&oacute;mo formamos a los nuevos integrantes del equipo a trabajar en el proyecto? Trabajando muy cerca con ellos. Transferimos nuestro conocimiento sentandonos junto a ellos y ayud&aacute;ndolos, resolviendo todas las dudas que tengan. As&iacute; pues, les hacemos parte del equipo mediante un entrenamiento cercano y la interacci&oacute;n experto &lt;-&gt; novato.</p>
<p>Los 2 mejores documentos para transferir la informaci&oacute;n a los nuevos integrantes son el c&oacute;digo fuente y el propio equipo. El c&oacute;digo no miente sobre lo que hace. Puede ser dificil extraer las decisiones e intenciones del c&oacute;digo, pero el c&oacute;digo es la &uacute;nica fuente de informaci&oacute;n un&iacute;voca. Los integrantes del equipo de desarrollo mantienen el mapa mental del sistema en su completa evoluci&oacute;n, de modo que no hay un modo m&aacute;s r&aacute;pido y eficiente de transferir este mapa mental al resto de integrantes que la interaccion frente a frente.</p>
<p>Pero al final del dia, es el software producido por el equipo lo que utilizar&aacute; el usuario, y no la documentaci&oacute;n. Por lo tanto, la documentaci&oacute;n no debe ser un objetivo en s&iacute;. De hecho, debe ser un medio de soporte para el producto real - el software.</p>
<ul>
<li>
<em><strong>Colaboraci&oacute;n del cliente</strong> frente a la negociaci&oacute;n de un contrato</em>
</li>
</ul>
<p>
Las caracter&iacute;sticas particulares del desarrollo de software hace que muchos proyectos hayan fracasado por intentar cumplir unos plazos y unos costes preestablecidos al inicio del mismo, seg&uacute;n los requisitos que el cliente manifestaba en ese momento. Por ello, se propone que exista una interacci&oacute;n constante entre el cliente y el equipo de desarrollo. Esta colaboraci&oacute;n entre ambos ser&aacute; la que marque la marcha del proyecto y asegure su &eacute;xito.
</p>
<p>El software no se puede pedir del mismo modo que realizamos el pedido de un producto. No podemos escribir la descripcion del software que queremos y esperar a que alguien lo desarrolle dentro de un calendario cerrado y un precio fijo. Las ocasiones en que se ha tratado los proyecto software de este modo y que han fracasado son innumerables. A veces los fallos son espectaculares.</p>
<p>En muy tentador para los empresarios decirles a su equipo de desarrollo cuales son sus necesidades y esperar que el equipo se vaya durante un rato y vuelva con un sistema que cumple sus necesidad. Pero este modo de trabajar tiende a fallar y tener una calidad pobre. </p>
<p>Los proyectos exitosos implican la retroalimentaci&oacute;n del cliente a un ritmo constante. M&aacute;s que depender de un contrato o una sentencia de trabajo, el cliente trabaja codo con codo con el equipo de desarrollo, ofreciendo la retroalimentaci&oacute;n frecuente a sus esfuerzos.</p>
<p>Un contrato que especifica los requisitos, la planificaci&oacute;n y el coste del proyecto falla por su base. En la mayor&iacute;a de los casos, los t&eacute;rminos especificados pierden todo el sentido antes de que el proyecto se complete. Los mejores contratos son aquellos que determinan que el cliente y el equipo de desarrollo deben trabajan juntos.</p>
<ul>
<li>
<em><strong>Respuesta al cambio</strong> frente al seguimiento estricto de un planning</em>
</li>
</ul>
<p>La habilidad de responder a los cambios que puedan surgir a los largo del proyecto (cambios en los requisitos, en la tecnolog&iacute;a, en el equipo, etc.) determina tambi&eacute;n el &eacute;xito o fracaso del mismo. Cuando hacemos una planificaci&oacute;n, debemos asegurarnos que nuestros plannings son flexibles y estan preparados para adaptararse a los cambios en el negocio y las tecnologias.</p>
<p>El curso de un proyecto software no se puede predecir a largo plazo. Existen demasiadas variable a tener en cuenta. Simplemente, no somos suficientemente buenos para estimar el coste de un proyecto a largo plazo, debido a que el entorno de negocio en el cual se mueve el software va a modificarse a lo largo del desarrollo. Es dificil escribir especificaciones de requisitos, ya que el cliente va a quere cambiar los requisitos en cuanto vea que la aplicaci&oacute;n empieza a funcionar.</p>
<p>Los gestores novatos tienden a crear diagramas de Pert y Gantt de la totalidad del proyecto y ponerlos en la pared m&aacute;s grande de la empresa. Les hace sentir que tiene control sobre el proyecto. Pueden llevar el control de las tareas individuales y tacharlas conforme se completan. Pueden comparar las fechas realies con las planificaciones y actuar en consonancia.</p>
<p>Pero lo que realmente ocurre es que la estructura del gr&aacute;fico se degrada. Conforme el equipo conoce m&aacute;s profundamente el sistema, y el cliente conoce sus propias necesidades reales, algunas tareas del gr&aacute;fico se convierten en innecesarias. Se descubrir&aacute;n nuevas tareas que se deber&aacute;n a&ntilde;adir. En resumen, la planificaci&oacute;n sufrir&aacute; cambios tanto en la forma como en las fechas.</p>
<p>Una mejor estrategia de planificaci&oacute;n es realizar planificaciones detalladas para las siguientes semanas, planificaciones menos detalladas para los siguientes meses, y planificaciones rudimentarias para las posteriores. Lo que debemos <em>saber</em> es lo que tenemos que hacer en las siguiente semanas. En cambio, debemos <em>conocer</em> los requisitos con los que trabajaremos en los siguiente meses, y por &uacute;ltimo, tener una <em>vaga idea</em> de lo que ser&aacute; el sistema dentro de un a&ntilde;o.</p>
<p>Esta resoluci&oacute;n descendiente de la planificaci&oacute;n significa que s&oacute;lo estamos invirtiendo esfuerzos en una planificaci&oacute;n detallada para aquellas tareas que son inmediatas. Una vez que la planificaci&oacute;n esta hecha, cambiarla se complica ya que el equipo tiene muchos compromisos y una velocidad adecuada. Pero como la planificacion solo gobierna el proyecto durante unas semanas, el resto del planning permance flexible. As&iacute; pues, la parte de planificaci&oacute;n que no esta detallada puede sufrir modificaciones con cierta facilidad.</p>
<a name="N10181"></a><a name="Los+Principios+%C3%81giles"></a>
<h3 class="underlined_5">Los Principios &Aacute;giles</h3>
<p>
Los valores anteriores inspiran los doce principios del manifiesto. Son caracter&iacute;sticas que diferencian un proceso &aacute;gil de uno tradicional. El objetivo de estos principios se divide en 2:</p>
<ol>
    
<li>Los principios se definen para ayudar a las personas a que comprendan mejor de que trata esto del desarrollo de software &aacute;gil.</li>
    
<li>Los principios se pueden utilizar para determinar si un desarrollador esta siguiendo una metodolog&iacute;a agil o no.</li>

</ol>
<p>Cabe destacar que estos principios no especifican un m&eacute;todo, sino que definen un conjunto de gu&iacute;as que cualquier enfoque que quiera estar bajo el paraguas "&aacute;gil" debe cumplir.</p>
<p>Los dos primeros principios son generales y resumen gran parte del esp&iacute;ritu &aacute;gil. El resto tienen que ver con el proceso a seguir y con el equipo de desarrollo, en cuanto metas a seguir y organizaci&oacute;n del mismo.
</p>
<ol>
	
<li>
<em>La prioridad absoluta es
	satisfacer al cliente cuanto antes mejor, y de forma continuada
	entregar software &uacute;til que le reporte valor.</em>
<br>
    Un proceso es &aacute;gil si a las pocas semanas de empezar ya entrega software que funcione aunque sea rudimentario. El cliente decide si pone en marcha dicho software con la funcionalidad que ahora le proporciona o simplemente lo revisa e informa de posibles cambios a realizar.
    </li>
	
<li>
<em>Apreciar los cambios de
	requisitos, incluso en fases tard&iacute;as del desarrollo. Los
	procesos &aacute;giles aprovechan los cambios para que el cliente
	tome ventaja competitiva.</em>
<br>
    Este principio es una actitud que deben adoptar los miembros del equipo de desarrollo. Los cambios en los requisitos deben verse como algo positivo. Les va a permitir aprender m&aacute;s, a la vez que logran una mayor satisfacci&oacute;n del cliente. Este principio implica adem&aacute;s que la estructura del software debe ser flexible para poder incorporar los cambios sin demasiado coste a&ntilde;adido. El paradigma orientado a objetos puede ayudar a conseguir esta flexibilidad.</li>
	
<li>
<em>Entregar frecuentemente software que funcione, desde un par
	de semanas a un par de meses, con el menor intervalo de tiempo
	posible entre una entrega y la siguiente</em>
<br>
    Las entregas al cliente se insiste en que sean software, no planificaciones, ni documentaci&oacute;n de an&aacute;lisis o de dise&ntilde;o.
    </li>
	
<li>
<em>La gente del negocio (el cliente) y los desarrolladores deben
	trabajar juntos a lo largo del proyecto</em>
<br>
    El proceso de desarrollo necesita ser guiado por el cliente, por lo que la interacci&oacute;n con el equipo es muy frecuente.
    </li>
	
<li>
<em>Construir proyectos en torno a individuos motivados. Darles
	el entorno y el apoyo que necesitan y confiar en ellos para
	conseguir el trabajo</em>
<br>
    La gente es el principal factor de &eacute;xito, todo los dem&aacute;s (proceso, entorno, gesti&oacute;n, etc.) queda en segundo plano. Si cualquiera de ellos tiene un efecto negativo sobre los individuos debe ser cambiado.
    </li>
	
<li>
<em>El di&aacute;logo cara a cara es el m&eacute;todo m&aacute;s
	eficiente y efectivo para comunicar informaci&oacute;n dentro de un
	equipo de desarrollo</em>
<br>
    Los miembros de equipo deben hablar entre ellos, &eacute;ste es el principal modo de comunicaci&oacute;n. Se pueden crear documentos pero no todo estar&aacute; en ellos, no es lo que el equipo espera.
    </li>
	
<li>
<em>La medida principal de progreso es el software que funciona</em>
<br>
    El estado de un proyecto no viene dado por la documentaci&oacute;n generada o la fase en la que se encuentre, sino por el  c&oacute;digo generado y en funcionamiento. Por ejemplo, un proyecto se encuentra al 50% si el 50% de los requisitos ya est&aacute;n en funcionamiento.
    </li>
	
<li>
<em>Los procesos &aacute;giles promueven un desarrollo
	sostenible. Los promotores, desarrolladores y usuarios deber&iacute;an
	ser capaces de mantener una paz constante</em>
<br>
    No se trata de desarrollar lo m&aacute;s r&aacute;pido posible, sino de mantener el ritmo de desarrollo durante toda la duraci&oacute;n del proyecto, asegurando en todo momento que la calidad de lo producido es m&aacute;xima. 
    </li>
	
<li>
<em>La atenci&oacute;n continua a la calidad t&eacute;cnica y al
	buen dise&ntilde;o aumentan la agilidad</em>
<br>
    Producir c&oacute;digo claro y robusto es la clave para avanzar m&aacute;s r&aacute;pidamente en el proyecto. 
    </li>
	
<li>
<em>La simplicidad (arte de maximizar la cantidad de trabajo no
	realizado) es esencial</em>
<br>
    Tomar los caminos m&aacute;s simples que sean consistentes con los objetivos perseguidos. Si el c&oacute;digo producido es simple y de alta calidad ser&aacute; m&aacute;s sencillo adaptarlo a los cambios que puedan surgir. 
    </li>
	
<li>
<em>Las mejores arquitecturas, requisitos y dise&ntilde;os surgen
	de los equipos de trabajo organizados por s&iacute; mismos</em>
<br>
    Todo el equipo es informado de las responsabilidades y &eacute;stas recaen sobre todos sus miembros. Es el propio equipo el que decide la mejor forma de organizarse, de acuerdo a los objetivos que se persigan.
    </li>
	
<li>
<em>En intervalos regulares, el equipo reflexiona respecto a c&oacute;mo
	llegar a ser m&aacute;s efectivo, y seg&uacute;n esto ajusta su
	comportamiento</em>
    
<br>
    Puesto que el entorno est&aacute; cambiando continuamente, el equipo tambi&eacute;n debe ajustarse al nuevo escenario de forma continua. Puede cambiar su organizaci&oacute;n, sus reglas, sus convenciones, sus relaciones, etc., para seguir siendo &aacute;gil.</li>

</ol>
<p>Algunos de estos principios pueden parecer obvios, mientras que otros m&aacute;s pol&eacute;micos. A simple vista, son bastante gen&eacute;ricos ("Apreciar los cambios"). Sin embargo, se han definido para guiar a las metodolog&iacute;as &aacute;giles, m&aacute;s que para ser realmente una metodolog&iacute;a por si solos. Por ejemplo, una metodologia agil deberia promover la entrega frecuente de sistemas que funcionan m&aacute;s que una gran entrega (tipo big bang). Un modo de interpretar esto es que un enfoque iterativo e incremental es mejor que el enfoque tradicional de cascada.</p>
<p>Por tanto, las metodolog&iacute;as &aacute;giles intentan concebir los m&eacute;todos que cambian:</p>
<ul>
    
<li>de procesos pesados a ligeros</li>
    
<li>de objetivos orientados a documento a orientados al c&oacute;digo</li>
    
<li>de m&eacute;todos predictivos a adaptativos</li>
    
<li>de actividades orientadas al proceso a orientadas a las personas.</li>

</ul>
</div>


<a name="N101FC"></a><a name="Conceptos+%C3%81giles"></a>
<h2 class="underlined_10">Conceptos &Aacute;giles</h2>
<div class="section">
<p>Todas las metodolog&iacute;as &aacute;giles compartes una serie de conceptos y/o t&eacute;cnicas que se repiten o utilizan en m&aacute;s de una metodolog&iacute;a. Queremos destacar:</p>
<ul>
    
<li>
<p>
<strong>Abrazar los Cambios</strong>: hay que afrontar los cambios como aliados, y no como enemigos, ya que los cambios permiten mayor creatividad y aportan valor al negocio m&aacute;s r&aacute;pidamente.</p>
</li>
    
<li>
<p>
<strong>Entregas Frecuentes</strong>: para realizar entregas frucuentes, debemos planificar muchas entregas con periodos cortos. De este modo, vamos a forzar la implementaci&oacute;n temprana de las funciones de mayor prioridad, entregando valor al cliente r&aacute;pidamente y provocando que los requisitos salgan a la superficie de un modo continuo.</p>
</li>
    
<li>
<p>
<strong>Dise&ntilde;o Simple</strong>: partiendo de la premisa anterior de que la simplicidad es el arte de minimizar el trabajo, debemos dise&ntilde;ar para la batalla, no para la guerra. Muchas veces realizamos sobreingeniera y complicamos un problema el cual es sencillo, o nos dedicamos a resolver un problema que no es el actualmente desarrollado. As&iacute; pues denemos tener presente principios como:</p>
    
<ul>
    
<li>Principio <strong>KISS</strong> (<em>Keep It Simple, Stupid</em>) - <a class="external" href="http://es.wikipedia.org/wiki/Principio_KISS">Wikipedia</a>
</li>
    
<li>Principio <strong>YAGNI</strong> (<em>You Aren't Going to Need It</em>) - <a class="external" href="http://es.wikipedia.org/wiki/No_vas_a_necesitarlo_%28YAGNI%29">Wikipedia</a>
</li>
    
</ul>
    
<p>Todo esto sin perder de vista que los cambios son inevitables, y que planificar para funcionalidades futuras es malgastar esfuerzos.</p>
</li>
    
<li>
<p>
<strong>Refactorizaci&oacute;n</strong>: consiste en eestructurar el software para eliminar la duplicaci&oacute;n de c&oacute;digo, mejorar la comunicaci&oacute;n, simplificar el c&oacute;digo, y a&ntilde;adir flexibilidad sin modificar el comportamiento. Los IDEs actuales ofrecen diferentes tipos de refactorizaciones que nos permiten simplificar continuamente el dise&ntilde;o, redise&ntilde;ando en caliente. El principio a tener en mente es:</p>
    
<ul>
<li>Principio <strong>DRY</strong> (<em>Don't Repeat Yourself</em>) - <a class="external" href="http://es.wikipedia.org/wiki/DRY">Wikipedia</a>
</li>
</ul>
    
</li>
    
<li>
<p>
<strong>Desarrollo Dirigido por las Pruebas (TDD)</strong>: tambien conocido como <em>Test-First</em>, consiste en los siguientes pasos:</p>
    
<ol>
    
<li>Codificar la prueba</li>
    
<li>Codificar la implementaci&oacute;n</li>
    
<li>Ejecutar la prueba</li>
    
</ol>
    
<p>De este modo, todos los m&oacute;dulo van a ser probados, y enfocamos el dise&ntilde;o de cada m&eacute;todo como una caja negra, entradas y salidas, para posteriormente centrarnos en la implementaci&oacute;n.</p>
    
<p>Las pruebas de los m&oacute;dulos y de los m&eacute;todos se realizan incrementalmente por los desarrolladores y los clientes antes y durante la codificaci&oacute;n.</p>
</li>
    
<li>
<p>
<strong>Programaci&oacute;n en Parejas</strong>: 2 programadores trabajan codo con codo en un ordenador, compartiendo el teclado. Esto exige una colaboraci&oacute;n continua en el mismo dise&ntilde;o, algoritmo, codificaci&oacute;n y pruebas.</p>
</li>
    
<li>
<p>
<strong>Conocimiento T&aacute;cito</strong>: la agilidad se consigue estableciendo y actualizando el conocimiento del proyecto en las cabezas de los participantes, no en papel. As&iacute;, se evitan los documentos innecesarios (conocimiento explicito)</p>
</li>
    
<li>
<p>
<strong>Retrospectiva</strong>: se trata de una reuni&oacute;n post-iteraci&oacute;n para evaluar la efectividad del trabajo realizado (qu&eacute; fue bien y qu&eacute; fue mal), m&eacute;todos utilizados, y estimaciones. Esta pr&aacute;ctica fomenta el aprendizaje y mejora las estimaciones para futuras iteraciones</p>
</li>

</ul>
<p>Entraremos en detalle en algunos de estos conceptos conceptos en las posteriores sesiones de <em>Programaci&oacute;n eXtrema</em> y <em>Pr&aacute;cticas &Aacute;giles</em>.</p>
</div>


<a name="N10283"></a><a name="Entorno+%C3%81gil"></a>
<h2 class="underlined_10">Entorno &Aacute;gil</h2>
<div class="section">
<p>El entorno del proyecto incluye el espacio f&iacute;sico y las herramientas software utilizadas por los desarrolladores.</p>
<p>Entre las pr&aacute;cticas utilizadas dentro de un entorno &aacute;gil debemos destacar:</p>
<ul>
    
<li>
<p>
<strong>Integraciones Continuas</strong>: Consiste en la continua integracion (CI) 24/7 de todo el c&oacute;digo fuente del sistema. En cuanto un cambio se sube al gestor de versiones, se construye el sistema, se despliega sobre el servidor y se ejecutan las pruebas.
    </p>
    
<p>En el caso de que las pruebas fallen, se pueden realizar diversas acciones, como enviar mails al arquitecto y al &uacute;ltimo desarrollador que ha subido el cambio al sistema. Dentro de un proyecto Java, la media de construccion es de 15 a 30 minutos. Esta pr&aacute;ctica nos asegura que nuestro sistema integra los cambios cuanto antes.</p>
    
<p>En la cuarta sesi&oacute;n de este m&oacute;dulo estudiaremos la herramienta <a class="external" href="http://cruisecontrol.sourceforge.net/">CruiseControl</a>.</p>
    
</li>
    
<li>
<p>
<strong>Wikis de Proyecto</strong>: El uso de wikis permite a los desarrolladores tener un respositorio compartido de conocimiento y facilitar la comunicaci&oacute;n de actividades y tareas. Tenemos versiones sencillas como <a class="external" href="http://www.usemod.com">Usemod</a> o m&aacute;s completas como <a class="external" href="http://www.xwiki.org/">XWiki</a> o <a class="external" href="http://www.twiki.org">TWiki</a>.</p>
</li>
    
<li>
<p>
<strong>Herramientas CASE e Ingenieria Inversa</strong>: Las herramientas CASE que soportan UML ofrecen Ingenieria Directa, mediante la generaci&oacute;n de codigo a partir de los diagrams, e Ingenieria Inversa, con la generaci&oacute;n de diagramas a partir del codigo.</p>
    
<p>Dentro de los proyecto &aacute;giles, las herramientas CASE se utilizan casi exclusivamente para la ingenieria inversa, ofreciendo mecanimos visuales para la comunicaci&oacute;n entre los integrantes del equipo.</p>
    
<p>Las herramientas comerciales m&aacute;s utilizas son <a class="external" href="http://www.borland.com/us/products/together/index.html">Borland Together</a> y <a class="external" href="http://www-306.ibm.com/software/awdtools/architect/swarchitect/index.html">Rational Software Architect</a>; mixtas/gratuitas tenemos <a class="external" href="http://www.omondo.com/">Omondo</a> y <a class="external" href="http://www.gentleware.com/">Poseidon UML</a> y <a class="external" href="http://www.staruml.com/">StarUML</a>.</p>
</li>
    
<li>
<a name="habitacionComun"></a>
<p>
<strong>Habitaci&oacute;n Com&uacute;n</strong>: Todos los desarrollades del equipo deben compartir una sala com&uacute;n, para que se produzca una comunicaci&oacute;n directa entre los integrantes. Para preservar la intimidad, pueden existir espacios privados separados que los desarrolladores pueden utilizar durante las tareas no relacionadas con el desarrollo.</p>
    
<p>Adem&aacute;s, es aconsejable situar la mesas en el centro de la sala, para dejar las paredes libres</p>
    
<p>
    
<br>
    
<img alt="Habitaci&oacute;n Com&uacute;n con Paredes Limpias" content-width="12cm" src="imagenes/s1/room.jpg" width="500">
    <br>
    
</p>
    
</li>
    
<li>
<p>
<strong>Paredes por Pizarras</strong>: El modelado &aacute;gil promueve utilizar pizarras belleda y para ello, necesitamos utilizar todo el espacio disponible (podemos situar las mesas en el centro de la sala). Mediante las pizarras y rotuladores de pizarra, las paredes se convierten en otro mecanismo de comunicaci&oacute;n.</p>
</li>
    
<li>
<p>
<strong>Camaras Digitales y Proyectores</strong>: Agilidad es sinonimo de velocidad, simplicidad y claridad. En vez de tener de tomar notas de los modelos diagramados en las paredes, una simple fotografia captura toda la informaci&oacute;n y nos permite imprimirla o publicarla en nuestro wiki.</p>
    
<p>Adem&aacute;s, el uso de proyectores donde visualizar las fotografias previas y los diagramas obtenidos por ingenieria inversa tambi&eacute;n facilitan el trabajo.</p>
</li>

</ul>
<p>Podemos ver ejemplos de entornos agiles en</p>
<ul>
    
<li>
<a class="external" href="http://www.scissor.com/resources/teamroom/">http://www.scissor.com/resources/teamroom/</a>
</li>
    
<li>
<a class="external" href="http://xp123.com/xplor/room-gallery/index.shtml">http://xp123.com/xplor/room-gallery/index.shtml</a>
</li>

</ul>
<p>En resumen, un entorno &aacute;gil se pueden resumir en el siguiente gr&aacute;fico:</p>
<p>
    
<img alt="Ejemplo de Sala &Aacute;gil" content-width="12cm" src="imagenes/s1/ejemploSala.gif" width="512">
</p>
</div>


<a name="N1031A"></a><a name="Metodolog%C3%ADa+%C3%81giles"></a>
<h2 class="underlined_10">Metodolog&iacute;a &Aacute;giles</h2>
<div class="section">
<a name="N10320"></a><a name="En+Resumen"></a>
<h3 class="underlined_5">En Resumen</h3>
<p>El aspecto comun de todas las metodologias &aacute;giles es que se centran en intentar producir una soluci&oacute;n que funcione y que sea capaz de responder a los cambios de los requisitos de los usuarios/clientes.</p>
<p>Por supuesto, las metodologias tradicionales tambien intentan desarrollar soluciones que funcione, pero su atencion a los requerimientos cambiantes donde yace la principal diferencia.</p>
<p>En un metodo &aacute;gil se consideran fijos el tiempo disponible y los recursos disponibles, mientras que la funcionalidad a implementar se considera flexible. El objetivo es fijar una fecha de entrega en el cual se entrega software que funciona y priorizar las funcionalidades que deben implementarse  de modo que se implemente lo que se pueda implementa, pero aceptando que no se va a poder entregar todo. En contraste, muchos proyectos software se han alargado porque la gesti&oacute;n ha considerado la funcionalidad fija pero el tiempo y los recursos disponibles variables.
</p>
<p>Por supuesto, existen situaciones donde se tiene que entregar toda la funcionalidad, pero en la mayor&iacute;a de los casos, la funcionalidad varia entre la que debe hacerse, la que estaria bien hacerla, y la que puede llegar a ser util y que nunca se va a utilizar en realidad. Por esto, priorizar estas funcionalidades puede resultar en una soluci&oacute;n m&aacute;s efectiva la cual se entrega a tiempo y dentro del presupuesto.</p>
<p>Por ejemplo, un supuesto fundamental de DSDM (M&eacute;todo de Desarrollo de Sistemas Din&aacute;micos) es que nada se desarrolla a la perfecci&oacute;n la primera vez, pero que un 80% del sistema propuesto que sea &uacute;til y usable puede ser desarrollado en un 20% del tiempo que tomar&iacute;a llevar a cabo una soluci&oacute;n total perfecta. Esto implica que el 20% restante puede no llegar a utilizarse nunca, o en el peor de lo casos, requerirse en entregas posteriores.
</p>
<p>Esto se logra manteniendo el foco del proyecto en las necesidades establecidas y no en las posibilidades percibidas. El criterio fundamental para decidir la aceptaci&oacute;n de los entregables es la adecuaci&oacute;n de los mismos a los objetivos de negocio.</p>
<p>A continuaci&oacute;n de describen las diferentes metodolog&iacute;as &aacute;giles que actualmente existen. Destacar que la metodolog&iacute;a de Programaci&oacute;n eXtrema (XP) se estudiar&aacute; en profundidad en la siguiente sesi&oacute;n.</p>
<a name="N1033C"></a><a name="Scrum"></a>
<h3 class="underlined_5">Scrum</h3>
<p>Desarrollada por <em>Ken Schwaber</em>, <em>Jeff Sutherland</em> y <em>Mike Beedle</em>. El t&eacute;rmino <em>Scrum</em> viene del rugby, donde significa un esfuerzo de equipo para puntuar.</p>
<p>Define un marco para la gesti&oacute;n de proyectos promoviendo los equipos auto-organizados y auto-dirigidos, con m&eacute;tricas de equipo diarias, y evitando la definici&oacute;n de pasos preestablecidos. Est&aacute; especialmente indicada para proyectos con un r&aacute;pido cambio de requisitos.</p>
<p>Sus principales caracter&iacute;sticas se pueden resumir en:</p>
<ul>

<li>Un <strong>Scrum Master</strong> actua como entrenador, eliminando las distracciones y facilitando el trabajo del equipo.</li>

<li>Desarrollo de software mediante iteraciones de 30 dias, denominadas <strong>Sprints</strong>. No se puede a&ntilde;adir trabajo a mitad de iteraci&oacute;n. El resultado de cada sprint es un incremento ejecutable que se muestra al cliente.</li>

<li>Reuni&oacute;n diaria de 15 minutos, denominada <strong>Scrum</strong>, del equipo de desarrollo, desarrollada de pie y en circulo, para coordinar e integrar el trabajo del dia a dia, as&iacute; como comunicar los problemas encontrados.</li>

</ul>
<p>M&aacute;s informaci&oacute;n en <a class="external" href="http://www.controlchaos.com">www.controlchaos.com</a>
</p>
<a name="N10373"></a><a name="Desarrollo+de+Software+Adaptativo+%28ASD%29"></a>
<h3 class="underlined_5">Desarrollo de Software Adaptativo (ASD)</h3>
<p>Impulsado por Jim Highsmith, destaca el principio de que la adaptaci&oacute;n continua del trabajo recien hecho es normal.</p>
<p>El ciclo de vida que propone tiene tres fases repetitivas en ciclos:</p>
<ol>

<li>
<em>Especulaci&oacute;n</em>: se inicia el proyecto y se planifican las caracter&iacute;sticas del software.</li>

<li>
<em>Colaboraci&oacute;n</em>: se desarrollan las caracter&iacute;sticas.</li>

<li>
<em>Aprendizaje</em>: se revisa su calidad, y se entrega al cliente. La revisi&oacute;n de los componentes sirve para aprender de los errores y volver a iniciar el ciclo de desarrollo.</li>

</ol>
<p>Sus principales caracter&iacute;sticas son que est&aacute; centrado en la misi&oacute;n, basado en caracteristicas, iterativo, timeboxed, dirigido por los riesgos y tolerante a los cambios.</p>
<p>M&aacute;s informaci&oacute;n en <a class="external" href="http://www.adaptivesd.com">www.adaptivesd.com</a>
</p>
<a name="N1039B"></a><a name="Lean+Development+%28LD%29"></a>
<h3 class="underlined_5">Lean Development (LD)</h3>
<p>Definida por Bob Charette a partir de su experiencia en proyectos dentro del &aacute;rea de gesti&oacute;n de riesgos, y los principios y visi&oacute;n de los conceptos de <a class="external" href="http://es.wikipedia.org/wiki/Lean_Manufacturing">manufacturaci&oacute;n de lean</a> (sin grasa).</p>
<p>En LD, los cambios se consideran riesgos, pero si se manejan adecuadamente se pueden convertir en oportunidades que mejoren la productividad del cliente. Su principal caracter&iacute;stica es introducir un mecanismo para implementar dicha tolerancia a los cambios.</p>
<p>LD enfatiza la satisfacci&oacute;n del cliente, promoviendo la reversibilidad del proyecto, ofreciendo valor al negocio, y creando una soluci&oacute;n m&iacute;nima pero esencial desde el inicio. Anima a centrarse en completar el proyecto m&aacute;s que construirlo (comprar en vez de construir, si se puede).</p>
<p>Otra caracter&iacute;stica de LD es que no se limita &uacute;nicamente al equipo de desarrollo, sino tambi&eacute;n involucra a todo el personal relacionado con el producto, como gestores. LD es m&aacute;s una estrategia de negocio y gesti&oacute;n de proyectos que un proceso de desarrollo, ya que no especifica practicas, pol&iacute;ticas o guias de desarrollo.</p>
<p>M&aacute;s informaci&oacute;n en <a class="external" href="http://www.poppendieck.com">www.poppendieck.com</a>
</p>
<a name="N103B8"></a><a name="Metodolog%C3%ADas+Crystal"></a>
<h3 class="underlined_5">Metodolog&iacute;as Crystal</h3>
<p>Se trata de un conjunto de metodolog&iacute;as &aacute;giles desarrolladas por <em>Alistair Cockburn</em> que trata los diferentes entornos y caracter&iacute;sticas especificas de cada proyecto. Pese a aceptar la necesidad de un ciclo de vida iterativo, destaca el desarrollo de software como <strong>peopleware</strong>, centrado en las personas que componen el equipo (de ellas depende el &eacute;xito del proyecto) y la reducci&oacute;n al m&aacute;ximo del n&uacute;mero de artefactos producidos, promoviendo la comunicaci&oacute;n.</p>
<p>El desarrollo de software se considera un juego cooperativo de invenci&oacute;n y comunicaci&oacute;n, limitado por los recursos a utilizar. El equipo de desarrollo es un factor clave, por lo que se deben invertir esfuerzos en mejorar sus habilidades y destrezas, as&iacute; como definir pol&iacute;ticas de trabajo en equipo.</p>
<p>Crystal fomenta que los equipos reflexionen, critiquen y solucionen, mediante comunicaciones abiertas, promoviendo la honestidad y la critica constructiva. Reconoce que la retroalimentaci&oacute;n es esencial.</p>
<p>Las diferentes versiones de Crystal se nombran con colores (<em>Clear</em>, <em>Yellow</em>, <em>Orange</em>, <em>Red</em>) para denotar el n&uacute;mero de personas implicadas y la criticidad de los fallos en t&eacute;rminos de p&eacute;rdidas (<em>Comfort</em>, <em>Discretionary Money</em>, Essential Money, y <em>Life</em>). Los colores son una met&aacute;fora, indicando que debemos empezar por los colores claros e ir pasando a los oscuros cuando el proyecto muestra signos  o riesgos significativos.</p>
<p>M&aacute;s informaci&oacute;n en <a class="external" href="http://alistair.cockburn.us">alistair.cockburn.us</a> y <a class="external" href="http://www.crystalmethodologies.org">www.crystalmethodologies.org</a>
</p>
<a name="N103F0"></a><a name="M%C3%A9todo+de+Desarrollo+de+Sistemas+Din%C3%A1mico+%28DSDM%29"></a>
<h3 class="underlined_5">M&eacute;todo de Desarrollo de Sistemas Din&aacute;mico (DSDM)</h3>
<p>Define el marco para desarrollar un proceso de producci&oacute;n de software. Nace en 1994 con el objetivo el objetivo de crear una metodolog&iacute;a RAD unificada, siendo un proceso iterativo e incremental, donde el equipo de desarrollo y el usuario deben trabajar juntos.</p>
<p>Propone cinco fases: estudio viabilidad (<em>feasibility</em>), estudio del negocio, modelado funcional, dise&ntilde;o y construcci&oacute;n, y finalmente implementaci&oacute;n. Las dos primeras fases son secuenciales, y sus resultados van a a informar a las tres &uacute;ltimas fases, las cuales son iterativas e incrementales.</p>
<p>El ciclo de vida DSDM hace un gran &eacute;nfasis en las actividades de gesti&oacute;n de proyectos:</p>
<ul>

<li>La planificaci&oacute;n es necesaria en cada fase, conforme el plan evoluciona basado en los incrementos y sus resultados.</li>

<li>Se realizan planificaciones con contenidos detallados.</li>

<li>Las iteraciones son timeboxed, siendo el principal modo de planificar, monitorizar y controlar el proyecto.</li>

<li>El calendario y los costes se mantienen constantes, siendo variable la cantidad de requisitos a implementar.</li>

<li>Los requisitos se priorizan con la t&eacute;cnica <strong>MoSCoW</strong> (<em>Must Have, Should Have, Could Have, Want</em>).</li>

</ul>
<p>M&aacute;s informaci&oacute;n en <a class="external" href="http://dsdm.org">dsdm.org</a>
</p>
<a name="N10421"></a><a name="Proceso+Unificado+%28UP%29"></a>
<h3 class="underlined_5">Proceso Unificado (UP)</h3>
<p>Refinado a partir de la metodolog&iacute;a RUP, ofrece una visi&oacute;n reducida, donde destaca:</p>
<ul>

<li>Iteraciones cortas y timeboxed</li>

<li>Desarrollo de los elementos con mayor riesgo y mayor valor en las primeras iteraciones, prefiriendo la reutilizaci&oacute;n de componentes existentes</li>

<li>Asegurar que se entrega valor al cliente</li>

<li>Afrontar los cambios desde el principio del proyecto</li>

<li>Trabajar juntos como un equipo</li>

</ul>
<p>Las iteraciones de UP, al igual que RUP, se agrupan en 4 fases: inicio, elaboraci&oacute;n (implementando los elementos de mayor riesgo y la arquitectura de la aplicaci&oacute;n), construcci&oacute;n y transici&oacute;n.</p>
<p>M&aacute;s informaci&oacute;n en <a class="external" href="http://en.wikipedia.org/wiki/Unified_Process">en.wikipedia.org/wiki/Unified_Process</a> y <a class="external" href="http://www.ambysoft.com/unifiedprocess">www.ambysoft.com/unifiedprocess</a>.
</p>
<a name="N1044B"></a><a name="Feature-Driven+Development+%28FDD%29"></a>
<h3 class="underlined_5">Feature-Driven Development (FDD)</h3>
<p>Se centra en un proceso sencillo, modelado eficiente, e iteraciones cortas (2 semanas) que ofrecen valor al cliente. Nace de las experiencias de Jeff De Luca y Peter Coad en el desarrollo de una compleja aplicaci&oacute;n comercial. El objetivo central es que el proceso de fondo sea un soporte m&aacute;s que una obligaci&oacute;n.</p>
<p>Se centra en las fases de dise&ntilde;o e implementaci&oacute;n del sistema partiendo del listado de requisitos, los cuales ya deben estar capturados y comprendidos.</p>
<p>M&aacute;s informaci&oacute;n en <a class="external" href="http://www.featuredrivendevelopment.com">www.featuredrivendevelopment.com</a> y <a class="external" href="http://www.nebulon.com/fdd">www.nebulon.com/fdd</a>.
</p>
</div>


<a name="N10464"></a><a name="Metodolog%C3%ADas+%C3%81giles+vs+Orientadas+a+la+Planificaci%C3%B3n"></a>
<h2 class="underlined_10">Metodolog&iacute;as &Aacute;giles vs Orientadas a la Planificaci&oacute;n</h2>
<div class="section">
<p>Antes de nada, destacar que los m&eacute;todos &aacute;giles son un subconjunto de los m&eacute;todos iterativos, por lo tanto estamos comparando las metodolog&iacute;as &aacute;giles e iterativas respecto a aquellas metodolog&iacute;as que basan sus esfuerzos en el seguimiento estricto de una planificaci&oacute;n, ya sea mediante un modelo en cascada o no.
</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>
    
<th colspan="1" rowspan="1"></th>
    <th colspan="1" rowspan="1">&Aacute;gil</th>
	<th colspan="1" rowspan="1">Tradicional</th>

</tr>

<tr>
    
<th colspan="3" rowspan="1">Caracter&iacute;sticas de Aplicaci&oacute;n</th>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Objetivos Principales</th>
    <td colspan="1" rowspan="1">Obtener valor r&aacute;pida y continuamente, responder al cambio</td>
    <td colspan="1" rowspan="1">Alta seguridad, predecible, repetible, optimizable</td>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Tama&ntilde;o</th>
    <td colspan="1" rowspan="1">Equipo y proyecto peque&ntilde;o/mediano</td>
    <td colspan="1" rowspan="1">Equipo y proyecto grande</td>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Entorno</th>
    <td colspan="1" rowspan="1">Turbulentos, alta tasa de cambios, foco en el proyecto</td>
    <td colspan="1" rowspan="1">Estables, pocos cambios, foco en proyecto y organizaci&oacute;n
</td>

</tr>

<tr>
    
<th colspan="3" rowspan="1">Caracter&iacute;sticas de Gesti&oacute;n</th>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Relaci&oacute;n con el Cliente</th>
    <td colspan="1" rowspan="1">Clientes in situ, dedicados al proyecto y centrado en priorizar requisitos</td>
    <td colspan="1" rowspan="1">Participaci&oacute;n del cliente s&oacute;lo cuando se necesita y centrado en el contrato</td>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Planificaci&oacute;n y Control</th>
    <td colspan="1" rowspan="1">La planificaci&oacute;n es un medio para llegar al fin. Control cualitativo</td>
    <td colspan="1" rowspan="1">Planificaci&oacute;n para comunicar y coordinar. Control cuantitativo</td>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Comunicaci&oacute;n</th>
    <td colspan="1" rowspan="1">Conocimiento t&aacute;cito e interpersonal</td>
    <td colspan="1" rowspan="1">Conocimiento expl&iacute;cito y documentado</td>

</tr>

<tr>
    
<th colspan="3" rowspan="1">Caracter&iacute;sticas T&eacute;cnicas</th>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Requisitos</th>
    <td colspan="1" rowspan="1">Historias informales y casos de prueba priorizados (valor + riesgo). Con cambios no predecibles</td>
    <td colspan="1" rowspan="1">Especificaciones formales y completas bajo control de cambios. Requisitos no funcionales</td>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Desarrollo</th>
    <td colspan="1" rowspan="1">Dise&ntilde;o simple / YAGNI. Incrementos cortos. Refactorizaci&oacute;n barata</td>
    <td colspan="1" rowspan="1">Arquitectura para anticipar cambios. Incrementos mayores. Refactorizaci&oacute;n cara.</td>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Pruebas</th>
    <td colspan="1" rowspan="1">Pruebas antes de codificar. Incrementales. Casos de prueba ejecutables definen requerimientos </td>
    <td colspan="1" rowspan="1">Plan y procedimientos de prueba a partir de las especificaciones</td>

</tr>

<tr>
    
<th colspan="3" rowspan="1">Caracter&iacute;sticas Personales</th>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Cliente</th>
    <td colspan="1" rowspan="1">Dedicados y en el lugar. CRACK (<em>collaborative, representative, authorized, committed, knowledgeable</em>)</td>
    <td colspan="1" rowspan="1">CRACK sin fulltime</td>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Desarrollador</th>
    <td colspan="1" rowspan="1">Habilidades t&eacute;cnicas y sociales. Alto porcentaje de senior, el resto semi-senior</td>
    <td colspan="1" rowspan="1">Perfiles menos talentosos. Alto porcentaje de senior al inicio, despu&eacute;s perfiles distribuidos</td>

</tr>

<tr>
    
<th colspan="1" rowspan="1">Cultura</th>
    <td colspan="1" rowspan="1">Reconocimiento a trav&eacute;s de libertad y autonom&iacute;a</td>
    <td colspan="1" rowspan="1">Reconocimiento con pol&iacute;ticas claras y procedimientos de roles</td>

</tr>


</table>
<p>&nbsp;</p>
</div>


<a name="N10586"></a><a name="Roadmap"></a>
<h2 class="underlined_10">Roadmap</h2>
<div class="section">
<a name="N1058C"></a><a name="Puntos+Destacados"></a>
<h3 class="underlined_5">Puntos Destacados</h3>
<ul>
	
<li>El desarrollo iterativo es bajo en riesgos mientras que el
	modelo en cascada es alto.</li>
	
<li>Descubrimiento y alivio de los riesgos de forma temprana</li>
	
<li>Acomoda y provoca el cambio al inicio del proyecto</li>
	
<li>Gestiona la complejidad</li>
	
<li>Confianza y satisfacci&oacute;n desde el principio, &eacute;xito
	repetido.</li>
	
<li>Producto parcial desde el inicio.</li>
	
<li>Seguimiento del progreso relevante, lo que conlleva una mejor
	predecibilidad.</li>
	
<li>M&aacute;s calidad, menos incidencias</li>
	
<li>El producto final encaja mejor en los deseos del cliente</li>
	
<li>Mejora del proceso de forma temprana y regular</li>
	
<li>Obligada comunicaci&oacute;n y compromiso.</li>
	
<li>"Lo sabr&eacute; cuando lo vea"
	</li> 

</ul>
<a name="N105BA"></a><a name="Para+Saber+M%C3%A1s"></a>
<h3 class="underlined_5">Para Saber M&aacute;s</h3>
<a name="N105C0"></a><a name="Bibliograf%C3%ADa"></a>
<h4>Bibliograf&iacute;a</h4>
<p>A nivel general, los libros "cl&aacute;sicos" del movimiento &aacute;gil son</p>
<ul>

<li>
<strong>Agile &amp; Iterative Development. A Manager's Guide</strong>, de <em>Craig Larman</em>. Un buen libro para introducirse en el mundo &aacute;gil, donde se justifica la necesidad de estas metodologias.</li>

<li>
<strong>Agile Software Development. Principles, Patters, and Practices</strong> de <em>Robert C. Martin</em>, uno de los integrantes de la Alianza &Aacute;gil. En este libro adem&aacute;s de una introducci&oacute;n al Movimiento &Aacute;gil, describe el uso de patrones de dise&ntilde;o que agilizan el desarrollo de software.</li> 

<li>
<strong>Balancing Agility and Discipline. A Guide for the Perplexed</strong>, de <em>Barry Bohem</em> y <em>Richard Turner</em>. Este libro ofrece una guia de como equilibrar las metodologias agiles con las orientadas a la planificaci&oacute;n.</li>

</ul>
<a name="N105E8"></a><a name="Enlaces"></a>
<h4>Enlaces</h4>
<ul>

<li>Articulo de MSDN en castellano <a class="external" href="http://www.microsoft.com/spanish/msdn/arquitectura/roadmap_arq/heterodox.asp">http://www.microsoft.com/spanish/msdn/arquitectura/roadmap_arq/heterodox.asp</a>
</li>

<li>Entrada de la Wikipedia (ingl&eacute;s) <a class="external" href="http://en.wikipedia.org/wiki/Agile_software_development">http://en.wikipedia.org/wiki/Agile_software_development</a>
</li>

</ul>
</div>



<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006-2007 Depto. CCIA</div>
</div>
</body>
</html>
