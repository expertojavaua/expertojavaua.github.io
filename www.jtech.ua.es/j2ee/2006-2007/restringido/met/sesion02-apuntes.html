<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Programaci&oacute;n eXtrema</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario en Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Metodologias de Desarrollo" src="images/baner_j2ee_der.gif" title="Metodologias de Desarrollo"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Metodolog&iacute;as de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Metodolog&iacute;as de Desarrollo</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Metodolog&iacute;as de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html" title="Sesi&oacute;n 1: Metodolog&iacute;as &Aacute;giles">Sesi&oacute;n 1</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 2</div>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html" title="Sesi&oacute;n 3: Modelado &Aacute;gil">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html" title="Sesi&oacute;n 4: Pr&aacute;cticas &Aacute;giles">Sesi&oacute;n 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion02-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Programaci&oacute;n eXtrema</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n">Introducci&oacute;n</a>
</li>
<li>
<a href="#Valores">Valores</a>
<ul class="minitoc">
<li>
<a href="#Comunicaci%C3%B3n">Comunicaci&oacute;n</a>
</li>
<li>
<a href="#Simplicidad">Simplicidad</a>
</li>
<li>
<a href="#Retroalimentaci%C3%B3n">Retroalimentaci&oacute;n</a>
</li>
<li>
<a href="#Coraje">Coraje</a>
</li>
</ul>
</li>
<li>
<a href="#Resultados+XP">Resultados XP</a>
<ul class="minitoc">
<li>
<a href="#Las+Historias+de+Usuario">Las Historias de Usuario</a>
</li>
<li>
<a href="#Tarjetas+CRC">Tarjetas CRC</a>
</li>
</ul>
</li>
<li>
<a href="#Pr%C3%A1cticas+XP">Pr&aacute;cticas XP</a>
<ul class="minitoc">
<li>
<a href="#El+Juego+de+la+Planificaci%C3%B3n">El Juego de la Planificaci&oacute;n</a>
<ul class="minitoc">
<li>
<a href="#El+Juego+en+Detalle">El Juego en Detalle</a>
</li>
<li>
<a href="#Exploraci%C3%B3n">Exploraci&oacute;n</a>
</li>
<li>
<a href="#Compromiso">Compromiso</a>
</li>
<li>
<a href="#Ajuste">Ajuste</a>
</li>
</ul>
</li>
<li>
<a href="#Entregas+Peque%C3%B1as">Entregas Peque&ntilde;as</a>
</li>
<li>
<a href="#Dise%C3%B1o+Simple">Dise&ntilde;o Simple</a>
</li>
<li>
<a href="#Desarrollo+Dirigido+por+las+Pruebas">Desarrollo Dirigido por las Pruebas</a>
<ul class="minitoc">
<li>
<a href="#Pruebas+Unitarias">Pruebas Unitarias</a>
</li>
<li>
<a href="#Pruebas+de+Aceptaci%C3%B3n">Pruebas de Aceptaci&oacute;n</a>
</li>
</ul>
</li>
<li>
<a href="#Refactorizaci%C3%B3n">Refactorizaci&oacute;n</a>
</li>
<li>
<a href="#Programaci%C3%B3n+en+Parejas">Programaci&oacute;n en Parejas</a>
</li>
<li>
<a href="#Propiedad+Colectiva+del+C%C3%B3digo">Propiedad Colectiva del C&oacute;digo</a>
</li>
<li>
<a href="#Integraciones+Continuas">Integraciones Continuas</a>
</li>
<li>
<a href="#Cliente+In-Situ">Cliente In-Situ</a>
</li>
<li>
<a href="#Est%C3%A1ndares+de+Programaci%C3%B3n">Est&aacute;ndares de Programaci&oacute;n</a>
</li>
<li>
<a href="#40+Horas+Por+Semana">40 Horas Por Semana</a>
</li>
<li>
<a href="#Met%C3%A1fora">Met&aacute;fora</a>
</li>
<li>
<a href="#Comentarios+respecto+de+las+pr%C3%A1cticas">Comentarios respecto de las pr&aacute;cticas</a>
</li>
<li>
<a href="#%C2%BFQu%C3%A9+hay+de+eXtremo+en+la+Programaci%C3%B3n+eXtrema%3F">&iquest;Qu&eacute; hay de eXtremo en la Programaci&oacute;n eXtrema?</a>
</li>
</ul>
</li>
<li>
<a href="#Proceso+XP">Proceso XP</a>
<ul class="minitoc">
<li>
<a href="#Planificando+Proyectos+XP">Planificando Proyectos XP</a>
</li>
<li>
<a href="#El+Juego+de+Planificaci%C3%B3n+Inicial">El Juego de Planificaci&oacute;n Inicial</a>
</li>
<li>
<a href="#El+Juego+de+Planificaci%C3%B3n+de+Entrega">El Juego de Planificaci&oacute;n de Entrega</a>
</li>
<li>
<a href="#El+Proceso+de+Elaboraci%C3%B3n">El Proceso de Elaboraci&oacute;n</a>
</li>
<li>
<a href="#Planificaci%C3%B3n+de+la+Iteraci%C3%B3n">Planificaci&oacute;n de la Iteraci&oacute;n</a>
</li>
</ul>
</li>
<li>
<a href="#Roles+XP">Roles XP</a>
</li>
<li>
<a href="#Para+Saber+M%C3%A1s">Para Saber M&aacute;s</a>
<ul class="minitoc">
<li>
<a href="#Bibliograf%C3%ADa">Bibliograf&iacute;a</a>
</li>
<li>
<a href="#Enlaces">Enlaces</a>
</li>
</ul>
</li>
</ul>
</div>



<a name="xp"></a>
<a name="N10011"></a><a name="Introducci%C3%B3n"></a>
<h2 class="underlined_10">Introducci&oacute;n</h2>
<div class="section">
<p>XP (eXtreme Programming) es una metodolog&iacute;a &aacute;gil, fundada por <em>Kent Beck</em>, centrada en potenciar las relaciones interpersonales como clave para el &eacute;xito en desarrollo de software, promoviendo el trabajo en equipo, preocup&aacute;ndose por el aprendizaje de los desarrolladores, y propiciando un buen clima de trabajo.
</p>
<p>La Programaci&oacute;n eXtrema trata de un cambio social. Trata de dejar los h&aacute;bitos del pasado y hacer el trabajo lo mejor que podamos. Trata de eliminar las barreras que interfieren en la productividad. Trata de dejar el sentimiento adolescente de "<em>s&eacute; mejor que nadie lo que tengo que hacer, y lo &uacute;nico que necesito es que me dejen a solas para ser el mejor</em>". Trata de escribir c&oacute;digo de calidad que realmente sea bueno para la aplicaci&oacute;n.</p>
<p>Las buenas relaciones provocan buenos negocios. La productividad y la confianza est&aacute;n relacionadas con las relaciones humanas en nuestro entorno de trabajo, del mismo modo que nuestros conocimientos t&eacute;cnicos lo hacen con otras actividades del trabajo. Un desarrollador necesita tanto t&eacute;cnicas como buenas relaciones. XP trata &aacute;mbas areas. Por un lado, se centra en los roles del cliente, gestor y programador, proponiendo <em>derechos y
deberes </em>para cada uno de &eacute;stos roles. Por otro lado, ofrece un conjunto de pr&aacute;cticas que cuidan y mejoran la calidad del c&oacute;digo de forma continua.</p>
<p>XP se define como especialmente adecuada para proyectos con requisitos
imprecisos y muy cambiantes, y donde existe un alto riesgo t&eacute;cnico. Siempre debemos tener en mente el lema de "<em>La &uacute;nica constante en los proyecto de software es el cambio</em>"</p>
<p>Los principios y pr&aacute;cticas son de sentido com&uacute;n pero
llevadas al extremo, de ah&iacute; proviene su nombre. A continuaci&oacute;n
presentaremos las caracter&iacute;sticas esenciales de XP.</p>
</div>


<a name="N10033"></a><a name="Valores"></a>
<h2 class="underlined_10">Valores</h2>
<div class="section">
<p>Los valores dentro de XP son la base de toda la metodolog&iacute;a. Ofrece un conjunto de pilares que todo integrante debe tomar como propios. Est&aacute;n m&aacute;s relacionados con el "querer hacer" que con el "saber hacer". Los valores son: comunicaci&oacute;n, simplicidad, retroalimentaci&oacute;n y coraje.</p>
<a name="N1003C"></a><a name="Comunicaci%C3%B3n"></a>
<h3 class="underlined_5">Comunicaci&oacute;n</h3>
<p>Se requiere una comunicaci&oacute;n fluida entre todos los participantes. Aunque parezca obvio para no requerir explicaci&oacute;n, no siempre se produce. Sin comunicaci&oacute;n se malgastan esfuerzos, ya sea mediante redundancia de trabajo, malinterpretaci&oacute;n, etc... </p>
<p>El software se desarrolla tan r&aacute;pido como lo permiten los canales de comunicaci&oacute;n del proyecto. El cliente comunica los requisitos a los programadores. El programador comunica su interpretaci&oacute;n de los requisitos al ordenador. El ordenador se comunica con los usuarios. El usuario comunica su satisfacci&oacute;n respecto al software al cliente.</p>
<p>La comunicaci&oacute;n en XP es bidireccional, y se basa un sistema de continuas iteraciones de retroalimentaci&oacute;n. El cliente le pregunta al usuario que es lo que quiere. El programador explicar las dificultades t&eacute;cnicas y pregunta para averiguar los requisitos. El ordenador notifica al programador de los errores de programaci&oacute;n y los resultados de las pruebas.</p>
<p>Los inform&aacute;ticos somos seres sociales, y como tales, debemos saber comunicarnos. No basta con dominar un lenguaje de programaci&oacute;n, debemos tener habilidades sociales para comunicarnos mediante el lenguaje natural. Puede que parte de culpa la tenga la educaci&oacute;n recibida, donde a lo largo de nuestros estudios, pocas veces hemos trabajado en equipo y siempre se nos ha recordado que los trabajos eran individuales, penalizando aquellos parecidos o con ideas compartidas.</p>
<p>Independientemente del motivo de una pobre comunicaci&oacute;n, como consecuencia tenemos sistemas con muchos fallos. La mala comunicaci&oacute;n puede ocurrir entre programadores, entre el usuario y el equipo de desarrollo, entre los desarrolladores y el jefe del proyecto, etc...</p>
<p>En un proyecto XP, las reglas de comunicaci&oacute;n son simples: <strong>todos los canales est&aacute;n abiertos a todas horas</strong>. El cliente es libre de hablar con los programadores. Los programadores hablan con el cliente y con los usuarios. Las comunicaciones sin restricciones mitigan el riesgo del proyecto reduciendo falsas expectativas. Todos los interesados saben que pueden esperar del resto del equipo.</p>
<a name="N10058"></a><a name="Simplicidad"></a>
<h3 class="underlined_5">Simplicidad</h3>
<p>La mejor soluci&oacute;n es la m&aacute;s simple. Cuanto m&aacute;s sencillas son las soluciones, m&aacute;s f&aacute;ciles son de entender. Debemos tener siempre en mente el principio KISS (<em>Keep It Simple, Stupid</em>).</p>
<p>La soluci&oacute;n m&aacute;s simple no quiere decir que sea la m&aacute;s f&aacute;cil ni la m&aacute;s sencilla de implementar, ya que la simplicidad es un concepto abstracto. El c&oacute;digo m&aacute;s simple puede ser muy dif&iacute;cil de conseguir a la primera. Tambi&eacute;n cuesta ignorar el ma&ntilde;ana y dise&ntilde;ar caracter&iacute;sticas que pueden ser geniales si se necesitasen en una iteraci&oacute;n futura. Otras limitaciones como la presi&oacute;n temporal, o el escribir c&oacute;digo impresionista (aquel que demuestra todos los conocimientos de un desarrollador, aunque se salga del alcance o motivaci&oacute;n del problema) pueden limitar la simplicidad de la soluci&oacute;n.</p>
<p>El principal problema radica, por un lado, en que no todos los integrantes del equipo tenemos los mismos conocimientos, y por otro, que esa caracter&iacute;stica que pensaste que se iba a necesitar ma&ntilde;ana, puede que se necesite dentro de 3 meses o que no se llegue a necesitar nunca.</p>
<p>XP lleva la simplicidad al extremo con las siguientes gu&iacute;as pr&aacute;cticas:</p>
<ul>
    
<li>
<strong>Haz la cosa m&aacute;s simple que pueda funcionar</strong>, implementando la primera idea que te venga en mente. Esto puede dar miedo. Conf&iacute;a en tu coraje y prueba la idea. Recuerda que el error es una parte importante del proceso creativo. Es improbable que esta primera idea sea la m&aacute;s simple, pero no podemos anticipar resultados hasta que lo hayamos probado.</li>
    
<li>
<strong>Representa los conceptos una sola vez</strong> - OAOO - (<em>Once And Only Once</em>). OAOO nos ayuda a mantener la agilidad reduciendo la cantidad de c&oacute;digo del aplicativo. Si permitimos que la redundancia se apodere de nuestro sistema, emplearemos m&aacute;s y m&aacute;s tiempo en tareas de correcci&oacute;n que de creaci&oacute;n. Cada vez que hacemos <em>copy&amp;paste</em>, creamos un acoplamiento impl&iacute;cito. S&eacute; valiente, evita el uso de rat&oacute;n y Ctrl+C/Ctrl+V, y apuesta por la refactorizaci&oacute;n.</li>
    
<li>
<strong>No vas a necesitarlo</strong> YAGNI (<em>You Aren't Going To Need It</em>). Cuando sea posible resolver un problema inmediato sin introducir nuevas caracter&iacute;sticas, estaremos simplificando el problema.</li>
    
<li>
<strong>Elimina funcionalidad (o m&eacute;todos) que ha dejado de utilizarse</strong>. En ocasiones a&ntilde;adimos un m&eacute;todo al sistema por alguna buena raz&oacute;n, que posteriormente deja de utilizarse (<em>dead code</em>). En este punto, debemos eliminar este m&eacute;todo. No necesitamos complejidad innecesaria. No hace falta mucho coraje, porque &eacute;l c&oacute;digo todav&iacute;a existe en el repositorio del gestor de versiones. Siempre podemos volver a recuperarlo si posteriormente lo volvemos a necesitar.</li>

</ul>
<a name="N10091"></a><a name="Retroalimentaci%C3%B3n"></a>
<h3 class="underlined_5">Retroalimentaci&oacute;n</h3>
<p>Es bueno obtener retroalimentaci&oacute;n. Los proyectos deber&iacute;an retroalimentarse desde el principio, de forma frecuente, y por parte del cliente, del equipo de desarrollo, de los usuarios finales, de terceras personas, etc...</p>
<p>Ayuda a identificar los problemas desde el principio, tratar con aspectos desconocidos y clarificar aspectos, evitando que los problemas se pospongan al final del proyecto (cuando el tiempo premia y no podemos permitirnos sorpresas  indeseadas).</p>
<p>La retroalimentaci&oacute;n se puede conseguir a varios niveles. La entrega al cliente de forma continua de funcionalidades parciales que le aportan valor, de modo que el cliente opina de forma r&aacute;pida y frecuente sobre la aplicaci&oacute;n y no espera a una entrega final. Mediante esta r&aacute;pida retroalimentaci&oacute;n, cuando un cliente pide un cambio, se le muestra una soluci&oacute;n, la cual puede ajustar. El cliente visualiza los requisitos o las correcciones implementadas en t&eacute;rminos de semanas, y no de meses o a&ntilde;os.</p>
<p>El valor de la retroalimentaci&oacute;n real e inmediata no debe subestimarse. Una de las razones del &eacute;xito de la Web es la gran cantidad de retroalimentaci&oacute;n estructurada e inmediata por parte de los usuarios. Los desarrollares observan los errores en tiempo real.</p>
<p>XP reduce los riesgos del proyecto llevando el desarrollo iterativo al extremo. La implicaci&oacute;n del cliente no acaba en la fase de planificaci&oacute;n, de modo que los errores de elicitaci&oacute;n de requisitos se corrigen casi inmediatamente. La calidad interna del sistema se mantiene mediante programadores trabajando por parejas, esforz&aacute;ndose en la simplicidad.  La ejecuci&oacute;n de pruebas unitarias al integrar c&oacute;digo nuevo en el sistema, provoca que cualquier problema introducido en el nuevo c&oacute;digo aparezca inmediatamente. Las pruebas autom&aacute;ticas retroalimentan a todo el equipo de c&oacute;mo el sistema est&aacute; cumpliendo las expectativas previstas.</p>
<a name="N100A7"></a><a name="Coraje"></a>
<h3 class="underlined_5">Coraje</h3>
<p>Para afrontar los cambios se necesita ser valiente. Para adoptar XP necesitar&aacute;s coraje.</p>
<p>Necesitar&aacute;s refactorizar el c&oacute;digo (modificar c&oacute;digo que funciona, &iquest;para qu&eacute;?), programar para hoy y no para ma&ntilde;ana, escribir antes la pruebas que el c&oacute;digo, trabajar con un compa&ntilde;ero que te puede criticar, escribir c&oacute;digo que cualquiera puede modificar, simplificar una soluci&oacute;n compleja (quiz&aacute;s tan compleja que no la entienda), completar un caso de prueba para cubrir todas las posibilidades, etc...</p>
<p>&iquest;Estoy motivado para tener coraje? La motivaci&oacute;n se consigue mediante el inter&eacute;s, el miedo o la confianza. XP ayuda a que crezca la confianza exponiendo a los integrantes a peque&ntilde;os pero continuos &eacute;xitos.</p>
<p>Superaremos el miedo, la incertidumbre y las dudas mediante el coraje apoyado en los otros 3 valores. Un sistema simple es m&aacute;s dificir de romper que uno complejo. La retroalimentaci&oacute;n r&aacute;pida y en diferentes niveles nos permite darnos cuenta r&aacute;pidamente cuando un cambio falla. Las comunicaciones abiertas significan que no vamos a afrontar nuestros miedos a solas, nuestros compa&ntilde;eros de equipo nos ayudaran. Solo tenemos que hablar de lo que nos asusta de una forma abierta.</p>
<p>El coraje es una espada de doble filo. Necesitamos superar nuestros miedos, pero demasiado coraje puede ser peligroso. XP fomenta peque&ntilde;os pasos para promover el coraje. Los integrantes del equipo observan un flujo continuo de fallos y errores, que evita el exceso de coraje pero mantiene un nivel acorde.</p>
</div>



<a name="N100BE"></a><a name="Resultados+XP"></a>
<h2 class="underlined_10">Resultados XP</h2>
<div class="section">
<p>A continuaci&oacute;n se muestran los resultados agrupados por fases de desarrollo:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
    
<tr>
        
<th colspan="1" rowspan="1">Requisitos</th>
        <th colspan="1" rowspan="1">Dise&ntilde;o</th>
    
</tr>
    
<tr>
        
<td colspan="1" rowspan="1">
            
<dl>
                
<dt>Historias de Usuario</dt>
<dd></dd>
            
</dl>
        
</td>
        <td colspan="1" rowspan="1">
            
<dl>
                
<dt>Tarjetas CRC</dt>
                
<dd>Son tarjetas de papel en forma de &iacute;ndice en las cuales se escriben de forma breve la responsabilidad de clases y las ideas de colaboraci&oacute;n</dd>
                
<dt>Esbozos</dt>
                
<dd>Diagramas en borrador sobre pizarras blancas</dd>
            
</dl>
        
</td>
    
</tr>
    
<tr>
        
<th colspan="1" rowspan="1">Implementaci&oacute;n</th>
        <th colspan="1" rowspan="1">Pruebas</th>
    
</tr>
    
<tr>
<td colspan="1" rowspan="1">&nbsp;</td><td colspan="1" rowspan="1">&nbsp;</td>
</tr>
    
<tr>
        
<th colspan="1" rowspan="1">Gesti&oacute;n de Proyectos</th>
        <th colspan="1" rowspan="1">Gesti&oacute;n y Configuraci&oacute;n del Cambio</th>
    
</tr>
    
<tr>
        
<td colspan="1" rowspan="1">
            
<dl>
                
<dt>Listado de Tareas</dt>
                
<dd>Ya sea tarjetas de papel o un listado en una pizarra belleda en la cual se escriben las tareas de las historias, todas dentro de una iteraci&oacute;n. Su granularidad es de 1 a 2 d&iacute;as.</dd>
                
<dt>Gr&aacute;fico Visible</dt>
                
<dd>En la pared, para una mejor comunicaci&oacute;n. El contenido depende de los equipos (por ejemplo, n&uacute;mero de pruebas definidas respecto a pasadas)</dd>
                
<dt>Historias de Usuario</dt>
<dd></dd>
            
</dl>		
        
</td>
        <td colspan="1" rowspan="1">&nbsp;</td>
    
</tr>

</table>
<a name="historiaUsuario"></a><a name="N10141"></a><a name="Las+Historias+de+Usuario"></a>
<h3 class="underlined_5">Las Historias de Usuario</h3>
<p>Las historias de usuario (<em>User Story</em>) son la t&eacute;cnica utilizada en XP para especificar los requisitos del software. Se trata de tarjetas/cuartillas de papel (<a class="external" href="http://www.xprogramming.com/xpmag/story_and_task_cards.htm">www.xprogramming.com/xpmag/story_and_task_cards.htm</a>) en las cuales el cliente describe brevemente las caracter&iacute;sticas que el sistema debe poseer, sean requisitos funcionales o no funcionales, incluso para crear
documentaci&oacute;n.</p>
<p>Las rellenan los clientes con sus propias palabras, aunque los desarrolladores suelen escribir lo que el cliente les dicta. Cada historia de usuario se captura de forma separada. El tratamiento de las historias de usuario es muy din&aacute;mico y flexible, en cualquier momento pueden romperse, reemplazarse por otras m&aacute;s espec&iacute;ficas o generales, a&ntilde;adirse nuevas o ser modificadas. Cada historia de usuario es lo suficientemente comprensible y delimitada para que los programadores puedan implementarla en unas semanas.</p>
<p>Respecto de la informaci&oacute;n contenida en la historia de usuario, existen varias plantillas sugeridas pero no existe un consenso al respecto. En muchos casos s&oacute;lo se propone utilizar un nombre y una descripci&oacute;n, una estimaci&oacute;n de esfuerzo en d&iacute;as (que puede ser "desconocida"), y un importancia relativa (sin&oacute;nimos de "<em>obligado</em>", "<img class="icon" alt="" src="">deber&iacute;a hacerse", "<em>podr&iacute;a hacerse</em>", "<em>deseo</em>", etc...).</p>
<p>Se adjunta una posible plantilla (formato OpenOffice):
<a href="recursos/plantillaHistoria.odt">Plantilla para Historia de Usuario</a>

</p>
<p>
    
<img alt="Plantilla de Historia de Usuario" content-width="14cm" src="imagenes/s2/historiaUsuario.gif" width="476">
</p>
<a name="crc"></a><a name="N10178"></a><a name="Tarjetas+CRC"></a>
<h3 class="underlined_5">Tarjetas CRC</h3>
<p>Las tarjetas CRC (<em>Clase, Responsabilidad, Colaboraci&oacute;n</em>)
ofrecen un mecanismo sencillo pero efectivo para enfocar un dise&ntilde;o que involucra a varios participantes de un equipo. Tal como veremos m&aacute;s adelante, XP promueve el desarrollo colaborativo, y aqu&iacute; las tarjetas CRC son una herramienta muy &uacute;til.</p>
<p>Se comienza la sesi&oacute;n de dise&ntilde;o con un mont&oacute;n de tarjetas en blanco, ya sean cuartillas de cartulina o un folio doblado en 2 veces. Cada cartulina representa un objeto del sistema, y se escribe en ella el nombre del objeto en la cabecera, las responsabilidades en la parte inferior izquierda y las clases de colaboraci&oacute;n a la derecha.</p>
<p>
    
<img alt="Tarjeta CRC" content-width="8cm" src="imagenes/s2/crc.gif" width="268">
</p>
<p>La sesi&oacute;n comienza con una historia de usuario, y cada miembro del equipo con un n&uacute;mero de tarjetas. El equipo conversa sobre el escenario, y el miembro responsable de la tarjeta se responsabiliza de guiar dicha historia. El detalle de las tarjetas cambia como resultado de la discusi&oacute;n, hasta que se identifican un conjunto de clases, responsabilidad y las colaboraciones asociadas que permitir&aacute;n ejecutar el escenario requerido.</p>
<p>En una sesi&oacute;n CRC de XP, no se produce un dise&ntilde;o formal, pero el grupo se lleva una idea del como el sistema implementar&aacute; la funcionalidad requerida.</p>
</div>




<a name="N10198"></a><a name="Pr%C3%A1cticas+XP"></a>
<h2 class="underlined_10">Pr&aacute;cticas XP</h2>
<div class="section">
<p>A partir de los valores explicados anteriormente, se definen una serie de pr&aacute;cticas (12). Tambi&eacute;n se conocen como las <em>Best Practices</em> que permitir&aacute;n adoptar XP de un modo exitoso.
</p>
<p>A continuaci&oacute;n se muestran las pr&aacute;cticas, que pueden apoyarse en varias disciplinas, agrupados por fases de desarrollo:</p>
<p>

<img alt="Pr&aacute;cticas XP" content-width="17cm" src="imagenes/s2/practicasXP.gif" width="719">
</p>
<p>La principal suposici&oacute;n que se realiza en XP es la posibilidad de disminuir la m&iacute;tica curva exponencial del costo del cambio a lo largo del proyecto, lo suficiente para que el dise&ntilde;o evolutivo funcione. XP apuesta por un crecimiento lento del costo del cambio y con un comportamiento asint&oacute;tico. Esto se consigue gracias a las tecnolog&iacute;as disponibles para ayudar en el desarrollo de software y a la aplicaci&oacute;n disciplinada de las pr&aacute;cticas que describiremos a continuaci&oacute;n.</p>
<a name="juegoPlanificacion"></a><a name="N101B6"></a><a name="El+Juego+de+la+Planificaci%C3%B3n"></a>
<h3 class="underlined_5">El Juego de la Planificaci&oacute;n</h3>
<p>Es un espacio frecuente de comunicaci&oacute;n entre el cliente y los programadores. El equipo t&eacute;cnico realiza una estimaci&oacute;n del esfuerzo requerido para la implementaci&oacute;n de las Historias de Usuario y los clientes deciden sobre el &aacute;mbito y tiempo de las entregas y de cada iteraci&oacute;n.</p>
<p>Esta pr&aacute;ctica se puede ilustrar como un juego, donde existen dos tipos de jugadores: cliente y programador. El <strong>Cliente</strong> (cualquiera que pueda tomar decisiones acerca de lo que debe realizar el sistema) establece la prioridad de cada historia de usuario, de acuerdo con el valor que aporta para el negocio. Los <strong>Desarrolladores</strong> (cualquier persona involucrada en la implementaci&oacute;n del proyecto) estiman el esfuerzo asociado a cada historia de usuario. Se ordenan las historias de usuario seg&uacute;n prioridad y esfuerzo, y se define el contenido de la entrega y/o iteraci&oacute;n, apostando por enfrentar lo de m&aacute;s valor y riesgo cuanto antes.</p>
<p>As&iacute; pues, el objetivo de este juego es decidir el &aacute;mbito/alcance y las prioridades del proyecto y sus respectivas entregas. Adem&aacute;s, nos va a permitir estimar el coste de las diferentes funcionalidades, as&iacute; como planificar estas funcionalidades en entregas.</p>
<p>Este juego se realiza durante la planificaci&oacute;n de la entrega, en la planificaci&oacute;n de cada iteraci&oacute;n y cuando sea necesario reconducir el proyecto.</p>
<a name="N101CE"></a><a name="El+Juego+en+Detalle"></a>
<h4>El Juego en Detalle</h4>
<p>El juego se divide en tres fases:</p>
<ol>
    
<li>
<strong>Exploraci&oacute;n</strong>: determina nuevas historias de usuario del sistema</li>
    
<li>
<strong>Compromiso</strong>: determina que funcionalidades se desarrollaran en una determinada entrega</li>
    
<li>
<strong>Ajuste (Steering)</strong>: actualiza la planificaci&oacute;n conforme el desarrollo progresa.</li>

</ol>
<p>Estas 3 fases son iterativas y suelen interactuar entre si. Por ejemplo, si en la fase de <em>Ajuste</em> nos damos cuenta de que necesitamos nuevas historias de usuario, entonces se vuelve a jugar en la fase de <em>Exploraci&oacute;n</em> para las nuevas historias necesarias, tras lo cual se realiza el <em>Compromiso</em>, y posteriormente se vuelve a revisar el <em>Ajuste</em> para producir una planificaci&oacute;n revisada.</p>
<a name="N101F9"></a><a name="Exploraci%C3%B3n"></a>
<h4>Exploraci&oacute;n</h4>
<p>Durante la fase de Exploraci&oacute;n, el juego intenta ayudar al equipo a identificar que deber&iacute;a hacer el sistema. Para conseguir esto, esta etapa contiene 3 pasos/movimientos sobre las Historias de Usuario:</p>
<ol>
    
<li>
<strong>Escribir</strong>. El <em>Cliente</em> empieza a hablar sobre lo que el sistema debe realizar. En alg&uacute;n momento, estas descripciones se escriben como historia de usuario (en cuartillas). Normalmente, las ideas iniciales se discuten mejor sobre pizarras antes de convertirlas en tarjetas.</li>
    
<li>
<strong>Estimar</strong>. Los <em>Desarrolladores</em> estiman cuanto tardar&aacute;n en implementar la historia. Si los <em>Desarrolladores</em> no pueden estimar la historia, entonces pueden pedir aclaraciones o solicitar que la historia se divida (para facilitar su comprensi&oacute;n). En las planificaciones iniciales del proyecto (durante el juego de planificaci&oacute;n inicial) normalmente s&oacute;lo se intenta obtener una cifra aproximada. M&aacute;s tarde (durante la planificaci&oacute;n de la entrega detallada), se requerir&aacute; mayor nivel de detalle al describir las historias.</li>
    
<li>
<strong>Dividir</strong>. Los usuarios normalmente no son conscientes de cuanto trabajo implica una cierta funcionalidad del sistema. A su vez, los desarrolladores normalmente no entregan lo que el cliente quiere. Como resultado, las historias de usuario pueden variar en tama&ntilde;o y complejidad. Las historias de usuario necesitan refinarse, pero las historias de usuario grandes (en t&eacute;rminos de complejidad o duraci&oacute;n) necesitan partirse en historias de usuario m&aacute;s peque&ntilde;as (y menos complejas). Como regla general, ninguna historia de usuario puede ser tan grande que ninguna pareja de programadores sea capaz de completarla dentro de una iteraci&oacute;n.</li>

</ol>
<a name="N1021D"></a><a name="%C2%BFComo+se+realizan+las+estimaciones%3F"></a>
<h5>&iquest;Como se realizan las estimaciones?</h5>
<p>Respecto a las estimaciones, citar que se trata de una actividad bastante dif&iacute;cil y con tendencia a ser err&oacute;nea. XP recomienda estimar en "<em>Tiempo Ideal de Ingenier&iacute;a</em>" (IET), compuesto de "<em>D&iacute;a Ideal de Ingenier&iacute;a</em>" (IED). Un IED es la cantidad de desarrollo que se puede conseguir en un &uacute;nico d&iacute;a por un desarrollador medio sin interrupciones ni dependencias. En la fase de Compromiso, en el paso de "fijar la velocidad del proyecto", se contempla que no existe un d&iacute;a ideal, que un programador tiene reuniones, proyectos previos, necesidades de otros programadores, etc... lo cual le interrumpir&aacute;. Por esto, el tiempo necesario para producir un IED puede que se asocia al trabajo de un media persona durante una semana. Conforme el proyecto progresa, quiz&aacute;s necesitemos revisar este ratio entre ideal y real.</p>
<p>Las estimaciones de esfuerzo asociado a la implementaci&oacute;n de las historias la establecen los programadores utilizando como medida el punto. Un <strong>punto</strong> equivale a una semana ideal de programaci&oacute;n. Las historias generalmente valen de 1 a 3 puntos. Por otra parte, el equipo de
    desarrollo mantiene un registro de la <strong>velocidad del proyecto</strong>, establecida en puntos por iteraci&oacute;n, bas&aacute;ndose principalmente en la suma de puntos correspondientes a las historias de usuario que fueron terminadas en la &uacute;ltima iteraci&oacute;n.</p>
<p>La planificaci&oacute;n se puede realizar bas&aacute;ndose en el tiempo o el alcance. La velocidad del proyecto se utiliza para establecer cu&aacute;ntas historias se pueden implementar antes de una fecha determinada o cu&aacute;nto tiempo se tardar&aacute; en implementar un conjunto de historias.</p>
<ul>
        
<li>Al <em>planificar por tiempo</em>, se multiplica el n&uacute;mero de iteraciones por la velocidad del proyecto, determin&aacute;ndose cu&aacute;ntos puntos se pueden completar.</li>
        
<li>Al <em>planificar seg&uacute;n alcance del sistema</em>, se divide la suma de puntos de las historias de usuario seleccionadas entre la velocidad del proyecto, obteniendo el n&uacute;mero de iteraciones necesarias para su implementaci&oacute;n.</li>
    
</ul>
<a name="N10249"></a><a name="Compromiso"></a>
<h4>Compromiso</h4>
<p>Durante esta etapa del juego, el <em>Cliente</em> debe identificar que habr&aacute;/suceder&aacute; en la siguiente iteraci&oacute;n y cuando ser&aacute; la siguiente entrega. Por su parte, los <em>Desarrolladores</em> deben llegar a un compromiso de aceptar la duraci&oacute;n y el contenido de la entrega. Si esta situaci&oacute;n no se puede alcanzar, entonces o bien se modifica la fecha de la entrega, o se altera el contenido de la misma.</p>
<p>Los pasos que se realiza para alcanzar el acuerdo son:</p>
<ol>
    
<li>
<strong>Ordenar por Valor</strong>. El <em>Cliente</em> ordena las historias de usuario en tres montones. Estos montones representan las historias con prioridades alta (obligatorias/<em>must have</em>), media (deber&iacute;an hacerse/<em>should have</em>) y baja (pueden aportar valor/<em>nice to have</em>). Desde el punto de vista del <em>Cliente</em>, las historias del mont&oacute;n de prioridad alta son m&aacute;s importantes que el resto. Por lo tanto, el equipo se centrar&aacute; primero en este mont&oacute;n, ya que ser&aacute;n las que aporten mayor valor al negocio.</li>
    
<li>
<strong>Ordenar por Riesgo</strong>. Las historias de usuarios se reordenan en otros 3 montones, los cuales representan un riesgo alto (no se pueden estimar), medio (estimaci&oacute;n razonable) y bajo (estimaci&oacute;n fiable). Estos montones nos permiten averiguar las historias de usuario que el <em>Cliente</em> considera que tienen una prioridad alta y que los <em>Desarrolladores</em> han afrontado la estimaci&oacute;n con certeza (una base s&oacute;lida para realizar una estimaci&oacute;n bien fundada). El resultado de esto es que el juego de la planificaci&oacute;n quiz&aacute;s deba volver a la etapa de Exploraci&oacute;n para intentar aclarar algunos aspectos relativos a la estimaci&oacute;n de las historias de usuario. Algunas historias pueden dejarse para investigarse posteriormente una vez haya terminado el juego.</li>
    
<li>
<strong>Elegir Alcance</strong>. El Cliente debe elegir el conjunto final de historias de usuario que formaran parte de la siguiente iteraci&oacute;n/entrega. La &uacute;nica restricci&oacute;n respecto a lo que compone una entrega es que la primera entrega deber&iacute;a estar completa en t&eacute;rminos de uso (aunque con una funcionalidad muy limitada) y que cada entrega posterior debe a&ntilde;adir algo que aporte valor al Cliente (para que se considere una entrega).<div class="frame note">
<div class="label">Destacar</div>
<div class="content">No todas las iteraciones tienen como resultado una entrega</div>
</div>
</li>
    
<li>
<strong>Fijar la Velocidad del Proyecto</strong>. Este paso mapea la Unidad Ideal de Ingenier&iacute;a (IDU) con la realidad y toma en cuenta la cantidad de tiempo que los desarrolladores realmente son productivos, su experiencia, etc... Ofrece un modo de comparar periodos estimados idealmente con tiempo real restante.</li>

</ol>
<p>Esta etapa se realiza de forma secuencial, con el <em>Cliente</em> ordenando la importancia relativa de las diferentes historias de usuario. A continuaci&oacute;n, los <em>Desarrolladores</em> determinan sobre las historias importantes que riesgo conllevan. Finalmente, el <em>Cliente</em> decidir&aacute; qu&eacute; historias formaran parte de una entrega particular (o entregas). La realidad es que se trata de un proceso iterativo, donde el <em>Cliente</em> revisa los montones conforme el juego avanza, influenciado por los <em>Desarrolladores</em>, la necesidad de dividir las historias y descubrir nuevas historias.</p>
<a name="N1029D"></a><a name="Ajuste"></a>
<h4>Ajuste</h4>
<p>En el mundo real, la planificaci&oacute;n siempre cambia; por una gran cantidad de razones, incluyendo:</p>
<ul>
    
<li>Requisitos que cambian</li>
    
<li>Nuevos requisitos</li>
    
<li>Prioridades que cambian</li>
    
<li>Estimaciones incorrectas</li>
    
<li>Recursos que cambian (desarrolladores salen y entran al proyecto/empresa con diferentes habilidades)</li>

</ul>
<p>
Todo esto significa que a lo largo de la vida de un proyecto, una planificaci&oacute;n requiere revisiones frecuentes y extensas. De hecho, la planificaci&oacute;n de un proyecto debe permitir obtener un hist&oacute;rico de cambios. Incluso dentro de una iteraci&oacute;n XP, estos factores pueden convertirse en realidad y a lo largo de varias iteraciones. El juego de planificaci&oacute;n XP reconoce expl&iacute;citamente estos factores dentro de la etapa de Ajuste.</p>
<p>La idea de esta etapa es ajustar el proyecto y retomar la direcci&oacute;n correcta. Los pasos son:</p>
<ol>
    
<li>
<strong>Planificaci&oacute;n de Iteraci&oacute;n</strong>. XP cita que solo debemos planificar en detalle la iteraci&oacute;n actual. Por lo tanto, al inicio de cada iteraci&oacute;n (cada 1-3 semanas), el <em>Cliente</em> planifica las Historias de Usuario a implementar, y los <em>Desarrolladores</em> planifican las tareas necesarias para implementar dichas historias.</li>
    
<li>
<strong>Recuperaci&oacute;n de Proyecto</strong>. Conforme progresa la iteraci&oacute;n, si los Desarrolladores se dan cuenta que van retrasados o adelantados respecto al calendario, pueden pedirle ayuda al Cliente para re-priorizar las historias de usuario a implementar.</li>
    
<li>
<strong>Identificar una nueva Historia</strong>. Si se identifica una nueva historia y se determina que es necesaria para la entrega actual, entonces se puede escribir, estimar y a&ntilde;adir a la iteraci&oacute;n. Como consecuencia, las restantes historias necesitan revisarse y algunas ser&aacute;n descartadas para lograr cumplir la entrega.</li>
    
<li>
<strong>Reestimaci&oacute;n de Proyecto</strong>. Si los desarrolladores consideran que la planificaci&oacute;n se desv&iacute;a de la realidad, entonces se puede replanificar la iteraci&oacute;n completa, reestimar las historias de usuario, poner a cero la velocidad del proyecto y reconsiderar las implicaciones del calendario del proyecto.</li>

</ol>
<p>Esta etapa suele realizarse en cualquier momento de la iteraci&oacute;n (o al final). Sin embargo, las 2 primeras etapas ocurren al inicio de la iteraci&oacute;n. Por lo tanto, el juego de la planificaci&oacute;n como pr&aacute;ctica XP se parte en trozos que se ejecutan en diferentes momentos den del ciclo de vida del proyecto.</p>
<a name="N102E0"></a><a name="Entregas+Peque%C3%B1as"></a>
<h3 class="underlined_5">Entregas Peque&ntilde;as</h3>
<p>La idea es producir r&aacute;pidamente versiones del sistema que sean operativas, aunque obviamente no cuenten con toda la funcionalidad pretendida para el sistema pero si que constituyan un resultado de valor para el negocio, del cual obtener retroalimentaci&oacute;n por parte del cliente y del usuario final</p>
<p>Tan pronto como un conjunto de tareas aporten valor al cliente, se debe entregar. Aparte de la retroalimentaci&oacute;n, estas entregas peque&ntilde;as facilitan las planificaciones a corto plazo, ya que un juego de planificaci&oacute;n solo necesitara considerar unas pocas semanas (una entrega no deber&iacute;a tardar m&aacute;s 3 meses), y por lo tanto, el nivel de incertidumbre es menor respecto a si la duraci&oacute;n es ilimitada.</p>
<a name="N102ED"></a><a name="Dise%C3%B1o+Simple"></a>
<h3 class="underlined_5">Dise&ntilde;o Simple</h3>
<p>Se debe dise&ntilde;ar la soluci&oacute;n m&aacute;s simple que pueda funcionar y ser implementada en un momento determinado del proyecto. La complejidad innecesaria y el c&oacute;digo extra deben ser eliminados inmediatamente, evitando los componentes generalizados. </p>
<div class="frame note">
<div class="label">Importante</div>
<div class="content">
No confundir el dise&ntilde;o simple con el dise&ntilde;o f&aacute;cil o trivial
</div>
</div>
<p>Aunque pueda parecer que XP minoriza el dise&ntilde;o, realmente se integra dentro de la implementaci&oacute;n. XP no obliga a dise&ntilde;ar el c&oacute;digo de una determinada manera, ya que se puede hacer mediante la programaci&oacute;n en parejas, el uso de tarjetas CRC, t&eacute;cnicas de Modelado &Aacute;gil, diagramas de flujo, etc... Esta decisi&oacute;n se sale fuera del &aacute;mbito de XP.</p>
<p>En cambio, XP promueve que el mejor dise&ntilde;o (el m&aacute;s simple) para el software es aquel que:</p>
<ul>
    
<li>Supera con &eacute;xito todas las pruebas.</li>
    
<li>No tiene l&oacute;gica duplicada.</li>
    
<li>Refleja claramente la intenci&oacute;n de implementaci&oacute;n de los programadores, por lo cual es f&aacute;cilmente comprensible por un programador externo.</li>
    
<li>Tiene el menor n&uacute;mero posible de clases y m&eacute;todos.</li>

</ul>
<a name="tdd"></a><a name="N10313"></a><a name="Desarrollo+Dirigido+por+las+Pruebas"></a>
<h3 class="underlined_5">Desarrollo Dirigido por las Pruebas</h3>
<p>En XP las pruebas son la actividad dominante. Las pruebas se producen antes de escribir cualquier c&oacute;digo, las pruebas de aceptaci&oacute;n se generan tan pronto como se escriben los requisitos (mediante <a href="#historiaUsuario">Historias de Usuario</a>), las pruebas unitarias se producen antes de implementar el c&oacute;digo, todo el c&oacute;digo debe pasar todas las pruebas durante el desarrollo, etc... Este enfoque se conoce como Desarrollo Dirigido por las Pruebas (<em>Test Driven Development</em>).</p>
<div class="frame note">
<div class="label">Importante</div>
<div class="content">
No puede existir c&oacute;digo sin su prueba asociada
</div>
</div>
<p>Debemos ser capaces de escribir (y de hecho realmente escribir) las pruebas para un m&oacute;dulo antes de implementarlo. El argumento es que si no puedes escribir las pruebas antes de implementar el m&oacute;dulo, es que todav&iacute;a no sabemos lo suficiente sobre el m&oacute;dulo. En este contexto de desarrollo evolutivo y de &eacute;nfasis en pruebas, la automatizaci&oacute;n para apoyar esta actividad es crucial.</p>
<p>El resultado de escribir primero las pruebas es que tenemos:</p>
<ul>
    
<li>Un conjunto completo de pruebas para todo el c&oacute;digo producido.</li>
    
<li>El c&oacute;digo m&aacute;s sencillo que pasa las pruebas.</li>
    
<li>Una visi&oacute;n clara de lo que el c&oacute;digo deber&iacute;a y no deber&iacute;a hacer.</li>
    
<li>Una forma sencilla de comprobar que el c&oacute;digo refactorizado no ha modificado la funcionalidad.</li>
    
<li>Un modo excelente de "documentaci&oacute;n" explicando que deber&iacute;a o no deber&iacute;a hacer un modulo.</li>

</ul>
<p>Volviendo a las pruebas en si, existen 2 tipos de pruebas dentro del marco XP, las pruebas unitarias (escritas por los desarrolladores) y las pruebas de aceptaci&oacute;n (desarrolladas por el cliente/s y los usuarios finales)</p>
<a name="N10342"></a><a name="Pruebas+Unitarias"></a>
<h4>Pruebas Unitarias</h4>
<p>El objetivo de las pruebas unitarias es validar la implementaci&oacute;n de un componente respecto a su dise&ntilde;o inicial. Estas pruebas conforman la columna vertebral del enfoque TDD, siendo responsabilidad del desarrollador su creaci&oacute;n.</p>
<p>Consisten en un conjunto de pruebas de granularidad fina que normalmente comprueban la funcionalidad de un componente a trav&eacute;s de sus m&eacute;todos y atributos p&uacute;blicos.</p>
<p>Las pruebas unitarias se pueden considerar en una combinaci&oacute;n de pruebas de   <em>caja negra</em> (la prueba unitaria valida la clase a trav&eacute;s de sus entradas y sus salida, confirmando que se cumplen los requisitos especificados) y <em>caja blanca</em> (la prueba se basa en el interior de la clase, en el c&oacute;digo implementado).</p>
<p>Dentro de XP, siempre se utiliza alg&uacute;n tipo de framework, y en concreto, dentro de la plataforma Java tenemos JUnit (<a class="external" href="http://junit.org">junit.org</a>), Cactus (<a class="external" href="http://jakarta.apache.org/cactus">jakarta.apache.org/cactus</a>), HttpUnit (<a class="external" href="http://sourceforge.net/projects/httpunit">sourceforge.net/projects/httpunit</a>), etc...</p>
<a name="N10367"></a><a name="Pruebas+de+Aceptaci%C3%B3n"></a>
<h4>Pruebas de Aceptaci&oacute;n</h4>
<p>Un prueba de aceptaci&oacute;n confirma que el sistema cumple los criterios de aceptaci&oacute;n de acuerdo con los clientes finales. Com&uacute;nmente, este tipo de pruebas lo realiza el propio equipo de QA del cliente, o un equipo formado por el cliente y el usuario final.</p>
<p>Este tipo de pruebas, al estar relacionadas con la perspectiva del usuario final son m&aacute;s dif&iacute;ciles de probar. Sin embargo, dependiendo del tipo de aplicaci&oacute;n, podemos utilizar alg&uacute;n framework espec&iacute;fico como puede ser Fit (<a class="external" href="http://fit.c2.com">fit.c2.com</a> y <a class="external" href="http://www.fitnesse.org">www.fitnesse.org</a>).</p>
<p>Independientemente del tipo de prueba, todo el c&oacute;digo debe pasar las pruebas antes de dar el c&oacute;digo por bueno. Si se automatizan las pruebas unitarias, entonces es posible utilizar herramientas relacionada con las integraciones continuas que permitan al construir el proyecto, comprobar que se pasan todas las pruebas antes de que el c&oacute;digo de suba al repositorio de c&oacute;digo fuente. Las herramientas que soportan este comportamiento son CruiseControl para las integraciones continuas, Ant/Maven para la construcci&oacute;n, JUnit/Cactus/HttpUnit para las pruebas unitarias y CVS como repositorio de codigo fuente y control de versiones.</p>
<a name="refactorizacion"></a><a name="N10383"></a><a name="Refactorizaci%C3%B3n"></a>
<h3 class="underlined_5">Refactorizaci&oacute;n</h3>
<p> La refactorizaci&oacute;n es el arte de mejorar la estructura interna del c&oacute;digo sin alterar su comportamiento externo. La refactorizaci&oacute;n es una actividad constante de reestructuraci&oacute;n del c&oacute;digo con el objetivo de remover duplicaci&oacute;n de c&oacute;digo, mejorar su legibilidad, simplificarlo y hacerlo m&aacute;s flexible para facilitar los posteriores cambios.</p>
<p>Aunque parezca poco productivo, ya que estamos modificando el sistema sin modificar su funcionalidad, tenemos 2 situaciones donde la refactorizaci&oacute;n es cr&iacute;tica:</p>
<ol>
    
<li>Antes de implementar una nueva funcionalidad. La refactorizaci&oacute;n en este punto va a facilitar a&ntilde;adir esta funcionalidad.</li>
    
<li>Tras implementar la nueva funcionalidad. Ahora nos ayudar&aacute; a simplificar la soluci&oacute;n adoptada.</li>

</ol>
<p>Por lo tanto, para mantener un dise&ntilde;o apropiado, es necesario realizar actividades de cuidado continuo durante el ciclo de vida del proyecto. De hecho, este cuidado continuo sobre el dise&ntilde;o es incluso m&aacute;s importante que el dise&ntilde;o inicial. Un concepto pobre al inicio puede ser corregido con esta actividad continua, pero sin ella, un buen dise&ntilde;o inicial se degradar&aacute;.</p>
<p>El 25% del esfuerzo de un proyecto XP se consume en t&eacute;cnicas de refactorizaci&oacute;n, refinando de forma continua el dise&ntilde;o del sistema. Esta es la principal raz&oacute;n por la cual no se realiza un modelado intenso.</p>
<p>Esta dedicaci&oacute;n implica que se le dedica m&aacute;s tiempo a refactorizar que a implementar, pero el resultado es que realizamos la soluci&oacute;n m&aacute;s simple conteniendo el c&oacute;digo m&aacute;s limpio y efectivo, con menor n&uacute;mero de agujeros negros.</p>
<p>La refactorizaci&oacute;n requiere fe, confianza y coraje en lo que haces, pero para compensar tenemos las pruebas unitarias que nos ayudan a comprobar que tras la refactorizaci&oacute;n el sistema sigue funcionando.</p>
<a name="N103A7"></a><a name="Programaci%C3%B3n+en+Parejas"></a>
<h3 class="underlined_5">Programaci&oacute;n en Parejas</h3>
<p>Toda la producci&oacute;n de c&oacute;digo debe realizarse en parejas de programadores, es decir, dos programadores en un ordenador, con un teclado y un rat&oacute;n, escriben todo el software del sistema.</p>
<p>Esto es posible porque los 2 desarrolladores juegan roles diferentes:</p>
<ul>
    
<li>Uno se centra en el m&eacute;todo, clase o interfaz a implementar (este es el que tiene el teclado y el rat&oacute;n)</li>
    
<li>El otro se centra en temas m&aacute;s estrat&eacute;gicos como si la soluci&oacute;n elegida se integra bien con el resto del sistema, cuales son las implicaciones, si existe una soluci&oacute;n mejor, si las pruebas cubren todas las posibilidades, etc...</li>

</ul>
<p>Estas parejas no deber&iacute;an durar m&aacute;s de 2 o 3 d&iacute;as (o incluso 2 o 3 horas), dependiendo de la historia de usuario a implementar (o de la tarea). Durante este periodo, ambos programadores deben intercambiar los mandos, de modo que unas veces sea uno el que teclea y otro el que revisa el c&oacute;digo y piensa en alternativas en pro de un dise&ntilde;o m&aacute;s sencillo.</p>
<p>Las parejas cambian conforme cambian las tareas y las historias. Por ejemplo, si un desarrollador esta trabajando en un &aacute;rea del c&oacute;digo que no domina, deber&iacute;a formar pareja con un desarrollador experto en dicha &aacute;rea. Es importante destacar que nunca se deben unir 2 programadores j&oacute;venes o inexpertos. Lo ideal es juntar a un experto con un programador en fase de aprendizaje.</p>
<p>Las principales ventajas de introducir este estilo de programaci&oacute;n son:</p>
<ul>
    
<li>2 cerebros son mejor que uno.</li>
    
<li>El conocimiento del sistema se extiende entre todos los integrantes, mediante un <strong>aprendizaje cruzado</strong>, posibilitando la transferencia de conocimientos.</li>
    
<li>Muchos errores son detectados conforme son introducidos en el c&oacute;digo (inspecciones de c&oacute;digo continuas), por consiguiente la tasa de errores del producto final es m&aacute;s baja, los dise&ntilde;os son mejores y el tama&ntilde;o del    c&oacute;digo menor (continua discusi&oacute;n de ideas de los programadores).</li>
    
<li>Mayor cobertura de las pruebas, ya que 2 personas ofrecer&aacute;n 2 perspectivas distintas.</li>
    
<li>La experiencia del equipo se extiende, mediante la mezcla de expertos y novatos, programadores senior y j&uacute;nior.</li>
    
<li>Los programadores conversan mejorando as&iacute; el flujo de informaci&oacute;n y la din&aacute;mica del equipo.</li>
    
<li>Los programadores disfrutan m&aacute;s su trabajo.</li>

</ul>
<p>Dichos beneficios se consiguen despu&eacute;s de varios meses de practicar la programaci&oacute;n en parejas.</p>
<a name="N103E6"></a><a name="Propiedad+Colectiva+del+C%C3%B3digo"></a>
<h3 class="underlined_5">Propiedad Colectiva del C&oacute;digo</h3>
<p>&iquest;Quien debe cambiar una clase que necesita modificarse? Cualquier programador puede mejorar cualquier parte del c&oacute;digo en cualquier momento, ya que el equipo entero es responsable de todo el c&oacute;digo. Cada integrante tiene el derecho y el deber de realizar modificaciones sobre cualquier parte del sistema cada vez que identifica una oportunidad de mejorarlo.</p>
<p>La propiedad colectiva es todo lo contrario a decir que es el proyecto el propietario del c&oacute;digo, ya que de este modo, nadie se hace responsable del c&oacute;digo ni tiene la obligaci&oacute;n de mejorarlo.</p>
<p>Tambi&eacute;n es diferente a decir que cada desarrollador es responsable de su c&oacute;digo (donde cada integrante solo se responsabiliza de su parte e ignora el resto). Esto conduce a una cultura de culpar e increpar a los compa&ntilde;eros. Uno de los objetivos de la propiedad colectiva es evitar la exclusividad y dependencia del c&oacute;digo respecto a un desarrollador, lo que puede dar pie a opiniones del estilo de <em>"es su c&oacute;digo, es su problema"</em>.</p>
<p>Esta pr&aacute;ctica motiva a todos a contribuir con nuevas ideas en todos los segmentos del sistema, evitando a la vez que alg&uacute;n programador sea imprescindible para realizar cambios en alguna porci&oacute;n de c&oacute;digo, fomentando la agilidad en los cambios.</p>
<p>Por supuesto, no todos los integrantes tienen el mismo nivel de conocimiento de cada aspecto del sistema, pero si los desarrolladores son conscientes de su nivel de conocimiento en un &aacute;rea problem&aacute;tica, pueden programar en pareja con alguien que si tiene la experiencia y conocimientos requeridos.</p>
<p>Un equipo que no sea XP puede encontrar esta pr&aacute;ctica problem&aacute;tica, ya que algunos desarrolladores mantienen relaciones de propiedad/pertenencia/posesi&oacute;n con el c&oacute;digo, siempre con un ojo sobre <em>"su"</em> c&oacute;digo. Ya sea por protegerlo, o por falta de confianza en el trabajo realizado, mantienen las afirmaciones de <em>"mi c&oacute;digo"</em> y <em>"vuestro c&oacute;digo"</em>. &iexcl;Esto es lo que debemos evitar!</p>
<a name="N1040B"></a><a name="Integraciones+Continuas"></a>
<h3 class="underlined_5">Integraciones Continuas</h3>
<p>Cada vez que se completa una tarea, el c&oacute;digo resultante debe integrarse con la construcci&oacute;n actual. Para ello, el c&oacute;digo debe pasar todas las pruebas unitarias (incluyendo las reci&eacute;n introducidas para probar la nueva funcionalidad). Cualquier problema encontrado debe resolverse inmediatamente. Una vez pasadas las pruebas, el nuevo c&oacute;digo se sube al sistema de control de versiones.</p>
<div class="frame note">
<div class="label">&iquest;Pregunta...?</div>
<div class="content">
&iquest;C&oacute;mo y cuando un equipo debe comprobar que el c&oacute;digo de cada uno de los integrantes funciona de forma correcta cuando se integran todos los elementos?
</div>
</div>
<p>Cada pieza de c&oacute;digo es integrada en el sistema una vez que est&eacute; lista. As&iacute;, el sistema puede llegar a ser integrado y construido varias veces en un mismo d&iacute;a. Todas las pruebas son ejecutadas y tienen que ser aprobadas para que el nuevo c&oacute;digo sea incorporado definitivamente.</p>
<p>Para tener un mayor control sobre el proyecto, las integraciones de los componentes y la calidad del mismo, es esencial el desarrollo de un proceso disciplinado y automatizado. La clave est&aacute; en la automatizaci&oacute;n. De este modo, el equipo XP est&aacute; m&aacute;s preparado para modificar el c&oacute;digo cuando sea necesario, debido a la confianza en la identificaci&oacute;n y correcci&oacute;n de los errores de integraci&oacute;n.</p>
<p>Para ello se debe disponer de una m&aacute;quina separada que corra un proceso 24/7 que se dedique a construir y probar el sistema de forma ininterrumpida. Cada vez que falla la integraci&oacute;n, se pueden tomar varias medidas, como pueda ser enviar un mail al &uacute;ltimo desarrollador que ha subido un cambio al servidor, o poner el sem&aacute;foro en rojo.</p>
<p>Esta t&eacute;cnica se estudia m&aacute;s adelante en la sesi&oacute;n 4&ordf; de "Pr&aacute;cticas &Aacute;giles - Integraciones Continuas", en concreto, mediante la herramienta <a class="external" href="http://cruisecontrol.sourceforge.net/">CruiseControl</a>.</p>
<a name="N1042B"></a><a name="Cliente+In-Situ"></a>
<h3 class="underlined_5">Cliente In-Situ</h3>
<p>&iquest;Cuantas veces hemos le&iacute;do un documento de requisitos y nos han aparecido dudas del tipo &iquest;esto que significa? &iquest;que pasa si cancela en este punto? ... Estas respuestas las tiene que ofrecer un cliente experto, por ejemplo, un usuario final que utilice el sistema.</p>
<p>El cliente tiene que estar presente y disponible todo el tiempo para el equipo. Gran parte del &eacute;xito del proyecto XP se debe a que es el cliente quien conduce constantemente el trabajo hacia lo que aportar&aacute; mayor valor de negocio y los programadores pueden resolver de manera inmediata cualquier duda asociada.</p>
<p>Destacar que las historias de usuario normalmente no ofrecen suficiente informaci&oacute;n para proceder a su implementaci&oacute;n. De hecho, se asume que el cliente in-situ comunicar&aacute; los detalles a los programadores cuando se requiera la informaci&oacute;n.</p>
<p>La comunicaci&oacute;n oral es m&aacute;s efectiva que la escrita, ya que esta &uacute;ltima toma mucho tiempo en generarse y puede tener m&aacute;s riesgo de ser mal interpretada. Por ello, se propone la pr&aacute;ctica &aacute;gil de <a href="sesion01-apuntes.html#habitacionComun">Habitaci&oacute;n Com&uacute;n</a>, de modo que los programadores y los clientes trabajen juntos en la misma habitaci&oacute;n.</p>
<p>As&iacute; pues, uno o m&aacute;s clientes (no confundir "el cliente" con "un cliente") deben permanecer, a ser posible, todo el tiempo con el equipo. De ellos se espera que sean expertos en la materia y que tengan peso suficiente en el proyecto para tomar decisiones relativas a las funcionalidades de os requisitos y sus prioridades.</p>
<p>En el caso de no poder disponer del cliente en la misma habitaci&oacute;n, algunas recomendaciones propuestas para dicha situaci&oacute;n son las siguientes:</p>
<ul>
    
<li>Intentar conseguir un representante que pueda estar siempre     disponible y que act&uacute;e como interlocutor del cliente.</li>
    
<li>Contar con el cliente al menos en las reuniones de planificaci&oacute;n.</li>
    
<li>Establecer visitas frecuentes de los programadores al cliente para validar el sistema.</li>
    
<li>Anticiparse a los problemas asociados estableciendo llamadas   telef&oacute;nicas frecuentes y conferencias.</li>
    
<li>Reforzar el compromiso de trabajo en equipo.</li>

</ul>
<a name="N1045A"></a><a name="Est%C3%A1ndares+de+Programaci%C3%B3n"></a>
<h3 class="underlined_5">Est&aacute;ndares de Programaci&oacute;n</h3>
<p>XP enfatiza la comunicaci&oacute;n de los programadores a trav&eacute;s del c&oacute;digo, con lo cual es indispensable que se sigan ciertos est&aacute;ndares de programaci&oacute;n (del
equipo, de la organizaci&oacute;n u otros est&aacute;ndares reconocidos para los lenguajes de programaci&oacute;n utilizados). Los est&aacute;ndares de programaci&oacute;n (<em>convenciones de c&oacute;digo</em>) mantienen el c&oacute;digo homog&eacute;neo y legible para los miembros del equipo, facilitando los cambios.</p>
<p>Debido a la propiedad colectiva del c&oacute;digo, la refactorizaci&oacute;n y la programaci&oacute;n por parejas, el c&oacute;digo debe cumplir un est&aacute;ndar.</p>
<p>Entre las ventajas m&aacute;s importante podemos destacar que:</p>
<ul>
    
<li>Se evitan discusiones tontas de si las llaves deben ir en la misma linea o en la posterior de una sentencia.</li>
    
<li>Cada integrante del equipo se siente c&oacute;modo con el estilo de codificaci&oacute;n adoptado, lo que facilita su lectura y comprensi&oacute;n.</li>
    
<li>Simples gu&iacute;as como "Todas las constantes en may&uacute;sculas" significan que tan pronto como se visualiza la convenci&oacute;n, se sabe el significado.</li>
    
<li>Ayudan a crear un entorno donde el c&oacute;digo se despersonaliza (sin propietarios ni creadores).</li>
    
<li>Facilitan las actividades de refactorizaci&oacute;n y programaci&oacute;n en parejas.</li>

</ul>
<p>Una caracter&iacute;stica esencial de los est&aacute;ndares de c&oacute;digo es que deben promover la simplicidad, y deben ser aceptadas por todos los integrantes del equipo. Ya sabemos que las imposiciones pocas veces funcionan, as&iacute; que es mejor llegar a un consenso sobre que est&aacute;ndar utilizar, ya sea uno propio del lenguaje (<a class="external" href="http://java.sun.com/docs/codeconv/">java.sun.com/docs/codeconv/</a>) o proyecto, convenciones a nivel de empresa (<a class="external" href="http://www.ambysoft.com/essays/javaCodingStandards.html">www.ambysoft.com/essays/javaCodingStandards.html</a>), cliente o una convenci&oacute;n recogida de Internet (<a class="external" href="http://www.ontko.com/java/java_coding_standards.html">www.ontko.com/java/java_coding_standards.html</a>) .</p>
<a name="N1048E"></a><a name="40+Horas+Por+Semana"></a>
<h3 class="underlined_5">40 Horas Por Semana</h3>
<p>&iquest;Qu&eacute; pasa cuando un equipo de desarrollo trabaja m&aacute;s de la cuenta porque no se llega a una fecha de entrega? El trabajo extra desmotiva al equipo. Un desarrollador cansado, desmotivado y deprimido no rinde. Es m&aacute;s, comete fallos.  Cuando no podemos pensar, siempre tomamos malas decisiones.</p>
<p>Un equipo de trabajo XP debe ser entusiasta, lleno de energ&iacute;a, y debe estar listo para afrontar retos. Por lo tanto, se debe trabajar un m&aacute;ximo de 40 horas por semana (de 35 a 45, pero nunca llegar a las 60-80 horas), con un ritmo de trabajo adecuado, as&iacute; como no trabajar horas extras en dos semanas seguidas.</p>
<div class="frame note">
<div class="label">&iquest;Pregunta...?</div>
<div class="content">
&iquest;Cual crees que es tu cantidad de tiempo productivo a la largo de un d&iacute;a? &iquest;Y durante una semana?</div>
</div>
<p>Si esto ocurre, tenemos un problema que debe corregirse. Los proyectos que requieren trabajo extra para intentar cumplir con los plazos, al final suelen entregarse con retraso. En lugar de esto se puede realizar el <a href="#juegoPlanificacion">Juego de la Planificaci&oacute;n</a> para cambiar el &aacute;mbito del proyecto o la fecha de entrega.</p>
<a name="N104A6"></a><a name="Met%C3%A1fora"></a>
<h3 class="underlined_5">Met&aacute;fora</h3>
<p>En XP no se enfatiza la definici&oacute;n temprana de una arquitectura estable para el sistema. Dicha arquitectura se asume evolutiva y los posibles inconvenientes que se generar&iacute;an por no contar con ella expl&iacute;citamente en el comienzo del
proyecto se solventan con la existencia de una met&aacute;fora.</p>
<p>El sistema se define mediante una met&aacute;fora o un conjunto de met&aacute;foras compartidas por el cliente y el equipo de desarrollo. Una met&aacute;fora es una historia compartida que describe c&oacute;mo deber&iacute;a funcionar el sistema, formando un conjunto de nombres que act&uacute;en como vocabulario para hablar sobre el dominio del problema. Este conjunto de nombres ayuda a la nomenclatura de clases y m&eacute;todos del sistema.</p>
<a name="N104B3"></a><a name="Comentarios+respecto+de+las+pr%C3%A1cticas"></a>
<h3 class="underlined_5">Comentarios respecto de las pr&aacute;cticas</h3>
<p>El mayor beneficio de las pr&aacute;cticas se consigue con su aplicaci&oacute;n conjunta y equilibrada puesto que se apoyan unas en otras. Esto se ilustra en las siguiente figura, donde una conexi&oacute;n entre dos pr&aacute;cticas significa que las dos pr&aacute;cticas se refuerzan entre s&iacute;.</p>
<p>
    
<img alt="Interacci&oacute;n de Pr&aacute;cticas XP" content-width="13.0cm" src="imagenes/s2/interaccionXP75.gif" width="475">
</p>
<p>Hasta que no hayamos probado las 12 pr&aacute;cticas conjuntas, no podemos decir realmente que hayamos seguido un enfoque XP. El todo completo es mucho m&aacute;s que la suma de las partes, y por lo tanto, s&oacute;lo obtendremos una soluci&oacute;n XP estable si seguimos las 12 pr&aacute;cticas.</p>
<p>As&iacute; pues, es un error aplicar un subconjunto de pr&aacute;cticas no compensadas, ya que unas se apoyan en otras. Primero hemos de probarlas todas y luego, dependiendo de nuestras circunstancias particulares, "customizar" aquellas pr&aacute;cticas que nos sean m&aacute;s &uacute;tiles.</p>
<a name="N104CE"></a><a name="%C2%BFQu%C3%A9+hay+de+eXtremo+en+la+Programaci%C3%B3n+eXtrema%3F"></a>
<h3 class="underlined_5">&iquest;Qu&eacute; hay de eXtremo en la Programaci&oacute;n eXtrema?</h3>
<p>La mayor&iacute;a de las pr&aacute;cticas propuestas por XP no son novedosas sino que de
alguna forma ya hab&iacute;an sido propuestas en Ingenier&iacute;a del Software e incluso demostrado su valor en la pr&aacute;ctica. El m&eacute;rito de XP es integrarlas de una forma efectiva y complementarlas con otras ideas desde la perspectiva del negocio, los valores humanos y el trabajo en equipo.</p>
<p>Pero, &iquest;qu&eacute; es lo que lo diferente que las hace extremas? La respuesta esta en que:</p>
<ol>
    
<li>XP es muy ligero, ya que realmente solo se centra en la parte de programaci&oacute;n de un sistema software.</li>
    
<li>XP toma un conjunto de pr&aacute;cticas que son exitosas y las lleva al extremo:
        <ul>
            
<li>Si las revisiones de c&oacute;digo son buenas, entonces revisaremos el c&oacute;digo continuamente (programaci&oacute;n en parejas).</li>
            
<li>Si las pruebas son buenas, todo el mundo realiza pruebas continuamente (pruebas unitarias), incluso los clientes (pruebas de aceptaci&oacute;n).</li>
            
<li>Si dise&ntilde;ar es bueno, entonces debe formar parte de lo que todos hacen cada d&iacute;a (refactorizar).</li>
            
<li>Si la simplicidad es buena, entonces siempre lucharemos por la soluci&oacute;n m&aacute;s simple (la soluci&oacute;n m&aacute;s simple que funcione).</li>
            
<li>Si la arquitectura es importante, entonces nos aseguraremos que todo el mundo se involucra en la creaci&oacute;n y refinamiento de la arquitectura durante todo el proyecto (met&aacute;fora).</li>
            
<li>Si las pruebas de integraci&oacute;n son buenas, entonces la integraci&oacute;n y las pruebas tienen que ser una todo (integraciones continuas) continuo (diarias o por horas).</li>
            
<li>Si las iteraciones cortas son buenas, entonces acort&eacute;moslas al m&aacute;ximo; por ejemplo, horas o d&iacute;as, no semanas o meses (juego de planificaci&oacute;n).</li>
        
</ul>
    
</li>

</ol>
</div> 



<a name="N104FF"></a><a name="Proceso+XP"></a>
<h2 class="underlined_10">Proceso XP</h2>
<div class="section">
<p>Un proyecto XP tiene &eacute;xito cuando el cliente selecciona el valor de negocio a implementar basado en la habilidad del equipo para medir la funcionalidad que puede entregar a trav&eacute;s del tiempo. El ciclo de desarrollo consiste (a grandes rasgos) en los siguientes pasos: 
</p>
<ol>
	
<li>El cliente define el valor de negocio a implementar.</li>
	
<li>El programador estima el esfuerzo necesario para su 	implementaci&oacute;n.</li>
	
<li>El cliente selecciona qu&eacute; construir, de acuerdo con sus prioridades y las restricciones de tiempo.</li>
	
<li>El programador construye ese valor de negocio.</li>
	
<li>Vuelve al paso 1.</li>

</ol>
<p>En todas las iteraciones de este ciclo tanto el cliente como el programador aprenden. No se debe presionar al programador a realizar m&aacute;s trabajo que el estimado, ya que se perder&aacute; calidad en el software o no se cumplir&aacute;n los plazos. De la misma forma el cliente tiene la obligaci&oacute;n de manejar el &aacute;mbito de entrega del producto, para asegurarse que el sistema tenga el mayor valor de negocio posible con cada iteraci&oacute;n.</p>
<a name="N1051D"></a><a name="Planificando+Proyectos+XP"></a>
<h3 class="underlined_5">Planificando Proyectos XP</h3>
<p>Dentro de XP, en vez de hacer una planificaci&oacute;n global describiendo el detalle de todas las tareas, se realiza una planificaci&oacute;n din&aacute;mica, donde se tiene una visi&oacute;n global solo a alto nivel, y se realizan planificaciones en detalle para cada iteraci&oacute;n o entrega. Aunque no lo parezca, mediante este planteamiento se realiza un mayor control sobre el proyecto, ya que las planificaciones son mucho m&aacute;s precisas, y en todo momento sabemos que esta sucediendo en el proyecto.</p>
<p>A continuaci&oacute;n se muestra un diagrama con las diferentes etapas de planificaci&oacute;n e implementaci&oacute;n dentro un proyecto XP.</p>
<p>
    
<img alt="Proceso XP" content-width="17cm" src="imagenes/s2/procesoXP.gif" width="610">
</p>
<p>Por ejemplo, comienza con un proceso de planificaci&oacute;n inicial del proyecto, durante el cual se esboza la planificaci&oacute;n global del proyecto. A esto le sigue una (o m&aacute;s de una) planificaci&oacute;n de entrega, donde se planifican los contenidos de la entrega, y las tareas a realizar para implementar dicha entrega. A continuaci&oacute;n, se implementa la entrega y los resultados de la retroalimentaci&oacute;n de la misma se utilizan como base de la planificaci&oacute;n de la siguiente iteraci&oacute;n. El equipo XP y el cliente planifican una iteraci&oacute;n, y con la retroalimentaci&oacute;n obtenida, la planificaci&oacute;n se adapta tras cada iteraci&oacute;n.</p>
<p>Respecto al diagrama cabe destacar que quiz&aacute;s sugiera una secuencia de eventos que fluyen de modo natural de un punto a otro. La realidad es que es un proceso iterativo, incremental y c&iacute;clico. Por ejemplo, si durante una iteraci&oacute;n observamos que la planificaci&oacute;n del proyecto y la realidad no coinciden, entonces el proyecto puedo volver al proceso de planificaci&oacute;n para considerar cualquier acci&oacute;n correctiva y replanificar el proyecto. Otra consideraci&oacute;n, es que los integrantes XP no perciben la vida tan ordenada, ya que se centran en el paso de la implementaci&oacute;n de la iteraci&oacute;n, siendo los otros pasos actividades adyacentes. Sin embargo, esta definici&oacute;n explicita del proceso facilita la compresi&oacute;n del mismo, y en realidad es como funciona un proyecto XP, pero de una forma m&aacute;s interactiva.</p>
<p>As&iacute; pues, &iquest;c&oacute;mo utilizamos el juego de la planificaci&oacute;n dentro del proyecto XP? &iquest;Cuando hacemos qu&eacute; y c&oacute;mo? En realidad existen 2 tipos de juegos de planificaci&oacute;n:</p>
<ul>
    
<li>El juego de planificaci&oacute;n inicial</li>
    
<li>El juego de planificaci&oacute;n de entrega</li>

</ul>
<p>Generalmente, existe otro paso entre estos, conocido como la fase/proceso de  Elaboraci&oacute;n. Este proceso permite aclarar las historias de usuarios sin las restricciones del juego.</p>
<p>Por lo tanto, un proyecto t&iacute;pico XP se puede planificar del siguiente modo:</p>
<ol>
    
<li>Un juego de planificaci&oacute;n inicial (cuyo objetivo es obtener una visi&oacute;n global del proyecto)</li>
    
<li>Proceso de elaboraci&oacute;n inicial (centrado en las historias de usuario de alto nivel)</li>
    
<li>Juego de Planificaci&oacute;n de la Entrega 1</li>
    
<li>Proceso de Elaboraci&oacute;n de la Entrega 1 (si fuera necesario)</li>
    
<li>Planificaci&oacute;n de la iteraci&oacute;n 1</li>
    
<li>...Iteraci&oacute;n/Implementaci&oacute;n de la Entrega 1...</li>
    
<li>Juego de Planificaci&oacute;n de la Entrega 2</li>
    
<li>Proceso de Elaboraci&oacute;n de la Entrega 2 (si fuera necesario)</li>
    
<li>Planificaci&oacute;n de la iteraci&oacute;n 2</li>
    
<li>...Iteraci&oacute;n/Implementaci&oacute;n de la Entrega 2...</li>
    
<li>...</li>
    
<li>Juego de Planificaci&oacute;n de la Entrega N</li>
    
<li>Proceso de Elaboraci&oacute;n de la Entrega N (si fuera necesario)</li>
    
<li>Planificaci&oacute;n de la iteraci&oacute;n N</li>
    
<li>...Iteraci&oacute;n/Implementaci&oacute;n de la Entrega N</li>

</ol>
<a name="N1057B"></a><a name="El+Juego+de+Planificaci%C3%B3n+Inicial"></a>
<h3 class="underlined_5">El Juego de Planificaci&oacute;n Inicial</h3>
<p>Se centra en lo que tiene que realizar el sistema como lo har&iacute;a un todo, como un producto. Considera todas las historias de usuario que est&aacute;n dentro del alcance (y de hecho se define el alcance del proyecto).</p>
<p>Se realiza al inicio del proyecto y se puede volver a convocar en ciertos momentos del proyecto para revisar el alcance del sistema, el conjunto de historias de usuario, sus prioridades, etc...</p>
<a name="N10588"></a><a name="El+Juego+de+Planificaci%C3%B3n+de+Entrega"></a>
<h3 class="underlined_5">El Juego de Planificaci&oacute;n de Entrega</h3>
<p>Se centra en los contenidos de una entrega o iteraci&oacute;n. Contiene los mismos pasos que el juego de planificaci&oacute;n inicial, pero el nivel de detalle necesario para considerar los detalles es mucho mayor. Durante el Juego de Planificaci&oacute;n Inicial debe quedar definida la planificaci&oacute;n global del proyecto. Al inicio de una entrega, se necesitan determinar los detalles de lo que contendr&aacute; la entrega. Esto significa que:</p>
<ol>
    
<li>Se desarrollan las historias de usuario y quiz&aacute;s necesiten partirse en historias de usuario m&aacute;s peque&ntilde;as (para que puedan implementarse en una iteraci&oacute;n).</li>
    
<li>Se obtienen las estimaciones detalladas y las prioridades de las historias.</li>
    
<li>Se confirman las historias de usuarios que se implementar&aacute;n dentro de la entrega. Tambi&eacute;n puede ser necesario la revisi&oacute;n o modificaci&oacute;n de las historias que as&iacute; lo requieran.</li>
    
<li>Se revisa la velocidad del proyecto. Por ejemplo, conforme el equipo XP obtiene mayor experiencia y conocimiento de la aplicaci&oacute;n, el equipo cada vez ser&aacute; m&aacute;s r&aacute;pido.</li>

</ol>
<p>Al completar el juego de planificaci&oacute;n de entrega, puede ser que posteriormente necesitemos explorar algunas historias de usuario (o sus repercusiones). Esto ocurrir&aacute; durante el proceso de elaboraci&oacute;n. Al acabar este proceso, durante el proceso de planificaci&oacute;n de la iteraci&oacute;n, tendremos las tareas de la iteraci&oacute;n planificadas en detalle.</p>
<a name="N105A4"></a><a name="El+Proceso+de+Elaboraci%C3%B3n"></a>
<h3 class="underlined_5">El Proceso de Elaboraci&oacute;n</h3>
<p>Se realiza a continuaci&oacute;n del juego de planificaci&oacute;n inicial y, normalmente, a menor escala tras un juego de planificaci&oacute;n de entrega. Durante esta fase, se realiza un estudio de las historias de usuario para estimar, aclarar los requisitos, o cualquier aspecto t&eacute;cnico. Los objetivos de este proceso son:</p>
<ul>
    
<li>Minimizar los riesgos de una mala estimaci&oacute;n.</li>
    
<li>Experimentar/prototipar las diferentes soluciones.</li>
    
<li>Mejorar la compresi&oacute;n del dominio/tecnolog&iacute;a por parte del equipo de desarrollo.</li>
    
<li>Confirmar que los procesos y procedimientos necesarios est&aacute;n en su lugar.</li>

</ul>
<p>Entre los juegos de planificaci&oacute;n inicial y de entrega, el proceso de elaboraci&oacute;n puede durar desde un d&iacute;a, un mes o varios meses, dependiendo del nivel de experiencia de los equipos de desarrollo sobre el dominio a analizar, las tecnolog&iacute;as disponibles y los m&eacute;todos a utilizar. Entre las entregas, el proceso de elaboraci&oacute;n es mucho m&aacute;s corto, normalmente unos pocos d&iacute;as.</p>
<a name="N105C0"></a><a name="Planificaci%C3%B3n+de+la+Iteraci%C3%B3n"></a>
<h3 class="underlined_5">Planificaci&oacute;n de la Iteraci&oacute;n</h3>
<p>Hay 2 aspectos a considerar a la hora de planificar una iteraci&oacute;n:</p>
<ol>
    
<li>
<strong>El tama&ntilde;o de la iteraci&oacute;n</strong>. &iquest;C&oacute;mo determinar cual deber&iacute;a ser el tama&ntilde;o de una iteraci&oacute;n? La respuesta es que la iteraci&oacute;n tiene que ser suficientemente grande para permitir tanto crear una nueva entrega que a&ntilde;ade valor al negocio, como ser capaz de realizar un progreso significativo. Sin embargo, deber&iacute;a suficientemente peque&ntilde;o para se desarrolle demasiado sin que se realiza una revisi&oacute;n (mediante otro juego de planificaci&oacute;n de entrega, etc...). La duraci&oacute;n cl&aacute;sica para una iteraci&oacute;n XP var&iacute;a de 1 a 3 semanas. Normalmente, los proyectos XP que son peque&ntilde;os/medianos involucran de 2 a 6 desarrolladores, como mucho 10. Esto limita la cantidad de trabajo que se pueden realizar para dentro de 2 o 3 semanas. Por ejemplo, si tenemos un equipo de 6 personas y la iteraci&oacute;n dura 2 semanas, entonces como mucho tenemos 12 personas/semana con las que contar.</li>
    
<li>
<strong>La propia planificaci&oacute;n</strong>. Es decir, definir que se deber&iacute;a hacer dentro de la iteraci&oacute;n para implementar las historias de usuario. Si el juego de planificaci&oacute;n identifica que nuevas funcionalidades deber&iacute;an a&ntilde;adirse al sistema evolutivo dentro de la actual iteraci&oacute;n, entonces la planificaci&oacute;n de la iteraci&oacute;n definir&aacute; como se tienen que conseguir dichas funcionalidades.</li>

</ol>
<p>Durante la planificaci&oacute;n de la iteraci&oacute;n, las historias de usuario se convierten en <strong>tareas</strong> que resultar&aacute;n en la implementaci&oacute;n de la historia. Una historia de usuario se puede implementar por una sola tarea, o por muchas tareas. Una tarea a su vez puede agrupar varias historias. Normalmente, una historia se implementa mediante una o m&aacute;s tareas. Algunas tareas puede que no est&eacute;n relacionadas directamente con una historia, como pueda ser migrar la aplicaci&oacute;n a la &uacute;ltima versi&oacute;n de Java.</p>
<p>La planificaci&oacute;n de la iteraci&oacute;n normalmente incorpora las siguientes fases:</p>
<ol>
    
<li>Evaluaci&oacute;n de las &uacute;ltimas iteraciones para analizar las lecciones aprendidas, cambios a realizar, etc...</li>
    
<li>Revisar las historias de usuario a incorporar en la iteraci&oacute;n, teniendo en cuenta:
        <ul>
            
<li>historias de usuario no abordadas</li>
            
<li>velocidad del proyecto</li>
            
<li>pruebas de aceptaci&oacute;n no superadas en la iteraci&oacute;n anterior</li>
            
<li>tareas no terminadas en la iteraci&oacute;n anterior.</li>
        
</ul>
    
</li>
    
<li>Exploraci&oacute;n de las tareas escritas para las historias de usuario. Estas tareas se puede dividir en tareas menores para ayudar a planificar y estimar. Esto, normalmente, ocurre cuando un desarrollador voluntariamente divide una historias de usuario en una o m&aacute;s tareas, ya que saben como atacar dichas tareas. Para dividir una historia, se necesita al menos a otro desarrollador (estilo programaci&oacute;n en parejas) para ayudarle con el an&aacute;lisis. Conforme progresa este paso, puede necesitar la ayuda del cliente o de otros desarrolladores. Por lo tanto, el cliente in-situ es clave para el &eacute;xito durante el proceso de la planificaci&oacute;n de la iteraci&oacute;n.</li>
    
<li>Compromiso de las tareas durante la estimaci&oacute;n de las mismas, carga de trabajo de los desarrolladores, etc...</li>
    
<li>Finalmente, se verifica y valida la planificaci&oacute;n de la iteraci&oacute;n.</li>

</ol>
<p>Todo este proceso no deber&iacute;a llevar m&aacute;s de 1 o 2 d&iacute;as (y quiz&aacute;s menos). El resultado final es un conjunto de tareas identificadas, ordenadas y  priorizadas. La programaci&oacute;n en parejas trabaja estas tareas durante la iteraci&oacute;n. La idea es que los desarrolladores autoseleccionen las tareas, eligiendo primero aquellas tareas que tienen mayor prioridad y comiencen a desarrollarlas. Existen 2 enfoques posibles para esto:</p>
<ul>
    
<li>
<strong>Elegir una tarea cada vez</strong>: un desarrollador elige una &uacute;nica tarea a implementar, y procede a su realizaci&oacute;n. Una vez acabada, seleccionar&aacute; otra tarea y as&iacute; hasta que no queden tareas pendientes o termine la iteraci&oacute;n.</li>
    
<li>
<strong>Llena tu mochila</strong>: se realiza un proceso de selecci&oacute;n de tareas de tipo <em>round robin</em>: cada desarrollador elige una o m&aacute;s tareas que le gustar&iacute;a realizar. En general, los desarrolladores eligen primero aquellas tareas que previamente hab&iacute;an identificado, analizado y estimado. Este proceso contin&uacute;a hasta que no quedan historias o hasta que la duraci&oacute;n de las estimaci&oacute;n coincide con la duraci&oacute;n de la iteraci&oacute;n. Cada desarrollador conoce el conjunto de tareas que tiene asignado para la iteraci&oacute;n actual. Esto puede cambiar conforme progresa la iteraci&oacute;n, ya que algunos desarrolladores pueden quedarse bloqueados con alguna tarea en particular mientras que otros se sienten agraciados y completan sus tareas m&aacute;s r&aacute;pidamente.</li>

</ul>
<p>Es importante recordar que como metodolog&iacute;a iterativa, las iteraciones son a tiempo cerrado (<em>timeboxed</em>), y tras cada iteraci&oacute;n se obtiene una versi&oacute;n del producto usable, lo que no quiere decir que sea una versi&oacute;n de entrega (<em>release</em>).</p>
<p>
En resumen, al inicio del proyecto se define el alcance completo del sistema, y se esbozan las iteraciones y entregas. A continuaci&oacute;n, el equipo elabora las historias de usuario (centr&aacute;ndose en aquellas que no saben estimar). Tras esto, se planifica e implementa una iteraci&oacute;n, durante la cual se consideran en detalle las tareas que forman parte de cada historia de usuario.</p>
</div>



<a name="N10621"></a><a name="Roles+XP"></a>
<h2 class="underlined_10">Roles XP</h2>
<div class="section">
<p>A continuaci&oacute;n se detallen los roles de XP agrupados por categor&iacute;as:
</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>
	
<th colspan="1" rowspan="1">Cliente</th>
	<th colspan="1" rowspan="1">Desarrollo</th>

</tr>

<tr>
	
<td colspan="1" rowspan="1">
		
<dl>
			
<dt>Cliente</dt>
			
<dd>Escribe las historias de usuario y las pruebas funcionales para 	validar su implementaci&oacute;n. Adem&aacute;s, asigna la prioridad a las historias de usuario y decide cu&aacute;les se implementan en cada iteraci&oacute;n centr&aacute;ndose en aportar mayor valor al negocio. El cliente es s&oacute;lo uno dentro del proyecto pero puede corresponder a un interlocutor que est&aacute; representando a varias personas que se ver&aacute;n afectadas por el sistema.</dd>
		
</dl>
	
</td>
	<td colspan="1" rowspan="1">
		
<dl>
			
<dt>Programador</dt>
			
<dd>Escribe las pruebas unitarias, refactoriza y produce el c&oacute;digo del sistema.<br>
            Adem&aacute;s, identifica las tareas y estima su duraci&oacute;n.<br>
            Debe existir una comunicaci&oacute;n y coordinaci&oacute;n adecuada entre los programadores y otros miembros del equipo.</dd>
			
<dt>Encargado de Pruebas (<em>Tester</em>)</dt>
			
<dd>Ayuda al cliente a escribir las pruebas funcionales. Ejecuta las pruebas regularmente, difunde los resultados en el equipo y es responsable de las herramientas de soporte para pruebas.</dd>
		
</dl>
	
</td>

</tr>

<tr>
	
<th colspan="1" rowspan="1">Gesti&oacute;n</th>
	<th colspan="1" rowspan="1">Otros</th>

</tr>

<tr>
	
<td colspan="1" rowspan="1">
		
<dl>
			
<dt>Entrenador/Tutor (<em>Coach</em>)</dt>
			
<dd>Es responsable del proceso global. Es necesario que conozca a fondo el proceso XP para proveer gu&iacute;as a los miembros del equipo de forma que se apliquen las pr&aacute;cticas XP y se siga el proceso correctamente.</dd>
			
<dt>Gestor (<em>Big boss</em>)</dt>
			
<dd>Es el v&iacute;nculo entre clientes y programadores, ayuda a que el equipo trabaje efectivamente creando las condiciones adecuadas. Su labor esencial es de coordinaci&oacute;n.</dd>
			
<dt>Encargado de seguimiento/Perseguidor (<em>Tracker</em>)</dt>
			
<dd>Proporciona realimentaci&oacute;n al equipo en el proceso XP. Su responsabilidad es verificar el grado de acierto entre las estimaciones realizadas y el tiempo real dedicado, comunicando los resultados para mejorar futuras estimaciones.<br>
            Tambi&eacute;n realiza el seguimiento del progreso de cada iteraci&oacute;n y eval&uacute;a si los objetivos son alcanzables con las restricciones de tiempo y recursos presentes. Determina cu&aacute;ndo es necesario realizar alg&uacute;n cambio para lograr los objetivos de cada iteraci&oacute;n.</dd>
		
</dl>
	
</td>
	<td colspan="1" rowspan="1">
		
<dl>
			
<dt>Consultor</dt>
			
<dd>Es un miembro externo del equipo con un conocimiento espec&iacute;fico en alg&uacute;n tema necesario para el proyecto. Gu&iacute;a al equipo para resolver un problema espec&iacute;fico.</dd>
		
</dl>
	
</td>

</tr>

</table>
</div> 


<a name="N106AC"></a><a name="Para+Saber+M%C3%A1s"></a>
<h2 class="underlined_10">Para Saber M&aacute;s</h2>
<div class="section">
<a name="N106B2"></a><a name="Bibliograf%C3%ADa"></a>
<h3 class="underlined_5">Bibliograf&iacute;a</h3>
<ul>

<li>
<strong>Extreme Programming Explained. Embrace Change</strong>, de <em>Kent Beck</em>. El libro por excelencia de Programaci&oacute;n eXtrema, donde se present&oacute; la metodolog&iacute;a y el cual ha sido la base para una gran biblioteca.</li>

<li>
<strong>Agile Software Construction</strong>, de <em>John Hunt</em>. Centrado en XP, Modelado &Aacute;gil y FDD.</li>

<li>Toda la Serie XP de libros editados por Addison Wesley: <a class="external" href="http://www.informit.com/series/series.asp?st=44007&amp;rl=1">XP Series</a>
</li>

</ul>
<a name="N106D2"></a><a name="Enlaces"></a>
<h3 class="underlined_5">Enlaces</h3>
<ul>

<li>Wiki original Programaci&oacute;n eXtrema (ingl&eacute;s): <a class="external" href="http://www.extremeprogramming.org">www.extremeprogramming.org</a>
</li>

<li>Wiki sobre Programaci&oacute;n eXtrema (traducci&oacute;n del ingl&eacute;s): <a class="external" href="http://www.programacionextrema.org">www.programacionextrema.org</a>
</li>

<li>Portal creado por Ron Jeffries sobre Programaci&oacute;n eXtrema: <a class="external" href="http://www.xprogramming.com">www.xprogramming.com</a>

</li>

</ul>
</div>


<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006-2007 Depto. CCIA</div>
</div>
</body>
</html>
