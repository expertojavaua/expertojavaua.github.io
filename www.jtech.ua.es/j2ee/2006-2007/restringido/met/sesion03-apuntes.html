<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Modelado &Aacute;gil</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario en Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Metodologias de Desarrollo" src="images/baner_j2ee_der.gif" title="Metodologias de Desarrollo"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Metodolog&iacute;as de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Metodolog&iacute;as de Desarrollo</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Metodolog&iacute;as de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html" title="Sesi&oacute;n 1: Metodolog&iacute;as &Aacute;giles">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="Sesi&oacute;n 2: Programaci&oacute;n eXtrema">Sesi&oacute;n 2</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 3</div>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html" title="Sesi&oacute;n 4: Pr&aacute;cticas &Aacute;giles">Sesi&oacute;n 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion03-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Modelado &Aacute;gil</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Agile+Modeling+%28AM%29">Agile Modeling (AM)</a>
<ul class="minitoc">
<li>
<a href="#Objetivos+y+Valores">Objetivos y Valores</a>
</li>
<li>
<a href="#%C2%BFQu%C3%A9+es+un+Modelo+%C3%81gil%3F">&iquest;Qu&eacute; es un Modelo &Aacute;gil?</a>
</li>
<li>
<a href="#%C2%BFQu%C3%A9+es+%28y+no+es%29+el+Modelado+%C3%81gil%3F">&iquest;Qu&eacute; es (y no es) el Modelado &Aacute;gil?</a>
</li>
</ul>
</li>
<li>
<a href="#Principios">Principios</a>
<ul class="minitoc">
<li>
<a href="#Principios+Centrales">Principios Centrales</a>
</li>
<li>
<a href="#Principios+Adicionales">Principios Adicionales</a>
</li>
</ul>
</li>
<li>
<a href="#Pr%C3%A1cticas">Pr&aacute;cticas</a>
<ul class="minitoc">
<li>
<a href="#Pr%C3%A1cticas+Centrales">Pr&aacute;cticas Centrales</a>
</li>
<li>
<a href="#Pr%C3%A1cticas+Adicionales">Pr&aacute;cticas Adicionales</a>
</li>
</ul>
</li>
<li>
<a href="#Artefactos">Artefactos</a>
</li>
<li>
<a href="#Escenario+%C3%81gil">Escenario &Aacute;gil</a>
</li>
<li>
<a href="#Desarrollo+%C3%81gil+Dirigido+por+el+Modelo+%28AMDD%29">Desarrollo &Aacute;gil Dirigido por el Modelo (AMDD)</a>
<ul class="minitoc">
<li>
<a href="#Modelado+Inicial">Modelado Inicial</a>
</li>
<li>
<a href="#Modelado+Detallado">Modelado Detallado</a>
</li>
</ul>
</li>
<li>
<a href="#Documentaci%C3%B3n+%C3%81gil">Documentaci&oacute;n &Aacute;gil</a>
</li>
<li>
<a href="#Trabajando+con+la+Pizarra">Trabajando con la Pizarra</a>
</li>
<li>
<a href="#Adoptando+AM">Adoptando AM</a>
</li>
<li>
<a href="#Para+Saber+M%C3%A1s">Para Saber M&aacute;s</a>
<ul class="minitoc">
<li>
<a href="#Bibliograf%C3%ADa">Bibliograf&iacute;a</a>
</li>
<li>
<a href="#Enlaces">Enlaces</a>
</li>
</ul>
</li>
</ul>
</div>


<a name="N1000C"></a><a name="Agile+Modeling+%28AM%29"></a>
<h2 class="underlined_10">Agile Modeling (AM)</h2>
<div class="section">
<p>El Modelado &Aacute;gil (AM) fue propuesto por <em>Scott Ambler</em> no tanto como un metodolog&iacute;a &aacute;gil cerrada en s&iacute; misma, sino como complemento de otras metodolog&iacute;as, sean &eacute;stas &aacute;giles o convencionales. AM no es proceso completo ni un metodolog&iacute;a &aacute;gil, sino un conjunto de principios y pr&aacute;cticas para modelar y realizar el an&aacute;lisis de requisitos, complementando a la mayor&iacute;a de metodolog&iacute;as iterativas. <em>Ambler</em> recomienda su uso con XP, RUP o cualquier otra metodolog&iacute;a. En el caso de XP los practicantes podr&iacute;an definir mejor los procesos de modelado que en ellos faltan, y en el caso de RUP, el modelado &aacute;gil permite hacer m&aacute;s ligeros los procesos que ya usan.</p>
<p>
    
<img alt="AM complementa a las Metodolog&iacute;as Base" content-width="15cm" src="imagenes/s3/amMejora.gif" width="630">
</p>
<p>AM es una estrategia de modelado (de clases, de datos, de procesos) pensada para contrarrestar la sospecha de que los m&eacute;todos &aacute;giles no modelan y no documentan. Se la podr&iacute;a definir como un proceso de software basado en pr&aacute;cticas cuyo objetivo es orientar el modelado de una manera efectiva y &aacute;gil. AM promueve el uso de pr&aacute;cticas que fomentan la velocidad, simplicidad y el flujo de creatividad, siguiendo una pol&iacute;tica de detalle vs tecnolog&iacute;a (<em>low-tech, high-touch</em>), de modo que se utilicen procedimientos pr&aacute;cticos en detrimento de t&eacute;cnicos</p>
<a name="N1002A"></a><a name="Objetivos+y+Valores"></a>
<h3 class="underlined_5">Objetivos y Valores</h3>
<p>Los principales objetivos de AM son:</p>
<ul>
    
<li>Definir y mostrar de qu&eacute; manera se deben poner en pr&aacute;ctica una colecci&oacute;n de valores, principios y pr&aacute;cticas que conducen al modelado ligero.</li>
    
<li>Describir como aplicar las t&eacute;cnicas de modelado en equipos que desarrollan software mediante un enfoque &aacute;gil.</li>
    
<li>Describir como mejorar las actividades de modelado mediante un enfoque "casi-&aacute;gil", en particular, en proyectos que sigan una metodolog&iacute;a similar a RUP.</li>

</ul>
<p>Los valores de AM incluyen a los de XP: <em>comunicaci&oacute;n, simplicidad, feedback y coraje</em>, a&ntilde;adiendo <strong>humildad</strong>. La humildad porque hemos de admitir que quiz&aacute;s no lo sepamos todo, que el resto de compa&ntilde;eros tienen cosas que aportar a los proyectos.</p>
<a name="N10049"></a><a name="%C2%BFQu%C3%A9+es+un+Modelo+%C3%81gil%3F"></a>
<h3 class="underlined_5">&iquest;Qu&eacute; es un Modelo &Aacute;gil?</h3>
<p>Un modelo es una abstracci&oacute;n que describe uno o m&aacute;s aspectos de un problema o de una posible soluci&oacute;n a un problema. Tradicionalmente, la palabra modelo es sin&oacute;nimo de 0 o m&aacute;s diagramas anexos a la documentaci&oacute;n. Sin embargo, tambi&eacute;n son modelos los artefactos no-gr&aacute;ficos, como las tarjetas CRC, la descripci&oacute;n textual de una o m&aacute;s reglas de negocio, o la descripci&oacute;n en pseudo-c&oacute;digo de un proceso de negocio.</p>
<p>Un modelo &aacute;gil es un modelo <strong>suficientemente bueno</strong>. Pero, &iquest;c&oacute;mo saber si un modelo es suficientemente bueno? Un modelo es &aacute;gil si:</p>
<ul>
    
<li>
<strong>Cumple con su prop&oacute;sito</strong>, ya sea para comunicar o para comprender.</li>
    
<li>
<strong>Es comprensible</strong> por la audiencia a la que van dirigidos. Un modelo valido para el equipo de desarrollo no nos va a servir para mostrarlo a los usuarios.</li>
    
<li>
<strong>Es suficientemente preciso</strong>. Lo normal es no necesitar el 100% de precisi&oacute;n en un modelo.</li>
    
<li>
<strong>Es suficientemente consistente</strong>. Nos podemos permitir nombrar al mismo elemento de forma diferente en 2 modelos distintos (contrase&ntilde;a y password), siempre y cuando quede claro que es el mismo objeto.</li>
    
<li>
<strong>Esta suficientemente detallado</strong>, dependiendo de la audiencia y del proyecto.</li>
    
<li>
<strong>Aporta valor</strong> positivo. Es decir, es un modelo que vale la pena realizar, y que no conlleva m&aacute;s esfuerzos que lo que llega a aportar. No lo hacemos por obligaci&oacute;n.</li>
    
<li>
<strong>Es tan simple como sea posible</strong>. Siempre hemos de tener el principio KISS en mente.</li>

</ul>
<p>
    
<img alt="AM complementa a las Metodolog&iacute;as Base" content-width="11cm" src="imagenes/s3/graficaSB.gif" width="389">
</p>
<a name="N10088"></a><a name="%C2%BFQu%C3%A9+es+%28y+no+es%29+el+Modelado+%C3%81gil%3F"></a>
<h3 class="underlined_5">&iquest;Qu&eacute; es (y no es) el Modelado &Aacute;gil?</h3>
<p>Una de las mejores maneras de explicar algo es mediante lo que un sistema es y no es. As&iacute; pues, los alcances de AM son:</p>
<ol>
    
<li>
<strong>AM es una actitud, no un proceso prescriptivo</strong>. Comprende una colecci&oacute;n de valores a los que los modeladores &aacute;giles se adhieren, principios en los que creen y pr&aacute;cticas que aplican. Describe un estilo de modelado; no es un recetario de cocina.</li>
    
<li>
<strong>AM es suplemento de otras metodolog&iacute;as</strong>. El primer foco es el modelado y el segundo la documentaci&oacute;n. AM se debe complementar con otras metodolog&iacute;as base (XP, RUP, ...)</li>
    
<li>
<strong>AM es un modo de trabajar en equipo</strong>. Fomenta tanto el trato entre iguales (desarrolladores) como desarrollador-cliente. No hay "yo" en AM ("<em>There is no I in agile</em>").</li>
    
<li>
<strong>AM es efectivo y trata sobre ser efectivo</strong>. AM ayuda a crear un modelo o proceso cuando se tiene un prop&oacute;sito claro y se comprenden las necesidades de la audiencia; contribuye a aplicar los artefactos correctos para afrontar la situaci&oacute;n inmediata y a crear los modelos m&aacute;s simples que sea posible. No se ha de hacer m&aacute;s del m&iacute;nimo que cumpla.</li>
    
<li>
<strong>AM es algo que funciona en la pr&aacute;ctica, no una teor&iacute;a acad&eacute;mica</strong>. Las pr&aacute;cticas han sido discutidas desde 2001 en comunidad (<a class="external" href="http://www.agilemodeling.com/feedback.htm">www.agilemodeling.com/feedback.htm</a>).</li>
    
<li>
<strong>AM no es una bala de plata</strong>. Se trata de una t&eacute;cnica efectiva para mejorar el desarrollo, no de la gallina de los huevos de oro.</li>
    
<li>
<strong>AM es para el programador promedio, pero no reemplaza a la gente competente</strong>. Se necesitan conocimientos b&aacute;sicos, y cuantas m&aacute;s t&eacute;cnicas de modelado, mejor.</li>
    
<li>
<strong>AM no es un ataque a la documentaci&oacute;n</strong>. La documentaci&oacute;n debe ser m&iacute;nima y relevante, pero es obligatoria. Es decir, los modeladores &aacute;giles crean documentaci&oacute;n, pero aquella que m&aacute;xima los esfuerzos invertidos en su creaci&oacute;n y mantenimiento.</li>
    
<li>
<strong>AM no es un ataque a las herramientas CASE</strong>. El uso de las herramientas m&aacute;s sencillas, en ocasiones supondr&aacute; utilizar una hoja de papel o una pizarra, y en otras ocasiones, una herramienta CASE.</li>

</ol>
</div>


<a name="N100CA"></a><a name="Principios"></a>
<h2 class="underlined_10">Principios</h2>
<div class="section">
<a name="N100D0"></a><a name="Principios+Centrales"></a>
<h3 class="underlined_5">Principios Centrales</h3>
<p>Los principios centrales son aquellos que se deben adoptar para realmente poder afirmar que se est&aacute; realizando un modelado &aacute;gil. Igual que con XP, estos principios se tienen que tomar como un conjunto, ya que los principios por separado pierden efectividad.</p>
<ul>
    
<li>
<strong>El software es el principal objetivo</strong>. Los modelos son un medio hacia el fin; el fin es construir software para el cliente. La documentaci&oacute;n y el dise&ntilde;o deben servir para conseguir este objetivo. Cualquier actividad que no contribuya a este objetivo deber&iacute;a cuestionarse , y si no puede justificarse, entonces la evitaremos.</li>
    
    
<li>
<strong>Permitir el siguiente esfuerzo</strong>. El desarrollo no es una actividad aislada; otros desarrolladores necesitaran extender o mejorar nuestro proyecto cuando ya no estemos. As&iacute; pues, debemos garantizar que el sistema es suficientemente robusto (mediante los modelos y documentaci&oacute;n suficientemente necesaria) para admitir mejoras posteriores; debe ser un objetivo, pero no el primordial.
    <div class="frame note">
<div class="label">Consejo</div>
<div class="content">
    Hay que pensar en los que vengan detr&aacute;s, ya que podemos volver a ser nosotros de nuevo. Ten siempre un ojo en el futuro.
    </div>
</div>
    
</li>
    
    
<li>
<a name="viajarLigero"></a><strong>Viajar ligero de equipaje</strong>. No crear m&aacute;s modelos de los necesarios, s&oacute;lo los justos. Con pocos modelos el equipo perder&aacute; su camino, y con demasiados, olvidar&aacute;n el objetivo principal de desarrollar software y no documentos. Hemos de tener en cuenta que cada modelo que creemos y decidamos conservar, hemos de mantenerlo hasta el final. Por ejemplo, si tenemos 7 modelos, y ocurre un cambio, hemos de considerar el impacto del cambio en los 7 modelos. Si solo decidimos mantener 3 modelos, las cosas se simplifican. Adem&aacute;s de la cantidad, hemos de vigilar la complejidad de los modelos (cuantos m&aacute;s dif&iacute;ciles, m&aacute;s pesan)</li>

    
<li>
<strong>Asumir simplicidad</strong>. Mant&eacute;n los modelos tan simples como puedas, teniendo en cuenta que la soluci&oacute;n m&aacute;s simple es la mejor. Modela s&oacute;lo lo que necesitas para hoy y conf&iacute;a en que puedes remodelar si fuese necesario.</li>

    
<li>
<strong>Abrazar los cambios</strong>. Conforme crezca el conocimiento que tenemos del proyecto, suceder&aacute;n los cambios. Adem&aacute;s, aparecer&aacute;n nuevos requisitos. En vez de luchar contra los cambios, hemos de aceptarlos y tener el valor de reconstruir los modelos.</li>
    
    
<li>
<strong>Cambio incremental</strong>. Los modelos no tienen porque estar bien a la primera; cambiar&aacute;n conforme se desarrolle el proyecto, mediante peque&ntilde;os cambios. Adem&aacute;s, no es necesario capturar todos los detalles en los modelos. Cuando se necesiten, se ir&aacute;n a&ntilde;adiendo.</li>    
    
    
<li>
<a name="modelarProposito"></a><strong>Modelar con un prop&oacute;sito</strong>. Si no se puede identificar por qu&eacute; se est&aacute; haciendo algo &iquest;porqu&eacute; molestarse? El primer paso es identificar un prop&oacute;sito valido para el modelo y a quien va enfocado (<em>audiencia</em>). A partir del prop&oacute;sito y la audiencia, desarrollaremos el modelo hasta el punto que sea suficientemente preciso y suficientemente detallado.
    <div class="frame note">
<div class="label">&iquest;Pregunta...?</div>
<div class="content">
    Un modelo que he realizado yo mismo y para mi con el objetivo de comprender mejor un subsistema de la aplicaci&oacute;n, &iquest; Puede servirle a un equipo de mantenimiento ? 
    </div>
</div>
    
</li>
        
    
<li>
<strong>M&uacute;ltiples modelos</strong>. Existen muchas maneras de modelar una soluci&oacute;n: elige aquella que mejor encaja con tu situaci&oacute;n. Por ejemplo, los modelos de datos para el equipo de base de datos. Cuando tengas la oportunidad, expande el conjunto de t&eacute;cnicas que conoces y aprende nuevas. Y recuerda que UML es un buen punto de partida, pero no es la panacea, existen otras soluciones.
    </li>

    
<li>
<strong>Trabajo de calidad</strong>. No hace falta que sea perfecto, solo suficientemente bueno, pero siempre teniendo en mente la calidad. Si un modelo no comunica, no es un buen modelo.</li>
    
    
<li>
<strong>Realimentaci&oacute;n r&aacute;pida</strong>. El tiempo entre una acci&oacute;n y su retroalimentaci&oacute;n es cr&iacute;tico. El hecho de trabajo junto al cliente y realizar actividades de modelado en grupo permiten obtener retroalimentaci&oacute;n casi instant&aacute;nea.</li>
    
    
<li>
<strong>Maximizar el ROI del cliente</strong>. El cliente invierte recursos (tiempo, dinero, ...) para que desarrollemos software que cumpla sus expectativas. Si el modelo que creamos no a&ntilde;ade valor &iquest;para qu&eacute; crearlo?
    Hemos de tener en mente que la documentaci&oacute;n del sistema es una decisi&oacute;n de negocio, no una decisi&oacute;n t&eacute;cnica. Si el cliente no quiere documentaci&oacute;n, es &eacute;l el que asume los riesgos que conlleva.</li>
    

</ul>
<a name="N10123"></a><a name="Principios+Adicionales"></a>
<h3 class="underlined_5">Principios Adicionales</h3>
<p>Los principios adicionales definen conceptos importantes que ayudan a realzar los esfuerzos de modelado:</p>
<ul>
    
<li>
<strong>El contenido es m&aacute;s importante que la representaci&oacute;n</strong>. Lo que se dice es m&aacute;s importante que el c&oacute;mo se dice. La gran mayor&iacute;a de las veces malgastamos tiempo mediante un herramienta CASE cuando un folio es suficiente.<br>
    Cualquier modelo tiene m&uacute;ltiples modos de representarlo. Por ejemplo, la especificaci&oacute;n de una GUI se puede crear mediante notas Post-It, folios DIN A3, diagramas en pizarras, mediante una herramienta de prototipado, o mediante un documento formal incluyendo una representaci&oacute;n visual y una descripci&oacute;n textual. Por lo tanto, independientemente de la t&eacute;cnica de representaci&oacute;n, lo m&aacute;s importante es el contenido.</li>
    
<li>
<strong>Comunicaci&oacute;n abierta y honesta</strong>. Mediante un enfoque AM se exige que los integrantes del equipo de desarrollo expresen sus ideas, sentimientos, frustraciones y diferentes puntos de vista. El equipo tomar&aacute; decisiones con m&aacute;s fundamento mediante el cultivo de un lugar de trabajo abierto y honesto, donde no se critiquen las comunicaciones aunque no beneficien a todos.
    </li>

</ul>
<p>Desde la publicaci&oacute;n del libro de presentaci&oacute;n, <em>Ambler</em> considera una serie de principios como "deprecated", ya que considera que no son necesarios para formar a un modelador &aacute;gil pero que son buenas ideas. Estos principios se exponen a continuaci&oacute;n:</p>
<ul>
    
<li>
<strong>Todo el mundo puede aprender de alg&uacute;n otro</strong>. Aprender y educarse no basta con los libros; tambi&eacute;n debemos aprender mientras trabajamos. Los cambios tecnol&oacute;gicos se producen a un ritmo que nadie puede asegurar que lo sabe todo. As&iacute; pues, hemos de sacar partido de nuestro compa&ntilde;eros y aprender/ense&ntilde;ar todo lo que podamos.</li>

    
<li>
<strong>Conoce tus modelos</strong>. Para poder afrontar las diferentes t&eacute;cnicas de modelado que se fomentan mediante el uso de m&uacute;ltiples modelos, si no sabemos los pros y contra de cada una de las t&eacute;cnicas, no vamos a poder sacar todo el partido.</li>

    
<li>
<strong>Adaptaci&oacute;n local</strong>. Se debe producir el modelo que resulte suficiente para el prop&oacute;sito. En ocasiones, el cliente puede insistir en determinadas herramientas de modelado o est&aacute;ndares a seguir. AM ofrece la flexibilidad necesaria para asumir estas restricciones.
    </li>
    
<li>
<strong>Trabajar con los instintos de la gente</strong>. Si sientes que algo no va a funcionar, conf&iacute;a en tus instintos, ya que muchas veces el subconsciente puede ser una entrada importante en los esfuerzos de modelado. Con la experiencia, los instintos se agudizan, y en ocasiones, si notamos que alg&uacute;n requisito es inconsistente o si adivinamos que la arquitectura tiene fallos, debemos tener coraje y tomar una decisi&oacute;n.</li>

</ul>
</div>


<a name="N1015A"></a><a name="Pr%C3%A1cticas"></a>
<h2 class="underlined_10">Pr&aacute;cticas</h2>
<div class="section">
<p>Las pr&aacute;cticas AM se formulan a partir de los principios. Aunque hasta que no se adoptan todas las pr&aacute;cticas centrales no se puede decir que se esta adoptando AM, algunas de estas por separado son igual de &uacute;tiles en un equipo que no se considera &aacute;gil.</p>
<a name="N10163"></a><a name="Pr%C3%A1cticas+Centrales"></a>
<h3 class="underlined_5">Pr&aacute;cticas Centrales</h3>
<p></p>
<ul>
    
<li>
<a name="colaboracionActiva"></a><strong>Colaboraci&oacute;n activa del cliente (e interesados)</strong>. AM funciona porque conf&iacute;a en que el cliente participa de forma activa en el proceso de modelado (igual que XP fomenta el Cliente in-situ). Esto requiere que los desarrolladores exhiban flexibilidad con los enfoques y notaciones de modelado.</li>
    
    
<li>
<a name="utilizarHerramientasSimples"></a><strong>Utilizar las herramientas m&aacute;s simples</strong> (CASE, o mejor pizarras, tarjetas, post-its). Los desarrollares no-&aacute;giles tienden a modelar en papel o pizarra y luego transcribir los modelos a una herramienta de dise&ntilde;o (de diagramado o CASE). Los desarrolladores &aacute;giles no malgastan tiempo de trascripci&oacute;n, y mediante una simple fotograf&iacute;a (ahora que las c&aacute;maras digitales est&aacute;n tan baratas) tienen el diagrama almacenado; ya que la mayor&iacute;a de diagramas son de "<em>usar y tirar</em>". Los desarrolladores &aacute;giles utilizar&aacute;n una herramienta CASE compleja (tipo Borland Together) cuando tenga sentido (por ejemplo, generar el c&oacute;digo esqueleto de la aplicaci&oacute;n).</li>
    
    
<li>
<a name="modelarConOtros"></a><strong>Modelar con otros</strong>. Cuando se <a href="#modelarProposito">Modela con un prop&oacute;sito</a>, normalmente se realiza para comprender algo, para comunicar tus ideas a otros, o en b&uacute;squeda de una visi&oacute;n conjunta del proyecto. Se trata de una actividad de grupo, donde la comunicaci&oacute;n amplifica la efectividad del equipo.</li>

    
<li>
<a name="ponerPruebaCodigo"></a><strong>Poner a prueba con c&oacute;digo</strong>. Un modelo es una abstracci&oacute;n, y hasta que no se implementa y prueba, no podemos estar seguros de que sea correcta. Destacar que dentro de un enfoque iterativo, el modelado forma parte del conjunto de tareas de desarrollo. Modela, implementa y prueba.</li>

    
<li>
<a name="aplicacionArtefactosCorrectos"></a><strong>Aplicaci&oacute;n de los artefactos correctos</strong>. Los desarrolladores &aacute;giles eligen la herramienta correcta. Existen much&iacute;simos artefactos (<a class="external" href="http://www.agilemodeling.com/artifacts/">www.agilemodeling.com/artifacts</a>): diagramas UML, flujos de datos, modelo de datos conceptual, diagramas de interfaces de usuario, etc... Esto implica la necesidad de conocer las ventajas e inconvenientes de cada tipo de artefacto, para poder determinar cuando utilizar o no uno de ellos. Pero siempre hemos de tener en mente que: "<em>Si una imagen vale mil palabras, entonces un modelo vale 1024 l&iacute;neas de c&oacute;digo</em>" :)</li>
    
    
<li>
<a name="crearModelosParalelo"></a><strong>Crear diversos modelos en paralelo</strong>. Como cada tipo de modelo tiene sus ventajas e inconvenientes, no existe el modelo perfecto. Cuando se utilizan diferentes modelos sobre un problema, la expresividad aumenta.</li>
    
    
<li>
<a name="iterarOtroArtefacto"></a><strong>Iterar sobre otro artefacto</strong>. Cuando al trabajar en un artefacto (caso de uso, CRC, o incluso c&oacute;digo fuente) y sientas que estas bloqueado, deja lo que est&eacute;s haciendo, y trabaja sobre otro artefacto. Cada artefacto tiene sus ventajas e inconvenientes, y para desbloquearse, lo mejor es enfocar el mismo problema desde un punto de vista distinto.</li>
    
    
<li>
<a name="modelarIncrementosPeque%C3%B1os"></a><strong>Modelar en incrementos peque&ntilde;os</strong>. Se sigue el contexto de desarrollo iterativo: modelar, comunicar, refinar y remodelar. De este modo, modelamos lo suficiente y abrazamos los cambios.</li>
    
    
<li>
<a name="propiedadColectiva"></a><strong>Propiedad colectiva de todos los elementos</strong>. Todo el mundo puede trabajar en cualquier modelo, y si fuera necesario, en cada artefacto del modelo.</li>
    
    
<li>
<a name="crearContenidoSimple"></a><strong>Crear contenido simple</strong>. Todos los contenidos del modelo (requisitos, an&aacute;lisis, arquitectura ..) deben ser simples, pero cumpliendo las necesidades del cliente. No se debe a&ntilde;adir aspectos adicionales en los modelos a no ser que sean justificados. Hemos de tener el coraje para a&ntilde;adir una funcionalidad cuando se nos pida, ni antes ni despu&eacute;s.</li>
    
    
<li>
<a name="dise%C3%B1arModelosSimple"></a><strong>Dise&ntilde;ar modelos de manera simple</strong>. De todos los posibles diagramas a utilizar, hemos de utilizar un subconjunto sencillo. Un modelo simple con un diagrama de clases y la relaci&oacute;n entre &eacute;stas suele ser suficiente. Se pueden realizar much&iacute;simos m&aacute;s diagramas, pero la mayor&iacute;a de la veces, no aportan valor. Igualmente, el representar los getter/setter en una clase tampoco aclara nada.</li>
    
    
<li>
<acronym title="exhibirModelos"></acronym><strong>Exhibir p&uacute;blicamente los modelos</strong>. Los modelos deben estar visibles a todos los integrantes en la "<strong>pared de modelado</strong>". Esta pared, ya sea f&iacute;sica o mediante un pizarra con pie (incluso una pared virtual dentro del wiki de proyecto), fomenta la comunicaci&oacute;n honesta y abierta.</li>


</ul>
<a name="N101D4"></a><a name="Pr%C3%A1cticas+Adicionales"></a>
<h3 class="underlined_5">Pr&aacute;cticas Adicionales</h3>
<p>Dependiendo del tipo de empresa y del proyecto, a continuaci&oacute;n se muestran las pr&aacute;cticas que opcionales puede adoptar un equipo &aacute;gil:</p>
<ul>
    
<li>
<strong>Aplicaci&oacute;n de est&aacute;ndares de modelado</strong>. Todos los desarrolladores deben seguir unos est&aacute;ndares compartidos de modelado. Al igual que ocurre con el c&oacute;digo, el uso de est&aacute;ndares de modelado (UML, OMG, ...) y de gu&iacute;as de estilo (<a class="external" href="http://www.agilemodeling.com/style/">www.agilemodeling.com/style</a>) facilita el trabajo.
    <div class="frame note">
<div class="label">&iquest;Que diferencia hay entre un est&aacute;ndar y una gu&iacute;a de estilo?</div>
<div class="content">
    Si hablamos de c&oacute;digo, un est&aacute;ndar es nombrar los atributos con camelCase, mientras que un gu&iacute;a de estilo ser&iacute;a tabular las instrucciones anidadas a un bucle/condicional.<br>
    Si hablamos de dise&ntilde;o, un est&aacute;ndar es utilizar un rect&aacute;ngulo para modelar una clase, mientras que un gu&iacute;a de estilo y situar las subclases debajo de las clases padre.
    </div>
</div>
    
</li>
    
    
<li>
<strong>Aplicaci&oacute;n adecuada de patrones de modelado</strong>. Teniendo siempre en cuenta la simplicidad, hemos de utilizar patrones de dise&ntilde;o cuando realmente sean necesarios. Algunos patrones, pese a ser la mejor soluci&oacute;n, son complejos, y por tanto, si no son necesarios, es mejor evitar el sobremodelado, y ce&ntilde;irnos a lo que tenemos.</li>

    
<li>
<a name="descartarModelosTemporales"></a><strong>Descartar los modelos temporales</strong>. La mayor&iacute;a de modelos que se crean son temporales (borradores de dise&ntilde;o, prototipos escuetos, tarjetas CRC, posibles arquitecturas, ...); son modelos que han cumplido su papel, pero que ya no aportan ning&uacute;n valor. Los modelos caducan muy r&aacute;pido, ya que el c&oacute;digo no para de modificarse, y los costes de sincronizar los modelos con el c&oacute;digo no compensan. Por lo tanto, como mucho, les tomaremos una foto, y los tiramos a la basura.</li>

    
<li>
<strong>Formalizar modelos de contrato</strong>. Los contratos de modelado se suelen necesitar cuando nuestro sistema necesita informaci&oacute;n de un sistema externo. Ambas partes se comprometen a cumplir el contrato para poder intercambiar la informaci&oacute;n, y en el caso de necesitarse, al realizar un cambio, la otra parte tambi&eacute;n propagar&aacute; la modificaci&oacute;n. Por ejemplo, interfaces de entrada a la aplicaci&oacute;n, descripci&oacute;n de ficheros XML mediante XML Schema o DTDs, o el modelo f&iacute;sico de un subsistema de la base de datos.<br>
    El objetivo, para mantener la agilidad, es minimizar el n&uacute;mero de modelos de contratos del sistema, ya que suelen ser actividades que conllevan mucho trabajo de creaci&oacute;n y mantenimiento. Adem&aacute;s, siempre se utilizar&aacute;n medios electr&oacute;nicos (documentos o p&aacute;ginas web/wiki) ya que el contrato nos obliga a mantenerlo.</li>

    
<li>
<strong>Actualizar s&oacute;lo cuando duela</strong>. Los modelos deben actualizarse &uacute;nicamente cuando sea absolutamente necesario, cuando el hecho de no tener el modelo desactualizado sea m&aacute;s doloroso que el esfuerzo que conlleve actualizarlo. Siguiendo esta pr&aacute;ctica, tendremos que la mayor&iacute;a de las veces no vamos a actualizar nuestro modelos. En cambio, si por ejemplo, hemos realizado un gran n&uacute;mero de refactorizaciones sobre un subsistema de la aplicaci&oacute;n, el actualizar el modelo nos ayudar&aacute; a tener una visi&oacute;n m&aacute;s clara del mismo.
    
    <div class="frame note">
<div class="label">Curiosidad</div>
<div class="content">
    Para explicar esta pr&aacute;ctica Ambler compara los modelos con los planos. Todos sabemos que en las ciudades (y en Alicante tambi&eacute;n) no paran de cambiar los sentidos de las calles, poner rotondas, etc... Si tengo un plano de Alicante de hace un par de a&ntilde;os &iquest;Vale la pena comprar un nuevo plano cada a&ntilde;o para que aparezcan todas las calles de forma correcta? 
    </div>
</div>
    
</li>

</ul>
<p>Al igual que con los principios, Ambler tambi&eacute;n considera una serie de pr&aacute;cticas como "deprecated":</p>
<ul>
    
<li>
<strong>Considerar la verificabilidad</strong>. Conforme se desarrolla un modelo, hemos de considerar como se puede validar. Y como hemos de seguir un enfoque de TDD, esta pr&aacute;ctica esta impl&iacute;cita en el AM.</li>
    
<li>
<strong>Modelar para comunicar</strong>. Una de las razones del modelado es la comunicaci&oacute;n con un integrante del equipo o con un contrato. Puede que sea necesario emplear tiempo en hacer los modelos "bonitos" mediante medios electr&oacute;nicos (procesadores de texto, herramientas de diagramaci&oacute;n o incluso sofisticadas herramientas CASE) para poder enviarlos a gente externa al equipo.</li>
    
<li>
<strong>Modelar para comprender</strong>. El objetivo principal del modelado es comprender el dominio del problema, identificar y analizar los requisitos, o comparar las posibles alternativas de dise&ntilde;o.</li>
    
<li>
<strong>Reutilizar los recursos existentes</strong>. Puede que algunos patrones de an&aacute;lisis o dise&ntilde;o sean apropiados para el sistema. O incluso modelos de datos, procesos de negocio, etc...</li>

</ul>
</div>


<a name="N10227"></a><a name="Artefactos"></a>
<h2 class="underlined_10">Artefactos</h2>
<div class="section">
<p>El desarrollo de software es complejo. Cada tipo de modelo es bueno desde un punto de vista determinado, y por tanto, pueden ser necesarios muchos puntos de vista. Para esto, es necesario conocer un conjunto extenso de t&eacute;cnicas (no hace falta dominarlas todas, pero al menos, aquellas que m&aacute;s utilicemos).</p>
<p>Los artefactos de AM se muestran a continuaci&oacute;n agrupados por categor&iacute;as, donde en cada categor&iacute;a hay t&eacute;cnicas similares:</p>
<p>
    
<img alt="Artefactos de AM" content-width="17cm" src="imagenes/s3/artefactosEstrella.gif" width="770">
</p>
</div>



<a name="N1023D"></a><a name="Escenario+%C3%81gil"></a>
<h2 class="underlined_10">Escenario &Aacute;gil</h2>
<div class="section">
<p>Para aclarar este concepto, vamos a exponer un escenario de modelado &aacute;gil. Sea la oficina donde se desarrolla un proyecto, exactamente la habitaci&oacute;n donde se desarrolla el software. Esta debe tener las paredes limpias (sin decoraci&oacute;n), cubiertas con pizarras blancas de belleda y con material para dibujar y borrar. Lunes por la ma&ntilde;ana, inicio de una iteraci&oacute;n de tres semanas. El equipo de 8 desarrolladores ha decidido dedicar 2 o 3 horas en las paredes para comprender y comunicar mejor sus ideas. Tras ello, comenzar&aacute;n a programar. 
</p>
<p>Se dividen en grupos. El grupo 1 analiza el dise&ntilde;o de objetos para el escenario principal de la aplicaci&oacute;n. En la mitad de una pizarra, realizan un borrador de un diagrama UML de secuencia. No es UML est&aacute;ndar, para eso es un borrador. Tras 15 minutos, se cambian a la otra mitad de la pizarra y esbozan un diagrama de clases que complementa el diagrama de secuencia. Tras 3 horas de tiras y afloja, refinan los 2 diagramas complementarios. Finalmente, le hacen
fotos digitales a las pizarras, las imprimen y limpian las pizarras. Cuando se pongan a programar, las fotos pueden ofrecer inspiraci&oacute;n (un pensamiento anterior puede inspirar algunas ideas de dise&ntilde;o en el c&oacute;digo).</p>
</div>



<a name="N1024A"></a><a name="Desarrollo+%C3%81gil+Dirigido+por+el+Modelo+%28AMDD%29"></a>
<h2 class="underlined_10">Desarrollo &Aacute;gil Dirigido por el Modelo (AMDD)</h2>
<div class="section">
<p>Como el nombre implica, AMDD es la versi&oacute;n &aacute;gil del Desarrollo Dirigido por el Modelo (<em>MDD - Model Driven Development</em>). MDD es un enfoque de desarrollo software donde se crean modelos extensivos antes de escribir el c&oacute;digo fuente. El ejemplo m&aacute;s claro del enfoque MDD es el est&aacute;ndar OMG de Arquitectura Dirigida por el Modelo (<em>MDA - Model Driven Architecture</em>). MDD sigue un enfoque secuencial, y por ello, es popular dentro de los tradicionalistas, aunque dentro de RUP tambi&eacute;n se puede seguir un enfoque MDD. La diferencia entre AMDD y MDD es que en vez de crear un conjunto de modelos extensos antes de escribir el c&oacute;digo fuente, se crean modelos &aacute;giles los cuales son suficientemente buenos.</p>
<p>El siguiente gr&aacute;fico muestra el ciclo de vida de AMMD para la entrega de un sistema. Antes de nada veamos como leer el diagrama. Cada caja representa una actividad de desarrollo. La actividad de modelado inicial incluye 2 subactividades principal, Modelado Inicial de Requisitos y Modelado Inicial de Arquitectura, las cuales se realizan en la iteraci&oacute;n 0. Normalmente, la iteraci&oacute;n 0 representa la primera iteraci&oacute;n antes de empezar dentro de las iteraciones de desarrollo (de la iteraci&oacute;n 1 en adelante). Las otras actividades - tormenta de modelos, revisiones e implementaci&oacute;n - suceden en cualquier iteraci&oacute;n, incluso la 0. El tiempo indicado en cada caja representa la duraci&oacute;n de una sesi&oacute;n media: pueden durar de unos pocos minutos a varias horas.</p>
<p>
    
<img alt="AMMD" content-width="14cm" src="imagenes/s3/amdd.gif" width="529">
</p>
<a name="N10265"></a><a name="Modelado+Inicial"></a>
<h3 class="underlined_5">Modelado Inicial</h3>
<p>El esfuerzo de modelado inicial normalmente se realiza durante la primera semana del proyecto. Para proyectos peque&ntilde;os (de varias semanas de duraci&oacute;n) este esfuerzo inicial puede durar pocas horas, y para proyectos grandes (12 o m&aacute;s meses) incluso hasta 2 semanas. Se recomienda no invertir m&aacute;s tiempo ya que se corre el peligro de sobremodelar o modelar algo que contiene demasiados problemas (2 semanas sin retroalimentaci&oacute;n auguran mucho riesgo).</p>
<p>Para la primera entrega del sistema, se necesitan varios d&iacute;as para identificar los requisitos de alto nivel y el alcance de la entrega (lo que pensamos que el sistema deber&iacute;a realizar). El objetivo es conseguir buenas vibraciones sobre el proyecto, recabar suficiente informaci&oacute;n y ofrecer una estimaci&oacute;n inicial del mismo. El objetivo de la arquitectura inicial es intentar identificar una arquitectura que tenga muchas posibilidad de funcionar.</p>
<p>En ciclos posteriores, estos requisitos inicial y arquitectura evolucionar&aacute;n conforme se tenga mayor conocimiento del dominio, pero para este ciclo es suficiente. En entregas posteriores, se puede decidir acortar el ciclo 0 a varios d&iacute;as, o incluso eliminarlo.</p>
<a name="N10275"></a><a name="Modelado+Detallado"></a>
<h3 class="underlined_5">Modelado Detallado</h3>
<p>Durante el modelado detallado, se exploran los requisitos o el dise&ntilde;o en mayor detalle. Durante los ciclos de desarrollo de una entrega, los esfuerzos de modelado normalmente se miden en orden de minutos. Por ejemplo, si nos reunimos con el cliente para analizar un requisito sobre el cual se esta trabajando, se crea un borrador en una pizarra durante unos minutos, para posteriormente volver a la codificaci&oacute;n. O quiz&aacute;s entre varios desarrolladores se esboza un enfoque de como afrontar un requisito, volviendo a emplear unos pocos minutos. Por supuesto, nosotros y nuestra pareja de programaci&oacute;n utilizaremos una herramienta de modelado para modelar los requisitos en detalle y posteriormente generar el c&oacute;digo de dicho requisito (15 o 20 minutos).</p>
<p>Cabe recordar que los requisitos iniciales y los modelos de arquitectura evolucionar&aacute;n conforme se realiza el modelado detallado y la implementaci&oacute;n de los modelos. Dependiendo de lo ligero que se viaje, puede no ser necesario tener que actualizar ning&uacute;n modelo.</p>
<p>Durante la implementaci&oacute;n el equipo emplear&aacute; la mayor&iacute;a del tiempo (el diagrama no muestra esta diferencia). Durante el desarrollo, es com&uacute;n emplear algunos minutos para realizar un modelado detallado, para posteriormente codificar durante horas siguiendo pr&aacute;cticas como el <a href="sesion02-apuntes.html#tdd">Desarrollo Dirigido por las Pruebas</a> (TDD) o la <a href="sesion02-apuntes.html#refactorizacion">Refactorizaci&oacute;n</a>. &iquest;Y porqu&eacute; funciona? Porque los esfuerzos de modelado centran los esfuerzos en aspectos de alto nivel, en los que intervienen elementos con dependencias entre entidades cruzadas, mientras que TDD se centra en aspectos locales, normalmente relativos a una &uacute;nica entidad. Con la refactorizaci&oacute;n, el dise&ntilde;o evoluciona mediante peque&ntilde;os pasos que aseguran que el c&oacute;digo mantiene un nivel de calidad alto.</p>
<p>
<em>Ambler</em> opina que no tienen sentidos los especialistas que s&oacute;lo modelan. &iquest;Van a modelar durante unos minutos, y luego esperaran sentados? Los perfiles &uacute;tiles son aquellos que son flexibles para trabajar en varios &aacute;mbitos. <em>Ambler</em> los denomina <strong>especialistas generalizados</strong>: persona con una o m&aacute;s especialidades junta a habilidades generales en el ciclo completo de desarrollo, que puede tanto codifica como, cuando sea necesario, modelar.</p>
</div>




<a name="N10299"></a><a name="Documentaci%C3%B3n+%C3%81gil"></a>
<h2 class="underlined_10">Documentaci&oacute;n &Aacute;gil</h2>
<div class="section">
<p>La documentaci&oacute;n es una parte ineludible en cualquier sistema, incluso en aquellos que siguen t&eacute;cnicas de desarrollo &aacute;gil. &iexcl;La documentaci&oacute;n puede ser &aacute;gil! Para ello debe cumplir los siguientes criterios:</p>
<ul>
    
<li>
<strong>Maximiza el ROI del cliente</strong>. Al menos debe ofrecer un valor positivo e idealmente el mayor valor (de acuerdo al cliente). Es decir, su beneficio debe ser mayor que los costes de creaci&oacute;n y mantenimiento del mismo.</li>
    
<li>
<strong>Es conciso</strong>. Un documento &aacute;gil es tan simple como pueda, conteniendo &uacute;nicamente la suficiente informaci&oacute;n para cumplir su prop&oacute;sito. Un modo de mantener un documento "fino" es mediante el principio DRY (<em>Don't Repeat Yourself</em>)</li>
    
<li>
<strong>Cumple un s&oacute;lo objetivo</strong>. Los documentos &aacute;giles est&aacute;n cohesionados. Si en alg&uacute;n momento existe alguna duda sobre el objetivo o la utilidad de un documento, debemos parar inmediatamente.</li>
    
<li>
<strong>Describe la informaci&oacute;n que menos va a cambiar</strong>. Cuanto m&aacute;s probable sea que cambie la informaci&oacute;n, menor valor tiene su documentaci&oacute;n, ya que puede que mientras estemos escribiendo, la informaci&oacute;n haya cambiado.</li>
    
<li>
<strong>Describe las cosas que hay que saber</strong>. Los documentos &aacute;giles capturan la informaci&oacute;n cr&iacute;tica, aquella que no es obvia a partir de procedimientos de dise&ntilde;o, usabilidad u operabilidad.</li>
    
<li>
<strong>Pertenece a un cliente espec&iacute;fico y facilita los esfuerzos de dicho cliente</strong>. Cada cliente tiene su estilo y gustos de documentaci&oacute;n. Trabajar cerca del cliente nos facilita la creaci&oacute;n del documento, porque estaremos escribiendo el documento que el cliente quiere y necesita. Si el cliente no est&aacute; involucrado, lo m&aacute;s seguro es que se acabe creando m&aacute;s documentaci&oacute;n de la necesaria (incluso documentaci&oacute;n que no cumple las necesidades reales).</li>
    
<li>
<strong>Es suficientemente preciso, consistente y detallado</strong>. Los documentos &aacute;giles no necesitan ser perfecto, sino suficientemente buenos.</li>
    
<li>
<strong>Est&aacute; suficientemente indexado</strong>. Si no encontramos la informaci&oacute;n, entonces no somos &aacute;giles. La tabla de contenidos y un &iacute;ndice del documento siempre ayudan.</li>

</ul>
<div class="frame warning">
<div class="label">Tener en cuenta que...</div>
<div class="content">Siempre hay matices, y si tenemos la suerte de escribir la documentaci&oacute;n de una estaci&oacute;n espacial, una central nuclear o una controladora a&eacute;rea, entonces valdr&aacute; la pena que la documentaci&oacute;n sea perfecta :)</div>
</div>
</div>


<p>Adem&aacute;s, los siguientes puntos son cr&iacute;ticos para una buena documentaci&oacute;n:</p>

<ul>
    
<li>El hecho fundamental es la comunicaci&oacute;n efectiva, no la documentaci&oacute;n</li>
    
<li>La documentaci&oacute;n es una parte del sistema, igual que el c&oacute;digo fuente.</li>
    
<li>La documentaci&oacute;n realmente deber&iacute;a ser necesaria, no s&oacute;lo querer hacerla, sino necesitarla.</li>
    
<li>La inversi&oacute;n en la documentaci&oacute;n del sistema es una decisi&oacute;n de negocio, no una decisi&oacute;n t&eacute;cnica (es el dinero del cliente, no el nuestro). Pero hemos de educar al cliente sobre la importancia de ciertos aspectos de la documentaci&oacute;n.</li>
    
<li>El lector, y no el escritor, es quien determina que la documentaci&oacute;n es suficiente.</li>

</ul>


<p>&iquest;Por qu&eacute; los clientes son tan categ&oacute;ricos respecto a escribir grandes cantidades de documentaci&oacute;n? Quiz&aacute;s, porque crean incrementar su nivel de confianza respecto al equipo, ya que si siguen una metodolog&iacute;a tradicional, hasta dentro de unos meses (u a&ntilde;os) no van a ver ninguna aplicaci&oacute;n funcionando, y el &uacute;nico modo de comprobar que se esta utilizando su dinero de un modo adecuado es mediante los documentos (requisitos, arquitectura, dise&ntilde;o, ...).</p>

<div class="frame note">
<div class="label">&iquest;Pregunta...?</div>
<div class="content">
Los documentos dan la impresi&oacute;n de que hay un progreso, pero &iquest;en la direcci&oacute;n correcta?.</div>
</div>

<p>En cambio, mediante una metodolog&iacute;a &aacute;gil, con lo entrega continua de software que funciona, el valor de la mayor&iacute;a de estos documentos desaparece, y por consiguiente, la cantidad de documentaci&oacute;n necesaria se reduce.</p>




<a name="N102F4"></a><a name="Trabajando+con+la+Pizarra"></a>
<h2 class="underlined_10">Trabajando con la Pizarra</h2>
<div class="section">
<p>Las pizarras son maravillosas, posiblemente, el mejor invento para un equipo de desarrollo. Se puede pensar que son buenas para el equipo, para dentro de la empresa, pero &iquest;y para afuera? &iquest;puedo poner diagramas fotografiados de pizarra en la documentaci&oacute;n?</p>
<p>La siguiente imagen muestra un borrador del diagrama EER sobre el que hemos basado el proyecto de integraci&oacute;n:</p>
<p>
    
<img alt="Fotografia de Entidad Relaci&oacute;n en Pizarra" content-width="16cm" src="imagenes/s3/eerRecortado750.jpg" width="750">
</p>
<p>Para evitar perder la informaci&oacute;n, tomamos una fotograf&iacute;a, la cual, si fuese necesario, podr&iacute;amos volver a reproducir en menos de un minuto. Este es un claro ejemplo de documentaci&oacute;n &aacute;gil, ya que puede que la imagen no sea bonita, pero es efectiva, y la informaci&oacute;n no se pierde.</p>
<p>Existen un par de problemas con la imagen anterior: el tama&ntilde;o en disco es relativamente grande y cuesta un poco de apreciar porque est&aacute; muy oscura. La verdad es que el tama&ntilde;o no importa mucho (el de disco :) ), porque los dispositivos de almacenamiento secundario son muy baratos, aunque pueda penalizar a la gente que disponga de conexiones de red lentas. Por suerte, existen algunas soluciones software (<em>Whiteboard</em> de <em>Polyvision</em> <a class="external" href="http://www.polyvision.com/products/wbp.asp">www.polyvision.com/products/wbp.asp</a>) que tratan la imagen y la limpian:</p>
<p>
    
<img alt="Fotografia de Pizarra Limpia" content-width="16cm" src="imagenes/s3/eerLimpio750.jpg" width="750">
</p>
<p>Al limpiarla, en ocasiones, debido al <a href="imagenes/s3/eerFlash750.jpg">reflejo del flash</a> puede ser necesario retocar la imagen con un programa de edici&oacute;n para borrar el flash. Siempre que sea posible, tomar la fotograf&iacute;a sobre una pizarra bien iluminada, de modo que no sea necesario el flash de la c&aacute;mara.</p>
<p>Respecto a estos borradores, en la mayor&iacute;a de las ocasiones (cerca del 95% de las veces), ser&aacute;n diagramas de usar y tirar, sin necesidad siquiera de tomar fotograf&iacute;as. El 5% restante se pueden almacenar mediante el proceso anterior de fotografiar y limpiar. Incluso algunos de estos &uacute;ltimos, pueden ser tan valiosos que posteriormente los realicemos sobre una herramienta CASE. Estos porcentajes son reales en equipos que siguen un enfoque AMDD, ya que con la experiencia y el coraje, se fundamenta el h&aacute;bito de viajar ligero y desechar los modelos innecesarios. Para los desarrolladores cl&aacute;sicos, el uso de las c&aacute;maras digitales son un paso radical.</p>
<p>La principal ventaja de modelar con pizarras es que se trata de un enfoque muy sencillo y que fomenta el trabajo en equipo (una pizarra, muchos rotuladores). Como desventaja, los diagramas no son permanentes (para eso tomaremos fotograf&iacute;as), su modificaci&oacute;n a partir de una imagen es costosa (implica redibujar el diagrama), y no generan c&oacute;digo.</p>
</div>


<a name="N10330"></a><a name="Adoptando+AM"></a>
<h2 class="underlined_10">Adoptando AM</h2>
<div class="section">
<p>El caso id&iacute;lico ser&iacute;a adoptar los principios y pr&aacute;cticas centrales desde el inicio. Una vez asumidos, continuar con los adicionales. Pero lo normal es que la empresa no tenga una organizaci&oacute;n &aacute;gil, y el adoptar AM de una sola vez puede ser demasiada agilidad para algo tan r&iacute;gido.
</p>
<p>Para ir poco a poco, el primer paso a dar es <strong>mejorar la comunicaci&oacute;n entre las personas</strong>. <a href="#modelarConOtros">Modelar con otros</a> y la <a href="#colaboracionActiva">Colaboraci&oacute;n activa del cliente</a> son las pr&aacute;cticas esenciales que hay que potenciar. Al <a href="#utilizarHerramientasSimples">Utilizar las herramientas m&aacute;s simples</a> es m&aacute;s f&aacute;cil <a href="#modelarConOtros">Modelar con otros</a> porque no existe una curva de aprendizaje sobre herramientas, y las herramientas simples posibilitan que el <a href="#colaboracionActiva">Cliente colabore activamente</a> contigo. Aprenderemos del cliente.</p>
<p>El segundo paso deber&iacute;a ser <strong>mantener las cosas tan simples como sea posible</strong> y <a href="#viajarLigero">Viajar tan ligero como sea posible</a>. F&aacute;cil de decir, dif&iacute;cil de conseguir, al menos al principio. Un paso cr&iacute;tico es el <a href="#utilizarHerramientasSimples">Uso de herramientas simples</a> como pizarras y papel para crear los modelos. Las herramientas simples hacen menos doloroso el proceso de <a href="#descartarModelosTemporales">Descartar los modelos temporales</a>, ya que no hemos invertido mucho tiempo en ellos. Adem&aacute;s, normalmente es m&aacute;s f&aacute;cil hacer las cosas a papel o en pizarra que mediante una herramienta CASE.</p>
</div>


<p>En el tercer paso, <strong>adoptar t&eacute;cnicas que capaciten la evoluci&oacute;n del trabajo</strong> (de forma iterativa e incremental). En este paso, las pr&aacute;cticas de <a href="#crearModelosParalelo">Crear varios modelos en paralelo</a> e <a href="#iterarOtroArtefacto">Iterar a otro artefacto</a> son cruciales, lo cual implica que aceptar que se necesitan m&uacute;ltiples modelos. Para esto ser&aacute;n necesarias m&aacute;s de una pizarra (una habitaci&oacute;n llena de pizarras es mucho mejor). El mantener los modelos peque&ntilde;os mediante el <a href="#modelarIncrementosPeque%C3%B1os">Modelado en iteraciones</a> tambi&eacute;n es importante. Est&aacute;s t&eacute;cnicas en conjunto ayudan a romper los h&aacute;bitos de un dise&ntilde;o cl&aacute;sico (<em>Big Design Up Front</em>). Para que el paso a la implementaci&oacute;n sea m&aacute;s suave, deberemos <a href="#ponerPruebaCodigo">Probar los modelos con c&oacute;digo</a>.</p>

<p>As&iacute; pues, para facilitar la entrada de AM en una empresa al menos se deben considerar los siguientes principios y pr&aacute;cticas:</p>

<ul>
    
<li>Colaboraci&oacute;n activa del cliente</li>
    
<li>Crear diversos modelos en paralelo</li>
    
<li>Dise&ntilde;ar modelos de manera simple</li>
    
<li>Iterar sobre otro artefacto</li>
    
<li>Modelar en incrementos peque&ntilde;os</li>
    
<li>Modelar con otros</li>
    
<li>M&uacute;ltiples modelos</li>
    
<li>Poner a prueba con c&oacute;digo</li>
    
<li>Viajar ligero de equipaje</li>
    
<li>Utilizar las herramientas m&aacute;s simples</li>

</ul>

<p>S&oacute;lo cabe recordar que para adoptar realmente AM se deben seguir todos los principios centrales as&iacute; como aplicar todas las pr&aacute;cticas centrales.</p>



<a name="N103A6"></a><a name="Para+Saber+M%C3%A1s"></a>
<h2 class="underlined_10">Para Saber M&aacute;s</h2>
<div class="section">
<p>Esta filosof&iacute;a se centra en el trabajo de Scott Ambler, y la comunidad que colabora con &eacute;l. Toda la informaci&oacute;n existente se publica de manera abierta en su web.</p>
<a name="N103AF"></a><a name="Bibliograf%C3%ADa"></a>
<h3 class="underlined_5">Bibliograf&iacute;a</h3>
<ul>
    
<li>
<strong>Agile Modeling</strong>, de <em>Scott W. Ambler</em>. El libro por excelencia de Modelado &Aacute;gil.</li>
    
<li>
<strong>The Object Primer. Agile Model-Driven Development with UML 2.0</strong>, de <em>Scott W. Ambler</em>. Muy buen libro, tratando el modelado con UML desde una perspectiva &aacute;gil.</li>

</ul>
<a name="N103C9"></a><a name="Enlaces"></a>
<h3 class="underlined_5">Enlaces</h3>
<ul>
    
<li>Modelado &Aacute;gil por Scott W. Ambler: <a class="external" href="http://www.agilemodeling.com/">www.agilemodeling.com/</a>
</li>

</ul>
</div>


<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006-2007 Depto. CCIA</div>
</div>
</body>
</html>
