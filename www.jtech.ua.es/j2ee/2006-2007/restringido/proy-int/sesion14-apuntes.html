<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Proyecto Enterprise</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario en Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Proyecto de Integracion" src="images/baner_j2ee_der.gif" title="Proyecto de Integracion"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Proyecto de Integraci&oacute;n</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Proyecto de Integraci&oacute;n</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Proyecto de Integraci&oacute;n">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html" title="Sesi&oacute;n 1: Caso de estudio">Sesi&oacute;n 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html" title="Sesi&oacute;n 2: DAO con JDBC">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html" title="Sesi&oacute;n 3: Aplicaci&oacute;n web con servlets">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html" title="Sesi&oacute;n 4: Aplicaci&oacute;n web con servlets y JSPs">Sesi&oacute;n 4</a>
</div>
<div class="menuitem">
<a href="sesion0506-apuntes.html" title="Sesiones 5 y 6: Aplicaci&oacute;n web con Struts">Sesi&oacute;n 5-6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html" title="Sesi&oacute;n 7: Aplicaci&oacute;n web con Hibernate">Sesi&oacute;n 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html" title="Sesi&oacute;n 8: Proyecto web">Sesi&oacute;n 8</a>
</div>
<div class="menuitem">
<a href="sesion09-apuntes.html" title="Sesi&oacute;n 9: Spring">Sesi&oacute;n 9</a>
</div>
<div class="menuitem">
<a href="sesion10-apuntes.html" title="Sesi&oacute;n 10: Servidores de aplicaciones">Sesi&oacute;n 10</a>
</div>
<div class="menuitem">
<a href="sesion11-apuntes.html" title="Sesi&oacute;n 11: Componentes EJB">Sesi&oacute;n 11</a>
</div>
<div class="menuitem">
<a href="sesion12-apuntes.html" title="Sesi&oacute;n 12: Mensajes: JMS">Sesi&oacute;n 12</a>
</div>
<div class="menuitem">
<a href="sesion13-apuntes.html" title="Sesi&oacute;n 13: Servicios Web">Sesi&oacute;n 13</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 14</div>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion14-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Proyecto Enterprise</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n">Introducci&oacute;n</a>
<ul class="minitoc">
<li>
<a href="#%C2%BFQu%C3%A9+Tenemos%3F">&iquest;Qu&eacute; Tenemos?</a>
</li>
<li>
<a href="#Donde+Queremos+Llegar">Donde Queremos Llegar</a>
</li>
</ul>
</li>
<li>
<a href="#Integrando+los+EJBs">Integrando los EJBs</a>
<ul class="minitoc">
<li>
<a href="#Service+Locator">Service Locator</a>
</li>
</ul>
</li>
<li>
<a href="#Procesos+Planificados">Procesos Planificados</a>
<ul class="minitoc">
<li>
<a href="#java.util.Timer">java.util.Timer</a>
</li>
<li>
<a href="#EJB+Timer">EJB Timer</a>
<ul class="minitoc">
<li>
<a href="#Timer+API">Timer API</a>
</li>
<li>
<a href="#Timers+y+tipos+de+EJBs">Timers y tipos de EJBs</a>
</li>
<li>
<a href="#Modelo+de+programaci%C3%B3n">Modelo de programaci&oacute;n</a>
</li>
<li>
<a href="#Ejemplo+de+EJB+Timer">Ejemplo de EJB Timer</a>
</li>
</ul>
</li>
<li>
<a href="#Quartz">Quartz</a>
<ul class="minitoc">
<li>
<a href="#%C2%BFPor+qu%C3%A9+utilizar+Quartz+y+no+EJB+Timer+o+el+API+Timer%3F">&iquest;Por qu&eacute; utilizar Quartz y no EJB Timer o el API Timer?</a>
</li>
<li>
<a href="#Modo+B%C3%A1sico+de+Empleo">Modo B&aacute;sico de Empleo</a>
</li>
<li>
<a href="#Trabajos+y+Disparadores">Trabajos y Disparadores</a>
</li>
<li>
<a href="#Fichero+de+Configuraci%C3%B3n">Fichero de Configuraci&oacute;n</a>
</li>
<li>
<a href="#Dentro+de+una+Aplicaci%C3%B3n+Web%2FEnterprise">Dentro de una Aplicaci&oacute;n Web/Enterprise</a>
</li>
<li>
<a href="#Quartz+y+EJBs">Quartz y EJBs</a>
</li>
</ul>
</li>
<li>
<a href="#Deshaciendo+las+Reservas+Caducadas">Deshaciendo las Reservas Caducadas</a>
</li>
</ul>
</li>
<li>
<a href="#Multidioma">Multidioma</a>
<ul class="minitoc">
<li>
<a href="#Soporte+Java">Soporte Java</a>
</li>
<li>
<a href="#Configuraci%C3%B3n+Struts">Configuraci&oacute;n Struts</a>
<ul class="minitoc">
<li>
<a href="#Controlador">Controlador</a>
</li>
<li>
<a href="#Fichero+de+Recursos">Fichero de Recursos</a>
</li>
<li>
<a href="#Cambio+de+Locale+Bajo+Petici%C3%B3n+del+Usuario">Cambio de Locale Bajo Petici&oacute;n del Usuario</a>
</li>
</ul>
</li>
<li>
<a href="#Modo+de+Empleo">Modo de Empleo</a>
</li>
</ul>
</li>
<li>
<a href="#Pruebas+de+Aceptaci%C3%B3n">Pruebas de Aceptaci&oacute;n</a>
<ul class="minitoc">
<li>
<a href="#Selenium">Selenium</a>
</li>
<li>
<a href="#Probando+la+Aplicaci%C3%B3n">Probando la Aplicaci&oacute;n</a>
</li>
</ul>
</li>
<li>
<a href="#Pruebas+de+Carga">Pruebas de Carga</a>
<ul class="minitoc">
<li>
<a href="#Inquietudes+con+el+Rendimiento">Inquietudes con el Rendimiento</a>
</li>
<li>
<a href="#JMeter">JMeter</a>
<ul class="minitoc">
<li>
<a href="#Componentes">Componentes</a>
</li>
<li>
<a href="#Creando+una+Prueba+de+Ejemplo">Creando una Prueba de Ejemplo</a>
</li>
<li>
<a href="#Consejos+JMeter">Consejos JMeter</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Entrega">Entrega</a>
</li>
</ul>
</div>


<a name="N1000C"></a><a name="Introducci%C3%B3n"></a>
<h2 class="underlined_10">Introducci&oacute;n</h2>
<div class="section">
<p>El objetivo del proyecto enterprise es poner en pr&aacute;ctica la gran mayor&iacute;a de pr&aacute;cticas estudiadas durante el curso, y servir como punto final donde se realicen una serie de pr&aacute;cticas a la finalizaci&oacute;n del proyecto.</p>
<a name="N10015"></a><a name="%C2%BFQu%C3%A9+Tenemos%3F"></a>
<h3 class="underlined_5">&iquest;Qu&eacute; Tenemos?</h3>
<p>Antes de empezar esta sesi&oacute;n, partimos de una aplicaci&oacute;n empaquetada dentro de un EAR (<span class="codefrag">proy-int.ear</span>), el cual contiene una aplicaci&oacute;n web (<span class="codefrag">proy-int-web.war</span>), un proyecto EJB (<span class="codefrag">proy-int-ejb.jar</span>) y una librer&iacute;a de utilidades (<span class="codefrag">proy-int-comun.jar</span>)</p>
<p>
    
<img alt="Esquema EAR" content-width="7cm" src="imagenes/s14/tenemosEar.jpg" width="268">
</p>
<p>A nivel l&oacute;gico, la aplicaci&oacute;n esta dividida en 3 capas: presentaci&oacute;n, negocio y datos. En el m&oacute;dulo de EJB, la parte de negocio de Operaci&oacute;n se refactoriz&oacute; a un EJB para aprovechar la gesti&oacute;n de transacciones y su escalabilidad. De este modo, el EJB de Operacion coordina las transacciones a nivel de negocio, en vez de realizarse a nivel de datos mediante JDBC.</p>
<p>
    
<img alt="Arquitectura de Despligue" content-width="15cm" src="imagenes/s14/tenemosEarArq.jpg" width="672">
</p>
<p>Como podemos observar en el siguiente gr&aacute;fico, &uacute;nicamente el subsistema de operaci&oacute;n se ha refactorizado a EJB. El hecho de tener en la aplicaci&oacute;n partes implementadas mediante EJB y otras sin ellos, se trata de una decisi&oacute;n que hay que tomar con buenos argumentos, ya que provoca inconsistencia en el c&oacute;digo, as&iacute; como duplicidad de c&oacute;digo (tenemos 2 factor&iacute;as para BOs).</p>
<p>
    
<img alt="Arquitectura EJB y BO" content-width="15cm" src="imagenes/s14/tenemosArq.jpg" width="676">
</p>
<a name="N1004C"></a><a name="Donde+Queremos+Llegar"></a>
<h3 class="underlined_5">Donde Queremos Llegar</h3>
<p>C&oacute;mo queremos una aplicaci&oacute;n homog&eacute;nea, y por cuestiones del gui&oacute;n hemos decidido utilizar EJBs, vamos a llevar toda nuestra l&oacute;gica de negocio a EJB de sesi&oacute;n sin estado.</p>
<p>
    
<img alt="Arquitectura con EJB" content-width="15cm" src="imagenes/s14/queremos.jpg" width="678">
</p>
<div class="frame note">
<div class="label">Optativo I - Proyectos Eclipse</div>
<div class="content">
El proyecto com&uacute;n contiene el c&oacute;digo del Negocio (<em>Business Objects</em>), los <em>Transfer Objects</em>, y los datos (<em>Data Transfer Objects</em>). Estas tres partes se pueden separar a su vez en proyectos diferentes y definir un nuevo grafo de dependencias, de modo que desde el proyecto web no se pueda instanciar un DAO.<br>
Realiza la separaci&oacute;n en capas l&oacute;gicas mediante proyectos de Eclipse y define las dependencias adecuadas.
</div>
</div>
</div>


<p class="pageBreakAfter"></p>

<a name="N10072"></a><a name="Integrando+los+EJBs"></a>
<h2 class="underlined_10">Integrando los EJBs</h2>
<div class="section">
<p>Del c&oacute;digo EJB existente, s&oacute;lo destacar que nuestros EJBs est&aacute;n heredando de la clase propietaria de Weblogic <span class="codefrag">GenericSessionBean</span>. Esta clase funciona como adaptador y evita tener que sobrescribir los m&eacute;todos <span class="codefrag">ejbCreate()</span>, <span class="codefrag">ejbDestroy()</span>. Spring ofrece diferentes adaptadores, como por ejemplo, <span class="codefrag">AbstractStatelessSessionBean</span>, que nos desacopla de un servidor de aplicaciones en concreto y facilita la reutilizaci&oacute;n de la l&oacute;gica de negocio. El problema viene cuando queremos aprovechar las ventajas que nos ofrece el IDE (Eclipse/Workshop) como el tratamiento de las anotaciones </p>
<p>Por otro lado, para poder desacoplar la parte web de los EJBs, hemos introducido una capa mediante el patr&oacute;n <em>Business Delegate</em>, el cual tiene el mismo interfaz que los BOs que ten&iacute;amos previamente.</p>
<p>Al introducir los EJBs, el interfaz se mantiene, pero la implementaci&oacute;n de los BOs cambia, ya que damos todo el control al contenedor para que gestione las transacciones de la aplicaci&oacute;n. Ya que mantiene la misma interfaz, es muy &uacute;til obligar que los EJBs y los <em>Business Delegate</em> implementen el mismo interfaz (antes del uso de las anotaciones, esto era un poco engorroso ya que obligaba a que, o bien propagar <span class="codefrag">RemoteException</span>s, o duplicar los interfaces y mantenerlos sincronizados a mano).</p>
<div class="frame note">
<div class="label">Pregunta</div>
<div class="content">
&iquest;Por qu&eacute; es muy &uacute;til que el interfaz este sincronizado entre el <em>Business Delegate</em> y el EJB?</div>
</div>
<p>As&iacute; pues, tendremos que tanto el <em>Business Delegate</em> implementa el interfaz</p>
<pre class="code">public class OperacionDelegate implements IOperacionBO</pre>
<p>como el EJB</p>
<pre class="code">public class OperacionBean extends GenericSessionBean
    implements SessionBean, IOperacionBO {</pre>
<div class="frame note">
<div class="label">Pregunta...?</div>
<div class="content">
&iquest;Para qu&eacute; sirve el m&eacute;todo <span class="codefrag">remove</span> de un EJB? &iquest;Es una buena idea crear un EJB en el constructor de una clase?
</div>
</div>
<a name="N100B5"></a><a name="Service+Locator"></a>
<h3 class="underlined_5">Service Locator</h3>
<p>En el estado actual, s&oacute;lo disponemos de una clase que utiliza un EJB, pero en las aplicaciones reales, son m&uacute;ltiples las clases que utilizan EJBs, y por tanto, el c&oacute;digo de b&uacute;squeda y creaci&oacute;n del EJB se repite a lo largo del c&oacute;digo. El patr&oacute;n Service Locator se encarga de juntar en una &uacute;nica clase todas las b&uacute;squedas JNDI e instanciaci&oacute;n de servicios ofrecidos por el servidor de aplicaciones, como pueden ser EJBs, componentes JMS o <em>datasources</em> JDBC.</p>
<p>En nuestro caso, vamos a crear un <em>singleton</em> con estrategia de cacheo dentro del proyecto com&uacute;n que encapsule las b&uacute;squedas JNDI.</p>
<pre class="code">
public class ServiceLocator {
    
    private static Log logger = LogFactory.getLog(ServiceLocator.class.getName());
    
    private static ServiceLocator me = new ServiceLocator();
    
<strong>    private InitialContext ic = null;</strong>
    
    /** Se utiliza para mantener las referencias a los EJBHomes, recursos JMS, para su reutilizacion */
<strong>    private Map cache = null;</strong>
    
    private ServiceLocator() {
        try {
<strong>            ic = new InitialContext();
            cache = Collections.synchronizedMap(new HashMap());
</strong>        } catch (NamingException ne) {
            logger.error("Error naming", ne);
        } catch (Exception e) {
            logger.error("Error exception", e);
        }
    }
    
    public static ServiceLocator getInstance() {
        return me;
    }
    
    public EJBLocalHome getLocalHome(String jndiHomeName)
        throws ServiceLocatorException {
        EJBLocalHome home = null;
        try {
<strong>            if (cache.containsKey(jndiHomeName)) {
                home = (EJBLocalHome) cache.get(jndiHomeName);
            } else {
                home = (EJBLocalHome) ic.lookup(jndiHomeName);
                cache.put(jndiHomeName, home);
            }</strong>
        } catch (NamingException ne) {
            throw new ServiceLocatorException("Error naming", ne);
        } catch (Exception e) {
            throw new ServiceLocatorException("Error", e);
        }
        return home;
    }
    
    public EJBHome getRemoteHome(String jndiHomeName, Class className)
        throws ServiceLocatorException {
        EJBHome home = null;
        try {
            if (cache.containsKey(jndiHomeName)) {
                home = (EJBHome) cache.get(jndiHomeName);
            } else {
                Object objref = ic.lookup(jndiHomeName);
                Object obj = PortableRemoteObject.narrow(objref, className);
                home = (EJBHome) obj;
                cache.put(jndiHomeName, home);
            }
        } catch (NamingException ne) {
            throw new ServiceLocatorException("Error naming", ne);
        } catch (Exception e) {
            throw new ServiceLocatorException("Error", e);
        }
        return home;
    }
    
    public DataSource getDataSource(String dataSourceName)
        throws ServiceLocatorException {
        DataSource dataSource = null;
        try {
            if (cache.containsKey(dataSourceName)) {
                dataSource = (DataSource) cache.get(dataSourceName);
            } else {
                dataSource = (DataSource) ic.lookup(dataSourceName);
                cache.put(dataSourceName, dataSource);
            }
        } catch (NamingException ne) {
            throw new ServiceLocatorException("Error naming", ne);
        } catch (Exception e) {
            throw new ServiceLocatorException("Error", e);
        }
        return dataSource;
    }
}
</pre>
<p>Del mismo modo, podemos a&ntilde;adir m&eacute;todos para buscar recursos JMS como <span class="codefrag">QueueConnectionFactory</span>, <span class="codefrag">Queue</span>, <span class="codefrag">TopicConnectionFactory</span> o <span class="codefrag">Topic</span>.</p>
<p>En el caso del datasource, sustituiremos el c&oacute;digo de creaci&oacute;n del contexto y b&uacute;squeda JNDI, por la llamada al m&eacute;todo delegado del Service Locator:</p>
<pre class="code">
<em>/*
 * Context initCtx = new InitialContext();
 * DataSource ds = (DataSource) initCtx.lookup("BiblioDS");
 */</em>

try {
    <strong>ds = ServiceLocator.getInstance().getDataSource("BiblioDS");</strong>
} catch (ServiceLocatorException sle) {
    logger.fatal("Error localizando datasource de JNDI", sle);
}
</pre>
<p>En cuanto al EJB, el ahorro de c&oacute;digo es mayor, y por tanto, m&aacute;s c&oacute;modo para poder crear los EJBs en los m&eacute;todos y no en el constructor.</p>
<pre class="code">
<em>/*
 * try { 
 *   Context jndiContext = new InitialContext();
 *   OperacionLocalHome home = (OperacionLocalHome) jndiContext.lookup("OperacionBeanLocal");
 *   operacionEJB = (OperacionLocal) home.create();
 * } catch (Exception e) {
 *   throw new RuntimeException("Error al obtener el EJB", e);
 * }
 */</em>
 
try {
    <strong>OperacionLocalHome home = (OperacionLocalHome)
        ServiceLocator.getInstance().getLocalHome("OperacionBeanLocal");</strong>
    operacionEJB = home.create();
} catch (Exception e) {
    logger.error("Error creando EJB de operacion", e);
    throw new RuntimeException("Error creando EJB de operacion", e);
}
</pre>
<p>M&aacute;s informaci&oacute;n sobre el patr&oacute;n <em>Service Locator</em> en: <a class="external" href="http://www.programacion.net/java/tutorial/patrones2/2/">www.programacion.net/java/tutorial/patrones2/2/</a>
</p>
<div class="frame note">
<div class="label">Alternativa</div>
<div class="content">Para evitar el uso del patr&oacute;n <em>Service Locator</em> + <em>Business Delegate</em>, la mejor soluci&oacute;n es seguir el enfoque que hace Spring, el cual desacopla tanto las llamadas como la duplicidad del interfaz. M&aacute;s informaci&oacute;n en <a class="external" href="http://www.springframework.org/docs/reference/ejb.html">www.springframework.org/docs/reference/ejb.html</a>

</div>
</div>
</div>


<p class="pageBreakAfter"></p>

<a name="N1011A"></a><a name="Procesos+Planificados"></a>
<h2 class="underlined_10">Procesos Planificados</h2>
<div class="section">
<p>Tal como comentamos en el caso de estudio, las reservas deben caducar. En la situaci&oacute;n actual, la &uacute;nica forma que tenemos de caducar las reservas es realizarlo a mano mediante la acci&oacute;n de "Anular Reserva" por parte de un usuario de tipo bibliotecario.</p>
<p>Necesitamos automatizar este proceso, de modo que cuando la fecha actual coincida con la fecha de finalizaci&oacute;n de una reserva (ffin), se elimine el registro de la base de datos. &iquest;C&oacute;mo hacemos esto? &iquest;Y si necesitamos ejecutar una tarea el &uacute;ltimo viernes de cada mes? &iquest;O todos los dias laborales a las 7 de la ma&ntilde;ana? &iquest;C&oacute;mo lo hacemos?</p>
<p>Para variar, hay varias soluciones. Una de ellas es realizar un proceso que se ejecute de forma autom&aacute;tica mediante un programador del sistema operativo, tipo cron o administrador de tareas. Esto provoca tener que configurar el sistema operativo y crear una mini-aplicaci&oacute;n java que realice este proceso. Los Sistemas Gestores de Bases de Datos como Oracle tambi&eacute;n incluyen jobs y eventos que permiten planificar los trabajos.</p>
<p>En la actualidad existen soluciones Java para automatizar procesos, como las caracter&iacute;sticas de la clase <strong>Timer</strong> (<a class="external" href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Timer.html">java.sun.com/j2se/1.5.0/docs/api/java/util/Timer.html</a>) o el uso de alg&uacute;n framework de planificaci&oacute;n, como <strong>Quartz</strong> (<a class="external" href="http://www.opensymphony.com/quartz/">www.opensymphony.com/quartz/</a>).</p>
<a name="N1013C"></a><a name="java.util.Timer"></a>
<h3 class="underlined_5">java.util.Timer</h3>
<p>Para implementar un planificador sencillo la propia JDK a partir de su versi&oacute;n 1.3 incluye las clases <span class="codefrag">Timer</span> y <span class="codefrag">TimerTask</span> (dentro del paquete <span class="codefrag">java.util</span>)</p>
<p>A continuaci&oacute;n se muestra un ejemplo explicativo:</p>
<pre class="code">
public class GeneradorInforme <strong>extends TimerTask</strong> {
  public void run() {
    System.out.println("Generando informe");
    <em>//TODO generar informe</em>
  }
}

class AplicacionMain {
  public static void main(String[] args) {
    Timer timer = new Timer();
    Calendar date = Calendar.getInstance();
    date.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);
    date.set(Calendar.HOUR, 0);
    date.set(Calendar.MINUTE, 0);
    date.set(Calendar.SECOND, 0);
    date.set(Calendar.MILLISECOND, 0);
    <em>// Planificado para ejecutar cada Domingo a medianoche</em>
    <strong>timer.schedule</strong>( new GeneradorInforme(), date.getTime(), 1000 * 60 * 60 * 24 * 7 );
  }
}
</pre>
<p>Podemos observar como necesitamos crear una clase que realiza la tarea planificada (en nuestro ejemplo, <span class="codefrag">GeneradorInforme</span>), la cual debe heredar de <span class="codefrag">TimerTask</span> (que a su vez implementa <span class="codefrag">java.lang.Runnable</span>). A continuaci&oacute;n, se planifica este objeto mediante los m&eacute;todos de planificaci&oacute;n de <span class="codefrag">Timer</span>. En nuestro caso, utilizamos el m&eacute;todo <span class="codefrag">schedule()</span> que acepta la fecha de la primer ejecuci&oacute;n y el periodo de las siguiente ejecuciones en milisegundos.
    </p>
<p>Al utilizar las caracter&iacute;sticas de planificaci&oacute;n, debemos tener en cuenta las garant&iacute;as de tiempo real que ofrece el API de planificaci&oacute;n. Desafortunadamente, debido a la naturaleza de Java y su implementaci&oacute;n en varias plataformas, la implementaci&oacute;n de la planificaci&oacute;n de los hilos es inconsistentes entre varias JVM. Por esto, el <span class="codefrag">Timer</span> no puede garantizar que nuestra <span class="codefrag">TimerTask</span> se ejecutar&aacute; en el momento exacto. Nuestras tareas implementadas como objetos <span class="codefrag">Runnable</span> se pone a dormir durante cierto tiempo. El Timer los despierta en un momento determinado, pero el momento exacto de ejecuci&oacute;n depende de la pol&iacute;tica de planificaci&oacute;n de la JVM y de cuantos hilos est&eacute;n esperando a entrar a la CPU.</p>
<p>Existen 2 escenarios comunes que pueden provocar que nuestras tareas se ejecuten con retraso. Primero, un gran n&uacute;mero de hilos pueden estar esperando a ejecutarse, y segundo, se puede producir un retraso por la actividad del recolector de basura.</p>
<p>Teniendo esto en cuenta, existen 2 modos diferentes de planificar dentro de la clase <span class="codefrag">Timer</span>: planificar mediante un retardo fijo (<span class="codefrag">schedule()</span>) y planificar con intervalos regulares (<span class="codefrag">scheduleAtFixedRate()</span>). Con los m&eacute;todos del primer grupo, cada retraso en la ejecuci&oacute;n de una tarea se propagar&aacute; en las consiguientes ejecuciones de la tarea. Con los m&eacute;todos del &uacute;ltimo, todo las ejecuciones posteriores se planifican a partir del tiempo de la tarea inicial, minimizando el retraso.</p>
<div class="frame note">
<div class="label">Importante</div>
<div class="content">Cada objeto <span class="codefrag">Timer</span> comienza un hilo de ejecuci&oacute;n en background. Este comportamiento no es deseable dentro de un entorno gestionado (<em>managed</em>), tal como un servidor de aplicaciones JavaEE, ya que estos hilos no est&aacute;n al alcance del contenedor.</div>
</div>
<a name="N10199"></a><a name="EJB+Timer"></a>
<h3 class="underlined_5">EJB Timer</h3>
<p>A partir de la especificaci&oacute;n 2.1 de EJB, el contenedor EJB puede gestionar servicios de tiempo lo que permite a los m&eacute;todos EJB registrar callbacks en un tiempo determinada o en un intervalo regular. Los timers EJB ofrecen facilidades para planificar tareas predeterminadas (igual que Quartz).</p>
<a name="N101A2"></a><a name="Timer+API"></a>
<h4>Timer API</h4>
<p>El API de EJB Timer se define mediante 4 interfaces dentro del paquete  <span class="codefrag">javax.ejb</span>:</p>
<ul>
        
<li>
<span class="codefrag">TimedObject</span>, el cual contiene los m&eacute;todos callback utilizados para las notificaciones de expiraci&oacute;n. El bean de implementaci&oacute;n EJB debe implementar este interfaz.</li>
        
<li>
<span class="codefrag">Timer</span>, interfaz que contiene la informaci&oacute;n sobre el planificador creado a trav&eacute;s del servicio EJB Timer.</li>
        
<li>
<span class="codefrag">TimerHandle</span>, manejador <span class="codefrag">Serializable</span> utilizado para persistir la informaci&oacute;n del Timer</li>
        
<li>
<span class="codefrag">TimerService</span>, el cual ofrece a los componentes EJB acceso al servicio planificador gestionado por el contenedor, y se expone a trav&eacute;s del interfaz <span class="codefrag">EJBContext</span>.</li>
    
</ul>
<p>Tenemos que utilizar los m&eacute;todos <span class="codefrag">createTimer</span> del interfaz <span class="codefrag">TimerService</span> para crear un timer. El timer puede ser <strong>sencillo</strong>, el cual puede ocurrir en un momento determinado o tras un periodo de tiempo espec&iacute;fico, o un timer <strong>peri&oacute;dico</strong>, el cual puede ejecutarse mediante una planificaci&oacute;n. Los tres posibles tipos de timers son los siguientes:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
        
<tr>
<th colspan="1" rowspan="1">Tipo de Timer</th><th colspan="1" rowspan="1"><span class="codefrag">createTimer</span> con par&aacute;metros</th>
</tr>
        
<tr>
<td colspan="1" rowspan="1">Timer sencillo</td><td colspan="1" rowspan="1"><span class="codefrag">createTimer(long timeoutDuration, Serializable info)</span></td>
</tr>
        
<tr>
<td colspan="1" rowspan="1">Timer sencillo con fecha de expiraci&oacute;n</td><td colspan="1" rowspan="1"><span class="codefrag">createTimer(Date firstDate, Serializable info)</span></td>
</tr>
        
<tr>
<td colspan="1" rowspan="1">Timer peri&oacute;dico con expiraci&oacute;n inicial</td><td colspan="1" rowspan="1"><span class="codefrag">createTimer(Date firstDate, long timeoutInterval, Serializable info)</span> o <br>
<span class="codefrag">createTimer(long timeoutDuration, long timeoutInterval, Serializable info)</span></td>
</tr>
    
</table>
<p>El <span class="codefrag">timeoutDuration</span> o intervalo se especifica en milisegundos, y el <span class="codefrag">initialExpiration</span> mediante un <span class="codefrag">java.util.Date</span>. El contenedor invocar&aacute; el m&eacute;todo <span class="codefrag">ejbTimeOut</span> del EJB cunado expire el <span class="codefrag">timeoutDuration</span>. Si decidimos cancelar el timer antes de que expire, tenemos que invocar el m&eacute;todo <span class="codefrag">cancel</span> del timer.</p>
<a name="N10224"></a><a name="Timers+y+tipos+de+EJBs"></a>
<h4>Timers y tipos de EJBs</h4>
<p>El uso de timers es similar para todos los tipos de EJBs, con pocas excepciones. Un timer creado por un bean de entidad se asocia con su identidad. Sin embargo, el m&eacute;todo <span class="codefrag">ejbTimeout</span> se puede invocar en cualquier instancia de un timer creado en un bean sin estado (<em>SLSB</em>) o en un bean dirigido por el mensaje (<em>MDB</em>). El ciclo de vida del timer esta atado al del bean. Destacar que un timer no se puede utilizar con bean se sesi&oacute;n con estado (<em>SFSB</em>).</p>
<a name="N1023A"></a><a name="Modelo+de+programaci%C3%B3n"></a>
<h4>Modelo de programaci&oacute;n</h4>
<p>El modelo de programaci&oacute;n es el siguiente. Cuando se acaba el tiempo del bean, el contenedor llamar&aacute; a su m&eacute;todo <span class="codefrag">ejbTimeout()</span>. Podemos poner cualquier tipo de l&oacute;gica de negocio que queramos dentro del m&eacute;todo <span class="codefrag">ejbTimeout()</span>. Por ejemplo, un bean de entidad que representa una factura podr&iacute;a tener un timer que se active despu&eacute;s de 45 d&iacute;as. Cuando se pase este tiempo, el contenedor llamar&aacute; al m&eacute;todo <span class="codefrag">ejbTimeout()</span>. El bean de entidad de la factura podr&iacute;a enviar un mensaje JMS para alertar a una aplicaci&oacute;n encargada de los cobros de que se ha pasado la fecha del pago, o enviar al cliente un e-mail solicit&aacute;ndole el pago.</p>
<p>El objeto Timer que se ha pasado a <span class="codefrag">ejbTimeout()</span> incluye caracter&iacute;sticas que nos permiten cancelar un temporizador, encontrar el tiempo que nos queda antes de que se acabe, u obtener un manejador para hacerlo persistente. Adem&aacute;s, cuando establecemos un objeto <span class="codefrag">Timer</span> podemos asociarlo con cualquier objeto serializable, y as&iacute; almacenar informaci&oacute;n espec&iacute;fica de la aplicaci&oacute;n con &eacute;l. Luego cuando se acabe el temporizador podremos acceder a esa informaci&oacute;n y utilizarla para determinar como procesar el evento disparado.</p>
<a name="N10256"></a><a name="Ejemplo+de+EJB+Timer"></a>
<h4>Ejemplo de EJB Timer</h4>
<p>Si queremos utilizar el service Timer de EJB para planificar una actividad de negocio, debemos seguir los siguientes pasos:</p>
<ul>
        
<li>La clase bean del EJB debe implementar el interfaz <span class="codefrag">javax.ejb.TimedObject</span>.</li>
        
<li>Hemos de crear el timer mediante la invocaci&oacute;n del m&eacute;todo <span class="codefrag">createTimer</span>, bien en el m&eacute;todo <span class="codefrag">ejbCreate</span> o en un m&eacute;todo de negocio del EJB. Si decidimos create el timer en <span class="codefrag">ejbCreate</span> o <span class="codefrag">ejbPostCreate</span>, el timer se inicializar&aacute; autom&aacute;ticamente cuando un cliente cree una instancia del bean. Si elegimos crear un m&eacute;todo de negocio, tenemos que exponer este m&eacute;todo en el/los interfaz/ces remotos y/o local. Los clientes invocar&aacute;n este m&eacute;todo para inicializar el timer.</li>
        
<li>Tenemos que implementar en el m&eacute;todo <span class="codefrag">ejbTimeout</span> la l&oacute;gica de negocio deseada cuando finalice el timer.</li>
    
</ul>
<p>Asumamos que una actividad de negocio debe realizar de forma peri&oacute;dica. Por lo tanto, crearemos un timer peri&oacute;dico, y le pasaremos la fecha inicial de expiraci&oacute;n y el intervalo de caducidad como par&aacute;metros.</p>
<p>Vamos a crear un bean de sesi&oacute;n sin estado que utilice un timer EJB. En nuestro ejemplo, <span class="codefrag">TimerDemoBean</span>, tiene un m&eacute;todo llamada <span class="codefrag">initializeTimer</span> que crea un timer peri&oacute;dico, y un cliente para planificar el timer para que se ejecute de forma peri&oacute;dica, e invoque al m&eacute;todo de negocio.</p>
<pre class="code">public class TimerDemoBean implements SessionBean, <strong>TimedObject</strong> {
    private SessionContext sc;
    private TimerHandle timerHandle = null;

    public void ejbCreate() {}
    public void ejbActivate() {}
    public void ejbPassivate() {}
    public void ejbRemove() {}
    public void setSessionContext(SessionContext ctx) { sc = ctx; }
    
    public void initializeTimer(Date firstDate, long timeout, String info) {
        try {
            <em>// Creamos el Timer</em>
            <strong>TimerService ts = sc.getTimerService();
            Timer timer = ts.createTimer(firstDate, timeout, info);</strong>
            System.out.println("Timer creado " + new Date(System.currentTimeMillis())
                + " con timeout: " + timeout + " y con info: " + info);
            
            <em>// Obtenemos el TimerHandle. Podemos utilizarlo para obtener valores del timer</em>
            timerHandle = timer.getHandle();
        } catch (Exception e) {
            System.out.println("Exception al crear timer: " + e.toString()); 
        }
        return;
    }
    
    public void ejbTimeout(Timer timer) {
        <em>// Aqui implementamos la l&oacute;gica de negocio</em>
        <strong>System.out.println("Hago mis tareas");</strong>
        System.out.println("ejbTimeout() invocado " +  new Date(System.currentTimeMillis()
            + " con info:" + timer.getInfo()));
        return;
    }

}</pre>
<p>Normalmente no queremos escribir en el c&oacute;digo la fecha/tiempo de expiraci&oacute;n inicial, y en cambio la pasaremos como par&aacute;metros desde el descriptor de despliegue, o dejando a los usuarios configurarlos dependiendo de sus requisitos de negocio. Evitar estas constantes hace la aplicaci&oacute;n portable y a&ntilde;ade flexibilidad para cambiar el intervalo cuando sea necesario. A no ser un bean de entidad, es mejor evitar la creaci&oacute;n del timer en <span class="codefrag">ejbCreate</span>, ya que no ofrece control a los clientes para crear el timer. Sin embargo, en el caso de un bean de entidad, tiene sentido crearlo en <span class="codefrag">ejbCreate</span> o <span class="codefrag">ejbPostCreate</span> cuando se asocia con su clave primaria, de modo que podamos planificar una tarea para crear una cuenta cuando se crea un empleado.</p>
<p>El c&oacute;digo de cliente necesario para invocar al m&eacute;todo EJB que crea el timer es el siguiente:</p>
<pre class="code">
<em>// Localizamos el EJBHome</em>
Context context = getInitialContext();
TimerDemoHome timerDemoHome = (TimerDemoHome) PortableRemoteObject.narrow(
    context.lookup("TimerDemo"), TimerDemoHome.class);

<em>// Utilizamos un los m&eacute;todos create() para crear una instancia</em>
TimerDemo timerDemo = timerDemoHome.create();

<em>// Llamamos al metodo remoto para acceder al EJB</em>
<strong>timerDemo.initializeTimer( firstDate, timeoutInterval, timerName );</strong>
</pre>
<p>Cuando se ejecuta la aplicaci&oacute;n, esta acci&oacute;n llamar&aacute; al servicio timer y crear&aacute; un timer peri&oacute;dico, y el contenedor invocar&aacute; al m&eacute;todo <span class="codefrag">ejbTimeout</span> en el momento <span class="codefrag">firstDate</span> y en los intervalos especificados en <span class="codefrag">timeoutInterval</span>.</p>
<div class="frame note">
<div class="label">Inicializar el Timer</div>
<div class="content">
    Si quisi&eacute;ramos evitar la necesidad de crear un cliente que inicie el timer, tendr&iacute;amos que jugar con el <span class="codefrag">ServletContextListener</span> o crear un Servlet, implementar el m&eacute;todo <span class="codefrag">init</span> y configurarlo para que cargue al arrancar el servidor mediante la propiedad <span class="codefrag">load-on-startup</span>, de modo que al arrancar el servidor se iniciase el timer (para repasar, revisa los apuntes de la primera sesi&oacute;n de Servlets: <a href="../jsp/sesion01-apuntes.html">www.jtech.ua.es/j2ee/2006-2007/restringido/jsp/sesion01-apuntes.html</a>). Otra alternativa que evita la modificaci&oacute;n del archivo web.xml y que ofrece m&aacute;s flexibilidad es crear un <span class="codefrag">PlugIn</span> en <em>Struts</em> (m&aacute;s informaci&oacute;n en <a class="external" href="http://www.onjava.com/pub/a/onjava/2004/11/10/ExtendingStruts.html">www.onjava.com/pub/a/onjava/2004/11/10/ExtendingStruts.html</a>).
    </div>
</div>
<p>M&aacute;s informaci&oacute;n en el tutorial de Sun: EJB 2.1 en <a class="external" href="http://java.sun.com/j2ee/1.4/docs/tutorial/doc/Session5.html">java.sun.com/j2ee/1.4/docs/tutorial/doc/Session5.html</a>, y EJB 3.0 en <a class="external" href="http://java.sun.com/javaee/5/docs/tutorial/doc/Session4.html">java.sun.com/javaee/5/docs/tutorial/doc/Session4.html</a>
</p>
<a name="N102EF"></a><a name="Quartz"></a>
<h3 class="underlined_5">Quartz</h3>
<p>Es un framework gratuito (<a class="external" href="http://www.opensymphony.com/quartz/">www.opensymphony.com/quartz/</a>) desarrollado por OpenSymphony (los mismos de <em>OSCache</em>), que se autodefine como un sistema completo de planificaci&oacute;n de tareas que puede integrarse con aplicaciones sencillas Java o aplicaciones complejas JavaEE, y que ofrece diferentes ventajas sobre los java.util.Timer, y en algunas ocasiones, sobre EJB Timer. Aunque se defina como un sistema completo, en su uso m&aacute;s sencillo es muy f&aacute;cil de utilizar.</p>
<a name="N102FF"></a><a name="%C2%BFPor+qu%C3%A9+utilizar+Quartz+y+no+EJB+Timer+o+el+API+Timer%3F"></a>
<h4>&iquest;Por qu&eacute; utilizar Quartz y no EJB Timer o el API Timer?</h4>
<p>La primera ventaja es la persistencia. Si los trabajos son est&aacute;ticos, como en nuestro primer ejemplo, quiz&aacute;s no necesitemos almacenar los trabajos. Pero si queremos crear trabajos que se disparen din&aacute;micamente cuando se cumplan ciertas condiciones, entonces tenemos que asegurarnos que dichas tareas no se pierdan cuando el sistema se reinicia. <em>Quartz</em> ofrece tanto trabajos no-persistentes como persistentes, en los cuales se almacena su estado en una base de datos, de modo que nos aseguramos que dichos trabajos no se pierden. Estos trabajos persistentes introducen una penalizaci&oacute;n en el rendimiento del sistema, por lo que hemos de usarlo solo cuando sean necesarios.</p>
<p>El API Timer tambi&eacute;n carece de m&eacute;todos para simplificar el fecha deseada de ejecuci&oacute;n. Lo m&aacute;s sofisticado que podemos hacer es poner una fecha de inicio y un intervalo peri&oacute;dico de ejecuci&oacute;n. Lo que queremos en una herramienta de planificaci&oacute;n tan potente como cron, pero integrada en Java. Quartz define <span class="codefrag">org.quartz.CronTrigger</span> que permite definir una fecha de activaci&oacute;n de un modo flexible.</p>
<p>Los desarrolladores tambi&eacute;n suelen necesitar una caracter&iacute;stica adicional: gestionar y organizar los trabajos y tareas por sus nombres. En Quartz, podemos obtener los trabajos por sus nombres o pertenencia a grupos, con cual facilita mucho el trabajo en entornos donde hay un gran n&uacute;mero de trabajos y disparadores.</p>
<a name="N10315"></a><a name="Modo+B%C3%A1sico+de+Empleo"></a>
<h4>Modo B&aacute;sico de Empleo</h4>
<p>Para utilizar Quartz simplemente hemos de crear una clase Java que implemente el interfaz <span class="codefrag">org.quartz.Job</span>, el cual s&oacute;lo contiene un m&eacute;todo:</p>
<pre class="code">public void execute(JobExecutionContext context) throws JobExecutionException;</pre>
<p>En esta clase <span class="codefrag">Job</span>, a&ntilde;adiremos la l&oacute;gica dentro del m&eacute;todo <span class="codefrag">execute()</span>. El objeto <span class="codefrag">JobExecutionContext</span> que se pasa como par&aacute;metro a este m&eacute;todo ofrece informaci&oacute;n a la instancia del trabajo sobre su entorno de ejecuci&oacute;n, como acceso al planificador que lo ha ejecutado, el trigger que le ha disparado, los detalles del trabajo mediante el objeto <span class="codefrag">JobDetail</span>, etc...</p>
<p>Una vez configurada la clase <span class="codefrag">Job</span> y lanzado el planificador, <em>Quartz</em> se preocupar&aacute; del resto. Cuando el <span class="codefrag">Scheduler</span> (planificador) determina que llega el momento de notificar al <span class="codefrag">Job</span> (trabajo), el framework <em>Quartz</em> llamar&aacute; a execute y le ceder&aacute; el control. Dentro del m&eacute;todo no tenemos que hacer nada con <em>Quartz</em>, &uacute;nicamente realizar las tareas que queremos. En el caso de que hayamos configurado el trabajo para que se vuelva a llama, el framework volver&aacute; a llamar al m&eacute;todo en el momento definido.</p>
<p>Ahora volveremos a crear el GeneradorInforme mediante Quartz a modo de ejemplo y explicaci&oacute;n del framework. Por un lado tenemos el trabajo, el cual se invocar&aacute; cuando el planificador decida:</p>
<pre class="code">public class InformeQuartz <strong>implements Job</strong> {

  <strong>public void execute(JobExecutionContext cntxt) throws JobExecutionException {</strong>
    System.out.println("Generando informe - " + cntxt.getJobDetail().getJobDataMap().get("type"));
    //TODO Generamos el informe
  }
}
</pre>
<p>Y por otro lado, el planificador. En nuestro caso, hemos creado un programa <span class="codefrag">Main</span> que crea un planificador, y que utiliza un <span class="codefrag">JobDataMap</span> para pasar parametros del planificador al trabajo, todo ello, disparado por un trigger basado en cron.</p>
<pre class="code">
public class MiPlanificador {
  public static void main(String[] args) {
    try {
      <strong>SchedulerFactory schedFact = new org.quartz.impl.StdSchedulerFactory();</strong><em>// creamos una factoria</em>
      <strong>Scheduler sched = schedFact.getScheduler();</strong><em>// obtenemos un planificador</em>
      <strong>sched.start();</strong> <em>// arrancamos el planificador</em>
      
      <em>// Creamos un trabajo con nombre+grupo+claseJob</em>
      <strong>JobDetail jobDetail =
        new JobDetail("Trabajo Informe de Ingresos", "Grupo GeneradorInforme", InformeQuartz.class); 
      jobDetail.getJobDataMap().put("type","FULL");</strong>
      
      <em>// Creamos un disparador basado en cron</em>
      <strong>CronTrigger trigger = new CronTrigger("Disparador Informe de Ingresos", "Grupo GeneradorInforme");
      trigger.setCronExpression("0 0 12 ? * SUN");</strong>
      
      <em>// A&ntilde;adimos el trabajo+disparador al planificador</em>
      <strong>sched.scheduleJob(jobDetail, trigger);</strong>
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
</pre>
<a name="N10386"></a><a name="Trabajos+y+Disparadores"></a>
<h4>Trabajos y Disparadores</h4>
<p>
<em>Quartz</em> define 2 abstracciones b&aacute;sicas, los trabajos (<strong>jobs</strong>) y los disparadores (<strong>triggers</strong>). Un trabajo es una abstracci&oacute;n del trabajo que deber&iacute;a realizarse, y el disparador representa el instante temporal en el que la acci&oacute;n deber&iacute;a ocurrir.</p>
<p>Job es un interfaz, y por lo tanto, nuestra clase que desee planificarse debe implementar el interfaz <span class="codefrag">org.quartz.Job</span> (o <span class="codefrag">org.quartz.StatefulJob</span>) y sobreescribir el m&eacute;todo <span class="codefrag">execute()</span>.</p>
<p>La decisi&oacute;n de si el trabajo debe ser sin estado o con estado depende de si vamos a necesitar cambiar estos par&aacute;metros durante la ejecuci&oacute;n. Si implementamos un <span class="codefrag">Job</span>, todos los par&aacute;metros se almacenan en el momento que el trabajo se planifica por primera vez, y todos los cambios posteriores se descartan. En cambio, si utilizamos un <span class="codefrag">StatefulJob</span>, y cambiamos los par&aacute;metros en el m&eacute;todo <span class="codefrag">execute</span>, los cambios se llevar&aacute;n a cabo cuando el trabajo se vuelva a disparar. Hay una pega, y es que los trabajos con estado no se pueden ejecutar concurrentemente, ya que los par&aacute;metros pueden cambiar durante la ejecuci&oacute;n.</p>
<p>En el ejemplo, podemos observar como podemos pasar atributos al trabajo mediante el atributo <span class="codefrag">jobDataMap</span>, el cual es una implementaci&oacute;n modificada de un <span class="codefrag">java.util.Map</span>.</p>
<p>Hay 2 tipos de disparadores: <span class="codefrag">SimpleTrigger</span> y <span class="codefrag">CronTrigger</span>. Mediante <span class="codefrag">SimpleTrigger</span> obtenemos la misma funcionalidad que con el API Timer. Lo utilizaremos si el trabajo debe dispararse una vez, y a continuaci&oacute;n repetirse mediante un intervalo temporal peri&oacute;dico. Mediante este disparador podemos especificar la fecha inicial, la final, un contador de repeticiones, y el intervalo peri&oacute;dico.  Por ejemplo:</p>
<pre class="code">Trigger trigger2Dias = new SimpleTrigger("disparador2d", "grupo2d");
trigger2Dias.setRepeatCount(SimpleTrigger.REPEAT_INDEFINITELY);
<em>// 24 horas * 60(minutos por hora) * 60(segundos por minuto) * 1000(milisegundos por segundo)</em>
trigger2Dias.setRepeatInterval(2L * 24L * 60L * 60L * 1000L); <em>// se ejecuta cada 2 dias</em>

Trigger triggerHora = TriggerUtils.makeHourlyTrigger(); <em>// se ejecuta cada hora</em>
triggerHora.setName("miTriggerHorario");
</pre>
<p>La clase <span class="codefrag">TriggerUtils</span> (en el paquete <span class="codefrag">org.quartz</span>) contiene operaciones comunes que ayudan a crear disparadores y fechas sin necesidad de pelearse con objetos <span class="codefrag">java.util.Calendar</span>. Mediante esta clase es muy f&aacute;cil crear disparadores que se ejecuten cada minuto, hora, d&iacute;a, semana, mes, etc... Adem&aacute;s, mediante esta clase podemos generar fechas redondeadas al siguiente segundo, minuto o hora, lo cual puede ser muy &uacute;til para establecer una fecha de inicio correcta.</p>
<p>En cambio, mediante el disparador <span class="codefrag">CronTrigger</span>, podemos crear disparadores a medida, con periodos y fechas m&aacute;s complejas. En el ejemplo anterior del <span class="codefrag">InformeQuartz</span> lanzado por <span class="codefrag">MiPlanificador</span>, hemos utilizado el disparador <span class="codefrag">CronTrigger</span> por su flexibilidad para planificar los trabajo mediante una base m&aacute;s real. Este disparador nos permite expresar planificaciones como "<em>cada d&iacute;a de la semana a la 7:00 de la ma&ntilde;ana</em>", o "<em>cada 5 minutos los s&aacute;bados y domingos</em>". M&aacute;s informaci&oacute;n en el javadoc: <a class="external" href="http://quartz.sourceforge.net/javadoc/org/quartz/CronTrigger.html">quartz.sourceforge.net/javadoc/org/quartz/CronTrigger.html</a>. Algunos ejemplos curiosos:</p>
<pre class="code">CronTrigger trigger5min = new CronTrigger("Disp 5 minutos", "GrupoCron");
trigger5min.setCronExpression("0 0/5 * * * ?"); <em>//cada 5 minutos</em>

CronTrigger trigger5min10seg = new CronTrigger("Disp 5 minutos 10 seg", "GrupoCron");
<em>//cada 5 minutos, y 10 segundo tras el minuto (10:00:10, 10:05:10, ...)</em>
trigger5min10seg.setCronExpression("0 0/5 * * * ?");

CronTrigger triggerHorasMediaRango = new CronTrigger("Disp 5 minutos 10 seg", "GrupoCron");
<em>// se ejecuta 10:30, 11:30, 12:30, y 13:30, cada Miercoles y Viernes</em>
triggerHorasMediaRango.setCronExpression("0 30 10-13 ? * WED,FRI");
</pre>
<div class="frame note">
<div class="label">Tener en cuenta que...</div>
<div class="content">Algunos requisitos de planificaci&oacute;n son demasiado complicados para expresarse mediante un &uacute;nico disparador; por ejemplo "<em>cada 5 minutos entre las 9:00am y las 10:00am, y cada 20 minutos entre la 1:00pm y las 10:00pm</em>". La soluci&oacute;n para este escenario es crear 2 disparadores, y registrar ambos para que ejecuten el mismo trabajo.</div>
</div>
<p>La ventaja de que los conceptos de trabajo y disparador est&eacute;n separados, es que se pueden crear y almacenar en el planificador de forma independientes, y muchos disparadores se pueden asociar con el mismo trabajo. Otro beneficio de este bajo acoplamiento es la habilidad para configurar trabajos que permanecen en el planificador una vez que los disparadores han expirado, de modo que pueden volver a planificarse, sin necesidad de volver a definirlos. Igualmente, permite modificar o remplazar un disparador sin tener que redefinir su trabajo asociado.</p>
<p>Los trabajos y disparadores se planifican a trav&eacute;s del interfaz <span class="codefrag">Scheduler</span>. Para obtener una instancia de este interfaz, bien creamos una factor&iacute;a (<span class="codefrag">SchedulerFactory</span>) y obtenemos el planificador (como en el ejemplo), o bien utilizamos el m&eacute;todo est&aacute;tico  <span class="codefrag">getDefaultScheduler()</span> de la clase <span class="codefrag">StdSchedulerFactory</span> (el cual crear&aacute; un planificador identificado por los datos del fichero de configuraci&oacute;n). Una vez arrancado el planificador mediante el m&eacute;todo <span class="codefrag">start()</span>, la aplicaci&oacute;n no terminar&aacute; hasta que se llame al m&eacute;todo <span class="codefrag">shutdown()</span>.</p>
<a name="N10423"></a><a name="Fichero+de+Configuraci%C3%B3n"></a>
<h4>Fichero de Configuraci&oacute;n</h4>
<p>Para poder ejecutar el ejemplo, necesitamos configurar el archivo <span class="codefrag">quartz.properties</span>, el cual debemos colocar en el <em>classpath</em>. Un ejemplo b&aacute;sico del archivo es el siguiente:</p>
<pre class="code"># Propiedades principales
org.quartz.scheduler.instanceName = TestScheduler
org.quartz.scheduler.instanceId = one

# Configuracion del pool de hilos
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount =  5
org.quartz.threadPool.threadPriority = 4

# Configuraci&oacute;n del almacen de trabajos
org.quartz.jobStore.misfireThreshold = 5000
org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore</pre>
<p>Otra ventaja de utilizar <em>Quartz</em> es el uso de un pool de hilos. Quartz utiliza este pool para la ejecuci&oacute;n de los trabajos. El tama&ntilde;o elegido afecta al n&uacute;mero de trabajos que pueden ejecutarse concurrentemente. Si el trabajo necesite activarse pero no hay ning&uacute;n hilo libre, se dormir&aacute; hasta que se libere alg&uacute;n hilo. El n&uacute;mero de hilos a utilizar es una decisi&oacute;n complicada, siendo el mejor modo de saberlo mediante la experimentaci&oacute;n mediante diversas pruebas. El valor por defecto es 5, el cual es suficiente si no se trabaja con miles de trabajos. Quartz ofrece una implementaci&oacute;n del pool de hilos, pero no se nos limita a su uso.</p>
<p>Respecto a los almacenes de trabajo (<em>JobStore</em>), contienen toda la informaci&oacute;n sobre los trabajos y los disparadores (a modo de diccionario de datos). Aqu&iacute; es donde decidimos si vamos a mantener nuestros trabajos persistentes o no. En el ejemplo, hemos utilizado <span class="codefrag">org.quartz.simpl.RAMJobStore</span>, lo que significa que todos los datos se mantienen en memoria y por tanto no son persistentes. Como resultado, si la aplicaci&oacute;n se cae, toda la informaci&oacute;n sobre los trabajos planificados se perder&aacute;. En algunas situaciones, este es el comportamiento deseado, pero cuando queramos hacer persistentes los datos, deberemos configurar la aplicaci&oacute;n para que utilice <span class="codefrag">org.quartz.simpl.JDBCJobStoreTX</span> (o <span class="codefrag">org.quartz.simpl.JDBCJobStoreCMP</span>).</p>
<a name="N1044C"></a><a name="Dentro+de+una+Aplicaci%C3%B3n+Web%2FEnterprise"></a>
<h4>Dentro de una Aplicaci&oacute;n Web/Enterprise</h4>
<p>Si desarrollamos una aplicaci&oacute;n web o enteprise, nos plantearemos donde es el lugar adecuado para inicializar el planificador. Para ello, Quartz ofrece el servlet <span class="codefrag">org.quartz.ee.servlet.QuartzInitializerServlet</span>. Una vez configurado en el <span class="codefrag">web.xml</span>, al inicializar la aplicaci&oacute;n leer&aacute; el fichero de configuraci&oacute;n y estar&aacute; preparado para planificar trabajos:</p>
<pre class="code">&lt;servlet&gt;
    &lt;servlet-name&gt;QuartzInitializer&lt;/servlet-name&gt;
    &lt;display-name&gt;Quartz Initializer Servlet&lt;/display-name&gt;
    &lt;servlet-class&gt;org.quartz.ee.servlet.QuartzInitializerServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;shutdown-on-unload&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;</pre>
<p>Es importante destacar el parametro <span class="codefrag">shutdown-on-unload</span>, el cual le dice al planificador, que cuando el servlet se destruya, tambi&eacute;n pare/destruya el planificador.</p>
<p>Si seguimos este enfoque, nos aseguramos que al arrancar la aplicaci&oacute;n, tenemos el planificador por defecto arrancado y listo para ejecutar trabajos. Si lo que queremos es que una serie de trabajos se ejecuten al arrancar la aplicaci&oacute;n, deberemos crear otro <em>Servlet</em> o utilizar una soluci&oacute;n similar. En cambio, si lo que queremos es planificar trabajos cuando suceda algun evento en la aplicaci&oacute;n, mediante este Servlet se centraliza en un punto el arranque y la parada del planificador.</p>
<a name="N1046C"></a><a name="Quartz+y+EJBs"></a>
<h4>Quartz y EJBs</h4>
<p>Si queremos llamar a un m&eacute;todo de un EJB como un trabajo, tenemos que pasarle la clase <span class="codefrag">org.quartz.ee.ejb.EJBInvokerJob</span> al detalle del trabajo (<span class="codefrag">JobDetail</span>). Para demostrar esta t&eacute;cnica, implementaremos el generador de informe como un bean de sesi&oacute;n, y llamaremos al m&eacute;todo <span class="codefrag">generarInforme()</span> del EJB registrado en JNDI mediante <span class="codefrag">InformeEJB</span>, desde el <em>Servlet</em>.</p>
<pre class="code">public class InformeServlet extends HttpServlet {

  public void init(ServletConfig conf) throws ServletException {
    JobDetail jobDetail = new JobDetail("Trabajo Informe de Ingresos", "Grupo GeneradorInforme", <strong>EJBInvokerJob.class</strong>);
    jobDetail.getJobDataMap().put("ejb", "<strong>java:comp/env/ejb/InformeEJB</strong>");
    jobDetail.getJobDataMap().put("method", "<strong>generarInforme</strong>");
    Object[] args = new Object[0];
    jobDetail.getJobDataMap().put("args", args);

    CronTrigger trigger = new CronTrigger("Disparador Informe de Ingresos", "Grupo GeneradorInforme");
    trigger.setCronExpression("0 0 12 ? * SUN");
    
    try {
        Scheduler sched = StdSchedulerFactory.getDefaultScheduler();
        sched.scheduleJob(jobDetail, trigger);
        sched.start();
    } catch (Exception e) {
        e.printStackTrace();
    }
  }
}</pre>
<p>Como podemos observar, para que <em>Quartz</em> funcione igual que <em>EJB Timer</em>, hay tres par&aacute;metros que tenemos que pasarle al trabajo:</p>
<ul>
        
<li>
<span class="codefrag">ejb</span>: nombre JNDI del bean</li>
        
<li>
<span class="codefrag">method</span>: m&eacute;todo a llamar</li>
        
<li>
<span class="codefrag">args</span>: array de objetos que se pasan como argumentos al m&eacute;todo</li>
    
</ul>
<p>El resto se mantiene igual desde el punto de vista del uso de <em>Quartz</em>. En el ejemplo, hemos puesto la llamada en la inicializaci&oacute;n del servlet, aunque se puede colocar en cualquier lugar de la aplicaci&oacute;n.</p>
<p>Para que se pueda ejecutar correctamente el trabajo, es necesario registrar el <em>EJB</em> en la aplicaci&oacute;n web, creando una referencia en el <span class="codefrag">web.xml</span>:</p>
<pre class="code">&lt;ejb-ref&gt;
    &lt;ejb-ref-name&gt;ejb/InformeEJB&lt;/ejb-ref-name&gt;
    &lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt;
    &lt;home&gt;es.ua.jtech.ejb.InformeHome&lt;/home&gt;
    &lt;remote&gt;es.ua.jtech.ejb.Informe&lt;/remote&gt;
    &lt;ejb-link&gt;InformeEJB&lt;/ejb-link&gt;
&lt;/ejb-ref&gt;</pre>
<p>Un art&iacute;culo muy interesante donde ampliar esta informaci&oacute;n es "<em>What is Quartz</em>" por <em>Chuck Cavaness</em> (autor de un libro sobre <em>Quartz</em>): <a class="external" href="http://www.onjava.com/pub/a/onjava/2005/09/28/what-is-quartz.html">http://www.onjava.com/pub/a/onjava/2005/09/28/what-is-quartz.html</a>. Aqu&iacute; pod&eacute;is aprender a realizar un enfoque declarativo para especificar la informaci&oacute;n referente a los trabajos y los disparadores, de modo que almacenamos en un fichero xml toda esta informaci&oacute;n, desacopl&aacute;ndola del c&oacute;digo de la aplicaci&oacute;n.</p>
<a name="N104D3"></a><a name="Deshaciendo+las+Reservas+Caducadas"></a>
<h3 class="underlined_5">Deshaciendo las Reservas Caducadas</h3>
<p>Tal como hemos comentado al inicio de esta secci&oacute;n, queremos crear un proceso    planificado que deshaga las reservas conforme caduquen. El c&oacute;digo necesario para liberar las reservas (si utilizamos un EJB, lo colocaremos en el m&eacute;todo <span class="codefrag">ejbTimeout</span>, y si utilizamos <em>Quartz</em>, dentro del m&eacute;todo <span class="codefrag">execute</span> de una clase que implemente el interfaz <span class="codefrag">Job</span>) es el siguiente:</p>
<pre class="code">
IOperacionDAO operacionDAO = FactoriaDAOs.getInstance().getOperacionDAO();

List&lt;OperacionTO&gt; reservasCaducadas;
try {
    reservasCaducadas = operacionDAO.selectReservasCaducadas();
    
    for (OperacionTO operacion : reservasCaducadas) {
        logger.info("Liberando reserva " + operacion.getIdOperacion()
            + " del usuario " + operacion.getUsuario()
            + " y libro " + operacion.getLibro());
        operacionDAO.anularReserva(operacion.getIdOperacion());
    }
} catch (DAOException e) {
    logger.error("Error caducando las reservas", e);
}
</pre>
<p>La operaci&oacute;n de consulta de reservas caducadas <span class="codefrag"> selectReservasCaducadas()</span> obtendr&aacute; aquellas reservas con fecha de finalizaci&oacute;n anterior a la fecha actual y con fecha final real nula (de modo que todav&iacute;a no se ha pasado a reserva).</p>
<div class="frame warning">
<div class="label">Cuidado</div>
<div class="content">Si os decidis por utilizar <em>Quartz</em>, aparte de la propia libreria <span class="codefrag">quartz.jar</span>, debemos incluir la libreria <span class="codefrag">jta.jar</span> si trabajamos con <em>Tomcat</em>, y diferentes librer&iacute;as <em>commons</em> (como <span class="codefrag">commons-logging.jar</span> y <span class="codefrag">commons-collections.jar</span>), disponibles en la distribuci&oacute;n de <em>Quartz</em>.</div>
</div>
</div> 


<p class="pageBreakAfter"></p>

<a name="N10515"></a><a name="Multidioma"></a>
<h2 class="underlined_10">Multidioma</h2>
<div class="section">
<p>En los tiempos que corren, con la multitud de idiomas vigentes, la inmigraci&oacute;n, la continua visita de extranjeros a nuestro pa&iacute;s y el cariz sin limites de fronteras que ofrece Internet, se hace casi impensable el desarrollo de una aplicaci&oacute;n en un s&oacute;lo idioma.</p>
<p>Aun cuando los requisitos dejen claro que la aplicaci&oacute;n deba estar s&oacute;lo en espa&ntilde;ol (o s&oacute;lo en ingl&eacute;s), si desde el principio dise&ntilde;amos la aplicaci&oacute;n y la arquitectura para que soporte m&uacute;ltiples idiomas, cuando en el futuro (que seguro que sucede), la aplicaci&oacute;n deba mostrarse en m&uacute;ltiples idiomas, los cambios necesarios ser&aacute;n m&iacute;nimos.</p>
<p>La caracter&iacute;stica de una aplicaci&oacute;n que soporta varios idiomas se conoce como <strong>internacionalizaci&oacute;n</strong> (i18n - <em>internationalization</em>).</p>
<a name="N1052A"></a><a name="Soporte+Java"></a>
<h3 class="underlined_5">Soporte Java</h3>
<p>La plataforma Java incluye una familia de clases Java (<span class="codefrag">java.util.ResourceBundle</span>) dise&ntilde;adas para soportar la b&uacute;squeda de cadenas de mensajes basadas en una clave est&aacute;ndar. Las clases del "<em>Resource Bundle</em>" autom&aacute;ticamente acceden a una clase Java (o a un fichero de propiedades) nombrado siguiendo una convenci&oacute;n que incluye el <span class="codefrag">Locale</span> al que pertenecen los mensajes de dicha clase (o fichero). Sin embargo, esta selecci&oacute;n se basa s&oacute;lo en el Locales por defecto de la plataforma del servidor, y no se puede modificar por cada usuario, tal como requieren las aplicaciones web.</p>
<div class="frame note">
<div class="label">Locale...</div>
<div class="content">
    Cada Locale representa una elecci&oacute;n particular de un pais y un idioma (de forma opcional se puede definir una variante del lenguaje), y adem&aacute;s un junto de suposiciones sobre el formateo de n&uacute;meros y fechas.</div>
</div>
<p>
<em>Struts</em> incluye un conjunto de clases (<span class="codefrag">org.apache.struts.util.MessageResources</span>) que extienden el enfoque b&aacute;sico de buscar cadenas de mensajes por clave, permitiendo, de forma opcional, especificar un <span class="codefrag">Locale</span> junto con la clave. De este modo, podemos construir aplicaciones que permitan al usuario seleccionar con que Locale desean operar, y en consecuencia, buscar los mensajes en ese lenguaje (utilizando las mismas claves de mensaje, sin importar que lenguaje se ha seleccionado).</p>
<p>Por defecto, Struts obtiene el Locale del navegador del usuario, de modo que si el usuario tiene el navegador en ingles, la aplicaci&oacute;n intentar&aacute; mostrar los mensajes en ingl&eacute;s.</p>
<p>Para m&aacute;s informaci&oacute;n acerca de la internacionalizaci&oacute;n de los mensajes:</p>
<ul>
        
<li>Informaci&oacute;n general de <em>i18n</em> disponible en <a class="external" href="http://java.sun.com/j2se/corejava/intl/index.jsp">
        http://java.sun.com/j2se/corejava/intl/index.jsp</a>, la cual ofrece informaci&oacute;n acerca los Locales, recursos localizados, formateo de mensajes, y otros temas de inter&eacute;s.</li>
        
<li>Tutorial de <em>i18n</em> disponible en <a class="external" href="http://java.sun.com/docs/books/tutorial/i18n/index.html">
        http://java.sun.com/docs/books/tutorial/i18n/index.html</a>
</li>
        
<li>API Javadoc de las clases:
            <ul>
                
<li>
<span class="codefrag">java.text.MessageFormat</span>
</li>
                
<li>
<span class="codefrag">java.util.ResourceBundle</span>
</li>
                
<li>
<span class="codefrag">java.util.PropertyResourceBundle</span>
</li>
                
<li>
<span class="codefrag">java.util.Properties</span>
</li>
            
</ul>
        
</li>
        
<li>La guia de uso de Struts incluye una secci&oacute;n sobre i18n: <a class="external" href="http://struts.apache.org/userGuide/building_view.html#i18n">struts.apache.org/userGuide/building_view.html#i18n</a>
        
</li>
        
<li>API Javadoc del paquete de <em>Struts</em> <span class="codefrag">org.apache.struts.util</span>
</li>
    
</ul>
<a name="N1058D"></a><a name="Configuraci%C3%B3n+Struts"></a>
<h3 class="underlined_5">Configuraci&oacute;n Struts</h3>
<p>Por defecto, Struts tiene la i18n activada.</p>
<a name="N10596"></a><a name="Controlador"></a>
<h4>Controlador</h4>
<p>En Struts 1.1 (y 1.0), en el archivo <span class="codefrag">web.xml</span> habiamos de informar al servlet de <em>Struts</em> que quer&iacute;amos <em>i18n</em> en nuestra aplicaci&oacute;n, de modo que obtiene el <span class="codefrag">Locale</span> del atributo <span class="codefrag">Globals.LOCALE_KEY</span> (normalmente mapeado con  de la sesi&oacute;n.</p>
<pre class="code">
&lt;servlet&gt;
    &lt;servlet-name&gt;action&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
        org.apache.struts.action.ActionServlet
    &lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;config&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/struts-config.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    <strong>&lt;init-param&gt;
        &lt;param-name&gt;locale&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;</strong>
&lt;/servlet&gt;
</pre>
<p>Si no quisi&eacute;ramos que el controlador activase el uso de Locale (lo que resulta en la creaci&oacute;n de una HttpSession), hemos de poner el atributo <span class="codefrag">locale</span> a <span class="codefrag">false</span> en el fichero de configuraci&oacute;n de struts.</p>
<pre class="code">
&lt;controller locale="false"/&gt;
</pre>
<a name="N105C3"></a><a name="Fichero+de+Recursos"></a>
<h4>Fichero de Recursos</h4>
<p>Por otro lado, para indicar en que fichero queremos almacenar los pares de clave-valor, en el archivo <span class="codefrag">struts-config.xml</span> hemos de especificar el nombre y la ruta del fichero de recursos:</p>
<pre class="code">
&lt;message-resources parameter="mensajes"/&gt;
</pre>
<p>Por lo tanto, en nuestra aplicaci&oacute;n, dicho archivo se encuentra en el paquete ra&iacute;z, siendo el archivo <span class="codefrag">mensajes.properties</span> el contenedor de los mensajes del lenguaje por defecto, <span class="codefrag">mensajes_ca.properties</span> el que contiene los textos en catal&aacute;n (o valenciano), <span class="codefrag">mensajes_en.properties</span> en ingl&eacute;s, etc... Adem&aacute;s, cada fichero de un idioma, puede tener especializaciones geogr&aacute;ficas, por ejemplo, ingl&eacute;s de Inglaterra (en_EN), ingl&eacute;s de EEUU (en_US), ingl&eacute;s de Canad&aacute; (en_CA), etc...</p>
<p>Es muy importante destacar que no todas las propiedades deben estar en todos los ficheros. Existe una relaci&oacute;n jer&aacute;rquica, de modo que si una propiedad no existe en el fichero hijo, se mostrar el mensaje del fichero padre. Por ejemplo, si queremos mostrar el mensaje de la propiedad "<span class="codefrag">login.title</span>", y el usuario tiene configurado el idioma ingl&eacute;s pero de Canad&aacute;, buscar&aacute; dicha propiedad en el archivo <span class="codefrag">mensajes_en_CA.properties</span>. Si no la encuentra en dicho archivo, la buscar&aacute; en <span class="codefrag">mensajes_en.properties</span> (mensajes en ingl&eacute;s, independiente de su localizaci&oacute;n geogr&aacute;fica). Finalmente, si tampoco la encuentra en ingl&eacute;s, la buscar&aacute; en el idioma por defecto, es decir, en el archivo <span class="codefrag">mensajes.properties</span>.</p>
<p>Si quieseramos guardar los ficheros de recursos dentro de la carpeta "<span class="codefrag">tradu</span>", entonces hemos de a&ntilde;adirlo como prefijo al nombre del fichero (<span class="codefrag">parameter="tradu.mensajes"</span>), indicando cada nivel con un punto, del mismo modo que la notaci&oacute;n de paquetes Java.</p>
<a name="N105F8"></a><a name="Cambio+de+Locale+Bajo+Petici%C3%B3n+del+Usuario"></a>
<h4>Cambio de Locale Bajo Petici&oacute;n del Usuario</h4>
<p>Adem&aacute;s, hemos de preparar un Action que cambie de forma din&aacute;mica, y bajo petici&oacute;n del usuario, el <span class="codefrag">Locale</span> existente en la sesi&oacute;n, sustituy&eacute;ndolo por el deseado.</p>
<pre class="code">
public class AccionCambiarLocale extends AccionComun {

    private static Log logger = LogFactory.getLog(AccionCambiarLocale.class.getName());
    
    public ActionForward execute(ActionMapping mapping, ActionForm actionForm,
            HttpServletRequest request, HttpServletResponse response)
            throws Exception {
    
        String lenguaje = request.getParameter("lenguaje");
        String pais = request.getParameter("pais");
    
        <strong>Locale newLocale = new Locale(lenguaje, pais);</strong>
        logger.info("Cambiamos locale " + request.getLocale() + " por "
                + newLocale);
    
        HttpSession session = request.getSession();
        <strong>session.setAttribute(Globals.LOCALE_KEY, newLocale);</strong>
    
        return mapping.findForward(Tokens.FOR_OK);
    }
}
</pre>
<p>As&iacute; pues, al llamar a este <em>Action</em>, se modificar&aacute; el <span class="codefrag">Locale</span> del usuario durante una sesi&oacute;n. Cuando un nuevo usuario vuelva a entrar a la aplicaci&oacute;n, volver&aacute; a aparecerle el texto con el idioma por defecto.</p>
<p>Finalmente, declaramos el <em>Action</em> en el archivo <span class="codefrag">struts-config.xml</span>:</p>
<pre class="code">&lt;action path="/accionCambiarLocale"
        type="es.ua.jtech.proyint.presentacion.acciones.AccionCambiarLocale"&gt;
        &lt;forward name="OK" path="/index.jsp" /&gt;
    &lt;/action&gt;
</pre>
<a name="N10626"></a><a name="Modo+de+Empleo"></a>
<h3 class="underlined_5">Modo de Empleo</h3>
<p>En nuestro caso, tenemos la p&aacute;gina <span class="codefrag">login.jsp</span> con soporte para el multidioma.</p>
<p>Como podemos observar, los textos a mostrar se visualizan mediante el uso del <em>taglib</em> <span class="codefrag">bean:message</span>, indicando en el atributo <span class="codefrag">key</span> la clave del elemento a mostrar.</p>
<pre class="code">&lt;html:form action="/accionLogin"&gt;
&lt;table border="0" cellpadding="0" cellspacing="0" width="616" align="center"&gt;
    ...
    &lt;tr&gt;
        &lt;td width="1" bgcolor="#D7D6D6"&gt;&lt;img src="imagenes/px_trans.gif" width="1" height="1"&gt;&lt;/td&gt;
        &lt;td width="247" height="95" bgcolor="#FFFFFF" valign="middle"&gt;
            &lt;h3&gt;<strong>&lt;bean:message key="login.bienvenida" /&gt;</strong>&lt;/h3&gt;
        &lt;/td&gt;
        &lt;td width="367" bgcolor="#FFFFFF" colspan="2"&gt;
        &lt;table&gt;
            &lt;tr&gt;
                &lt;td width="11"&gt;&amp;nbsp;&lt;/td&gt;
                &lt;td width="288" height="95" valign="middle"&gt;
                    <strong>&lt;bean:message key="login.instrucciones" /&gt;</strong>
                &lt;/td&gt;
                &lt;td width="11"&gt;&amp;nbsp;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
        &lt;/td&gt;
        &lt;td width="1" bgcolor="#D7D6D6"&gt;&lt;img src="imagenes/px_trans.gif" width="1" height="1"&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td colspan="5" height="1" bgcolor="#D7D6D6"&gt;
            &lt;img src="imagenes/px_trans.gif" width="1" height="1"&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td width="1" bgcolor="#D7D6D6"&gt;
            &lt;img src="imagenes/px_trans.gif" width="1" height="1"&gt;
        &lt;/td&gt;
        &lt;td width="247" height="192" bgcolor="#D7D6D6" align="right" valign="top" class="bold"&gt;
            &lt;img src="imagenes/px_trans.gif" width="1" height="30"&gt;
            <strong>&lt;bean:message key="login.login" /&gt;</strong>&amp;nbsp;&amp;nbsp;
            &lt;br /&gt;&lt;br /&gt;
            <strong>&lt;bean:message key="login.password" /&gt;</strong>&amp;nbsp;&amp;nbsp;
        &lt;/td&gt;
        &lt;td width="367" colspan="2" align="left" valign="top"&gt;
            &lt;img src="imagenes/px_trans.gif" width="1" height="30"&gt;&amp;nbsp;
            <em>&lt;html:text property="login" maxlength="18" size="16" /&gt;</em>
            &lt;br /&gt;&lt;br /&gt;&amp;nbsp;
            <em>&lt;html:password property="password" maxlength="18" size="16" /&gt;</em>
            &lt;img src="imagenes/px_trans.gif" width="22" height="1"&gt;
            <em>&lt;html:submit value="entrar" /&gt;</em>
        &lt;/td&gt;
        &lt;td width="1" bgcolor="#D7D6D6"&gt;&lt;img src="imagenes/px_trans.gif" width="1" height="1"&gt;&lt;/td&gt;
    &lt;/tr&gt;
    ...
&lt;/table&gt;

&lt;/html:form&gt;</pre>
<p>Cada clave se va a sustituir por el mensaje correspondiente, perteneciente al fichero de recursos asociados con el Locale almacenado en la sesi&oacute;n (en el caso del idioma por defecto ser&aacute; <span class="codefrag">mensajes.properties</span>).</p>
<pre class="code">
# -- mensajes p&aacute;gina de login --
login.title=Login Biblioteca jTech
login.bienvenida=bienvenido a la &lt;b&gt;Biblioteca jTech&lt;/b&gt;
login.instrucciones=Por favor, introduzca su &lt;b&gt;login y password&lt;/b&gt; &lt;br&gt;para acceder a la biblioteca
login.login=login
login.password=password

# -- errores standard --
errors.header=&lt;div class="box"&gt;
errors.footer=&lt;/div&gt;
errors.required=el campo {0} es obligatorio
errors.integer=el valor debe ser un entero
errors.date=formato de fecha incorrecto. Debe ser {0}

...
</pre>
<p>Y, por ejemplo, en ingl&eacute;s, en el archivo <span class="codefrag">mensajes_en.properties</span>:</p>
<pre class="code">
login.bienvenida=welcome to the &lt;b&gt;jTech Library&lt;/b&gt;
login.instrucciones=Please, type your &lt;b&gt;login and password&lt;/b&gt; &lt;br&gt;to enter the library
login.login=login
login.password=password
</pre>
<div class="frame warning">
<div class="label">Cuidado</div>
<div class="content">
    Tener en cuenta que se han de traducir tanto las etiquetas, t&iacute;tulos de p&aacute;gina, botones de la aplicaci&oacute;n, como los mensajes de error.</div>
</div>
<p>Para editar estos archivos, existen herramientas como <strong>i18nEdit</strong> (descarga <a class="external" href="http://sourceforge.net/projects/i18nedit">sourceforge.net/projects/i18nedit</a> - doc: <a class="external" href="http://i18nedit.sourceforge.net/userdoc/">i18nedit.sourceforge.net/userdoc/</a>), o el plugin de Eclipse <strong>ResourceBundle</strong> (<a class="external" href="http://resourcebundleeditor.com/">resourcebundleeditor.com/</a>)n que permiten la edici&oacute;n sincronizada de todos los archivos <em>properties</em>.</p>
<p>Finalmente, para cambiar el <span class="codefrag">Locale</span> bajo petici&oacute;n del usuario, podemos ofrecer diferentes enlaces (con textos, banderas, etc...) o un combo, que tras su selecci&oacute;n, realice una llamada al Action antes comentado pas&aacute;ndole como par&aacute;metros los datos del idioma a emplear.</p>
<pre class="code">
&lt;logic:match name="org.apache.struts.action.LOCALE" scope="session" value="es"&gt;
   Espa&ntilde;ol - 
   <strong>&lt;html:link page="/accionCambiarLocale.do?lenguaje=en&amp;pais=en"&gt;Ingl&eacute;s&lt;/html:link&gt;</strong>
&lt;/logic:match&gt;
&lt;logic:match name="org.apache.struts.action.LOCALE" scope="session" value="en"&gt;
   <strong>&lt;html:link page="/accionCambiarLocale.do?lenguaje=es&amp;pais=es"&gt;Spanish&lt;/html:link&gt;</strong>
   - English
&lt;/logic:match&gt;
</pre>
<p>Al pulsar sobre los enlaces, tendremos diferentes vistas, con diferentes idiomas, de una misma p&aacute;gina.</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
    
<tr>
    
<td colspan="1" rowspan="1"><img alt="En Espa&ntilde;ol" content-width="11cm" src="imagenes/s14/i18nES.jpg" width="409"></td>
    <td colspan="1" rowspan="1"><img alt="En Ingl&eacute;s" content-width="11cm" src="imagenes/s14/i18nEN.jpg" width="406"></td>
    
</tr>
    
</table>
<div class="frame warning">
<div class="label">Importante</div>
<div class="content">Para que nuestra p&aacute;gina de login soporte el multidioma, previamente Struts tiene que haber creado un objeto <span class="codefrag">HttpSession</span>. Como actualmente estamos accediendo directamente a la p&aacute;gina <span class="codefrag">index.jsp</span> sin pasar por ning&uacute;n <em>Action</em>, no existe ninguna sesi&oacute;n creada.<br>
    La soluci&oacute;n que hemos elegido es crear un <span class="codefrag">ForwardAction</span> llamado <span class="codefrag">/index</span> que rediriga el control a la pagina <span class="codefrag">index.jsp</span> (<span class="codefrag">&lt;action path="/index" type="org.apache.struts.actions.ForwardAction" parameter="/index.jsp" /&gt;</span>), y en el archivo <span class="codefrag">web.xml</span>, crear un <span class="codefrag">welcome-file</span> con el action <span class="codefrag">index.do</span> (en Tomcat no reconoce un action como recurso de bienvenida, asi que tambi&eacute;n hemos creado otro archivo <span class="codefrag">indexForward.jsp</span> que  tambi&eacute;n hemos a&ntilde;adido a la lista de bienvenida, el cual contiene una redirecci&oacute;n al action <span class="codefrag">index.do</span> (<span class="codefrag">&lt;logic:redirect page="/index.do" /&gt;</span>).<br>
    No olvidemos que al hacer <em>logout</em>, tambi&eacute;n hemos de pasar por <span class="codefrag">index.do</span> para que inicialice una nueva sesi&oacute;n.
    </div>
</div>
<div class="frame note">
<div class="label">Optativo II - Multidioma</div>
<div class="content">
    1.- &iquest;Como podemos forzar a que la aplicaci&oacute;n utilice siempre el idioma que nosotros queramos de modo que ignore el idioma del navegador?<br>
    2.- &iquest;Como podemos cambiar el idioma de la aplicaci&oacute;n y que siga en la misma p&aacute;gina en la que estaba?
    </div>
</div>
</div>


<p class="pageBreakAfter"></p>


<a name="N106F2"></a><a name="Pruebas+de+Aceptaci%C3%B3n"></a>
<h2 class="underlined_10">Pruebas de Aceptaci&oacute;n</h2>
<div class="section">
<p>Las pruebas de aceptaci&oacute;n o funcionales se centra comprobar que el sistema ofrece la funcionalidad esperada por el cliente. El comportamiento funcional del sistema se puede detallar mediante una serie de casos de uso, como es la pr&aacute;ctica de un proceso dirigido por casos de uso como RUP, o mediante un conjunto de historias de usuario cuando se sigue una metodolog&iacute;a &aacute;gil como XP.</p>
<p>En XP, el cliente trabaja con el equipo de desarrollo para generar una suite de pruebas de aceptaci&oacute;n autom&aacute;ticas. En proyectos m&aacute;s grandes que siguen RUP, normalmente es el equipo de QA el encargado de crear los scripts de prueba a partir de los casos de uso del sistema.</p>
<p>Las pruebas funcionales son una t&eacute;cnica de caja negra, y dentro del sistema de negocio conf&iacute;a en los casos de prueba que prueban la funcionalidad del sistema mediante el interfaz de usuario.</p>
<p>Diferentes herramientas ofrecen enfoques distintos, y dentro de las pruebas de aceptaci&oacute;n, un enfoque puede ser capturar los eventos del usuario y volver a realizar todos los pasos contra el GUI (como si grab&aacute;semos una macro y luego la ejecut&aacute;semos cuantas veces necesitemos). Otro enfoque se basa en tomar el control del interfaz de usuario de forma programativa mediante el uso de scripts.</p>
<a name="N10704"></a><a name="Selenium"></a>
<h3 class="underlined_5">Selenium</h3>
<p>Selenium (<a class="external" href="http://www.openqa.org/selenium/">www.openqa.org/selenium/</a>) es una herramienta para probar aplicaciones web, desarrollada por ThoughtWorks, siendo un proyecto open source con gran actividad en la comunidad. Las pruebas Selenium se ejecutan directamente en un navegador (IE y Firefox en Windows, Linux y MacOs), igual que hacen los usuarios reales.</p>
<p>Selenium nos permite probar la compatibilidad con los navegadores, ya que el mismo script de pruebas se puede ejecutar en diferentes plataformas. Y lo m&aacute;s importante, permite realizar pruebas funcionales, mediante pruebas de regresi&oacute;n para verificar la funcionalidad de la aplicaci&oacute;n y la aceptaci&oacute;n del cliente.</p>
<p>Selenium ofrece una interfaz gr&aacute;fica, Selenium IDE (<a class="external" href="http://www.openqa.org/selenium-ide">www.openqa.org/selenium-ide</a>), para la grabaci&oacute;n de los scripts. Se trata de un entorno de desarrollo para pruebas Selenium. Esta implementado mediante un extensi&oacute;n Firefox, y permite grabar, editar y depurar las pruebas. Tras la instalaci&oacute;n de la extensi&oacute;n de Firefox, nos aparecer&aacute; una ventana como la siguiente, donde podemos observar todos los elementos caracter&iacute;sticos de un entorno de debug (<em>play</em>, <em>pause</em>, <em>step</em>), m&aacute;s un bot&oacute;n para grabar la prueba y elementos para mostrar el resultado de la prueba:</p>
<p>
        
<img alt="Selenium IDE" content-width="11cm" src="imagenes/s14/seleniumIDE.jpg" width="400">
        </p>
<p>Selenium IDE no es s&oacute;lo una herramienta de grabaci&oacute;n, tambi&eacute;n permite editar los scripts a mano, con soporte de autocompletado y la posibilidad de mover los comandos r&aacute;pidamente. Adem&aacute;s, permite la integraci&oacute;n de estas pruebas con cualquier lenguaje de programaci&oacute;n, como Java, .Net, Perl, Python y Ruby, mediante el m&oacute;dulo de Control Remoto (<a class="external" href="http://www.openqa.org/selenium-rc">www.openqa.org/selenium-rc</a>). Una vez grabada una prueba, solo necesitamos exportar la prueba (<em>Archivo -&gt; Export Test As...</em>) en el lenguaje deseado.</p>
<p>Se puede visualizar un video explicativo de como trabajar con Selenium en: <a class="external" href="http://wiki.openqa.org/download/attachments/400/Selenium+IDE.swf?version=1">wiki.openqa.org/download/attachments/400/Selenium+IDE.swf</a>.</p>
<div class="frame note">
<div class="label">Otras Herramientas</div>
<div class="content">Otras herramientas relacionadas con las pruebas de aceptaci&oacute;n son <strong>Jameleon</strong> (<a class="external" href="http://jameleon.sourceforge.net/">jameleon.sourceforge.net</a>) y <strong>Fitnesse</strong> (<a class="external" href="http://www.fitnesse.org/">www.fitnesse.org</a> - Articulo JavaWorld (<a class="external" href="http://www.javaworld.com/javaworld/jw-02-2006/jw-0220-fitnesse.html">www.javaworld.com/javaworld/jw-02-2006/jw-0220-fitnesse.html</a>).</div>
</div>
<a name="N10755"></a><a name="Probando+la+Aplicaci%C3%B3n"></a>
<h3 class="underlined_5">Probando la Aplicaci&oacute;n</h3>
<p>Vamos a simular una prueba funcional. En concreto, vamos a probar que funciona tanto la operaci&oacute;n de reservar como la de anular la reserva. Al reservar un libro, queremos que nos lleve a la p&aacute;gina donde elegir la usuario a reservar, y una vez realizada, la reserva aparezca en el listado de libros reservados. A partir de aqu&iacute;, probaremos que al anular la reserva, nos vuelve a llevar a la p&aacute;gina de reservas, donde dicho libro ya no aparece.</p>
<ol>
        
<li>Abrir Firefox y apuntar con el navegador a la direcci&oacute;n <a class="external" href="http://localhost:8080/proy-int-web">http://localhost:8080/proy-int-web</a>
</li>
        
<li>Tras abrir Selenium, indicamos que nuestra direcci&oacute;n base (direcci&oacute;n del servidor) es <a class="external" href="http://localhost:8080/proy-int-web">http://localhost:8080</a>
</li>
        
<li>En Selenium, pulsamos sobre el bot&oacute;n de grabar y empezamos a realizar nuestra prueba</li>
        
<li>Volvemos al navegador, e introducimos como login y password el usuario bibliotecario/bibliotecario, y pulsamos en "entrar"</li>
        
<li>
<p>Si ahora volvemos a Selenium, podemos observar la parte de script generada, la cual ser&aacute; similar al siguiente gr&aacute;fico:</p>
        
<p>
           
<img alt="Selenium tras hacer login" content-width="11cm" src="imagenes/s14/seleniumLogin.jpg" width="438">
        </p>
        
<p>En este momento, si decidimos parar el script, podemos ver como funciona la prueba, pulsando sobre el bot&oacute;n de play, de modo que en el navegador, podremos observar como se realiza el login cada vez que ejecutamos la prueba (ver demo en <a href="http://www.jtech.ua.es/j2ee/2006-2007/restringido/proy-int/recursos/s14/seleniumLoginDivX.avi">videoSeleniumLogin.avi</a>).</p>
        
</li>
        
        
<li>De nuevo en firefox, una vez tenemos el listado de libros, vamos a realizar alguna aserci&oacute;n para que la prueba valide que se encuentra en el listado y no se ha producido un error en el login. Para ello, vamos a seleccionar el texto de "<em>Listado de Todos los Libros</em>", y con el bot&oacute;n derecho seleccionamos la opci&oacute;n de <strong>verifyTextPresent</strong> <em>Listado de Todos los Libros</em>
        
<p>
           
<img alt="Verificando texto con Selenium" content-width="11cm" src="imagenes/s14/seleniumVerifyTextListadoTodosLibros.jpg" width="494">
        </p>
        
<p>Del mismo modo, tambi&eacute;n vamos a verificar que aparece el usuario bibliotecario dentro del sistema, seleccionando el texto "<em>Usuario:bibliotecario</em>"</p>
        
</li>
        
<li>Una vez realizadas las verificaciones, vamos a probar la reserva de libros. Antes de hacer la reserva, vamos a seleccionar el titulo de un libro, por ejemplo, el de "<em>Agile Retrospectives</em>".</li>
        
<li>Ahora, vamos pulsar sobre la reserva de este libro, y en la p&aacute;gina de reserva, con Selenium a&ntilde;adimos las verificaciones de la acci&oacute;n que realizamos ("<em>Proceso de Reserva</em>") y del titulo del libro a reservar (el mismo que el anterior).</li>
        
<li>Seleccionamos el usuario que realiza la reserva (en mi caso, por ejemplo, "<em>juan</em>"). Podemos observar como todas las verificaciones y selecciones se van almacenando como comandos en Selenium:
        <p>
           
<img alt="Comandos antes de confirmar la reserva" content-width="11cm" src="imagenes/s14/seleniumReserva.jpg" width="431">
        </p>
        
</li>
        
<li>Realizamos la reserva pulsando en enviar</li>
        
<li>Verificamos que la acci&oacute;n de la p&aacute;gina es "<em>Listado de Reservas de Libros</em>", y que aparece el titulo de libro "<em>Agile Retrospectives</em>" y el usuario "<em>juan</em>"</li>
        
<li>Ahora vamos a comprobar que funciona la acci&oacute;n de anular reserva. Para ello, pulsamos sobre la imagen de anular reserva del libro "<em>Agile Retrospectives</em>"</li>
        
<li>Al anular la reserva, nos quedamos en la misma p&aacute;gina, pero el libro ha desaparecido. Para comprobar esto, mediante el interfaz de Selenium no podemos hacerlo y hemos de introducir a mano el comando sobre Selenium (utilizaremos el comando <strong>verifyNotPresent</strong>).</li>
        
<li>En Selenium, si sobre la caja de Command comenzamos a escribir, nos aparezca un desplegable con las opciones posibles, mostr&aacute;ndose en el panel inferior la documentaci&oacute;n referente al comando. M&aacute;s informaci&oacute;n sobre todos los comandos en:<a class="external" href="http://www.openqa.org/selenium-core/reference.html">www.openqa.org/selenium-core/reference.html</a>.
        Por lo tanto, tendremos:
        <p>
           
<img alt="Comando de verificar la no presencia" content-width="11cm" src="imagenes/s14/seleniumVerifyNotPresent.jpg" width="451">
        </p>        
        
</li>
        
<li>Pulsamos sobre el enlace de "<em>Listado de Libros Disponibles</em>", y verificamos tanto el t&iacute;tulo de la acci&oacute;n, como que en el listado aparece el libro.</li>
        
<li>Paramos la grabaci&oacute;n en Selenium, y ya tenemos una prueba completa de aceptaci&oacute;n :) Ahora llega el momento de ejecutarla.</li>
        
</ol>
<p>Se adjunta un v&iacute;deo demostrativo del proceso de realizaci&oacute;n de la prueba y su posterior ejecuci&oacute;n: <a href="http://www.jtech.ua.es/j2ee/2006-2007/restringido/proy-int/recursos/s14/seleniumPruebaCompletaDivX.avi">videoPruebaSelenium.avi</a>
</p>
<div class="frame note">
<div class="label">&iquest;Pregunta...?</div>
<div class="content">
        &iquest;Qu&eacute; pasa si borramos el libro de "<em>Agile Retrospectives</em>" y ejecutamos la prueba?
        </div>
</div>
<p>Un art&iacute;culo interesante que trata Selenium desde el punto de vista del Test Runner: <a class="external" href="http://www.ibm.com/developerworks/web/library/wa-selenium-ajax/">www.ibm.com/developerworks/web/library/wa-selenium-ajax/</a>
</p>
</div>

<p class="pageBreakAfter"></p>
    
<a name="N1080C"></a><a name="Pruebas+de+Carga"></a>
<h2 class="underlined_10">Pruebas de Carga</h2>
<div class="section">
<p>Las pruebas de carga y stress forman parte del proceso de validaci&oacute;n de un sistema para comprobar que el sistema cumple con los requisitos no funcionales, como puedan ser rendimiento, confiabilidad, escalabilidad y robustez.</p>
<p>Las pruebas de carga validan el rendimiento del sistema en t&eacute;rminos de tratar un n&uacute;mero espec&iacute;fico de usuarios manteniendo un ratio de transacciones. Las pruebas de stress comprueban la confiabilidad y robustez del sistema cuando se superan la carga normal. Aunque el sistema puede rechazar algunas peticiones cuando esta sobrecargado, deber&iacute;a tener la capacidad de recuperaci&oacute;n para mantiene el sistema funcionando sin sufrir ning&uacute;n par&oacute;n.</p>
<p>El criterio de rendimiento esperado se puede detallar de forma precisa de diferentes modos, pero lo normal es mediante un ratio requerido de transacciones cuando el sistema soporta una carga determinada. Por ejemplo, un requisito que fije el rendimiento puede citar que una petici&oacute;n al sistema se debe tratar en menos de 2 segundos cuando existen 10.000 usuarios dentro del sistema. En situaciones contractuales, la especificaci&oacute;n de la carga del sistema debe ser detallada, teniendo en cuenta elementos operacionales como el entorno, tama&ntilde;o de la base de datos, ancho de banda de la red, configuraci&oacute;n del hardware, etc...</p>
<div class="frame warning">
<div class="label">Cuidado</div>
<div class="content">Hay que tener mucho cuidado con criterios de rendimiento ambiguos, como "<em>Las peticiones se tienen que servir en un tiempo razonable</em>". Dichas sentencias son imposibles de cuantificar y por lo tanto, imposibles de probar con precisi&oacute;n. Elimina las ambig&uuml;edades y aseg&uacute;rate de que dispones de cifras para definir las m&eacute;tricas de rendimiento que debe cumplir el sistema.</div>
</div>
<a name="N10822"></a><a name="Inquietudes+con+el+Rendimiento"></a>
<h3 class="underlined_5">Inquietudes con el Rendimiento</h3>
<p>Uno de los fallos en mucho proyectos es que las pruebas de rendimiento no se realizan hasta el final del proyecto. Si los problemas de rendimientos no se detectan hasta las &uacute;ltimas iteraciones, los cambios necesarios ser&aacute;n dr&aacute;sticos para la arquitectura de la aplicaci&oacute;n. Los esfuerzos de los &uacute;ltimos minutos ponen la calidad y estabilidad de la aplicaci&oacute;n en un riesgo alto e innecesario. Adem&aacute;s, estos cambios de &uacute;ltima hora siempre conllevan retrasos en la fechas de entrega.</p>
<p>Una buena estrategia de pruebas combinada con una arquitectura software que considere el rendimiento desde el inicio del desarrollo evita el peligro. Las iteraciones iniciales del proyecto se tienen que utilizar para construir prototipos exploratorios y comprobar todos los requisitos no funcionales. Las pruebas realizadas contra estos prototipos validan la arquitectura. Adem&aacute;s, las mismas pruebas permanecen disponibles a los largo del desarrollo del sistema completo para asegurar la compatibilidad con los requisitos de rendimiento conforme evoluciona la aplicaci&oacute;n.</p>
<p>Las pruebas de este tipo necesitan de herramientas que automaticen estas pruebas. Por suerte, nuestros amigos de Jakarta nos ofrecen JMeter.</p>
<a name="N10832"></a><a name="JMeter"></a>
<h3 class="underlined_5">JMeter</h3>
<p>Apache JMeter (<a class="external" href="http://jakarta.apache.org/jmeter/">jakarta.apache.org/jmeter</a>) es una herramienta de escritorio 100% Java dise&ntilde;ada para medir el rendimiento mediante pruebas de carga. Originalmente se dise&ntilde;o para probar aplicaciones web, pero desde entonces se ha expandido a otras funciones.</p>
<p>JMeter permite cargar muchos tipos distintos de aplicaciones. El primer concepto importante es el de "<em>Sampler</em>" o "<em>Muestreador</em>". JMeter viene con un conjunto de samplers para hacer peticiones HTTP y FTP, as&iacute; como samplers para Servicios Web, bases de datos JDBC y directorios LDAP.</p>
<p>Mediante JMeter, no se nos limita a realizar un petici&oacute;n tras otra a un sampler, sino que disponemos de m&uacute;ltiple hilos de ejecuci&oacute;n concurrente, procesando diversos y diferentes patrones de petici&oacute;n. Mediante los controladores l&oacute;gicos, podemos controlar como se realizan las peticiones y en que orden.</p>
<p>Por supuesto, en ocasiones no queremos bombardear el sistema con peticiones una tras otra. En este caso, podemos utilizar componentes planificados (timer) para enviar un n&uacute;mero limitado de peticiones en un periodo fijo de tiempo, o utilizar un timer para asegurar que se env&iacute;an un n&uacute;mero uniforme de peticiones dentro de un periodo de tiempo dado. JMeter incluso soporta pausas aleatorias entre los env&iacute;os de petici&oacute;n de modo que podemos a&ntilde;adir un nivel de incertidumbre a nuestras pruebas de carga.</p>
<p>A veces puede ser &uacute;til asegurarse que los datos retornados en una petici&oacute;n son correctos. Para soportar esto, podemos incluir aserciones en los datos retornados, y JMeter llevar&aacute; la cuenta del n&uacute;mero de peticiones exitosas y fallidas. Esto es muy &uacute;til para los sitios web, ya que se puede observar los datos validos que sabemos que la p&aacute;gina retornar&aacute;, y cuando dejan de aparecer estos datos, entonces alg&uacute;n tipo de error habr&aacute; ocurrido en el servidor.</p>
<p>La pieza final del puzzle es como se muestran los resultados. JMeter incluye una amplia variedad de herramientas de an&aacute;lisis desde simples tablas de datos, a informes agregados, gr&aacute;ficos con picos, medias, desviaciones, etc...</p>
<a name="N10854"></a><a name="Componentes"></a>
<h4>Componentes</h4>
<p>El plan de prueba se compone de elementos de prueba que controlan la ejecuci&oacute;n de la prueba de carga. Los elementos se a&ntilde;aden al plan de prueba como nodos del arbol en el panel izquierdo del GUI de JMeter.</p>
<p>La estructura de arbol permite una organizaci&oacute;n jer&aacute;rquica de los elementos del plan. Los principales tipos de elementos son:</p>
<ul>
            
<li>
<strong>Grupo de Hilos</strong>: punto de inicio del plan de prueba que controla el n&uacute;mero de hilos que ejecutan los casos de prueba funcionales.</li>
            
<li>
<strong>Muestreados (<em>Sampler</em>)</strong>: env&iacute;a peticiones, tales como peticiones HTTP, al servidor. JMeter ofrece diferentes tipos de samplers, haciendo posible probar aplicaciones diferentes a las aplicaciones Web. Existen diferentes muestreadores para poder probar todo tipo de tecnolog&iacute;as, como pueden ser samplers Java, JDBC, Web Services, JMS, FTP, Email, LDAP, etc...</li>
            
<li>
<strong>Controlador l&oacute;gico</strong>: encargado de informar a JMeter cuando tratar las peticiones de servidor. Los diferentes tipos de controlador m&aacute;s importantes son:
            <ul>
                
<li>
<strong>ForEach</strong>: itera sobre todos los elementos hijo y ofrece un nuevo valor en cada iteraci&oacute;n</li>
                
<li>
<strong>If</strong>: hace condicional la ejecuci&oacute;n de uno de los elementos hijo.</li>
                
<li>
<strong>Interleave</strong>: ejecuta alternamente uno de los samplers hijo por cada iteraci&oacute;n del controlador.</li>
                
<li>
<strong>Loop</strong>: itera sobre cada hijo durante un n&uacute;mero determinado de ocasiones.</li>
                
<li>
<strong>Random</strong>: realiza la ejecuci&oacute;n de los subcontroladores de forma aleatoria.</li>
                
<li>
<strong>Simple</strong>: lugar para organizar elementos.</li>
                
<li>
<strong>Transaction</strong>: mide el tiempo tomado por todos los elementos hijos durante su ejecuci&oacute;n.</li>
            
</ul>
            M&aacute;s informaci&oacute;n con ejemplos en: <a class="external" href="http://jakarta.apache.org/jmeter/usermanual/component_reference.html#logic_controllers">jakarta.apache.org/jmeter/usermanual/component_reference.html#logic_controllers</a>
            
</li>
            
<li>
<strong>Elemento de configuraci&oacute;n</strong> para a&ntilde;adir o modificar peticiones de servidor.</li>
            
<li>
<strong>Listener</strong>: ofrece una vision de los datos que recolecta JMeter.</li>
        
</ul>
<p>M&aacute;s informaci&oacute;n en <a class="external" href="http://jakarta.apache.org/jmeter/usermanual/test_plan.html">jakarta.apache.org/jmeter/usermanual/test_plan.html</a>
</p>
<a name="N108B0"></a><a name="Creando+una+Prueba+de+Ejemplo"></a>
<h4>Creando una Prueba de Ejemplo</h4>
<p>Para este ejemplo, vamos a probar los tiempos de respuesta de la p&aacute;gina de login del proyecto, y el listado de todos los libros. Tambi&eacute;n nos vamos a asegurar que en cada ciclo, primero se entre a la p&aacute;gina de login y luego al listado de todos los libros, como ocurrir&iacute;a en el escenario est&aacute;ndar de cualquier usuario bibliotecario.</p>
<p>Tras su instalaci&oacute;n (versi&oacute;n 2.2), ejecutaremos el comando <span class="codefrag">jmeter.bat</span>, y nos abrir&aacute; una aplicaci&oacute;n Swing sobre la cual crearemos las pruebas. Las diferentes opciones de ejecuci&oacute;n de la aplicaci&oacute;n se pueden consultar en <a class="external" href="http://jakarta.apache.org/jmeter/usermanual/get-started.html">jakarta.apache.org/jmeter/usermanual/get-started.html</a>
</p>
<p>Una vez abierto JMeter, podemos observar 2 nodos en el &aacute;rbol de la izquierda, uno para el "<em>Plan de Pruebas</em>" y otro el "<em>Banco de Trabajo</em>". Vamos a crear un plan de pruebas "<em>Plan de Biblioteca jTech</em>"</p>
<p>
            
<img alt="Plan de Pruebas de JMeter" content-width="16cm" src="imagenes/s14/JMeterPlanPruebas.jpg" width="721">
        </p>
<a name="N108D7"></a><a name="Grupo+de+Hilos"></a>
<h5>Grupo de Hilos</h5>
<p>El siguiente paso es crear un <strong>grupo de hilos</strong> que controle la ejecuci&oacute;n de las peticiones. Para hacer esto, bot&oacute;n derecho sobre el "<em>Plan de Biblioteca jTech</em>" y seleccionamos <span class="codefrag">A&ntilde;adir -&gt; Grupo de hilos</span> del men&uacute; emergente. Esto crear&aacute; en el &aacute;rbol un nodo de <span class="codefrag">Grupo de Hilos</span> bajo el nodo del Plan, y mostrar&aacute; la p&aacute;gina de propiedades en el panel de la derecha.</p>
<p>
            
<img alt="Grupo de Hilos de JMeter" content-width="13cm" src="imagenes/s14/JMeterGrupoHilos.jpg" width="563">
        </p>
<p>Dentro del grupo de hilos, podemos darle un nombre apropiado y elegir el n&uacute;mero de hilos que queremos que ejecuten las pruebas. Hemos decidido limitar nuestro grupo a un hilo; se puede elegir el n&uacute;mero de veces que el grupo de hilos iterar&aacute; con los controladores y los samplers contenidos, o dejar que el bucle se ejecute hasta que se detenga de forma manual. El periodo de subida sirve para que los hilos se creen de forma gradual, de modo que podamos comprobar como rinde el servidor conforme crece la carga. Si el periodo de subida es 100 segundos y el n&uacute;mero de hilos es 50, significa que el servidor tardar&aacute; 100 segundos en crear los 50 hilos, es decir, un nuevo hilo cada 2 segundos. Vamos a dejar que la prueba se ejecute ininterrumpidamente.</p>
<p>Aunque el ejemplo s&oacute;lo utilice un grupo de hilos, el nodo de plan permite la adici&oacute;n de muchos grupos de hilos, cada uno con su propia configuraci&oacute;n y casos de prueba.</p>
<a name="N108FC"></a><a name="Controlador-N108FC"></a>
<h5>Controlador</h5>
<p>Una vez creado el grupo, llega la hora de configurar los par&aacute;metros de prueba para este grupo. Haciendo click con el bot&oacute;n derecho sobre el "Grupo de Hilos", elegimos <span class="codefrag">Controlador L&oacute;gico -&gt; Controlador Interleave</span>. El <strong>controlador</strong> determina cuando se realizan las peticiones al servidor, dirigiendo la ejecuci&oacute;n y orden de los elementos del plan, y por tanto, orquestando el flujo de control. En el caso del controlador interleave, ejecutar&aacute; uno de sus subcontroladores o samplers en cada iteraci&oacute;n del bucle de pruebas, altern&aacute;ndose secuencialmente a lo largo de la lista.</p>
<p>
        
<img alt="Controlador Interleave de JMeter" content-width="13cm" src="imagenes/s14/JMeterControladorInterleave.jpg" width="563">
        </p>
<p>Podemos colocar los samplers directamente bajo el grupo de hilos, pero es preferible utilizar un controlador interleave para que si fuese necesario realizar un n&uacute;mero espec&iacute;fico de peticiones a una p&aacute;gina, podamos indicar el contador de bloque de forma acorde en el grupo de hilos.</p>
<p>Si por ejemplo, hubi&eacute;semos querido entrar a la aplicaci&oacute;n, y luego haber realizado 100 listados de libros, podr&iacute;amos haber utilizado 2 controlador: Un controlador simple y un controlador loop. El controlador simple ofrece un entorno para organizar los elementos del plan, de modo que tendr&iacute;a 2 hijos, uno con el sampler de petici&oacute;n HTTP para el login, y otro con el controlador loop. Dentro del controlador loop indicar&iacute;amos el n&uacute;mero de iteraciones. Debajo de este controlador deber&iacute;amos a&ntilde;adir la petici&oacute;n HTTP para el listado de libros.</p>
<a name="N1091B"></a><a name="Sampler"></a>
<h5>Sampler</h5>
<p>Llega la hora de a&ntilde;adir <strong>samplers</strong> a las p&aacute;ginas que queremos probar, Para hacer esto, haremos click con el bot&oacute;n derecho sobre el controlador interleave, y elegiremos <span class="codefrag">A&ntilde;adir -&gt; Muestreador -&gt; Petici&oacute;n HTTP</span>. Esto mostrar&aacute; la p&aacute;gina de propiedades de la petici&oacute;n HTTP en el panel derecho.</p>
<p>En este panel, indicamos las propiedades de la p&aacute;gina que queremos pedir. Configuramos el servidor como localhost, y el puerto como 8080. (si probamos sobre weblogic, entonces el puerto por defecto es 7001). En el campo del path, introducimos el path completo de la p&aacute;gina de login (<span class="codefrag">/proy-int-web/index.jsp</span>). No hay que introducir el nombre del servidor ni el puerto, ya que lo hemos introducido en la configuraci&oacute;n de la petici&oacute;n. Tras a&ntilde;adir los par&aacute;metros para probar el login, le damos nombre a la petici&oacute;n.</p>
<div class="frame note">
<div class="label">Consejo</div>
<div class="content">
        Si todas nuestras peticiones HTTP comparten los mismos datos de servidor y puerto, podemos a&ntilde;adir al grupo de hilos una configuraci&oacute;n por defecto para peticiones HTTP (sobre el grupo de hilos, bot&oacute;n derecho, y seleccionamos <span class="codefrag">A&ntilde;adir -&gt; Elementos de Configuraci&oacute;n -&gt; Valores por defecto para petici&oacute;n HTTP</span>), de modo que todas las peticiones que cuelguen de este grupo de hilos no tienen porque configurar los datos aqu&iacute; fijados.</div>
</div>
<p>
        
<img alt="Petici&oacute;n HTTP de Login en JMeter" content-width="16cm" src="imagenes/s14/JMeterHTTPLogin.jpg" width="736">
        </p>
<p>Al especificar las de una petici&oacute;n HTTP, no se nos limita a probar contra una aplicaci&oacute;n ejecutandose en local. De hecho, en la mayor&iacute;a de los casos querremos probar contra una aplicaci&oacute;n real teniendo en cuenta el tr&aacute;fico de Internet as&iacute; como el hardware real del servidor.</p>
<p>Repetiremos el proceso para crear una petici&oacute;n para el listado de todos los libros.</p>
<div class="frame note">
<div class="label">Ten en cuenta...</div>
<div class="content">
        En mi caso, cuando el usuario hace login, el <em>Action</em> <span class="codefrag">accionLogin</span> redirige la petici&oacute;n al <em>Action</em> <span class="codefrag">accionListadoLibros</span>, de modo que el resultado del login es el listado de todo los libros.</div>
</div>
<p>
        
<img alt="Petici&oacute;n HTTP de Bibliotecario Registrado en JMeter" content-width="17cm" src="imagenes/s14/JMeterHTTPBibliotecarioRegistrado.jpg" width="819">
        </p>
<p>Ahora creamos una aserci&oacute;n para asegurarnos que la p&aacute;gina retornada cuando hacemos login realmente es la p&aacute;gina de inicio del bibliotecario. Hacemos click con el bot&oacute;n derecho sobre el nodo de la petici&oacute;n a la p&aacute;gina de login y elegimos <span class="codefrag">A&ntilde;adir -&gt; Aserciones -&gt; Aserciones de Respuesta</span>. Ponemos el campo de respuesta a "Respuesta Textual", y el patr&oacute;n a "Contiene". Dentro el patr&oacute;n a probar, pulsamos en a&ntilde;adir e introducimos "Listado de Libros". Esta aserci&oacute;n comprueba que el texto de respuesta de petici&oacute;n tras el login contiene la frase "Listado de Libros". En el caso de producirse un error, la p&aacute;gina de error del servidor no contendr&aacute; esta cadena.</p>
<p>
        
<img alt="Asercion de Listado de Libros en JMeter" content-width="16cm" src="imagenes/s14/JMeterAsercionListadoLibros.jpg" width="757">
        </p>
<p>El &uacute;ltimo paso es a&ntilde;adir algunos <em>Listeners</em> para analizar los datos recibidos por JMeter. En este ejemplo, vamos a a&ntilde;adir un listener para los <span class="codefrag">Resultados de la Aserci&oacute;n</span>, para visualizar los errores producidos por las aserciones, un listener de <span class="codefrag">Informe Agregado</span>, el cual ofrece un resumen general de la prueba, y finalmente un listener con un <span class="codefrag">Gr&aacute;fico de Resultados</span>, el cual ofrece un bonito gr&aacute;fico con el rendimiento de la aplicaci&oacute;n (todos mediante bot&oacute;n derecho sobre el Controlador Interleave, y seleccionamos <span class="codefrag">A&ntilde;adir -&gt; Listener</span>, y el tipo de listener comentado).</p>
<p>
        
<img alt="Listeners en JMeter" content-width="15cm" src="imagenes/s14/JMeterListeners.jpg" width="651">
        </p>
<p>Una vez que la prueba esta preparada, s&oacute;lo queda ejecutarla y ver los resultados. Antes debemos grabar el plan (<span class="codefrag">Archivo -&gt; Guardar</span>) por si el ordenador "petara" durante la ejecuci&oacute;n de las pruebas. Esto es bastante probable cuando al ejecutar las pruebas el uso de CPU alcanza una media del 95%.</p>
<p>Para empezar, seleccionamos <span class="codefrag">Arrancar</span> del men&uacute; <span class="codefrag">Lanzar</span>. Si queremos visualizar las pruebas conforme se ejecutan, podemos monitorizarlas mediante cualquiera de los listeners para ver que esta ocurriendo. Por ejemplo, en el gr&aacute;fico podemos ver la media de rendimiento y tiempos de respuesta. Una vez que tenemos suficientes datos, llega el momento de parar la prueba y analizar los datos. Para parar la prueba, simplemente seleccionar <span class="codefrag">Parar</span> del men&uacute; <span class="codefrag">Lanzar</span>. Una vez que la prueba ha finalizado, podemos tomar el tiempo necesario para mirar los datos en detalle.</p>
<p>Por ejemplo, mediante el <span class="codefrag">Informe Agregado</span>, podemos obtener datos como el n&uacute;mero de peticiones, los tiempos m&iacute;nimos, medios y m&aacute;ximos de respuesta, porcentaje de errores o el rendimiento en t&eacute;rminos de peticiones por segundo.</p>
<p>
        
<img alt="Informe Agregado en JMeter" content-width="17cm" src="imagenes/s14/JMeterInformeAgregado.jpg" width="764">
        </p>
<p>El informe ofrece una representaci&oacute;n concisa y f&aacute;cil de leer en formato de tabla. Dado que este informe muestra informaci&oacute;n resumida, no es posible averiguar como se ha comportado la aplicaci&oacute;n durante la prueba. Para esto, necesitamos el listener gr&aacute;fico.</p>
<p>Si lo que queremos es una representaci&oacute;n gr&aacute;fico de los datos, el listener de <span class="codefrag">Gr&aacute;fico de Resultados</span> dibuja varios tipos de informaci&oacute;n relacionada con el rendimiento, incluyendo ejemplos de datos, media y mediana de tiempos empleado, desviaci&oacute;n est&aacute;ndar y rendimiento.</p>
<p>
        
<img alt="Gr&aacute;fico de Resultados en JMeter" content-width="17cm" src="imagenes/s14/JMeterGraficoResultados.jpg" width="760">
        </p>
<p>El gr&aacute;fico muestra la duraci&oacute;n de la prueba en el eje de las X, y los tiempos de respuesta del servidor para las peticiones HTTP en el eje de las Y. Los puntos negros son los tiempos individuales de cada petici&oacute;n. Idealmente, el tiempo necesario por la aplicaci&oacute;n para tratar una petici&oacute;n deber&iacute;a ser uniforme. Podemos ver como la aplicaci&oacute;n ha tardado un m&aacute;ximo de 312ms en responder a una petici&oacute;n, tardando una media de 170ms en responder a las peticiones.</p>
<div class="frame warning">
<div class="label">Cuidado...</div>
<div class="content">Algunos visualizadores de resultados son muy agresivos con la memoria, y pueden provocar la ca&iacute;da de JMeter.</div>
</div>
<p>Como hemos comentado, JMeter puede probar todo tipo de aplicaciones. Si est&aacute;s interesado en realizar pruebas de carga sobre Web Services y JMS tienes m&aacute;s informaci&oacute;n en <a class="external" href="http://dev2dev.bea.com/pub/a/2006/08/jmeter-performance-testing.html">dev2dev.bea.com/pub/a/2006/08/jmeter-performance-testing.html</a>
</p>
<a name="N109CE"></a><a name="Consejos+JMeter"></a>
<h4>Consejos JMeter</h4>
<p>A continuaci&oacute;n se describen una series de consejos muy &uacute;tiles a la hora de realizar pruebas de carga con JMeter:</p>
<ul>
            
<li>Utiliza escenarios de prueba significativos, y construye planes de prueba que prueben situaciones representativas del mundo real. Los casos de uso ofrece un punto de partida ideal sobre los cuales construir las pruebas de carga.</li>
            
<li>Aseg&uacute;rate de ejecutar JMeter en una m&aacute;quina distinta a la del sistema a probar. Esto previene a JMeter de afectar sobre los resultados de las pruebas.</li>
            
<li>El proceso de pruebas es un proceso cient&iacute;fico, de modo que todas las pruebas se deben realizar bajo condiciones completamente controladas. Si estas trabajando con un servidor compartido, primero comprueba que nadie m&aacute;s esta realizando pruebas de carga contra la misma aplicaci&oacute;n web.</li>
            
<li>Aseg&uacute;rate de que dispones de un ancho de banda en la estaci&oacute;n que ejecuta JMeter. La idea es probar el rendimiento de la aplicaci&oacute;n y el servidor, y no la conexi&oacute;n de la red.</li>
            
<li>Utiliza diferentes instancias de JMeter ejecut&aacute;ndose en diferentes m&aacute;quinas para a&ntilde;adir carga adicional al servidor. Esta configuraci&oacute;n suele ser necesaria para realizar pruebas de stress. JMeter puede controlar las instancias JMeter de las otras m&aacute;quinas y coordinar la prueba. M&aacute;s informaci&oacute;n en <a class="external" href="http://jakarta.apache.org/jmeter/usermanual/remote-test.html">jakarta.apache.org/jmeter/usermanual/remote-test.html</a>.</li>
            
<li>Deja una prueba JMeter ejecutarse durante largos periodos de tiempo, posiblemente varios d&iacute;as o semanas. Estar&aacute;s probando la disponibilidad del sistema y resaltando las posibles degradaciones en el rendimiento del servidor debido a una mala gesti&oacute;n de los recursos.</li>
            
<li>No realices pruebas JMeter contra servidor externos de los cuales no eres responsable. Los responsables pueden considerar tu prueba un ataque de denegaci&oacute;n de servicio.</li>
        
</ul>
<p>Al dise&ntilde;ar y ejecutar pruebas de carga, recuerda que cada sistema tiene sus limites. Al ejecutar JMeter en varias m&aacute;quinas, es muy probable que se excedan dichos l&iacute;mites. Esta es una prueba v&aacute;lida, ya que el sistema debe mostrar un comportamiento err&oacute;neo para este escenario. Sin embargo, el objetivo de las pruebas de carga es comprobar la habilidad de la aplicaci&oacute;n para cumplirlos los criterios de rendimiento estipulados en los requisitos no funcionales.</p>
<div class="frame note">
<div class="label">Otras Herramientas</div>
<div class="content">
        Otras herramientas relacionadas con las pruebas de carga son <strong>OpenSTA</strong> (<a class="external" href="http://www.opensta.org/">www.opensta.org/</a>) y <strong>Microsoft Web Application Stress Tool (WAS)</strong> (<a class="external" href="http://www.microsoft.com/technet/archive/itsolutions/intranet/downloads/webstres.mspx">www.microsoft.com/technet/archive/itsolutions/intranet/downloads/webstres.mspx</a>). Eclipse tambi&eacute;n integra un modulo para realizar pruebas de carga, denominado <strong>Eclipse Test &amp; Performance Tools Platform</strong> (<a class="external" href="http://www.eclipse.org/tptp/index.php">www.eclipse.org/tptp/index.php</a>)</div>
</div>
</div>


<p class="pageBreakAfter"></p>

<a name="N10A17"></a><a name="Entrega"></a>
<h2 class="underlined_10">Entrega</h2>
<div class="section">
<p>La parte obligatoria a entregar es la siguiente:</p>
<ul>
        
<li>Refactorizar la aplicaci&oacute;n de modo que toda la l&oacute;gica de la aplicaci&oacute;n resida en EJBs.</li>
        
<li>Ofrecer soporte para al menos 2 idiomas, de modo que la aplicaci&oacute;n permita cambiar el idioma en la p&aacute;gina de login.</li>
        
<li>Realizar un proceso autom&aacute;tico, eligiendo la tecnolog&iacute;a que consideres adecuada (<em>Timer EJB</em> o <em>Quartz</em>), para que se liberen las reservas caducadas.</li>
        
<li>Realizar una prueba de aceptaci&oacute;n similar al ejemplo realizado con <em>Selenium</em>. Se debe entregar el fichero con el script de Selenium, en formato html.</li>
        
<li>Realizar pruebas de carga sobre la p&aacute;gina de login y listado de libros, y comprobar cuantas peticiones se realizan por segundo (rendimiento) y la velocidad de transmisi&oacute;n del servidor (kb/sec). Se debe entregar el fichero del plan JMeter, y una imagen con el resultado del <em>Informe Agregado</em>.</li>
    
</ul>
<p>La parte optativa se define a lo largo de los apuntes y referencia a la refactorizaci&oacute;n de los proyectos en Eclipse, y resolver e implementar las preguntas relacionadas con el Multidioma.</p>
</div>

<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2006-2007 Depto. CCIA</div>
</div>
</body>
</html>
