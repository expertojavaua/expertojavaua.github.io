<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Introducci&oacute;n a los Servicios Web</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servicios Web" src="images/baner_j2ee_der.gif" title="Servicios Web"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servicios Web</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servicios Web</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servicios Web">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menupage">
<div class="menupagetitle">Sesion 1</div>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html" title="Roadmap">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion01-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Introducci&oacute;n a los Servicios Web</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#%C2%BFQu%C3%A9+es+un+Servicio+Web%3F">&iquest;Qu&eacute; es un Servicio Web?</a>
</li>
<li>
<a href="#Caracter%C3%ADsticas+de+los+Servicios+Web">Caracter&iacute;sticas de los Servicios Web</a>
</li>
<li>
<a href="#Arquitecturas+Orientadas+a+Servicios">Arquitecturas Orientadas a Servicios</a>
</li>
<li>
<a href="#Arquitectura+de+los+Servicios+Web">Arquitectura de los Servicios Web</a>
</li>
<li>
<a href="#Seguridad">Seguridad</a>
<ul class="minitoc">
<li>
<a href="#Confidencialidad">Confidencialidad</a>
</li>
<li>
<a href="#Autentificaci%C3%B3n">Autentificaci&oacute;n</a>
</li>
<li>
<a href="#Seguridad+de+la+red">Seguridad de la red</a>
</li>
</ul>
</li>
<li>
<a href="#Tecnolog%C3%ADas+b%C3%A1sicas">Tecnolog&iacute;as b&aacute;sicas</a>
<ul class="minitoc">
<li>
<a href="#SOAP">SOAP</a>
</li>
<li>
<a href="#WSDL">WSDL</a>
</li>
<li>
<a href="#UDDI">UDDI</a>
</li>
<li>
<a href="#Tecnolog%C3%ADas+de+segunda+generaci%C3%B3n">Tecnolog&iacute;as de segunda generaci&oacute;n</a>
</li>
</ul>
</li>
<li>
<a href="#Tecnolog%C3%ADas+J2EE+para+Servicios+Web">Tecnolog&iacute;as J2EE para Servicios Web</a>
<ul class="minitoc">
<li>
<a href="#JAXP">JAXP</a>
</li>
<li>
<a href="#JAXM">JAXM</a>
</li>
<li>
<a href="#JAX-RPC+%2F+JAX-WS">JAX-RPC / JAX-WS</a>
</li>
<li>
<a href="#JAXR">JAXR</a>
</li>
<li>
<a href="#JAXB">JAXB</a>
</li>
<li>
<a href="#Java+API+for+WSDL">Java API for WSDL</a>
</li>
</ul>
</li>
<li>
<a href="#Invocaci%C3%B3n+de+Servicios">Invocaci&oacute;n de Servicios</a>
<ul class="minitoc">
<li>
<a href="#Tipos+de+acceso">Tipos de acceso</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+mediante+stub+est%C3%A1tico">Invocaci&oacute;n mediante stub est&aacute;tico</a>
<ul class="minitoc">
<li>
<a href="#Invocaci%C3%B3n+de+servicios+web+con+JDK+1.6">Invocaci&oacute;n de servicios web con JDK 1.6</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+de+servicios+web+con+Weblogic">Invocaci&oacute;n de servicios web con Weblogic</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+de+servicios+web+con+Netbeans">Invocaci&oacute;n de servicios web con Netbeans</a>
</li>
</ul>
</li>
<li>
<a href="#Interfaz+de+invocaci%C3%B3n+din%C3%A1mica+%28DII%29">Interfaz de invocaci&oacute;n din&aacute;mica (DII)</a>
<ul class="minitoc">
<li>
<a href="#A+partir+de+un+documento+WSDL">A partir de un documento WSDL</a>
</li>
<li>
<a href="#Sin+un+documento+WSDL">Sin un documento WSDL</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>


<p>El dise&ntilde;o del software tiende a ser cada vez m&aacute;s modular. Las 
  aplicaciones se componen de una serie de componentes (servicios) reutilizables, 
  que pueden encontrarse distribuidos a lo largo de una serie de m&aacute;quinas 
  conectadas en red.</p>

<p>Los Servicios Web nos permitir&aacute;n distribuir nuestra aplicaci&oacute;n 
  a trav&eacute;s de Internet, pudiendo una aplicaci&oacute;n utilizar los servicios 
  ofrecidos por cualquier servidor conectado a Internet.</p>


<a name="N10012"></a><a name="%C2%BFQu%C3%A9+es+un+Servicio+Web%3F"></a>
<h2 class="underlined_10">&iquest;Qu&eacute; es un Servicio Web?</h2>
<div class="section">
<p>Un Servicio Web es un componente al que podemos acceder mediante protocolos 
  Web est&aacute;ndar, utilizando XML para el intercambio de informaci&oacute;n.</p>
<p>Normalmente nos referimos con Servicio Web a una colecci&oacute;n de procedimientos 
  (m&eacute;todos) a los que podemos llamar desde cualquier lugar de Internet 
  o de nuestra intranet, siendo este mecanismo de invocaci&oacute;n totalmente 
  independiente de la plataforma que utilicemos y del lenguaje de programaci&oacute;n 
  en el que se haya implementado internamente el servicio.</p>
<p>Cuando conectamos a un servidor web desde nuestro navegador, el servidor nos 
  devuelve la p&aacute;gina web solicitada, que es un documento que se mostrar&aacute; 
  en el navegador para que lo visualice el usuario, pero es dif&iacute;cilmente 
  entendible por una m&aacute;quina. Podemos ver esto como web para humanos. En 
  contraposici&oacute;n, los Servicios Web ofrecen informaci&oacute;n con un formato 
  est&aacute;ndar que puede ser entendido f&aacute;cilmente por una aplicaci&oacute;n. 
  En este caso estar&iacute;amos ante una web para m&aacute;quinas. </p>
</div>

<a name="N10022"></a><a name="Caracter%C3%ADsticas+de+los+Servicios+Web"></a>
<h2 class="underlined_10">Caracter&iacute;sticas de los Servicios Web</h2>
<div class="section">
<p>Las caracter&iacute;sticas deseables de un Servicio Web son:</p>
<ul>
  
<li>Un servicio debe poder ser <strong>accesible a trav&eacute;s de la Web</strong>. 
    Para ello debe utilizar protocolos de transporte est&aacute;ndares como HTTP, 
    y codificar los mensajes en un lenguaje est&aacute;ndar que pueda conocer 
    cualquier cliente que quiera utilizar el servicio.</li>
  
<li>Un servicio debe contener una <strong>descripci&oacute;n de s&iacute; mismo</strong>. 
    De esta forma, una aplicaci&oacute;n podr&aacute; saber cu&aacute;l es la 
    funci&oacute;n de un determinado Servicio Web, y cu&aacute;l es su interfaz, 
    de manera que pueda ser utilizado de forma autom&aacute;tica por cualquier 
    aplicaci&oacute;n, sin la intervenci&oacute;n del usuario.</li>
  
<li>Debe poder <strong>ser localizado</strong>. Deberemos tener alg&uacute;n 
    mecanismo que nos permita encontrar un Servicio Web que realice una determinada 
    funci&oacute;n. De esta forma tendremos la posibilidad de que una aplicaci&oacute;n 
    localice el servicio que necesite de forma autom&aacute;tica, sin tener que 
    conocerlo previamente el usuario.</li>

</ul>
</div>

<a name="N10041"></a><a name="Arquitecturas+Orientadas+a+Servicios"></a>
<h2 class="underlined_10">Arquitecturas Orientadas a Servicios</h2>
<div class="section">
<p>Las arquitecturas orientadas a servicios (SOA) se basan en el desarrollo de servicios altamente reutilizables, y en la combinaci&oacute;n de estos servicios para dar lugar a nuestra aplicaci&oacute;n.</p>
<p>Estos servicios idealmente deber&iacute;an tener una interfaz est&aacute;ndar bien definida, de forma que se pueda integrar f&aacute;cilmente en cualquier aplicaci&oacute;n. Adem&aacute;s no debe tener estado, ni depender del estado de otros componentes. Debe recibir toda la informaci&oacute;n necesaria en la petici&oacute;n.
</p>
<p>Se conoce como <em>orquestaci&oacute;n</em> de servicios la secuenciaci&oacute;n de llamadas a diferentes servicios para realizar un determinado proceso de negocio. Al no tener estado, los servicios se podr&aacute;n secuenciar en cualquier orden, pudiendo formar as&iacute; diferentes flujos que implementen la l&oacute;gica de negocio.</p>
<p>Normalmente cuando hablamos de arquitecturas orientadas a servicios pensamos en su implementaci&oacute;n mediante servicios web. Sin embargo, estas arquitecturas puedes estar formadas por cualquier tipo de servicio, como pueden ser por ejemplo servicios accesibles mediante JMS. En el caso de una SOA implementada mediante Servicios Web, sus servicios ser&aacute;n accesibles a trav&eacute;s de la web.</p>
<p>En una arquitectura orientada a servicios podemos distinguir tres agentes con diferentes funciones:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Proveedor de servicio</strong> </td>
    <td colspan="2" rowspan="1">Implementa unas determinadas operaciones (servicio). Un cliente 
      podr&aacute; solicitar uno de estos servicios a este proveedor. </td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Cliente del servicio</strong></td>
    <td colspan="2" rowspan="1">Invoca a un proveedor de servicio para la realizaci&oacute;n de alguna 
      de los operaciones que proporciona.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Registro de servicios</strong></td>
    <td colspan="2" rowspan="1">Mantiene una lista de proveedores de servicios disponibles, junto a sus 
      descripciones.</td>
  
</tr>

</table>
<p>El mecanismo b&aacute;sico de invocaci&oacute;n de servicios consistir&aacute; 
  en que un cliente solicitar&aacute; un determinado servicio a un proveedor, 
  efectuando el proveedor dicho servicio. El servidor devolver&aacute; una respuesta 
  al cliente como resultado del servicio invocado.</p>
<p>Esto podremos hacerlo as&iacute; si el cliente conoce de antemano el proveedor 
  del cual va a obtener el servicio. Pero hemos de pensar que en Internet encontraremos 
  una gran cantidad de Servicios Web dispersos, lo cual har&aacute; dif&iacute;cil 
  localizar el que busquemos. Adem&aacute;s, si hemos localizado uno que realiza 
  la funci&oacute;n que necesitamos, si dicho servicio no est&aacute; mantenido 
  por nosotros puede ocurrir que en alg&uacute;n momento este servicio cambie 
  de lugar, de interfaz o simplemente desaparezca, por lo que no podremos confiar 
  en que vayamos a poder utilizar siempre este mismo servicio.</p>
<p>Los registros de servicios nos permiten automatizar la localizaci&oacute;n 
  de Servicios Web. Un proveedor puede <em>anunciarse </em>en un determinado registro, 
  de forma que figurar&aacute; en dicho registro la localizaci&oacute;n de este 
  servicio junto a una descripci&oacute;n de su funcionalidad y de su interfaz, 
  que podr&aacute; ser entendida por una aplicaci&oacute;n.</p>
<p>Cuando un cliente necesite un determinado servicio, puede acudir directamente 
  a un registro y solicitar el tipo de servicio que necesita. Para ello es importante 
  establecer un determinada sem&aacute;ntica sobre las posibles descripciones 
  de funcionalidades de servicios, evitando las posibles ambig&uuml;edades.</p>
<p>El registro devolver&aacute; entonces una lista de servicios que realicen la 
  funci&oacute;n deseada, de los cuales el cliente podr&aacute; elegir el m&aacute;s 
  apropiado, analizar su interfaz, e invocarlo.</p>
</div>

<a name="N100A5"></a><a name="Arquitectura+de+los+Servicios+Web"></a>
<h2 class="underlined_10">Arquitectura de los Servicios Web</h2>
<div class="section">
<p>Los protocolos utilizados en los Servicios Web se organizan en una serie de 
  capas:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Capa</strong></td>
    <td colspan="2" rowspan="1"><strong>Descripci&oacute;n</strong></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Transporte de servicios</em></td>
    <td colspan="2" rowspan="1">Es la capa que se encarga de transportar los mensajes entre aplicaciones. 
      Normalmente se utiliza el protocolo <strong>HTTP</strong> para este transporte, 
      aunque los servicios web pueden viajar mediante otros protocolos de transferencia 
      de hipertexto como SMTP, FTP o BEEP.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Mensajer&iacute;a XML</em></td>
    <td colspan="2" rowspan="1">Es la capa responsable de codificar los mensajes en XML de forma que puedan 
      ser entendidos por cualquier aplicaci&oacute;n. Puede implementar los protocolos 
      XML-RPC o<strong> SOAP</strong>.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Descripci&oacute;n de servicios</em></td>
    <td colspan="2" rowspan="1">Se encarga de definir la interfaz p&uacute;blica de un determinado servicio. 
      Est&aacute; definici&oacute;n se realiza mediante <strong>WSDL</strong>.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Localizaci&oacute;n de servicios</em></td>
    <td colspan="2" rowspan="1">Se encarga del registro centralizado de servicios, permitiendo que estos 
      sean anunciados y localizados. Para ello se utiliza el protocolo <strong>UDDI</strong>.</td>
  
</tr>

</table>
<p>M&aacute;s adelante describiremos cada una de las tecnolog&iacute;as para Servicios 
  Web vistas en las distintas capas.</p>
</div>

<a name="N10113"></a><a name="Seguridad"></a>
<h2 class="underlined_10">Seguridad</h2>
<div class="section">
<p>En la utilizaci&oacute;n de los Servicios Web, encontramos problemas de seguridad 
  en diferentes aspectos. Podemos encontrar problemas de seguridad en cuanto a 
  la confidencialidad, la autentificaci&oacute;n y la seguridad de la red.</p>
<a name="N1011C"></a><a name="Confidencialidad"></a>
<h3 class="underlined_5">Confidencialidad</h3>
<p>Cuando un cliente utiliza un Servicio Web, deber&aacute; enviarle un mensaje 
  a este servicio a trav&eacute;s de la red, y el servicio le responder&aacute; 
  mediante otro mensaje. Estos mensajes contendr&aacute;n informaci&oacute;n que 
  puede ser confidencial.</p>
<p>Dado que estos mensajes se env&iacute;an mediante protocolo HTTP, podr&aacute;n 
  ser encriptados mediante SSL evitando de esta forma que puedan ser interceptados 
  por un tercero.</p>
<p>Sin embargo, en aplicaciones en las que el mensaje deba atravesar una cadena 
  de servicios, este mensaje deber&aacute; desencriptarse y volverse a encriptar 
  entero en cada uno de estos servicios, por lo que los datos estar&aacute;n inseguros 
  dentro de cada nodo. Podr&iacute;amos solucionar este problema permitiendo que 
  s&oacute;lo se desencripte en cada nodo una parte del mensaje, que ser&aacute; 
  la parte que ata&ntilde;e a dicho nodo, pero que no pueda acceder al resto del 
  mensaje que no le concierne.</p>
<a name="N1012C"></a><a name="Autentificaci%C3%B3n"></a>
<h3 class="underlined_5">Autentificaci&oacute;n</h3>
<p>Puede que necesitemos identificar a un usuario para prestarle un determinado 
  servicio, o bien para saber si tiene autorizaci&oacute;n para acceder a dicho 
  servicio. </p>
<p>Podemos utilizar para ello la autentificaci&oacute;n que nos proporciona el 
  protocolo HTTP. Encontramos el mismo problema que en el caso anterior, necesitamos 
  invocar un conjunto de servicios, deberemos autentificarnos por separado para 
  cada uno de ellos, ya que pueden estar distribuidos en distintos servidores 
  a trav&eacute;s de Internet. Para solucionar este problema, deber&iacute;amos 
  contar con un contexto compartido global de donde cualquier servicio pudiese 
  obtener esta informaci&oacute;n de autentificaci&oacute;n.</p>
<p>Tanto <em>Microsoft Passport</em> como <em>Liberty Project</em> (formado por una alianza de empresas entre las que se encuentra Sun) pretenden dar soluci&oacute;n a este problema, proporcionando un servicio de autentificaci&oacute;n centralizado. De esta forma podremos acceder a diferentes servicios utilizando siempre el mismo <em>login</em>, ya que todos podr&iacute;an utilizar el mismo servidor de identidades para autentificarnos.</p>
<a name="N10145"></a><a name="Seguridad+de+la+red"></a>
<h3 class="underlined_5">Seguridad de la red</h3>
<p>Hemos de pensar que estamos permitiendo invocar procedimientos remotos mediante 
  protocolo HTTP, que en un principio fue dise&ntilde;ado para la extracci&oacute;n 
  de documentos. Por lo tanto, sus puertos no suelen ser cortados por ning&uacute;n 
  <em>firewall</em>, de forma cualquiera podr&aacute; utilizar estos servicios 
  libremente, sin que los <em>firewalls</em> puedan controlarlo.</p>
</div>

<a name="N10156"></a><a name="Tecnolog%C3%ADas+b%C3%A1sicas"></a>
<h2 class="underlined_10">Tecnolog&iacute;as b&aacute;sicas</h2>
<div class="section">
<p>Tenemos una serie de tecnolog&iacute;as, todas ellas basadas en XML, que son 
  fundamentales para el desarrollo de Servicios Web. Estas tecnolog&iacute;as 
  son independientes tanto del SO como del lenguaje de programaci&oacute;n utilizado 
  para implementar dichos servicios. Por lo tanto, ser&aacute;n utilizadas para 
  cualquier Servicio Web, independientemente de la plataforma sobre la que construyamos 
  dichos servicios (como puede ser J2EE o .NET). </p>
<a name="N1015F"></a><a name="SOAP"></a>
<h3 class="underlined_5">SOAP</h3>
<p>Se trata de un protocolo derivado de XML que nos sirve para intercambiar informaci&oacute;n 
  entre aplicaciones.</p>
<p>Normalmente utilizaremos SOAP para conectarnos a un servicio e invocar m&eacute;todos 
  remotos, aunque puede ser utilizado de forma m&aacute;s gen&eacute;rica para 
  enviar cualquier tipo de contenido. Podemos distinguir dos tipos de mensajes 
  seg&uacute;n su contenido:</p>
<ul>
  
<li>
<strong>Mensajes orientados al documento</strong>: Contienen cualquier tipo 
    de contenido que queramos enviar entre aplicaciones.</li>
  
<li>
<strong>Mensajes orientados a RPC</strong>: Este tipo de mensajes servir&aacute; 
    para invocar procedimientos de forma remota (<em>Remote Procedure Calls</em>). 
    Podemos verlo como un tipo m&aacute;s concreto dentro del tipo anterior, ya 
    que en este caso como contenido del mensaje especificaremos el m&eacute;todo 
    que queremos invocar junto a los par&aacute;metros que le pasamos, y el servidor 
    nos deber&aacute; devolver como respuesta un mensaje SOAP con el resultado 
    de invocar el m&eacute;todo.</li>

</ul>
<p>Cuando hablamos de Servicios Web normalmente nos referimos a RPC, por lo que 
  nos centraremos en este tipo de mensajes. </p>
<p>Puede ser utilizado sobre varios protocolos de transporte, aunque est&aacute; 
  especialmente dise&ntilde;ado para trabajar sobre HTTP.</p>
<p>Dentro del mensaje SOAP podemos distinguir los siguientes elementos:</p>
<p>
<img alt="Elementos de un mensaje SOAP" content-width="4cm" height="225" src="imagenes/soap.gif" width="203"></p>
<ul>
  
<li>Un sobre (<span class="codefrag">Envelope</span>), que describe el mensaje, a quien va 
    dirigido, y c&oacute;mo debe ser procesado. El sobre incluye las definiciones 
    de tipos que se usar&aacute;n en el documento. Contiene una cabecera de forma 
    opcional, y el cuerpo del mensaje.</li>
  
<li>Una cabecera (<span class="codefrag">Header</span>) opcional, donde podemos incluir informaci&oacute;n 
    sobre el mensaje. Por ejemplo, podemos especificar si el mensaje es obligatorio 
    (debe ser entendido de forma obligatoria por el destinatario), e indicar los 
    actores (lugares por donde ha pasado el mensaje).</li>
  
<li>El cuerpo del mensaje (<span class="codefrag">Body</span>), que contiene el mensaje en 
    si. En el caso de los mensajes RPC se define una convenci&oacute;n sobre como 
    debe ser este contenido, en el que se especificar&aacute; el m&eacute;todo 
    al que se invoca y los valores que se pasan como par&aacute;metros. Puede 
    contener un error de forma opcional.</li>
  
<li>Un error (<span class="codefrag">Fault</span>) en el cuerpo del mensaje de forma opcional. 
    Nos servir&aacute; para indicar en una respuesta SOAP que ha habido un error 
    en el procesamiento del mensaje de petici&oacute;n que mandamos.</li>

</ul>
<p>Hemos visto como los mensajes SOAP nos sirven para intercambiar cualquier documento 
  XML entre aplicaciones. Pero puede ocurrir que necesitemos enviar en el mensaje 
  datos que no son XML, como puede ser una imagen. En ese caso tendremos que recurrir 
  a la especificaci&oacute;n de mensajes SOAP con anexos.</p>
<p>Los mensajes SOAP con anexos a&ntilde;aden un elemento m&aacute;s al mensaje:</p>
<p>
<img alt="Elementos de un mensaje SOAP con Anexos" content-width="4cm" height="269" src="imagenes/swa.gif" width="203"></p>
<ul>
  
<li>El anexo (<span class="codefrag">Attachment</span>), puede contener cualquier tipo de 
    contenido (incluido el XML). De esta forma podremos enviar cualquier tipo 
    de contenido junto a un mensaje SOAP.</li>

</ul>
<p>Nuestro mensaje podr&aacute; contener tantos anexos como queramos.</p>
<p>Un ejemplo de mensaje SOAP es el siguiente:</p>
<pre class="code">&lt;SOAP-ENV:Envelope 
 xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"    
 SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;    
    &lt;SOAP-ENV:Body&gt; 
        &lt;ns:getTemperatura xmlns:ns="http://j2ee.ua.es/ns"&gt;    
            &lt;area&gt;Alicante&lt;/area&gt; 
        &lt;/ns:getTemperatura&gt; 
    &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;</pre>
<p>En &eacute;l estamos llamando a nuestro m&eacute;todo <span class="codefrag">getTemperatura</span> 
  para obtener informaci&oacute;n meteorol&oacute;gica, proporcionando como par&aacute;metro 
  el &aacute;rea de la que queremos obtener la temperatura.</p>
<p>Podemos encontrar la especificaci&oacute;n de SOAP y SOAP con anexos publicada 
  en la p&aacute;gina del W3C, en las direcciones <span class="codefrag">http://www.w3.org/TR/SOAP/</span> 
  y <span class="codefrag">http://www.w3.org/TR/SOAP-attachments</span> respectivamente.</p>
<p></p>
<a name="N101DA"></a><a name="WSDL"></a>
<h3 class="underlined_5">WSDL</h3>
<p>Es otro lenguaje derivado de XML, que se utiliza para describir los Servicios 
  Web, de forma que una aplicaci&oacute;n pueda conocer de forma autom&aacute;tica 
  la funci&oacute;n de un Servicio Web, as&iacute; como la forma de uso de dicho 
  Servicio Web.</p>
<p>El fichero WSDL describir&aacute; la interfaz del Servicio Web, con los m&eacute;todos 
  a los que podemos invocar, los par&aacute;metros que debemos proporcionarles 
  y los tipos de datos de dichos par&aacute;metros.</p>
<p>Si desarrollamos un Servicio Web, y queremos que otras personas sean capaces 
  de utilizar nuestro servicio para sus aplicaciones, podremos proporcionar un 
  documento WSDL describiendo nuestro servicio. De esta forma, a partir de este 
  documento otros usuarios podr&aacute;n generar aplicaciones clientes en cualquier 
  plataforma (ya que WSDL se define como un est&aacute;ndar) que se ajusten a 
  nuestro servicio.</p>
<p>El elemento ra&iacute;z dentro de este fichero es <span class="codefrag">definitions</span>, 
  donde se especifican los espacios de nombres que utilizamos en nuestro servicio. 
  Dentro de este elemento ra&iacute;z encontramos los siguientes elementos:</p>
<ul>
  
<li>
<span class="codefrag">types</span>: Se utiliza para definir los tipos de datos que se 
    intercambiar&aacute;n en el mensaje.</li>
  
<li>
<span class="codefrag">message</span>: Define los distintos mensajes que se intercambiaran 
    durante el proceso de invocaci&oacute;n del servicio. Se deber&aacute;n definir 
    los mensajes de entrada y salida para cada operaci&oacute;n que ofrezca el 
    servicio. En el caso de mensajes RPC, en el mensaje de entrada se definir&aacute;n 
    los tipos de par&aacute;metros que se proporcionan, y en el de salida el tipo 
    del valor devuelto.</li>
  
<li>
<span class="codefrag">portType</span>: Define las operaciones que ofrece el servicio. 
    De cada operaci&oacute;n indica cuales son los mensajes de entrada y salida, 
    de entre los mensajes definidos en el apartado anterior.</li>
  
<li>
<span class="codefrag">binding</span>: Indica el protocolo y el formato de los datos 
    para cada mensaje de los definidos anteriormente. Este formato puede ser orientado 
    al documento u orientado a RPC. Si es orientado al documento tanto el mensaje 
    de entrada como el de salida contendr&aacute;n un documento XML. Si es orientado 
    a RPC el mensaje de entrada contendr&aacute; el m&eacute;todo invocado y sus 
    par&aacute;metros, y el de salida el resultado de invocar dicho m&eacute;todo.</li>
  
<li>
<span class="codefrag">service</span>: Define el servicio como una colecci&oacute;n de 
    puertos a los que se puede acceder. Un puerto es la direcci&oacute;n (URL) 
    donde el servicio act&uacute;a. Esta ser&aacute; la direcci&oacute;n a la 
    que las aplicaciones deber&aacute;n conectarse para acceder al servicio. Adem&aacute;s 
    contiene la documentaci&oacute;n en lenguaje natural del servicio.</li>

</ul>
<p>Un documento WSDL de ejemplo es el siguiente:</p>
<pre class="code">&lt;?xml version="1.0" encoding="utf-8" ?&gt; 
  &lt;<strong>definitions</strong> xmlns:s="http://www.w3.org/2001/XMLSchema"
     xmlns:http="http://schemas.xmlsoap.org/wsdl/http/"    
     xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" 
     xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"
     xmlns:tns="http://j2ee.ua.es/wsdl"
     xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" 
     targetNamespace="http://j2ee.ua.es/wsdl"
     xmlns="http://schemas.xmlsoap.org/wsdl/"&gt;
   &lt;<strong>message</strong> name="getTempRequest"&gt;
     &lt;part name="string_1" 
           xmlns:partns="http://www.w3.org/2001/XMLSchema"
           type="partns:string" /&gt; 
   &lt;/<strong>message</strong>&gt;
   &lt;<strong>message</strong> name="getTempResponse"&gt;
     &lt;part name="double_1" 
           xmlns:partns="http://www.w3.org/2001/XMLSchema"
           type="partns:double" /&gt; 
   &lt;/<strong>message</strong>&gt;
   &lt;<strong>portType</strong> name="TempPortType"&gt;
     &lt;operation name="getTemp"&gt;
       &lt;input message="tns:getTempRequest" /&gt; 
       &lt;output message="tns:getTempResponse" /&gt; 
     &lt;/operation&gt;
   &lt;/<strong>portType</strong>&gt;
   &lt;<strong>binding</strong> name="TempPortSoapBinding" type="tns:TempPortType"&gt;
     &lt;soap:binding style="rpc" 
         transport="http://schemas.xmlsoap.org/soap/http" /&gt; 
     &lt;operation name="getTemp"&gt;
       &lt;soap:operation soapAction=" style="rpc" /&gt; 
       &lt;input&gt;
         &lt;soap:body use="encoded" 
         namespace="http://j2ee.ua.es/wsdl" 
         encodingStyle=
           "http://schemas.xmlsoap.org/soap/encoding/" /&gt; 
       &lt;/input&gt;
       &lt;output&gt;
         &lt;soap:body use="encoded" 
         namespace="http://j2ee.ua.es/wsdl"    
         encodingStyle=
           "http://schemas.xmlsoap.org/soap/encoding/" /&gt; 
       &lt;/output&gt;
     &lt;/operation&gt;
   &lt;/<strong>binding</strong>&gt;
   &lt;<strong>service</strong> name="Temp"&gt;
     &lt;documentation&gt;Documentacion&lt;/documentation&gt;    
     &lt;port name="TempPort" binding="tns:TempPortSoapBinding"&gt;
       &lt;soap:address 
           location="http://localhost:7001/sw_temp/Temp" /&gt; 
     &lt;/port&gt;
   &lt;/<strong>service</strong>&gt;
&lt;/<strong>definitions</strong>&gt;</pre>
<p>En el que se define un servicio que proporciona el m&eacute;todo <span class="codefrag">getTemp</span>, 
  que toma como par&aacute;metro una cadena con el nombre del &aacute;rea que 
  queremos consultar, y nos devuelve un valor real. </p>
<p>En los elementos <span class="codefrag">message</span> vemos que tenemos dos mensajes: los 
  mensajes de entrada y salida de la operaci&oacute;n <span class="codefrag">getTemp</span> de nuestro 
  servicio. El mensaje de entrada contiene un dato de tipo <span class="codefrag">string</span> (el 
  par&aacute;metro del m&eacute;todo), y el de salida es de tipo <span class="codefrag">double</span> 
  (la temperatura que devuelve el servicio).</p>
<p>El elemento <span class="codefrag">portType</span> define la operaci&oacute;n <span class="codefrag">getTemp</span> 
  a partir de los mensajes de entrada y salida que la componen, y en <span class="codefrag">binding</span> 
  se establece esta operaci&oacute;n como de tipo RPC y se indica la codificaci&oacute;n 
  de estos mensajes.</p>
<p>Por &uacute;ltimo en el apartado <span class="codefrag">service</span> se especifica el 
  puerto al que podemos conectar para usar el servicio, dando la URL a la que 
  nuestro cliente deber&aacute; acceder. </p>
<p>Podemos encontrar la especificaci&oacute;n de WSDL publicada en la p&aacute;gina 
  del W3C, en la direcci&oacute;n <span class="codefrag">http://www.w3.org/TR/wsdl</span>.</p>
<p></p>
<a name="N10266"></a><a name="UDDI"></a>
<h3 class="underlined_5">UDDI</h3>
<p>UDDI nos permite localizar Servicios Web. UDDI define la especificaci&oacute;n 
  para construir un directorio distribuido de Servicios Web, donde los datos se 
  almacenan en XML.</p>
<p>Adem&aacute;s, UDDI define una API para trabajar con dicho registro, que nos 
  permitir&aacute; buscar datos almacenados en &eacute;l, y publicar datos nuevos. 
</p>
<p>De esta forma, una aplicaci&oacute;n podr&aacute; anunciar sus servicios en 
  un registro UDDI, o bien localizar servicios que necesitemos mediante este registro.</p>
<p>Esta capacidad de localizar servicios en tiempo de ejecuci&oacute;n, y de que 
  una aplicaci&oacute;n pueda saber c&oacute;mo utilizarlo inmediatamente gracias 
  a la descripci&oacute;n del servicio, nos permitir&aacute; realizar una integraci&oacute;n 
  d&eacute;bilmente acoplada de nuestra aplicaci&oacute;n.</p>
<p>La interfaz de UDDI est&aacute; basada en SOAP. Para acceder al registro se 
  utilizar&aacute;n mensajes SOAP, que son transportados mediante protocolo HTTP.</p>
<p>Podemos encontrar la especificaci&oacute;n de UDDI, documentaci&oacute;n, y 
  m&aacute;s informaci&oacute;n en la direcci&oacute;n <span class="codefrag">http://www.uddi.org/</span>.</p>
<p></p>
<a name="N10284"></a><a name="Tecnolog%C3%ADas+de+segunda+generaci%C3%B3n"></a>
<h3 class="underlined_5">Tecnolog&iacute;as de segunda generaci&oacute;n</h3>
<p>Una vez asentadas las tecnolog&iacute;as b&aacute;sicas para servicios web que hemos visto en los puntos anteriores, se empiezan a desarrollar extensiones sobre ellas para cubrir las necesidades que van apareciendo, entre las que encontramos:</p>
<ul>

<li>
<em>WS-Policy</em> y <em>WS-PolicyAttachment</em> nos permitir&aacute;n describir funcionalidades que no pod&iacute;amos especificar con WSDL.</li>

<li>
<em>WS-Security</em> nos permitir&aacute; a&ntilde;adir caracter&iacute;sticas de seguridad adaptadas a las necesidades de seguridad de los Servicios Web. Con esta API podemos utilizar seguridad a nivel de mensaje, mientras que con SSL s&oacute;lo podr&iacute;amos hacer que fuese seguro a nivel de transporte.</li>

<li>
<em>WS-Addressing</em> y <em>WS-ReliableMessaging</em> nos permitir&aacute;n implementar y utilizar Servicios Web que funcionen de forma as&iacute;ncrona. Podremos hacer una petici&oacute;n sin quedarnos bloqueados esperando una respuesta, y recibir la respuesta mediante un <em>callback</em>.</li>

<li>
<em>WS-Coordination</em> o <em>BPEL</em> nos permitir&aacute;n orquestar servicios web.</li>

</ul>
</div>

<a name="N102B2"></a><a name="Tecnolog%C3%ADas+J2EE+para+Servicios+Web"></a>
<h2 class="underlined_10">Tecnolog&iacute;as J2EE para Servicios Web</h2>
<div class="section">
<p>Hemos visto las tecnolog&iacute;as en las que se basan los Servicios Web, y 
  que los hacen independientes de la plataforma y del lenguaje de programaci&oacute;n 
  utilizado. Sin embargo, escribir manualmente los mensajes SOAP desde nuestras 
  aplicaciones puede ser una tarea tediosa. Por ello, las distintas plataformas 
  existentes incorporan librer&iacute;as y utilidades que se encargan de realizar 
  esta tarea por nosotros.</p>
<p>En este tema veremos las librer&iacute;as que incorpora J2EE para la generaci&oacute;n 
  y el procesamiento de c&oacute;digo XML, que nos servir&aacute;n para implementar 
  y utilizar Servicios Web.</p>
<a name="N102BE"></a><a name="JAXP"></a>
<h3 class="underlined_5">JAXP</h3>
<p>La API JAXP nos permite procesar cualquier documento XML desde lenguaje Java. 
  Tiene en cuenta los espacios de nombres, lo cual nos permite trabajar con DTDs 
  que podr&iacute;an tener conflictos de nombres si estos no estuviesen soportados. 
  Adem&aacute;s, soporta XSLT, lo cual nos permitir&aacute; convertir un documento 
  XML a otro formato, como por ejemplo HTML.</p>
<p>Esta es una librer&iacute;a gen&eacute;rica, para procesar cualquier documento 
  XML. A continuaci&oacute;n veremos una serie de librer&iacute;as, para tareas 
  m&aacute;s especificas, que se apoyan en JAXP para realizar el procesado de 
  diferentes lenguajes como SOAP, WSDL y UDDI, todos ellos derivados de XML. Por 
  lo tanto, todas estas librer&iacute;as depender&aacute;n de JAXP para su correcto 
  funcionamiento.</p>
<a name="N102CB"></a><a name="JAXM"></a>
<h3 class="underlined_5">JAXM</h3>
<p>La API JAXM implementa la mensajer&iacute;a XML en Java orientada al documento. 
  Nos permitir&aacute; de forma sencilla crear mensajes XML, insertando el contenido 
  que queramos en ellos, y enviarlos a cualquier destinatario, as&iacute; como 
  extraer el contenido de los mensajes que recibamos. Permite enviar y recibir 
  los mensajes de forma s&iacute;ncrona (modelo petici&oacute;n-respuesta) o as&iacute;ncrona 
  (env&iacute;o de mensaje sin esperar respuesta).</p>
<p>Los mensajes XML con los que trabaja JAXM siguen la especificaci&oacute;n SOAP 
  y SOAP con anexos. Dentro de JAXM encontramos dos APIs:</p>
<ul>
  
<li>SAAJ (<em>SOAP with Attachmets API for Java</em>) es la API que se utiliza 
    para construir mensajes SOAP y para extraer la informaci&oacute;n que contienen. 
    Esta API es independiente, y suficiente para enviar mensajes de tipo petici&oacute;n-respuesta 
    (s&iacute;ncronos).</li>
  
<li>JAXM proporciona un proveedor de mensajer&iacute;a XML, con el que podremos 
    enviar y recibir mensajes de forma as&iacute;ncrona, sin necesidad de esperar 
    una respuesta de la otra parte. Esta API depender&aacute; de SAAJ para funcionar, 
    ya que SAAJ es la que se encargar&aacute; de crear y manipular los mensajes.</li>

</ul>
<a name="N102E4"></a><a name="JAX-RPC+%2F+JAX-WS"></a>
<h3 class="underlined_5">JAX-RPC / JAX-WS</h3>
<p>La API JAX-RPC implementa la infraestructura para realizar llamadas a procedimiento 
  remoto (RPC) mediante XML. En este caso se enviar&aacute; un mensaje SOAP con 
  el m&eacute;todo que queremos invocar junto a los par&aacute;metros que le pasamos, 
  y nos devolver&aacute; de forma s&iacute;ncrona una respuesta SOAP con el valor 
  devuelto por el m&eacute;todo tras su ejecuci&oacute;n. </p>
<p>Por lo tanto, JAX-RPC depender&aacute; de SAAJ para construir los mensajes 
  SOAP, para enviarlos, y para extraer la informaci&oacute;n del mensaje SOAP 
  que nos devuelve como resultado.</p>
<p>Esta API nos permitir&aacute;, de forma sencilla, invocar Servicios Web de 
  tipo RPC, as&iacute; como crear nuestros propios Servicios Web RPC a partir 
  de clases Java que tengamos implementadas. Cuando hablamos de Servicios Web, 
  normalmente nos referimos a este tipo de Servicios Web.</p>
<p>A partir de la versi&oacute;n 2.0, esta API pasa a recibir el nombre JAX-WS. Esta nueva versi&oacute;n se basa en JAXB para manipular los datos. Adem&aacute;s permite el uso de la API <em>Web Services Metadata for the Java Platform</em> que permite construir los servicios web utilizando anotaciones.</p>
<a name="N102FA"></a><a name="JAXR"></a>
<h3 class="underlined_5">JAXR</h3>
<p>La API JAXR nos permitir&aacute; acceder a registros XML a trav&eacute;s de 
  una API est&aacute;ndar Java. Esta API pretende proporcionar una interfaz &uacute;nica 
  para acceder a distintos tipos de registros, cada uno de los cuales tiene un 
  protocolo distinto.</p>
<p>Actualmente JAXR es capaz de trabajar con registros UDDI y ebXML. Podremos 
  realizar dos tipos de tareas distintas cuando accedamos a un registro mediante 
  JAXR:</p>
<ul>
  
<li>Consultar el registro, para localizar los servicios que necesitemos.</li>
  
<li>Publicar un servicio en el registro, para que otros clientes sean capaces 
    de localizarlo cuando lo necesiten, as&iacute; como modificar o eliminar los 
    servicios publicados que sean de nuestra propiedad.</li>

</ul>
<a name="N10310"></a><a name="JAXB"></a>
<h3 class="underlined_5">JAXB</h3>
<p>La API de JAXB (<em>Java API for Binding</em>) nos permite asociar esquemas 
  XML y c&oacute;digo Java. A partir de un esquema XML, podremos generar una clase 
  Java que represente dicho esquema. </p>
<p>De esta forma podremos convertir un documento XML a una serie de objetos Java 
  que contendr&aacute;n la informaci&oacute;n de dicho documento (<em>unmarshalling</em>). 
  Podremos entonces trabajar desde nuestra aplicaci&oacute;n con estos objetos, 
  accediendo y modificando sus valores. Finalmente, podremos volver a obtener 
  un documento XML a partir de los objetos Java (<em>marshalling</em>).</p>
<p>Esto nos va a simplificar la tarea de utilizar tipos de datos propios en llamadas 
  a Servicios Web, ya que utilizando JAXB podremos realizar de forma sencilla 
  la conversi&oacute;n entre nuestra clase Java y un documento XML con la informaci&oacute;n 
  de dicha clase.</p>
<a name="N10329"></a><a name="Java+API+for+WSDL"></a>
<h3 class="underlined_5">Java API for WSDL</h3>
<p>La API de Java para WSDL nos permite de forma sencilla analizar documentos 
  WSDL, y de esa forma poder descubrir las caracter&iacute;sticas de un servicio 
  en tiempo de ejecuci&oacute;n. </p>
<p>Mediante esta API, podremos <em>"interrogar"</em> un servicio a partir 
  de su especificaci&oacute;n WSDL, y obtener informaci&oacute;n como las operaciones 
  que podemos invocar en este servicio, los par&aacute;metros que deberemos proporcionar 
  a cada una de ellas, y el tipo de datos resultante que nos devuelven. </p>
<p>De esta forma podremos realizar la integraci&oacute;n de la aplicaci&oacute;n 
  en tiempo de ejecuci&oacute;n, ya que no ser&aacute; necesario indicar al programa 
  c&oacute;mo debe acceder a un servicio, ni los m&eacute;todos a los que debe 
  llamar, sino que el programa ser&aacute; capaz de determinar esta informaci&oacute;n 
  analizando la especificaci&oacute;n WSDL del servicio.</p>
</div>



<a name="N1033D"></a><a name="Invocaci%C3%B3n+de+Servicios"></a>
<h2 class="underlined_10">Invocaci&oacute;n de Servicios</h2>
<div class="section">
<p>Vamos a ver ahora c&oacute;mo invocar Servicios Web desde 
  Java. Para ello contamos con la API JAX-WS (o JAX-RPC en versiones anteriores). 
  Con esta librer&iacute;a podremos ejecutar procedimientos de forma remota, simplemente haciendo 
  una llamada a dicho procedimiento, sin tener que introducir apenas c&oacute;digo 
  adicional. Ser&aacute; JAX-WS quien se encargue de gestionar internamente la 
  conexi&oacute;n con el servicio y el manejo de los mensajes SOAP de llamada 
  al procedimiento y de respuesta.</p>
<p>Podemos encontrar las clases de la API de JAX-WS dentro del paquete<span class="codefrag"> 
  javax.xml.ws</span> y en subpaquetes de &eacute;ste. </p>
<p>Nuestro cliente Java realizado con JAX-WS ser&aacute; interoperable con pr&aacute;cticamente 
  todos los servicios creados desde otras plataformas que cumplan el est&aacute;ndar WS-I.</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Con JAX-WS no podremos invocar servicios que utilicen codificaci&oacute;n <span class="codefrag">rpc/encoded</span>, ya que el uso
  de esta codificaci&oacute;n est&aacute; desaconsejado por los est&aacute;ndares actuales. En estos casos deberemos utilizar
  la antigua librer&iacute;a JAX-RPC, que si que es compatible con este tipo de servicios.</div>
</div>
<a name="N10355"></a><a name="Tipos+de+acceso"></a>
<h3 class="underlined_5">Tipos de acceso</h3>
<p>Tenemos dos formas diferentes de invocar un Servicio Web utilizando JAX-WS o JAX-RPC:</p>
<ul>
  
<li>
<strong>Creaci&oacute;n de un stub est&aacute;tico</strong>: Consiste en 
    generar una capa de <em>stub</em> por debajo del cliente de forma autom&aacute;tica. 
    Dicho <em>stub</em> implementar&aacute; la misma interfaz que el servicio, 
    lo cu&aacute;l nos permitir&aacute; desde nuestro cliente acceder al Servicio 
    Web a trav&eacute;s del <em>stub</em> tal y como si estuvi&eacute;ramos accediendo 
    directamente al servicio. 
    <p>Para utilizar este mecanismo es recomendable contar con alguna herramienta 
      dentro de nuestra plataforma que nos permita generar dicho <em>stub</em>, 
      para no tener que encargarnos nosotros de realizar esta tarea manualmente.</p>
  
</li>
  
<li>
<strong>Utilizaci&oacute;n de la Interfaz de Invocaci&oacute;n Din&aacute;mica 
    (DII)</strong>: Esta forma de acceso nos permitir&aacute; hacer llamadas a 
    procedimientos de nuestro Servicio Web de forma din&aacute;mica, sin crear 
    un <em>stub</em> para ello. Utilizaremos este tipo de invocaci&oacute;n cuando 
    no conozcamos la interfaz del servicio <em>a priori</em>, para invocarlo deberemos 
    proporcionar &uacute;nicamente los nombres de los m&eacute;todos a utilizar 
    mediante una cadena de texto. 
    <p>Podremos utilizar esta interfaz din&aacute;mica aunque no contemos con 
      un documento WSDL que nos indique la interfaz y datos de nuestro servicio. 
      En este caso, deberemos proporcionar manualmente esta informaci&oacute;n, 
      de forma que sea capaz de acceder al servicio correctamente.</p>
  
</li>

</ul>
<a name="N10384"></a><a name="Invocaci%C3%B3n+mediante+stub+est%C3%A1tico"></a>
<h3 class="underlined_5">Invocaci&oacute;n mediante stub est&aacute;tico</h3>
<p>Est&aacute; ser&aacute; la forma m&aacute;s sencilla de acceder siempre que 
  contemos con una herramienta que genera el <em>stub</em> de forma autom&aacute;tica. 
</p>
<p>De esta forma, una vez generado el <em>stub</em>, s&oacute;lo tendremos que 
  utilizar este <em>stub</em> como si se tratase de nuestro servicio directamente. 
  En el <em>stub</em> podremos hacer las mismas llamadas a m&eacute;todos que 
  har&iacute;amos directamente en la clase que implemente nuestro servicio, ya 
  que ambos implementar&aacute;n la misma interfaz.</p>
<p>Las herramientas para generar este <em>stub</em> variar&aacute;n seg&uacute;n la plataforma con la 
  que trabajemos. A partir de JDK 1.6 se incluye en Java SE la librer&iacute;a JAX-WS y las herramientas
  necesarias para crear e invocar servicios. En el caso de contar con versiones anteriores de JDK, 
  podemos o bien incorporar a nuestro proyecto las librer&iacute;as necesarias (JAX-WS o JAX-RPC), o bien 
  utilizar herramientas y librer&iacute;as similares proporcionadas por los servidores de aplicaciones, como es el 
  caso de Weblogic 9.2, o desarrolladas por terceros, como es el caso de Apache Axis, que se incluye en
  Eclipse Web Tools.</p>
<p>Vamos a ver c&oacute;mo crear clientes para servicios web utilizando tanto las herramientas est&aacute;ndar proporcionadas
por Sun (en JDK 1.6), como las herramientas proporcionadas por Weblogic. Finalmente, veremos como crear estos
clientes utilizando el IDE Netbeans, que internamente utilizar&aacute; las herramientas y librer&iacute;as est&aacute;ndar de Sun.</p>
<a name="N103A5"></a><a name="Invocaci%C3%B3n+de+servicios+web+con+JDK+1.6"></a>
<h4>Invocaci&oacute;n de servicios web con JDK 1.6</h4>
<p>Para crear un cliente en JDK 1.6 (o con JAX-WS en versiones anteriores de JDK) utilizaremos la herramienta
<span class="codefrag">wsimport</span>, que tomar&aacute; como entrada el documento WSDL del servicio al que queremos acceder y producir&aacute;
un conjunto de clases Java que nos permitir&aacute;n acceder al servicio. Esta herramienta se puede invocar desde l&iacute;nea
de comando:</p>
<pre class="code">
<strong>wsimport -s</strong> <em>&lt;src.dir&gt;</em> <strong>-d</strong> <em>&lt;dest.dir&gt;</em> <strong>-p</strong> <em>&lt;pkg&gt;</em> <em>&lt;wsdl.uri&gt;</em>
</pre>
<p>El documento WSDL (<span class="codefrag">&lt;wsdl.url&gt;</span>) se especificar&aacute; mediante su ruta en el disco o mediante su URL. Podemos proporcionar otros 
par&aacute;metros para indicar la forma en la que se debe generar el <em>stub</em>, como el directorio donde
queremos que guarde los fuentes de las clases generadas (<span class="codefrag">&lt;src.dir&gt;</span>), el directorio donde guardar&aacute; estas clases compiladas (<span class="codefrag">&lt;dest.dir&gt;</span>),
y el paquete en el que se generar&aacute; este conjunto de clases (<span class="codefrag">&lt;pkg&gt;</span>). </p>
<p>Por ejemplo podr&iacute;amos utilizar el siguiente comando para crear el cliente de un servicio <span class="codefrag">HolaMundo</span>
que se encuentra definido en <span class="codefrag">http://jtech.ua.es/HolaMundo/wsdl/HolaMundoSW.wsdl</span>, 
separando los fuentes en el directorio <span class="codefrag">src</span> y las clases compiladas en <span class="codefrag">bin</span>, y generando 
todas estas clases dentro de un paquete <span class="codefrag">es.ua.jtech.servcweb.hola.stub</span>:</p>
<pre class="code">
<strong>wsimport -s</strong> src <strong>-d</strong> bin <strong>-p</strong> es.ua.jtech.servcweb.hola.stub 
         http://jtech.ua.es/HolaMundo/wsdl/HolaMundoSW.wsdl</pre>
<p>Tambi&eacute;n existe una tarea de ant equivalente. Para utilizarla deberemos declararla previamente (teniendo la librer&iacute;a 
<span class="codefrag">jaxws-tools.jar</span> dentro del <span class="codefrag">CLASSPATH</span> de ant):</p>
<pre class="code">&lt;taskdef name="<strong>wsimport</strong>" classname="<strong>com.sun.tools.ws.ant.WsImport</strong>"/&gt;</pre>
<p>Una vez declarada, podremos utilizarla de forma similar a la herramienta en l&iacute;nea de comando:</p>
<pre class="code">&lt;<strong>wsimport sourcedestdir</strong>="${src.home}" <strong>destdir</strong>="${bin.home}" 
          <strong>package</strong>="${pkg.name}" <strong>wsdl</strong>="${wsdl.uri}" /&gt;</pre>
<p>Con esto se generar&aacute;n una serie de clases que nos permitir&aacute;n acceder al servicio web e invocar sus operaciones
desde nuestro cliente. Dentro de estas clases tendremos una que recibir&aacute; el mismo nombre que el servicio, y que 
heredar&aacute; de la clase <span class="codefrag">Service</span>. Deberemos instanciar esta clase, y a partir de ella obtendremos el
<em>stub</em> para acceder a un puerto del servicio. Este <em>stub</em> tendr&aacute; la misma interfaz que el servicio web,
y a partir de &eacute;l podremos invocar sus operaciones. En el ejemplo del servicio <span class="codefrag">HolaMundo</span> acceder&iacute;amos
al servicio de la siguiente forma:</p>
<pre class="code">
<strong>HolaMundoSWService</strong> service = new <strong>HolaMundoSWService</strong>();
<strong>HolaMundoSW</strong> port = service.<strong>getHolaMundoSW</strong>();

System.out.println("Resultado: " + port.<strong>saluda</strong>("Miguel"));</pre>
<p>El servicio ofrece una operaci&oacute;n <span class="codefrag">saluda</span> que recibe un nombre, y genera un saludo incluyendo
dicho nombre. En este ejemplo vemos como podemos invocar la operaci&oacute;n <span class="codefrag">saluda</span> del servicio a partir del <em>stub</em> (<span class="codefrag">port</span>) como 
si se tratase de un m&eacute;todo de un objeto local.</p>
<a name="N1044F"></a><a name="Invocaci%C3%B3n+de+servicios+web+con+Weblogic"></a>
<h4>Invocaci&oacute;n de servicios web con Weblogic</h4>
<p>Weblogic incluye una serie de ficheros JAR que contienen la implementaci&oacute;n 
  de JAX-RPC para el cliente. Tenemos los siguientes ficheros en el directorio <span class="codefrag">WL_HOME/server/lib</span>:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">webserviceclient.jar</span></td>
    <td colspan="2" rowspan="1">Implementaci&oacute;n de JAX-RPC para el cliente</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">webserviceclient+ssl.jar</span></td>
    <td colspan="2" rowspan="1">Implementaci&oacute;n para utilizar SSL</td>
  
</tr>

</table>
<p>El cliente deber&aacute; tener acceso a las librer&iacute;as necesarias, por lo que deberemos tener uno de 
estos dos ficheros en el <span class="codefrag">CLASSPATH</span> (el fichero seleccionado depender&aacute; de si vamos a utilizar 
SSL o no), adem&aacute;s de la librer&iacute;a <span class="codefrag">weblogic.jar</span> y de <span class="codefrag">xbean.jar</span>, que se utilizar&aacute;
para encapsular los tipos de datos propios que utilice el servicio.</p>
<p>Ahora deberemos generar las clases de <em>stub</em> en el cliente para nuestro 
  Servicio Web espec&iacute;fico. Para ello en la implementaci&oacute;n de Weblogic 
  contamos con una tarea de la herramienta <strong>ant</strong> que realizar&aacute; 
  este trabajo por nosotros, se trata de la tarea <span class="codefrag">clientgen</span>.</p>
<p>Para poder utilizar esta tarea, antes deberemos declararla con:</p>
<pre class="code">&lt;taskdef name="<strong>clientgen</strong>" 
         classname="<strong>weblogic.wsee.tools.anttasks.ClientGenTask</strong>" /&gt;</pre>
<p>Adem&aacute;s ant deber&aacute; tener en su <span class="codefrag">CLASSPATH</span> la librer&iacute;a <span class="codefrag">weblogic.jar</span>, 
que se encuentra en el directorio <span class="codefrag">WL_HOME/server/lib</span>.</p>
<p>Crearemos el <em>stub</em> a partir del fichero WSDL que describe el servicio, tal como se 
muestra a continuaci&oacute;n:</p>
<pre class="code">&lt;<strong>clientgen</strong> 
	<strong>wsdl</strong>="${wsdl.url}" 
	<strong>packageName</strong>="${pkg.name}"    
	<strong>destDir</strong>="${src.home}" /&gt;</pre>
<p>Como datos del servicio &uacute;nicamente aportamos la URL del 
  documento WSDL del cu&aacute;l vamos a extraer la informaci&oacute;n del Servicio 
  Web a invocar. Adem&aacute;s tambi&eacute;n deberemos indicar el paquete que asignaremos 
  a las clases generadas, y el 
  directorio en el que las ubicaremos.</p>
<p>Con esto habremos generado el <em>stub</em> necesario en el paquete especificado 
  en <span class="codefrag">packageName</span>, y se habr&aacute; almacenado en el directorio indicado en <span class="codefrag">destDir</span>. 
  Podemos implementar un cliente de la siguiente forma:</p>
<pre class="code">
<strong>HolaMundoSWService</strong> service = new <strong>HolaMundoSWService_Impl</strong>();
<strong>HolaMundoSW</strong> port = service.<strong>getHolaMundoSW</strong>();
		
System.out.println("Resultado: " + port.<strong>saluda</strong>("Miguel"));</pre>
<p>Para acceder al <em>stub</em> primero debemos crear la implementaci&oacute;n 
  generada del servicio correspondiente (<em><span class="codefrag">&lt;servicio&gt;</span></em><span class="codefrag">_Impl</span>). 
  Podremos crearla proporcionando como par&aacute;metro la URL del documento WSDL que describe el servicio. 
  En caso de no especificar este dato, utilizar&iacute;a por defecto la direcci&oacute;n 
  WSDL que hubi&eacute;semos especificado al generar las clases de <em>stub</em>. 
  Una vez tenemos este objeto, podemos obtener a partir de &eacute;l el <em>stub</em> 
  para acceder a un puerto del servicio, y a partir de este objeto <em>stub</em> 
  acceder al servicio igual que si estuvi&eacute;semos accediendo a la clase que 
  lo implementa en modo local.</p>
<p>Por ejemplo, podr&iacute;amos crear una clase principal <span class="codefrag">Main</span> para invocar desde ella directamente
el servicio web:</p>
<pre class="code">package es.ua.jtech.servcweb.hola;

import es.ua.jtech.servcweb.hola.stub.HolaMundoSW;
import es.ua.jtech.servcweb.hola.stub.HolaMundoSWService;
import es.ua.jtech.servcweb.hola.stub.HolaMundoSWService_Impl;

public class Main {
  public static void main(String[] args) throws Exception {
    HolaMundoSWService service = new HolaMundoSWService_Impl();
    HolaMundoSW port = service.getHolaMundoSW();
		
    System.out.println("Resultado: " + port.saluda("Miguel"));
  }
}</pre>
<p>Para poder compilar e invocar esta aplicaci&oacute;n cliente, se deber&aacute; 
  poder localizar las clases generadas para el cliente, adem&aacute;s de las clases 
  de JAX-RPC en las que se basa. Por lo tanto deberemos tener en el <span class="codefrag">CLASSPATH</span> las
  librer&iacute;as comentadas anterioremente:</p>
<pre class="code">WL_HOME/server/lib/weblogic.jar
WL_HOME/server/lib/webserviceclient.jar
WL_HOME/server/lib/xbean.jar</pre>
<p>En Weblogic 10 adem&aacute;s se incluye la librer&iacute;a <span class="codefrag">WL_HOME/server/lib/wseeclient.zip</span> que contiene
  todas las clases necesarias para los clientes de servicios web. De esta forma, para distribuir la aplicaci&oacute;n cliente
  s&oacute;lo ser&iacute;a necesario incluir dicha librer&iacute;a.</p>
<a name="N1051D"></a><a name="Invocaci%C3%B3n+de+servicios+web+con+Netbeans"></a>
<h4>Invocaci&oacute;n de servicios web con Netbeans</h4>
<p>Vamos a ver ahora c&oacute;mo crear un cliente de servicios web de forma visual mediante Netbeans. Este 
entorno utilizar&aacute; internamente las librer&iacute;as y herramientas est&aacute;ndar de Sun para crear <em>stub</em> del cliente.</p>
<p>En primer lugar, deberemos crear un proyecto, o utilizar uno ya existente. Este proyecto podr&aacute; ser de cualquier tipo
(aplicaci&oacute;n Java, aplicaci&oacute;n Web, etc). Una vez tengamos un proyecto creado, podremos a&ntilde;adir el <em>stub</em> para acceder
a un servicio web pulsando con el bot&oacute;n derecho sobre el proyecto y seleccionando la opci&oacute;n <em>Web Service Client ...</em>.</p>
<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 1." content-width="8cm" height="383" src="imagenes/sesion1/client_nb1.gif" width="400"></p>
<p>Se abrir&aacute; un asistente para crear el <em>stub</em> del cliente. Aqu&iacute; deberemos especificar en primer lugar el documento
WSDL que define el servicio al que vamos a acceder, por ejemplo indicando la URL en la que se encuentra. En segundo lugar 
especificaremos el paquete en el que queremos que se generen las clases del <em>stub</em>. En el caso de contar con una versi&oacute;n
de JDK anterior a la 1.6, podremos tambi&eacute;n especificar la librer&iacute;a que queremos utilizar: JAX-WS o JAX-RPC. En este caso 
se a&ntilde;adir&aacute;n autom&aacute;ticamente las librer&iacute;as necesarias al proyecto. En el caso de tener JDK 1.6 obligatoriamente deberemos utilizar 
JAX-WS, y no se a&ntilde;adir&aacute; ninguna librer&iacute;a al proyecto ya que a partir de esta versi&oacute;n dicha librer&iacute;a ya pertenece a la API de 
Java SE.</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Una vez seleccionada la librer&iacute;a para acceder a los servicios web dentro de un proyecto, en los sucesivos clientes de 
servicios que se creen dentro de dicho proyecto siempre se deber&aacute; utilizar la misma librer&iacute;a. Es decir, JAX-RPC y JAX-WS no
pueden coexistir dentro del mismo proyecto.</div>
</div>
<p>Finalmente, una vez introducidos estos datos pulsaremos el bot&oacute;n <em>Finish</em>, tras lo cual Netbeans lanzar&aacute; la tarea de ant
<span class="codefrag">wsimport</span> para generar el <em>stub</em> del servicio.</p>
<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 2." content-width="8cm" height="235" src="imagenes/sesion1/client_nb2.gif" width="400"></p>
<p>Una vez generado el <em>stub</em> del cliente, podremos ver en la pesta&ntilde;a <em>Projects</em>, dentro del apartado <em>Web 
Service References</em>, los datos del servicio al que vamos a acceder y las operaciones que ofrece. Sin embargo, no se
muestran las clases Java generadas. Para ver estas clases deberemos ir a la pesta&ntilde;a <em>Files</em>, y dentro de ella al
directorio <span class="codefrag">/build/generated/wsimport/client/</span>.</p>
<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 3." content-width="8cm" height="274" src="imagenes/sesion1/client_nb3.gif" width="400"></p>
<p>Una vez creado el <em>stub</em> del cliente, deberemos utilizarlo en nuestra aplicaci&oacute;n para acceder al servicio. Vamos a suponer
que lo queremos invocar desde la clase principal de nuestra aplicaci&oacute;n, aunque lo mismo podr&iacute;a hacerse para invocarlo desde 
cualquier otra clase, o incluso desde un JSP. Para crear el c&oacute;digo que llame al servicio pulsaremos con el bot&oacute;n derecho del rat&oacute;n
en el lugar del fuente de nuestra clase en el que queramos insertar la llamada, y seleccionaremos la opci&oacute;n <em>Web Service
Client Resources &gt; Call Web Service Operation</em>.</p>
<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 4." content-width="8cm" height="162" src="imagenes/sesion1/client_nb4.gif" width="400"></p>
<p>Se abrir&aacute; una ventana en la que deberemos seleccionar la operaci&oacute;n que queramos invocar. En nuestro caso seleccionaremos
la operaci&oacute;n <span class="codefrag">saluda</span> del servicio <span class="codefrag">HolaMundo</span> y pulsamos el bot&oacute;n <em>OK</em>.</p>
<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 5." content-width="8cm" height="301" src="imagenes/sesion1/client_nb5.gif" width="400"></p>
<p>Una vez hecho esto se introducir&aacute; en nuestra clase el c&oacute;digo que hace la llamada al servicio. Deberemos editar este c&oacute;digo
para especificar los par&aacute;metros que vamos a proporcionar en la llamada.</p>
<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 6." content-width="8cm" height="176" src="imagenes/sesion1/client_nb6.gif" width="400"></p>
<p>Con esto ya podremos ejecutar nuestra aplicaci&oacute;n cliente, que se conectar&aacute; al servicio web <span class="codefrag">HolaMundo</span>
para utilizar la operaci&oacute;n <span class="codefrag">saluda</span>.</p>
<a name="N105AF"></a><a name="Interfaz+de+invocaci%C3%B3n+din%C3%A1mica+%28DII%29"></a>
<h3 class="underlined_5">Interfaz de invocaci&oacute;n din&aacute;mica (DII)</h3>
<p>Mediante esta interfaz ya no utilizaremos un <em>stub</em> para invocar los 
  m&eacute;todos del servicio, sino que nos permitir&aacute; invocar los m&eacute;todos 
  de forma din&aacute;mica, indicando simplemente el nombre del m&eacute;todo 
  que queremos invocar como una cadena de texto, y sus par&aacute;metros como 
  un <em>array</em> de objetos.</p>
<p>Esto nos permitir&aacute; utilizar servicios que no conocemos previamente. 
  De esta forma podremos implementar por ejemplo un <em>broker</em> de servicios. 
  Un <em>broker</em> es un servicio intermediario, al que podemos solicitar alguna 
  tarea que necesitemos. Entonces el <em>broker</em> intentar&aacute; localizar 
  el servicio m&aacute;s apropiado para dicha tarea en un registro de servicios, 
  y lo invocar&aacute; por nosotros. Una vez haya conseguido la informaci&oacute;n 
  que requerimos, nos la devolver&aacute;. De esta forma la localizaci&oacute;n 
  de servicios se hace totalmente transparente para nosotros.</p>
<p>Podremos acceder con esta interfaz tanto si contamos con un documento WSDL 
  como si no contamos con &eacute;l, pero en el caso de que no tengamos el WSDL 
  deberemos especificar en el c&oacute;digo todos los datos incluidos en estos 
  documentos que necesitemos y de los que en este caso no disponemos (<em>endpoint</em>, 
  par&aacute;metros y tipos, etc).</p>
<a name="N105D0"></a><a name="A+partir+de+un+documento+WSDL"></a>
<h4>A partir de un documento WSDL</h4>
<p>Vamos a ver el caso en el que contamos con el documento WSDL que describe el 
  servicio. El primer paso ser&aacute; conseguir el objeto <span class="codefrag">Service</span> 
  igual que hicimos en el caso anterior:</p>
<pre class="code">ServiceFactory sf = ServiceFactory.newInstance();
Service serv = sf.createService(
  new URL("http://localhost:7001/HolaMundo/hola?WSDL"), 
  new QName("http://jtech.ua.es", "Conversion"));</pre>
<p>Utilizaremos el objeto <span class="codefrag">Call</span> para hacer las llamadas din&aacute;micas 
  a los m&eacute;todos del servicio. Deberemos crear un objeto <span class="codefrag">Call</span> 
  correspondiente a un determinado puerto y operaci&oacute;n de nuestro servicio:</p>
<pre class="code">
<strong>Call</strong> call = serv.<strong>createCall</strong>(
  new QName("http://jtech.ua.es", "HolaMundoPortTypeSoapPort"),
  new QName("http://jtech.ua.es", "saluda"));</pre>
<p>El &uacute;ltimo paso ser&aacute; invocar la llamada que hemos creado:</p>
<pre class="code">Integer result = (Integer) call.<strong>invoke</strong>(
                 new Object[] { "Miguel" });</pre>
<p>A este m&eacute;todo le debemos proporcionar un <em>array</em> de objetos como 
  par&aacute;metro, ya que debe poder utilizarse para cualquier operaci&oacute;n, 
  con diferente n&uacute;mero y tipo de par&aacute;metros. Como tampoco se conoce<em> 
  a priori</em> el valor devuelto por la llamada, deberemos hacer una conversi&oacute;n 
  <em>cast</em> al tipo que corresponda, ya que nos devuelve un <span class="codefrag">Object</span> 
  gen&eacute;rico.</p>
<a name="N1060C"></a><a name="Sin+un+documento+WSDL"></a>
<h4>Sin un documento WSDL</h4>
<p>Si no contamos con el WSDL del servicio, crearemos un objeto <span class="codefrag">Service</span> 
  proporcionando &uacute;nicamente el nombre del servicio:</p>
<pre class="code">ServiceFactory sf = ServiceFactory.newInstance(); 
Service serv = sf.createService( 
  new QName("http://jtech.ua.es", "HolaMundo"));</pre>
<p>A partir de este objeto podremos obtener un objeto <span class="codefrag">Call</span> para 
  realizar una llamada al servicio de la misma forma que vimos en el caso anterior:</p>
<pre class="code">
<strong>Call</strong> call = serv.<strong>createCall</strong>(
  new QName("http://jtech.ua.es", "HolaMundoPortTypeSoapPort"),
  new QName("http://jtech.ua.es", "saluda"));</pre>
<p>En este caso el objeto <span class="codefrag">Call</span> no tendr&aacute; ninguna informaci&oacute;n 
  sobre las caracter&iacute;sticas del servicio, ya que no tiene acceso al documento 
  WSDL que lo describe, por lo que deberemos proporcion&aacute;rselas nosotros 
  expl&iacute;citamente.</p>
<p>En primer lugar, deberemos especificar el <em>endpoint</em> del servicio, para 
  que sepa a qu&eacute; direcci&oacute;n debe conectarse para acceder a dicho 
  servicio:</p>
<pre class="code">call.<strong>setTargetEndpointAddress</strong>(endpoint);</pre>
<p>Una vez especificada esta informaci&oacute;n, deberemos indicar el tipo de 
  datos que nos devuelve la llamada a la operaci&oacute;n que vamos a invocar 
  (en nuestro ejemplo <span class="codefrag">saluda</span>):</p>
<pre class="code">QName t_int = 
  new QName("http://www.w3.org/2001/XMLSchema", "int");
call.<strong>setReturnType</strong>(t_string);</pre>
<p>Por &uacute;ltimo, indicaremos los par&aacute;metros de entrada que toma la 
  operaci&oacute;n y sus tipos:</p>
<pre class="code">QName t_double = 
  new QName("http://www.w3.org/2001/XMLSchema", "string");
call.<strong>addParameter</strong>("string_1", t_string, ParameterMode.IN);</pre>
<p>Una vez hecho esto, podremos invocar dicha operaci&oacute;n igual que en el 
  caso anterior:</p>
<pre class="code">Integer result = (Integer) call.<strong>invoke</strong>(
                 new Object[] { "Miguel" });</pre>
</div>


<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2007 Depto. CCIA</div>
</div>
</body>
</html>
