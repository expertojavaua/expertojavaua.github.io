<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Creaci&oacute;n de Servicios Web</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="J2EE" src="images/baner_j2ee_izq.gif" title="Curso Especialista Universitario J2EE"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servicios Web" src="images/baner_j2ee_der.gif" title="Servicios Web"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="../index.html">M&oacute;dulos</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servicios Web</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servicios Web</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servicios Web">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 2</div>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html" title="Roadmap">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion02-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Creaci&oacute;n de Servicios Web</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Arquitectura+de+los+Servicios+Web+orientados+a+RPC">Arquitectura de los Servicios Web orientados a RPC</a>
</li>
<li>
<a href="#Tipos+de+datos+compatibles">Tipos de datos compatibles</a>
</li>
<li>
<a href="#Implementaci%C3%B3n+del+servicio%3A+Fichero+JWS">Implementaci&oacute;n del servicio: Fichero JWS</a>
<ul class="minitoc">
<li>
<a href="#Anotaciones">Anotaciones</a>
</li>
<li>
<a href="#Estilo+y+codificaci%C3%B3n+del+servicio">Estilo y codificaci&oacute;n del servicio</a>
</li>
<li>
<a href="#Tratamiento+de+errores">Tratamiento de errores</a>
</li>
</ul>
</li>
<li>
<a href="#Compilaci%C3%B3n+del+fichero+JWS">Compilaci&oacute;n del fichero JWS</a>
<ul class="minitoc">
<li>
<a href="#Compilaci%C3%B3n+del+servicio+con+JDK+1.6">Compilaci&oacute;n del servicio con JDK 1.6</a>
</li>
<li>
<a href="#Compilaci%C3%B3n+del+servicio+con+Weblogic">Compilaci&oacute;n del servicio con Weblogic</a>
<ul class="minitoc">
<li>
<a href="#Crear+un+servicio+partiendo+de+un+documento+WSDL">Crear un servicio partiendo de un documento WSDL</a>
</li>
<li>
<a href="#Crear+un+servicio+que+invoque+otro+servicio">Crear un servicio que invoque otro servicio</a>
</li>
<li>
<a href="#Probar+los+servicios">Probar los servicios</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Creaci%C3%B3n+de+servicios+web+con+BEA+Workshop">Creaci&oacute;n de servicios web con BEA Workshop</a>
<ul class="minitoc">
<li>
<a href="#Invocaci%C3%B3n+de+servicios+desde+dentro+de+otro+servicio">Invocaci&oacute;n de servicios desde dentro de otro servicio</a>
</li>
<li>
<a href="#Operaciones+as%C3%ADncronas">Operaciones as&iacute;ncronas</a>
</li>
<li>
<a href="#Servicios+web+conversacionales">Servicios web conversacionales</a>
</li>
</ul>
</li>
<li>
<a href="#Handlers+de+mensajes">Handlers de mensajes</a>
<ul class="minitoc">
<li>
<a href="#Creaci%C3%B3n+de+un+handler">Creaci&oacute;n de un handler</a>
<ul class="minitoc">
<li>
<a href="#Handlers+en+JAX-RPC">Handlers en JAX-RPC</a>
</li>
<li>
<a href="#Handlers+en+JAX-WS">Handlers en JAX-WS</a>
</li>
</ul>
</li>
<li>
<a href="#Registro+de+handlers+en+el+servicio">Registro de handlers en el servicio</a>
</li>
<li>
<a href="#Registrar+el+handler+en+el+cliente">Registrar el handler en el cliente</a>
<ul class="minitoc">
<li>
<a href="#Registro+de+handlers+con+JAX-RPC">Registro de handlers con JAX-RPC</a>
</li>
<li>
<a href="#Registro+de+handlers+con+JAX-WS">Registro de handlers con JAX-WS</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>


<p>Vamos a crear nuestros propios Servicios Web, que ofrecer&aacute;n una serie 
  de m&eacute;todos a los que se podr&aacute; llamar mediante RPC desde cualquier 
  lugar de Internet mediante protocolos est&aacute;ndar (mensajes SOAP).</p>

<p>Deberemos por lo tanto ser capaces de interpretar en nuestras aplicaciones 
  los mensajes SOAP entrantes de petici&oacute;n para la invocaci&oacute;n de 
  un m&eacute;todo. Posteriormente, invocaremos el m&eacute;todo solicitado, y 
  con el resultado que nos devuelva deberemos construir un mensaje SOAP de respuesta 
  y devolv&eacute;rselo al cliente.</p>

<p>Si tuvi&eacute;semos que introducir nosotros el c&oacute;digo para interpretar 
  este mensaje de entrada, y generar manualmente el mensaje de respuesta, el desarrollo 
  de Servicios Web ser&iacute;a una tarea altamente costosa.</p>

<p>Es m&aacute;s, si se forzase al programador a componer el mensaje SOAP manualmente 
  cada vez que desarrolle un Servicio Web, es muy probable que cometa alg&uacute;n 
  error y no respete exactamente el est&aacute;ndar SOAP. Esto ser&iacute;a un 
  grave problema para la interoperabilidad de los Servicios Web, que es una de 
  las caracter&iacute;sticas que perseguimos con esta tecnolog&iacute;a.</p>

<p>Para evitar estos problemas, utilizaremos librer&iacute;as que nos permitan 
  leer o generar mensajes SOAP para la invocaci&oacute;n de m&eacute;todos remotos 
  (RPC), como es el caso de la API JAX-RPC (o JAX-WS). </p>

<p>Adem&aacute;s, para facilitar a&uacute;n m&aacute;s la tarea de desarrollar 
  Servicios Web, normalmente contaremos con herramientas que a partir de las clases 
  que implementan nuestro servicio generen autom&aacute;ticamente todo el c&oacute;digo 
  necesario para leer el mensaje SOAP de entrada, invocar el m&eacute;todo, escribir 
  el mensaje SOAP de salida, y devolverlo al cliente.</p>

<p>Por lo tanto, nosotros deberemos centrarnos &uacute;nicamente en la tarea de 
  programar la funcionalidad que implementan nuestros servicios, olvid&aacute;ndonos 
  del mecanismo de invocaci&oacute;n de &eacute;stos.</p>

<p>JAX-RPC/WS es una especificaci&oacute;n est&aacute;ndar de Sun Microsystems, pero 
  no todos los servidores de aplicaciones utilizan esta librer&iacute;a para gestionar 
  los Servicios Web. Por ejemplo, es el caso de Weblogic, que define su propia 
  API para implementar los Servicios Web.</p>


<a name="N10024"></a><a name="Arquitectura+de+los+Servicios+Web+orientados+a+RPC"></a>
<h2 class="underlined_10">Arquitectura de los Servicios Web orientados a RPC</h2>
<div class="section">
<p>En las aplicaciones basadas en JAX-RPC/WS encontramos los siguientes elementos:</p>
<ul>
  
<li>
<strong>Servicio</strong>: Elemento del servidor que implementa la funcionalidad 
    de nuestro servicio. Normalmente utilizaremos una clase Java o un EJB.</li>
  
<li>
<strong>Cliente</strong>: Aplicaci&oacute;n cliente que invoca los m&eacute;todos 
    del servicio remoto. La localizaci&oacute;n del servicio ser&aacute; transparente 
    para el desarrollador de esta aplicaci&oacute;n, que invocar&aacute; los m&eacute;todos 
    del servicio de la misma forma que si &eacute;ste fuese local.</li>
  
<li>
<strong>Stub</strong>: Capa en el cliente que implementa la interfaz del 
    servicio, y utiliza internamente JAX-RPC/WS para construir los mensajes SOAP 
    necesarios para invocar cada m&eacute;todo de la interfaz, y para leer el 
    mensaje de respuesta que recibamos. Este <em>stub</em> ser&aacute; el sustituto 
    del servicio en el lado del cliente, la aplicaci&oacute;n cliente ejecutar&aacute; 
    en &eacute;l los m&eacute;todos que ofrece el servicio, haciendo de esta forma 
    transparente la localizaci&oacute;n del servicio para ella.</li>
  
<li>
<strong>Tie</strong>: Capa en el servidor que decodificar&aacute; los mensajes 
    SOAP entrantes con destino a nuestro servicio, y leer&aacute; de ellos el 
    m&eacute;todo que se quiere invocar y los par&aacute;metros de entrada que 
    se proporcionan. Esta capa acceder&aacute; al componente (clase Java o EJB) 
    que implementa nuestro servicio, ejecutando dicho m&eacute;todo en &eacute;l. 
    Una vez obtenido el resultado, generar&aacute; un mensaje SOAP de respuesta 
    y lo devolver&aacute; al cliente. </li>
  
<li>
<strong>JAX-RPC/WS</strong>: Librer&iacute;a que nos permitir&aacute; analizar 
    y componer mensajes SOAP orientados a RPC, y enviarlos a trav&eacute;s de 
    protocolo HTTP. Adem&aacute;s proporciona <em>listeners</em> y <em>servlets</em> 
    que permanecer&aacute;n a la escucha en el servidor para recibir mensajes 
    entrantes de peticiones a los servicios. Una vez recibida una petici&oacute;n, 
    utilizar&aacute; la capa <strong>Tie</strong> del servicio correspondiente 
    para invocarlo, proporcion&aacute;ndole a esta capa el mensaje SOAP entrante. 
    A diferencia de las capas anteriores, que son espec&iacute;ficas para un servicio 
    concreto, la librer&iacute;a JAX-RPC/WS es gen&eacute;rica, nos servir&aacute; 
    para cualquier servicio orientado a RPC.</li>

</ul>
<p>
<img alt="Arquitectura de JAX-RPC" content-width="5cm" height="115" src="imagenes/jaxrpc.gif" width="259"></p>
<p>Las &uacute;nicas capas que debemos implementar nosotros son el <strong>Cliente</strong> 
  y el <strong>Servicio</strong>. En la implementaci&oacute;n de estos componentes 
  el uso de la librer&iacute;a JAX-RPC/WS ser&aacute; totalmente transparente para 
  nosotros. No har&aacute; falta que introduzcamos c&oacute;digo JAX-RPC/WS dentro 
  de ellas. En el servicio simplemente implementaremos los m&eacute;todos que 
  queremos que ofrezca nuestro servicio, como si se tratase de cualquier clase 
  Java, y en el cliente podremos invocar los m&eacute;todos de este servicio como 
  si invoc&aacute;semos directamente los m&eacute;todos de la clase Java.</p>
<p>Las capas <strong>Stub</strong> y <strong>Tie</strong>, son capas construidas 
  a medida para la interfaz de nuestro servicio. Est&aacute;s son las capas que 
  utilizar&aacute;n JAX-RPC/WS para generar y leer los mensajes SOAP que vamos a 
  utilizar para invocar el servicio, y devolver la respuesta al cliente. Generar&aacute;n 
  o ser&aacute;n capaces de leer los mensajes apropiados para el caso concreto 
  de los m&eacute;todos que definimos en nuestro servicio, por lo que deberemos 
  generar estas capas para cada servicio que desarrollemos. Afortunadamente, normalmente 
  contaremos con herramientas que generen de forma autom&aacute;tica estas capas 
  a partir de la interfaz de nuestro servicio, por lo que no ser&aacute; necesario 
  que el desarrollador de servicios trate directamente con JAX-RPC/WS en ning&uacute;n 
  momento.</p>
</div>

<a name="N10070"></a><a name="Tipos+de+datos+compatibles"></a>
<h2 class="underlined_10">Tipos de datos compatibles</h2>
<div class="section">
<p>Vamos a ver los tipos de datos que podemos utilizar cuando trabajamos con JAX-RPC/WS 
  como tipo de los par&aacute;metros y del valor devuelto por los m&eacute;todos 
  de nuestro servicio.</p>
<p>Podremos utilizar cualquiera de los tipos b&aacute;sicos de Java:</p>
<pre class="code">boolean
byte
double
float
int
long
short
char</pre>
<p>Adem&aacute;s, tambi&eacute;n podremos utilizar cualquiera de los <em>wrappers</em> 
  de estos tipos b&aacute;sicos:</p>
<pre class="code">java.lang.Boolean
java.lang.Byte
java.lang.Double
java.lang.Float
java.lang.Integer
java.lang.Long
java.lang.Short
java.lang.Character</pre>
<p>Las siguientes clases de Java tambi&eacute;n son aceptadas como tipos v&aacute;lidos 
  por JAX-RPC/WS:</p>
<pre class="code">java.lang.String
java.math.BigDecimal
java.math.BigInteger
java.util.Calendar
java.util.Date</pre>
<p>Podremos utilizar tambi&eacute;n gran parte de las clases pertenecientes al 
  marco de colecciones de Java:</p>
<pre class="code">
<strong>Listas: List</strong> 
ArrayList 
LinkedList 
Stack 
Vector 
<strong>Mapas: Map</strong> 
HashMap 
Hashtable 
Properties 
TreeMap 
<strong>Conjuntos: Set</strong> 
HashSet 
TreeSet 
</pre>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">JAX-RPC/WS no soporta la utilizaci&oacute;n de gen&eacute;ricos. Es decir, las operaciones podr&aacute;n utilizar
como par&aacute;metros o como respuesta datos de tipo <span class="codefrag">ArrayList</span> pero no <span class="codefrag">ArrayList&lt;String&gt;</span>.</div>
</div>
<p>Adem&aacute;s de estos datos, se permitir&aacute; el uso de <em>arrays</em>, 
  tanto unidimensionales como multidimensionales, cuyos elementos podr&aacute;n 
  ser de cualquiera de los tipos admitidos.</p>
<p>Las clases desarrolladas por nosotros tambi&eacute;n podr&aacute;n ser usadas 
  si cumplen ciertas condiciones:</p>
<ul>
  
<li>Debe tener un constructor p&uacute;blico sin par&aacute;metros.</li>
  
<li>No debe implementar la interfaz RMI <span class="codefrag">javax.rmi.Remote</span>.</li>
  
<li>Todos sus campos deben ser tipos soportados por JAX-RPC/WS. Estos campos pueden 
    ser p&uacute;blicos, protegidos o privados. Para que JAX-RPC/WS sea capaz de 
    leer o establecer los valores de estos campos deber&aacute; cumplirse que: 
    <ul>
      
<li>Los campos p&uacute;blicos no deben ser ni <span class="codefrag">final</span> ni <span class="codefrag">transient</span>.</li>
      
<li>Los campos no p&uacute;blicos deben tener sus correspondientes m&eacute;todos 
        <span class="codefrag">get*</span> y <span class="codefrag">set*</span>. </li>
    
</ul>
  
</li>

</ul>
<p>Si nuestros tipos de datos no cumplen estas caracter&iacute;sticas, o bien 
  estamos trabajando con herramientas que no soportan estos tipos, deberemos construir 
  manualmente serializadores y deserializadores para nuestras clases. Su funci&oacute;n 
  ser&aacute; realizar la conversi&oacute;n entre nuestra clase Java y su correspondiente 
  formato como documento XML.</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Para que se generen autom&aacute;ticamente los artefactos que permitan tratar nuestros tipos de datos propios, 
estos deben quedar expuestos en la interfaz del servicio (par&aacute;metros o resultados de los m&eacute;todos). Es por lo tanto
recomendable utilizar <em>arrays</em> en lugar de listas (por ejemplo <span class="codefrag">Articulo []</span> en lugar de 
<span class="codefrag">ArrayList</span>), ya que de esta manera se especifica de forma expl&iacute;cita el tipo de datos utilizado.</div>
</div>
</div>



<a name="N100E6"></a><a name="Implementaci%C3%B3n+del+servicio%3A+Fichero+JWS"></a>
<h2 class="underlined_10">Implementaci&oacute;n del servicio: Fichero JWS</h2>
<div class="section">
<p>Para implementar los servicios deberemos crear una clase <em>JWS</em>, que consiste en una 
clase Java con anotaciones de la API <em>Web Services Metadata for the Java Platform</em> 
(JSR-181). Parte de los m&eacute;todos de esta clase se ofrecer&aacute;n como operaciones del servicio web.
Para poder ofrecer los m&eacute;todos de esta clase como servicio web deberemos
generar las capas vistas anteriormente. Para ello contaremos con diferentes herramientas,
que depender&aacute;n de la plataforma de desarrollo que utilizamos. Posteriormente 
veremos tanto las herramientas incluidas en JDK 1.6 como las herramientas de Weblogic.</p>
<p>La API <em>Web Services 
Metadata for the Java Platform</em> viene a estandarizar la forma en la que se definen 
los Servicios Web en Java. Anteriormente, cada plataforma defin&iacute;a su propia forma de 
crear servicios web, por lo que, por ejemplo, un servicio web desarrollado con el JWSDP 
de Sun no pod&iacute;a desplegarse directamente en Weblogic. Adem&aacute;s, el fichero JWS contendr&aacute; 
toda la informaci&oacute;n necesaria para generar el servicio, 
por lo que no har&aacute; falta tener la informaci&oacute;n sobre el servicio dispersa en diferentes 
ficheros como ocurr&iacute;a antes. </p>
<p>Para crear la clase JWS que implemente el servicio deberemos crear una clase con 
  un constructor sin par&aacute;metros (si no se crea ning&uacute;n constructor por defecto la 
  clase tendr&aacute; un constructor sin par&aacute;metros vac&iacute;o), y con al menos la anotaci&oacute;n 
  <span class="codefrag">@WebService</span>. Los m&eacute;todos p&uacute;blicos que definamos 
  en esta clase ser&aacute;n por defecto las operaciones que ofrecer&aacute; el 
  servicio aunque, como veremos m&aacute;s adelante, tambi&eacute;n podemos especificar mediante 
  anotaciones los m&eacute;todos que queremos que se publiquen como servicio. 
  Por ejemplo, podemos implementar nuestro servicio como:</p>
<pre class="code">package es.ua.jtech.servcweb.conversion;

import javax.jws.WebService;

<strong>@WebService</strong>
public class ConversionSW { 
  public int euro2ptas(double euro) {	   
    return (int) (euro * 166.386); 
  } 

  public double ptas2euro(int ptas) { 
    return ((double) ptas) / 166.386; 
  }
}</pre>
<p>Con esto habremos implementado la funcionalidad del servicio como una clase 
  Java ordinaria, sin necesitar tener conocimientos de ninguna librer&iacute;a 
  adicional.</p>
<a name="N1010B"></a><a name="Anotaciones"></a>
<h3 class="underlined_5">Anotaciones</h3>
<p>Podemos especificar la forma en la que se crea el servicio mediante diferentes anotaciones. Las principales anotaciones disponibles son:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebService</span></td>
<td colspan="2" rowspan="1">Indica que la clase define un servicio web. Se pueden especificar como par&aacute;metros los nombres del servicio, del puerto, y de su espacio de nombres, que figurar&aacute;n en el documento WSDL del servicio:

<pre class="code">@WebService(name="ConversionPortType", 
    serviceName="ConversionService",
    targetNamespace="http://jtech.ua.es")</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@SOAPBinding</span></td>
<td colspan="2" rowspan="1">Permite especificar el estilo y la codificaci&oacute;n de los mensajes SOAP utilizados para invocar el servicio. Por ejemplo:
<pre class="code">@SOAPBinding(style=SOAPBinding.Style.DOCUMENT,
    use=SOAPBinding.Use.LITERAL,
    parameterStyle=
      SOAPBinding.ParameterStyle.WRAPPED)</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebMethod</span></td>
<td colspan="2" rowspan="1">Indica que un determinado m&eacute;todo debe ser publicado como operaci&oacute;n del servicio. Si no se indica para ning&uacute;n m&eacute;todo, se considerar&aacute; que deben ser publicados todos los m&eacute;todos p&uacute;blicos. Si no, s&oacute;lo se publicar&aacute;n los m&eacute;todos indicados. Adem&aacute;s, de forma opcional se puede indicar como par&aacute;metro el nombre con el que queramos que aparezca la operaci&oacute;n en el documento WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
public int euro2ptas(double euros) {
   ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@Oneway</span></td>
<td colspan="2" rowspan="1">Indica que la llamada a la operaci&oacute;n no debe esperar ninguna respuesta. Esto s&oacute;lo lo podremos hacer con m&eacute;todos que devuelvan <span class="codefrag">void</span>. Por ejemplo:
<pre class="code">@Oneway()
@WebMethod()
public void publicarMensaje(String mensaje) {
   ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebParam</span></td>
<td colspan="2" rowspan="1">Permite indicar el nombre que recibir&aacute;n los par&aacute;metros en el fichero WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
public int euro2ptas(
  @WebParam(name="CantidadEuros",
            targetNamespace="http://jtech.ua.es")
  double euros) {
    ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebResult</span></td>
<td colspan="2" rowspan="1">Permite indicar el nombre que recibir&aacute; el mensaje de respuesta en el fichero WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
@WebResult(name="ResultadoPtas",
    targetNamespace="http://jtech.ua.es")
public int euro2ptas(double euros) {
    ...
}</pre>

</td>

</tr>

</table>
<a name="N10192"></a><a name="Estilo+y+codificaci%C3%B3n+del+servicio"></a>
<h3 class="underlined_5">Estilo y codificaci&oacute;n del servicio</h3>
<p>Hemos visto que mediante la anotaci&oacute;n <span class="codefrag">@SOAPBinding</span> podemos cambiar el estilo 
y la codificaci&oacute;n del servicio. Los posibles estilos son:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.Style.RPC</span>: Se utilizan mensajes SOAP orientados a RPC, en los que 
se codifican en XML las llamadas a m&eacute;todos remotos.</li>

<li>
<span class="codefrag">SOAPBinding.Style.DOCUMENT</span>: Se utilizan mensajes SOAP orientados al documento. 
Dado que en estos mensajes se puede incluir cualquier tipo de documento XML, tambi&eacute;n se pueden 
utilizar para invocar operaciones de servicios.</li>

</ul>
<p>Podemos especificar tambi&eacute;n la codificaci&oacute;n:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.Use.LITERAL</span>: Esta es la &uacute;nica codificaci&oacute;n aceptada en el WS-I 
Basic Profile (BP), que da soporte a los servicios de tipo <em>document/literal</em> y 
<em>RPC/literal</em>.</li>

<li>
<span class="codefrag">SOAPBinding.Use.ENCODED</span>: Se trata de una codificaci&oacute;n que permite representar 
una mayor variedad de estructuras de datos que la anterior, pero est&aacute; desaprobada por el 
BP por ser la causa de gran cantidad de incompatibilidades entre servicios. De hecho JAX-WS 
es incompatible con los servicios de este tipo. Esta codificaci&oacute;n se suele utilizar con 
servicios de tipo RPC, dando lugar al tipo <em>RPC/encoded</em>.</li>

</ul>
<p>En el caso de los servicios de tipo <em>document/literal</em>, tambi&eacute;n podemos especificar 
la forma en la que se representan los tipos de datos de los par&aacute;metros de las operaciones:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.ParameterStyle.BARE</span>: Los par&aacute;metros se pasan directamente.</li>

<li>
<span class="codefrag">SOAPBinding.ParameterStyle.WRAPPED</span>: Los par&aacute;metros se pasan envueltos en 
tipos de datos complejos.</li>

</ul>
<p>Por defecto los servicios ser&aacute;n del tipo <em>document/literal/wrapped</em>.</p>
<a name="N101DE"></a><a name="Tratamiento+de+errores"></a>
<h3 class="underlined_5">Tratamiento de errores</h3>
<p>Cuando se produzca un error en nuestro servicio, podemos lanzar una excepci&oacute;n de tipo 
<span class="codefrag">SOAPFaultException</span> para notificar al cliente del error producido. Al lanzar
esta excepci&oacute;n se devolver&aacute; al cliente un mensaje <em>SOAP Fault</em>. Podemos 
lanzar esta excepci&oacute;n de la siguiente forma:</p>
<pre class="code">package es.ua.jtech.servcweb.conversion;

import javax.jws.WebMethod;
import javax.jws.WebService;
import javax.xml.namespace.QName;
import javax.xml.rpc.soap.SOAPFaultException;
import javax.xml.soap.Detail;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPFactory;

@WebService
public class ConversionSW {

  @WebMethod
  public int euro2ptas(double euro) {	   
    if(euro&lt;0) {
      lanzarExcepcion("La cantidad de euros debe ser positiva");
    }
    return (int) (euro * 166.386); 
  } 

  @WebMethod
  public double ptas2euro(int ptas) { 
    if(ptas&lt;0) {
      lanzarExcepcion("La cantidad de ptas debe ser positiva");
    }
    return ((double) ptas) / 166.386; 
  }

  private void <strong>lanzarExcepcion</strong>(String mensaje) {
    Detail detail = null;

    try {
      SOAPFactory soapFactory = SOAPFactory.newInstance();
      detail = soapFactory.createDetail();
    } catch (SOAPException e) { }

    QName faultCode = null;
    String faultString = mensaje;
    String faultActor = "Servicio Conversion";
    throw new SOAPFaultException(faultCode, faultString, 
                                 faultActor, detail);
  }
}</pre>
</div>



<a name="N101F6"></a><a name="Compilaci%C3%B3n+del+fichero+JWS"></a>
<h2 class="underlined_10">Compilaci&oacute;n del fichero JWS</h2>
<div class="section">
<p>Para generar y desplegar el servicio no basta con compilar la clase JWS, sino que deberemos
utilizar herramientas espec&iacute;ficas para generar las capas necesarias para ofrecer
los m&eacute;todos de la clase como servicio web. Veremos tanto las herramientas disponibles en
JDK a partir de la versi&oacute;n 1.6, como las herramientas ofrecidas por la plataforma Weblogic. 
Posteriormente veremos como crear los servicios web de forma visual con BEA Workshop.</p>
<a name="N101FF"></a><a name="Compilaci%C3%B3n+del+servicio+con+JDK+1.6"></a>
<h3 class="underlined_5">Compilaci&oacute;n del servicio con JDK 1.6</h3>
<p>Igual que en el caso de los clientes de servicios web, a partir de la versi&oacute;n 1.6
de JDK se incluyen herramientas para generar servicios web. Concretamente la 
herramienta que se utilizar&aacute; para generar el servicio es <span class="codefrag">wsgen</span>, que al 
igual que <span class="codefrag">wsimport</span> se podr&aacute; utilizar tanto en l&iacute;nea de comando como en 
forma de tarea de ant.</p>
<p>Lo primero que deberemos hacer es compilar la clase que implementa el servicio
(fichero JWS) al igual que cualquier otra clase Java, con la herramienta <span class="codefrag">javac</span>. 
Una vez hecho esto, generaremos el servicio con <span class="codefrag">wsgen</span> a partir de la 
clase compilada. Utilizaremos <span class="codefrag">wsgen</span> de la siguiente forma:</p>
<pre class="code">
<strong>wsgen -cp</strong> <em>&lt;classpath&gt;</em> <strong>-s</strong> <em>&lt;src.dir&gt;</em> <strong>-d</strong> <em>&lt;dest.dir&gt;</em> 
      <em>&lt;nombre.clase.servicio&gt;</em>
</pre>
<p>La clase que implementa el servicio (<span class="codefrag">&lt;nombre.clase.servicio&gt;</span>) 
se especificar&aacute; mediante su nombre completo, es decir, incluyendo el nombre del 
paquete al que pertenece. Podemos proporcionar 
otros par&aacute;metros para indicar la forma en la que se deben generar las clases, 
como el directorio donde queremos que guarde los fuentes de las clases generadas 
(<span class="codefrag">&lt;src.dir&gt;</span>), el directorio donde guardar&aacute; estas clases compiladas 
(<span class="codefrag">&lt;dest.dir&gt;</span>), y el <span class="codefrag">classpath</span>, en el que deber&aacute; 
encontrarse la clase especificada.</p>
<p>En el caso concreto del servicio <span class="codefrag">ConversionSW</span> definido anteriormente, 
podr&iacute;amos generar las clases necesarias (despu&eacute;s de haber compilado la clase 
<span class="codefrag">ConversionSW</span>) de la siguiente forma:</p>
<pre class="code">
<strong>wsgen -cp</strong> bin <strong>-s</strong> src <strong>-d</strong> bin 
      es.ua.jtech.servcweb.conversion.ConversionSW</pre>
<p>Tambi&eacute;n podr&iacute;amos utilizar la versi&oacute;n de ant de esta herramienta. Para ello deberemos
declarar previamente la tarea <span class="codefrag">wsgen</span> (teniendo la librer&iacute;a 
<span class="codefrag">jaxws-tools.jar</span> dentro del <span class="codefrag">CLASSPATH</span> de ant):</p>
<pre class="code">&lt;taskdef name="<strong>wsgen</strong>" classname="<strong>com.sun.tools.ws.ant.WsGen</strong>"/&gt;</pre>
<p>Una vez declarada se podr&aacute; utilizar de la siguiente forma:</p>
<pre class="code">&lt;<strong>wsgen classpath</strong>="${bin.home}" 
       <strong>sei</strong>="${service.class.name}" 
       <strong>sourcedestdir</strong>="${src.home}" 
       <strong>destdir</strong>="${bin.home}" /&gt;</pre>
<p>Con esto habremos creado las clases necesarias para publicar el servicio. Con JDK 1.6
no ser&aacute; necesario contar con un servidor de aplicaciones para publicar este servicio, 
sino que lo podremos publicar desde cualquier aplicaci&oacute;n Java. Podemos publicar
el servicio de la siguiente forma:</p>
<pre class="code">package es.ua.jtech.servcweb;

import javax.xml.ws.Endpoint;
import es.ua.jtech.servcweb.conversion.ConversionSW;

public class Servicio {
  public static void main(String[] args) {
    <strong>Endpoint.publish</strong>(
      "http://localhost:8080/ServicioWeb/Conversion",
      new ConversionSW());
  }
}</pre>
<p>Cuando ejecutemos la aplicaci&oacute;n, podremos acceder al WSDL del servicio a trav&eacute;s de 
cualquier navegador en la siguiente direcci&oacute;n:</p>
<pre class="code">http://localhost:8080/ServicioWeb/Conversion?WSDL</pre>
<a name="N10290"></a><a name="Compilaci%C3%B3n+del+servicio+con+Weblogic"></a>
<h3 class="underlined_5">Compilaci&oacute;n del servicio con Weblogic</h3>
<p>Weblogic nos proporciona herramientas para generar 
  las capas necesarias para construir y desplegar nuestros Servicios Web. </p>
<p>Una vez escrito el fichero JWS, deberemos compilar esta clase mediante la 
herramienta <span class="codefrag">jwsc</span> de Weblogic. Podemos utilizar esta herramienta como 
tarea de ant. Para ello primero deberemos introducir la librer&iacute;a 
<span class="codefrag">weblogic.jar</span> (que se encuentra en el directorio <span class="codefrag">WL_HOME/server/lib</span>)
en el <span class="codefrag">CLASSPATH</span> de ant. Una vez hecho esto, declararemos la tarea 
<span class="codefrag">jwsc</span> en nuestro <em>buildfile</em>:</p>
<pre class="code">&lt;taskdef name="jwsc" 
         classname="weblogic.wsee.tools.anttasks.JwscTask"/&gt;</pre>
<p>Utilizaremos esta tarea para compilar el servicio de la siguiente forma:</p>
<pre class="code">&lt;<strong>jwsc</strong> srcdir="${src.home}" destdir="${ear.home}"&gt;
  &lt;<strong>jws</strong> file="${jws.file}"/&gt;
&lt;/<strong>jwsc</strong>&gt;</pre>
<p>Donde:</p>
<ul>

<li>
<span class="codefrag">srcdir</span> es el directorio en el que se encuentran los fuentes de nuestro 
servicio (el fichero JWS).</li>

<li>
<span class="codefrag">destdir</span> es el directorio en el que se generar&aacute; el EAR con el servicio, 
listo para ser desplegado en Weblogic, bien mediante la consola de administraci&oacute;n o 
mediante la tarea <span class="codefrag">wldeploy</span>.</li>

<li>
<span class="codefrag">file</span> es el nombre del fichero JWS, del que se debe indicar la ruta 
relativa al directorio en el que est&aacute; dicho fichero respecto al 
directorio de fuentes especificado (por ejemplo 
<span class="codefrag">es/ua/jtech/servcweb/conversion/ConversionSW.java</span>).</li>

</ul>
<p>Una vez ejecutemos esta tarea, si no se producen errores de compilaci&oacute;n tendremos el 
servicio generado en <span class="codefrag">destdir</span>, con la estructura completa de la aplicaci&oacute;n 
EAR que puede desplegarse directamente en Weblogic. Si nuestro servicio necesita 
clases (o ficheros) adicionales para poder ejecutarse, &eacute;stas se pueden incluir en 
el subdirectorio <span class="codefrag">APP-INF/classes</span> del directorio donde se ha generado el 
EAR. El contenido de este directorio ser&aacute; compartido por todos los componentes de 
la aplicaci&oacute;n que se despliega con el EAR.</p>
<p>Una vez desplegado, podremos acceder al documento WSDL que describe el servicio en 
  la siguiente direcci&oacute;n:</p>
<pre class="code">http://localhost:7001/&lt;<em>nombre del servicio</em>&gt;/&lt;<em>nombre del servicio</em>&gt;?WSDL</pre>
<p>En el caso concreto de nuestro ejemplo esta direcci&oacute;n ser&iacute;a:</p>
<pre class="code">http://localhost:7001/Conversion/Conversion?WSDL</pre>
<a name="N102FA"></a><a name="Crear+un+servicio+partiendo+de+un+documento+WSDL"></a>
<h4>Crear un servicio partiendo de un documento WSDL</h4>
<p>En ocasiones nos puede interesar crear un servicio a partir de un documento WSDL, para forzarlo a que cumpla una determinada interfaz y as&iacute; asegurarnos la compatibilidad del servicio. Weblogic incorpora una tarea que nos permite hacer esto, generando el fichero <em>JWS</em> y los tipos de datos Java necesarios a partir de un documento WSDL. Esta tarea es <span class="codefrag">wsdlc</span>.</p>
<p>Para utilizar la tarea de ant <span class="codefrag">wsdlc</span>, primero deberemos declararla en nuestro <em>buildfile</em>:</p>
<pre class="code">&lt;taskdef name="<strong>wsdlc</strong>"
         classname="<strong>weblogic.wsee.tools.anttasks.WsdlcTask</strong>"/&gt;</pre>
<p>Una vez declarada, podremos generar los ficheros <em>JWS</em> para implementar nuestro servicio de la siguiente forma:</p>
<pre class="code">&lt;<strong>wsdlc srcWsdl</strong>="${wsdl}"
       <strong>destJwsDir</strong>="${lib.home}"
       <strong>destImplDir</strong>="${src.home}"
       <strong>packageName</strong>="${package.name}" /&gt;</pre>
<p>Donde:</p>
<ul>

<li>
<span class="codefrag">srcWsdl</span>: Indica el documento WSDL a partir del cual se generar&aacute; el servicio.</li>

<li>
<span class="codefrag">destJwsDir</span>: Indicar el directorio en el cual se generar&aacute; la librer&iacute;a con los tipos de datos necesarios para invocar el servicio. Esta librer&iacute;a se generar&aacute; en un fichero JAR con nombre <em><span class="codefrag">${wsdl}</span></em><span class="codefrag">_wsdl.jar</span>.</li>

<li>
<span class="codefrag">destImplDir</span>: Ser&aacute; el directorio donde se generar&aacute; la plantilla del fichero JWS, que tomar&aacute; el nombre <em><span class="codefrag">PortType</span></em><span class="codefrag">Impl.java</span> (donde <em><span class="codefrag">PortType</span></em> es el nombre del tipo de puerto que aparece en el documento WSDL). Este fichero ser&aacute; el que deberemos modificar para implementar en &eacute;l el servicio.</li>

<li>
<span class="codefrag">packageName</span>: Nombre del paquete en el que se generar&aacute;n las clases anteriores. Si no se especifica este dato, se obtendr&aacute; un nombre de paquete a partir del espacio de nombres especificado en el documento WSDL.</li>

</ul>
<p>Una vez ejecutada esta tarea, deberemos incluir el c&oacute;digo necesario en el fichero <em>JWS</em> generado para implementar las operaciones del servicio. Cuando est&eacute; implementado, utilizaremos la tarea <span class="codefrag">jwsc</span> para generar el servicio, igual que en los casos anteriores.</p>
<a name="N10366"></a><a name="Crear+un+servicio+que+invoque+otro+servicio"></a>
<h4>Crear un servicio que invoque otro servicio</h4>
<p>Cuando queramos crear un servicio web que invoque otro servicio web ser&aacute; necesario
que nuestro servicio contenga el <em>stub</em> que da acceso al servicio web que
vamos a utilizar. Para hacer esto podemos anidar una etiqueta <span class="codefrag">clientgen</span> 
(como la vista en la secci&oacute;n anterior para crear los clientes) dentro de la etiqueta
<span class="codefrag">jws</span> que define nuestro servicio:</p>
<pre class="code">&lt;jwsc srcdir="${src.home}" destdir="${ear.home}"&gt;
  &lt;jws file="${jws.file}"&gt;
    &lt;<strong>clientgen</strong> wsdl="${wsdl.url}" packageName="${pkg.name}" /&gt;
  &lt;/jws&gt;
&lt;/jwsc&gt;</pre>
<a name="N10380"></a><a name="Probar+los+servicios"></a>
<h4>Probar los servicios</h4>
<p>Una vez desplegados los servicios, podremos probarlos mediante un cliente web gen&eacute;rico del que disponemos en Weblogic (<em>Weblogic Test Client</em>). Podemos acceder a este cliente en la siguiente direcci&oacute;n:</p>
<pre class="code">http://localhost:7001/<strong>wls_utc</strong>
</pre>
<p>Aqu&iacute; deberemos introducir la direcci&oacute;n del documento WSDL del servicio a probar. Una vez hecho esto nos aparecer&aacute; la lista de operaciones que ofrece y una serie de formularios HTML para probarlas.</p>
</div>



<a name="N10398"></a><a name="Creaci%C3%B3n+de+servicios+web+con+BEA+Workshop"></a>
<h2 class="underlined_10">Creaci&oacute;n de servicios web con BEA Workshop</h2>
<div class="section">
<p>A parte de las herramientas vistas anteriormente, normalmente los diferentes IDEs (BEA Workshop, Eclipse, Netbeans, etc)
nos permiten crear servicios web de forma sencilla, mediante asistentes y de forma visual en muchos casos. Vamos
a ver a continuaci&oacute;n c&oacute;mo crear servicios web paso a paso utilizando BEA Workshop.</p>
<p>Los servicios web creados con BEA Workshop utilizar&aacute;n en muchos casos una serie de librer&iacute;as espec&iacute;ficas 
(como es el caso de los controles Beehive) de las que este entorno se sirve para poder crear los servicios
de forma visual. Para que estos proyectos funcionen correctamente en Weblogic, deberemos crear un dominio
que incluya dichas librer&iacute;as. Para ello, en el asistente de creaci&oacute;n del dominio deberemos marcar la casilla
<em>Workshop for WebLogic Platform</em>:</p>
<p>
<img alt="Configuraci&oacute;n del dominio." content-width="10cm" height="358" src="http://www.jtech.ua.es/j2ee/2006-2007/restringido/servc-web/imagenes/sesion2/dominio-workshop.gif" width="500"></p>
<p>Vamos a seguir el ejemplo del servicio web de conversi&oacute;n (de euros a ptas y viceversa) visto en los puntos
anteriores para ilustrar el procedimiento que utilizaremos en BEA Workshop para crear un servicio web. 
Seguiremos los siguiente pasos:</p>
<ol>

<li>Lo primero que haremos ser&aacute; crear un nuevo proyecto en BEA Workshop. Normalmente este proyecto ser&aacute; incluido
en el EAR de nuestra aplicaci&oacute;n, aunque para el caso de nuestro ejemplo lo crearemos como proyecto independiente.

<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 1." content-width="10cm" height="147" src="imagenes/sesion2/wl-sw-1.gif" width="494"></p>


</li>

<li>Como tipo de proyecto seleccionaremos <em>Web Service Project</em>, dentro del apartado <em>Web Services</em>.

<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 2." content-width="7cm" height="420" src="imagenes/sesion2/wl-sw-2.gif" width="356"></p>


</li>

<li>Daremos un nombre al proyecto y dejaremos el resto de opciones con sus valores por defecto.

<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 3." content-width="9cm" height="391" src="imagenes/sesion2/wl-sw-3.gif" width="432"></p>


</li>

<li>Deberemos crear en el directorio de fuentes el paquete que contendr&aacute; la implementaci&oacute;n de nuestro servicio, 
y sobre &eacute;l crear un nuevo <em>WebLogic Web Service</em>.

<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 4." content-width="10cm" height="259" src="imagenes/sesion2/wl-sw-4.gif" width="500"></p>


</li>

<li>Damos nombre al servicio web (este ser&aacute; el nombre de la clase que implementar&aacute; el servicio).
<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 5." content-width="7cm" height="454" src="imagenes/sesion2/wl-sw-5.gif" width="343"></p>


</li>

<li>Veremos las operaciones del servicio de forma visual. Por defecto crea una operaci&oacute;n <span class="codefrag">hello</span>.
<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 6." content-width="10cm" height="220" src="imagenes/sesion2/wl-sw-6.gif" width="500"></p>


</li>

<li>Podemos modificar estas operaciones pulsando sobre ellas con el bot&oacute;n derecho del rat&oacute;n. Pulsamos sobre la 
operaci&oacute;n <span class="codefrag">hello</span> y seleccionamos <em>Edit signature</em> para cambiar la interfaz de la operaci&oacute;n.
En lugar de <span class="codefrag">void hello()</span> pondremos <span class="codefrag">int euro2ptas(double euros)</span>.
<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 7." content-width="7cm" height="407" src="imagenes/sesion2/wl-sw-7.gif" width="343"></p>


</li>

<li>Al cambiar la interfaz de la operaci&oacute;n aparecer&aacute; un error, porque espera que devuelva un valor <span class="codefrag">int</span>
y por el momento no hemos implementado dicha funci&oacute;n. Pincharemos con el bot&oacute;n derecho sobre la operaci&oacute;n y 
seleccionaremos <em>Edit source</em> para modificar el c&oacute;digo fuente y a&ntilde;adir el comportamiento correspondiente.
<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 8." content-width="7cm" height="405" src="imagenes/sesion2/wl-sw-8.gif" width="357"></p>


</li>

<li>Introducimos el c&oacute;digo fuente dentro de la funci&oacute;n.
<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 9." content-width="10cm" height="237" src="imagenes/sesion2/wl-sw-9.gif" width="503"></p>


</li>

<li>Vamos a a&ntilde;adir una nueva operaci&oacute;n al servicio, para ello volvemos a la vista de dise&ntilde;o y pulsamos con el bot&oacute;n
derecho sobre el fondo. Seleccionamos la opci&oacute;n <em>New Web Method</em> y creamos una nueva operaci&oacute;n
<span class="codefrag">double ptas2euro(int ptas)</span>. Repetimos los pasos 8 y 9 para introducir el c&oacute;digo fuente de esta nueva
operaci&oacute;n.
<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 10." content-width="7cm" height="412" src="imagenes/sesion2/wl-sw-10.gif" width="353"></p>


</li>

<li>Podemos probar las operaciones de nuestro servicio pulsando sobre ellas (o sobre el propio servicio) con
el bot&oacute;n derecho del rat&oacute;n y seleccionando <em>Run As &gt; Run on Server</em>. Esto pondr&aacute; en marcha el servidor 
WebLogic y desplegar&aacute; en &eacute;l los servicios implementados (deberemos utilizar un dominio preparado para Workshop).
<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 11." content-width="10cm" height="402" src="imagenes/sesion2/wl-sw-11.gif" width="500"></p>


</li>

<li>Una vez iniciado el servidor y desplegados los servicios autom&aacute;ticamente se abrir&aacute; el cliente de prueba
de WebLogic (<em>Weblogic Test Client</em>) visto anteriormente para probar dichos servicios. En &eacute;l podremos 
especificar los par&aacute;metros que tomar&aacute;n las operaciones e invocarlas. Veremos el resultado obtenido y los mensajes
SOAP de petici&oacute;n y respuesta utilizados para la invocaci&oacute;n.
<p>
<img alt="Creaci&oacute;n de servicios web con Weblogic. Paso 12." content-width="10cm" height="322" src="imagenes/sesion2/wl-sw-12.gif" width="500"></p>


</li>

</ol>
<a name="N10463"></a><a name="Invocaci%C3%B3n+de+servicios+desde+dentro+de+otro+servicio"></a>
<h3 class="underlined_5">Invocaci&oacute;n de servicios desde dentro de otro servicio</h3>
<p>Si queremos invocar un servicio desde dentro de otro servicio podr&iacute;amos crear un 
<em>stub</em> como vimos en el tema anterior e incluir dicha librer&iacute;a dentro de
nuestro proyecto de servicio web, o en un proyecto de utilidad asociado a nuestro 
proyecto. De esta misma forma tambi&eacute;n podr&iacute;amos invocar servicios web desde dentro
de otros componentes como por ejemplo aplicaciones web o EJBs.</p>
<p>Sin embargo, en BEA Workshop existe la posibilidad de crear estos clientes de servicios
de forma visual en forma de controles Beehive, concretamente se utilizar&aacute;n controles
para acceso a servicios (<em>service controls</em>). Estos controles podr&aacute;n ser utilizados
desde dentro de otros servicios web o en flujos de p&aacute;ginas de aplicaciones web
(<em>Page Flows</em>).</p>
<p>A continuaci&oacute;n veremos como crear paso a paso un servicio web que invoque otro 
servicio de forma visual mediante BEA Workshop. Para este ejemplo ampliaremos el servicio
web de conversi&oacute;n monetaria visto en el punto anterior, a&ntilde;adiendo operaciones para
convertir entre euros y d&oacute;lares. Dado que la tasa de cambio entre estas dos monedas
var&iacute;a con el tiempo, ser&aacute; necesario recurrir a un servicio web externo para obtener
la tasa de cambio actual entre dichas monedas.</p>
<p>Partiendo del servicio web del caso anterior, realizaremos los siguientes pasos para
a&ntilde;adir las nuevas operaciones y los controles para acceder al servicio web de cambio
monetario:</p>
<ol>

<li>Lo primero que deberemos hacer es crear un nuevo paquete en el que crearemos los
controles que actuaran como cliente de los servicios web externos que vamos a invocar
(en nuestro caso utilizaremos el servicio <em>CurrencyExchangeService</em>). Dentro de 
este paquete copiaremos el documento WSDL que define dicho servicio, y crearemos un 
nuevo <em>Service Control</em> a partir de dicha especificaci&oacute;n.

<p>
<img alt="Creaci&oacute;n de controles para invocar servicios. Paso 1." content-width="10cm" height="349" src="imagenes/sesion2/wl-control-1.gif" width="500"></p>


</li>

<li>En el asistente para crear el <em>Service Control</em> seleccionaremos el documento
WSDL que hemos a&ntilde;adido al proyecto en el paso anterior.

<p>
<img alt="Creaci&oacute;n de controles para invocar servicios. Paso 2." content-width="9cm" height="416" src="imagenes/sesion2/wl-control-2.gif" width="465"></p>


</li>

<li>A continuaci&oacute;n nos pide que indiquemos el nombre de la clase correspondiente al
control. Podemos dejar el nombre que aparece por defecto, que se crear&aacute; dentro del
mismo paquete en el que tenemos el documento WSDL.

<p>
<img alt="Creaci&oacute;n de controles para invocar servicios. Paso 3." content-width="9cm" height="488" src="imagenes/sesion2/wl-control-3.gif" width="420"></p>


</li>

<li>Una vez creado el control, podemos a&ntilde;adirlo dentro de nuestro servicio. Para ello
iremos a la vista de dise&ntilde;o del servicio de conversi&oacute;n, pulsaremos sobre el fondo con
el bot&oacute;n derecho del rat&oacute;n y seleccionaremos la opci&oacute;n <em>New Control Reference ...</em>.

<p>
<img alt="Creaci&oacute;n de controles para invocar servicios. Paso 4." content-width="8cm" height="421" src="imagenes/sesion2/wl-control-4.gif" width="390"></p>


</li>

<li>En la ventana de selecci&oacute;n de controles seleccionaremos el control creado anteriormente
que nos dar&aacute; acceso del servicio <em>CurrencyExchangeService</em>.

<p>
<img alt="Creaci&oacute;n de controles para invocar servicios. Paso 5." content-width="7cm" height="341" src="imagenes/sesion2/wl-control-5.gif" width="347"></p>


</li>

<li>A la derecha de la vista de dise&ntilde;o del servicio aparecer&aacute; el control que acabamos
de a&ntilde;adir con todos los m&eacute;todos que ofrece. Entre estos m&eacute;todos estar&aacute;n las operaciones
del servicio al que represente. En este caso, la operaci&oacute;n que ofrece el servicio es
<span class="codefrag">getRate</span>. Pulsaremos sobre el bot&oacute;n derecho sobre esta operaci&oacute;n y 
seleccionaremos la opci&oacute;n <em>Generate Delegate Method</em> para que genere en nuestro
servicio un m&eacute;todo que invoque dicha operaci&oacute;n en el servicio remoto.

<p>
<img alt="Creaci&oacute;n de controles para invocar servicios. Paso 6." content-width="10cm" height="422" src="imagenes/sesion2/wl-control-6.gif" width="500"></p>


</li>

<li>Con esto se a&ntilde;adir&aacute; a la interfaz de nuestro servicio una nueva operaci&oacute;n 
<span class="codefrag">getRate</span> que &uacute;nicamente llamar&aacute; a esa misma operaci&oacute;n en el servicio 
remoto y nos devolver&aacute; el resultado obtenido. Podemos fijarnos en el c&oacute;digo fuente
de dicha funci&oacute;n para ver c&oacute;mo se invoca el servicio remoto a trav&eacute;s del control.

<p>
<img alt="Creaci&oacute;n de controles para invocar servicios. Paso 7." content-width="10cm" height="410" src="imagenes/sesion2/wl-control-7.gif" width="500"></p>


</li>

<li>A&ntilde;adiremos las operaciones <span class="codefrag">euro2dolar</span> y <span class="codefrag">dolar2euro</span> de 
la misma forma que a&ntilde;adimos las operaciones <span class="codefrag">euro2ptas</span> y <span class="codefrag">ptas2euro</span>.
Dentro del c&oacute;digo de estas operaciones invocaremos el servicio remoto para obtener la
tasa de cambio entre d&oacute;lares y euros y as&iacute; poder convertir de forma adecuada la cantidad
que se nos proporcione. El c&oacute;digo completo del servicio quedar&aacute; como se muestra a 
continuaci&oacute;n:

<pre class="code">package es.ua.jtech.servcweb.conversion;

import javax.jws.*;
import org.apache.beehive.controls.api.bean.Control;
import es.ua.jtech.servcweb.controles.CurrencyExchangeServiceControl;

@WebService
public class ConversionSW {

  @Control
  private CurrencyExchangeServiceControl 
                        currencyExchangeServiceControl;

  @WebMethod
  public int euro2ptas(double euros) {
    return (int)(euros*166.386);
  }

  @WebMethod
  public double ptas2euro(int ptas) {
    return ptas/166.386;
  }

  @WebMethod
  public float getRate(java.lang.String country1_arg,
                       java.lang.String country2_arg) {
    return currencyExchangeServiceControl.getRate(
                            country1_arg, country2_arg);
  }

  @WebMethod
  public double dolar2euro(double dolar) {
    return currencyExchangeServiceControl.getRate(
                                 "usa", "euro") * dolar;
  }

  @WebMethod
  public double euro2dolar(double euros) {
    return currencyExchangeServiceControl.getRate(
                                 "euro", "usa") * euros;
  }
}</pre>


</li>

</ol>
<p>Los controles se pueden importar de forma visual desde Workshop tanto dentro
de servicios web como en flujos de p&aacute;ginas, pero no en otro tipo de componentes. Si 
queremos utilizar estos controles desde otros componentes, deberemos instanciarlos
manualmente.</p>
<pre class="code">CurrencyExchangeControlServiceBean bean =
      Controls.instantiate(CurrencyExchangeControlServiceBean.class,
                           null,
                           ControlThreadContext.getContext(), null);</pre>
<a name="N10501"></a><a name="Operaciones+as%C3%ADncronas"></a>
<h3 class="underlined_5">Operaciones as&iacute;ncronas</h3>
<p>Hasta el momento hemos visto servicios en los que al invocar una operaci&oacute;n
obtenemos un resultado inmediato (debido al mecanismo s&iacute;ncrono petici&oacute;n-respuesta
del protocolo HTTP sobre el que funcionan dichos servicios). Sin embargo, en un
proceso de negocio podemos encontrar operaciones que no sean inmediatas, o 
incluso que necesiten la supervisi&oacute;n de una persona para poder completarse. Por ejemplo,
en el caso de petici&oacute;n de un pr&eacute;stamo normalmente deber&aacute; haber una persona que lo 
apruebe o lo deniegue, y no se dejar&aacute; que una m&aacute;quina tome dicha decisi&oacute;n. En estos 
casos no se podr&aacute; utilizar este mecanismo s&iacute;ncrono, ya que la respuesta podr&iacute;a tardar
bastante tiempo en llegar. Para solucionar este problema contamos con la posibilidad
de definir operaciones as&iacute;ncronas en nuestros servicios.</p>
<p>La operaciones as&iacute;ncronas (<em>oneway</em>) devolver&aacute;n el control inmediatamente
al llamador, sin producir ning&uacute;n resultado. El resultado se proporcionar&aacute; 
posteriormente mediante un <em>callback</em>. Podemos hacer una analog&iacute;a con un servicio
de informaci&oacute;n telef&oacute;nica, en el que si llamamos solicitando un n&uacute;mero y no tienen
la informaci&oacute;n, para no hacernos esperar demasiado tiempo al tel&eacute;fono pueden colgar, 
buscarla, y devolvernos la llamada (<em>callback</em>) cuando
la encuentren.</p>
<p>Vamos a ver como ejemplo un servicio web sencillo, en el que programamos la recepci&oacute;n
de un mensaje tras un determinado n&uacute;mero de segundos. Seguiremos los siguientes pasos:</p>
<ol>

<li>Creamos un servicio web con una operaci&oacute;n <span class="codefrag">void programa(String mensaje, 
int segundos)</span>. Pulsamos con el bot&oacute;n derecho sobre dicha operaci&oacute;n y seleccionamos
<em>Oneway</em> para marcarla como operaci&oacute;n as&iacute;ncrona, ya que programar&aacute; la recepci&oacute;n
del mensaje pero no devolver&aacute; ning&uacute;n resultado.

<p>
<img alt="Creaci&oacute;n de operaciones as&iacute;ncronas. Paso 1." content-width="9cm" height="413" src="imagenes/sesion2/wl-async-1.gif" width="419"></p>


</li>

<li>Veremos que la operaci&oacute;n aparece ahora con una &uacute;nica flecha, indicando que es 
s&oacute;lo de entrada. Deberemos a&ntilde;adir el <em>callback</em> para devolver el resultado
cuando est&eacute; disponible. Para ello pulsamos con el bot&oacute;n derecho sobre el fondo
y seleccionamos <em>New Callback</em>.

<p>
<img alt="Creaci&oacute;n de operaciones as&iacute;ncronas. Paso 2." content-width="9cm" height="410" src="imagenes/sesion2/wl-async-2.gif" width="424"></p>


</li>

<li>El <em>callback</em> tendr&aacute; como interfaz <span class="codefrag">void enviaRespuesta(String mensaje)</span>. En 
este caso, los datos que se pasan como par&aacute;metro son los que recibir&aacute; el cliente
cuando se devuelva la llamada.

<p>
<img alt="Creaci&oacute;n de operaciones as&iacute;ncronas. Paso 3." content-width="8cm" height="88" src="imagenes/sesion2/wl-async-3.gif" width="380"></p>


</li>

<li>Haremos que la operaci&oacute;n <span class="codefrag">programa</span> programe un temporizador, para que
transcurridos los segundos indicados invoque al <em>callback</em> <span class="codefrag">enviaRespuesta</span>
para devolver el mensaje especificado. El c&oacute;digo fuente completo del servicio quedar&aacute;
como se muestra a continuaci&oacute;n.

<pre class="code">package es.ua.jtech.servcweb.temporizador;

import java.util.Timer;
import java.util.TimerTask;

import javax.jws.*;
import weblogic.jws.CallbackService;
import weblogic.wsee.jws.CallbackInterface;
import weblogic.jws.Callback;

@WebService
public class TemporizadorSW {

  @Callback
  private CallbackSvc callback;

  @WebMethod
  @Oneway()
  public void programa(String mensaje, int segundos) {
    TimerTask tarea = new Temporizador(mensaje);
    Timer timer = new Timer();
    timer.schedule(tarea, segundos * 1000);
  }

  @CallbackService
  public interface CallbackSvc extends CallbackInterface {
    @WebMethod
    public void enviaRespuesta(String mensaje);
  }
	
  class Temporizador extends TimerTask {
    String mensaje;
	
    public Temporizador(String mensaje) {
      this.mensaje = mensaje;
    }
		
    public void run() {
      callback.enviaRespuesta(mensaje);
    }
  }
}</pre>


</li>

<li>Podremos probar este servicio directamente en <em>WebLogic Test Client</em>. En 
principio tendremos &uacute;nicamente disponible la operaci&oacute;n <span class="codefrag">programa</span>. La
invocaremos para programar la recepci&oacute;n de un mensaje en un determinado n&uacute;mero de
segundos.

<p>
<img alt="Creaci&oacute;n de operaciones as&iacute;ncronas. Paso 5." content-width="10cm" height="312" src="imagenes/sesion2/wl-async-6.gif" width="500"></p>


</li>

<li>Si tras esperar el n&uacute;mero de segundos indicado pulsamos sobre <em>Show Operations</em>,
veremos que junto a la operaci&oacute;n invocada anteriormente aparece el <em>callback</em>
que ya est&aacute; disponible. Pulsando sobre el enlace al <em>callback</em> veremos
el resultado que nos ha devuelto.

<p>
<img alt="Creaci&oacute;n de operaciones as&iacute;ncronas. Paso 6." content-width="5cm" height="209" src="imagenes/sesion2/wl-async-7.gif" width="226"></p>


</li>

<li>Tambi&eacute;n podremos crear un cliente que invoque el servicio as&iacute;ncrono que acabamos
de crear. Para ello crearemos un nuevo servicio web y a&ntilde;adiremos un control para
acceder al servicio <span class="codefrag">TemporizadorSW</span> definido en los pasos anteriores.
Crearemos un m&eacute;todo delegado para la operaci&oacute;n <span class="codefrag">programa</span>, como hemos
visto anteriormente, y un manejador de eventos para recibir el <em>callback</em> del
servicio. Para esto &uacute;ltimo, pulsaremos con el bot&oacute;n derecho sobre el <em>callback</em>
<span class="codefrag">enviaRespuesta</span> del control, y seleccionamos la opci&oacute;n <em>Create
Event Handler</em>.

<p>
<img alt="Creaci&oacute;n de operaciones as&iacute;ncronas. Paso 7." content-width="6cm" height="285" src="imagenes/sesion2/wl-async-4.gif" width="322"></p>


</li>

<li>A&ntilde;adiremos una nueva operaci&oacute;n <span class="codefrag">getUltimoMensaje</span> que nos devolver&aacute;
el &uacute;ltimo mensaje que nuestro servicio haya recibido del manejador de eventos.

<p>
<img alt="Creaci&oacute;n de operaciones as&iacute;ncronas. Paso 8." content-width="10cm" height="413" src="imagenes/sesion2/wl-async-5.gif" width="500"></p>


</li>

<li>El manejador de eventos guardar&aacute; el mensaje recibido en un campo est&aacute;tico de la clase, 
y la operaci&oacute;n <span class="codefrag">getUltimoMensaje</span> nos devolver&aacute; el valor de dicho campo. El c&oacute;digo
fuente completo de este cliente quedar&aacute; como se muestra a continuaci&oacute;n.

<pre class="code">package es.ua.jtech.servcweb.temporizador;

import javax.jws.*;
import org.apache.beehive.controls.api.bean.Control;
import es.ua.jtech.servcweb.controles.TemporizadorSWServiceControl;
import org.apache.beehive.controls.api.events.EventHandler;

@WebService
public class ClienteTemporizadorSW {

  static String mensaje = null;
	
  @Control
  private TemporizadorSWServiceControl temporizadorSWServiceControl;

  @WebMethod
  public void programa(java.lang.String mensaje_arg, 
                       int segundos_arg) {
    temporizadorSWServiceControl.programa(mensaje_arg, segundos_arg);
  }

  @WebMethod
  public String getUltimoMensaje() {
    if(mensaje==null) {
      return "No se ha recibido ningun mensaje";
    } else {
      return mensaje;			
    }
  }

  @EventHandler(field = "temporizadorSWServiceControl", 
              eventSet = TemporizadorSWServiceControl.Callback.class, 
              eventName = "enviaRespuesta")
  protected void temporizadorSWServiceControl_Callback_enviaRespuesta(
      java.lang.String mensaje_arg) {
    mensaje = mensaje_arg;
  }
}</pre>


</li>


</ol>
<a name="N105BA"></a><a name="Servicios+web+conversacionales"></a>
<h3 class="underlined_5">Servicios web conversacionales</h3>
<p>Un problema del protocolo HTTP heredado por los servicios web es la carencia de
estado. Cuando en una aplicaci&oacute;n necesitamos mantener un estado, por ejemplo para
tener un carrito de la compra, necesitaremos buscar alguna forma de identificar 
cu&aacute;ndo varias peticiones provienen de un mismo cliente.</p>
<p>Como primer enfoque para resolver este problema podr&iacute;amos plantearnos proporcionar
al cliente un identificador de su sesi&oacute;n, y que este cliente proporcione dicho
identificador como par&aacute;metro en cada sucesiva llamada al servicio. Esto tiene el
inconveniente de que parte de la responsabilidad de la gesti&oacute;n de la sesi&oacute;n recae en
el cliente. Como alternativa a este sistema encontramos los servicios web conversacionales,
que implementan el mantenimiento de la sesi&oacute;n en el lado del servidor, de forma
transparente para el cliente.</p>
<p>En los servicios web conversacionales se distinguen 3 tipos diferentes de operaciones:</p>
<ul>

<li>
<span class="codefrag">START</span>: Este tipo de operaciones estar&aacute;n disponibles antes de iniciar
una conversaci&oacute;n. Cuando invoquemos una de estas operaciones se iniciar&aacute; una nueva
conversaci&oacute;n.</li>

<li>
<span class="codefrag">CONTINUE</span>: Este tipo de operaciones estar&aacute;n disponibles cuando haya
una conversaci&oacute;n iniciada. Cuando invoquemos una de estas operaciones continuaremos
con la conversaci&oacute;n actual.</li>

<li>
<span class="codefrag">FINISH</span>: Este tipo de operaciones estar&aacute;n disponibles cuando haya
una conversaci&oacute;n iniciada. Cuando invoquemos una de estas operaciones finalizar&aacute; 
la conversaci&oacute;n actual. Para poder volver a utilizar el servicio deberemos iniciar
una nueva conversaci&oacute;n.</li>

</ul>
<p>En un servicio web convencional los campos que definamos en la clase del servicio 
deber&iacute;an ser est&aacute;ticos para asegurar su consistencia. Es decir, siempre tendremos 
campos compartidos por todas las llamadas al servicio. Sin embargo, en el caso de 
los servicios web conversacionales podremos incluir campos no est&aacute;ticos, que ser&aacute;n
propios de cada conversaci&oacute;n. Podremos utilizar estos campos para almacenar
la informaci&oacute;n de estado que necesite el servicio (por ejemplo el carrito de la
compra del cliente actual).</p>
<p>Vamos a ver un ejemplo de servicio de venta de productos, en el que podremos
crear una nueva venta, a&ntilde;adir art&iacute;culos a la venta, consultar los art&iacute;culos
que llevamos y finalizar la venta. Para crear este servicio seguiremos los siguientes
pasos:</p>
<ol>

<li>Creamos un proyecto de servicio web dentro de un proyecto EAR, y a&ntilde;adimos un nuevo
servicio (<span class="codefrag">CarritoSW</span>) dentro de &eacute;l. A&ntilde;adimos una nueva operaci&oacute;n 
<span class="codefrag">void comenzarCompra(String cliente)</span>, y en las propiedades de dicha 
operaci&oacute;n, en la ventana <em>Annotations</em>, seleccionamos <em>START</em> como valor de 
la propiedad <em>Conversation &gt; value</em>. Con esto indicamos que esta operaci&oacute;n
se encargar&aacute; de iniciar una nueva conversaci&oacute;n.

<p>
<img alt="Creaci&oacute;n de servicios web conversacionales. Paso 1." content-width="10cm" height="150" src="imagenes/sesion2/wl-conv-1.gif" width="500"></p>


<div class="frame note">
<div class="label">Nota</div>
<div class="content">Al crear un servicio web conversacional es necesario que el proyecto del
servicio web est&eacute; vinculado a un proyecto EAR. De no ser as&iacute;, no se desplegar&aacute; 
correctamente.</div>
</div>


</li>

<li>De la misma forma que en el caso anterior, a&ntilde;adimos las operaciones 
<span class="codefrag">agregarArticulo(String nombre, double precio)</span>,
<span class="codefrag">Articulo [] verArticulos()</span> y <span class="codefrag">Ticket finalizarCompra()</span>. Los
dos primeros ser&aacute;n de tipo <em>CONTINUE</em>, y el &uacute;ltimo ser&aacute; de tipo <em>FINISH</em>. 
En la vista de dise&ntilde;o del servicio veremos en cada operaci&oacute;n un s&iacute;mbolo correspondiente
a la fase de la conversaci&oacute;n a la que pertenece.

<p>
<img alt="Creaci&oacute;n de servicios web conversacionales. Paso 2." content-width="7cm" height="137" src="imagenes/sesion2/wl-conv-2.gif" width="323"></p>


</li>


<li>En la implementaci&oacute;n del servicio, deberemos especificar que implemente la interfaz
<span class="codefrag">Serializable</span>. De la misma forma, cualquier tipo de datos que utilicemos
tambi&eacute;n debe ser <span class="codefrag">Serializable</span> para poder utilizarlo en un servicio
conversacional. El c&oacute;digo fuente del servicio quedar&aacute; de la siguiente forma:

<pre class="code">package es.ua.jtech.servcweb.carrito;

import java.io.Serializable;

import javax.jws.*;

import es.ua.jtech.servcweb.carrito.to.Articulo;
import es.ua.jtech.servcweb.carrito.to.Ticket;
import weblogic.jws.Context;
import weblogic.jws.Conversation;
import weblogic.wsee.jws.JwsContext;
import weblogic.jws.Conversational;

@WebService
@Conversational(runAsStartUser=false, maxIdleTime = "600 seconds", 
                maxAge = "2 day")
public class CarritoSW implements Serializable {

  private static final long serialVersionUID = -1005644027645719969L;

  @Context  
  private JwsContext ctx;
  Ticket ticket;
  Articulo articulo;
	
  @WebMethod
  @Conversation(Conversation.Phase.START)
  public void comenzarCompra(String cliente) {
    ticket = new Ticket(cliente);
  }	

  @WebMethod
  @Conversation(Conversation.Phase.FINISH)
  public Ticket finalizarCompra() {
    ticket.calcularTotal();
    return ticket;
  }

  @WebMethod
  @Conversation(Conversation.Phase.CONTINUE)
  public void agregarArticulo(String articulo, double precio) {
    ticket.addArticulo(new Articulo(articulo, precio));
  }

  @WebMethod
  @Conversation(Conversation.Phase.CONTINUE)
  public Articulo [] verArticulos() {
    return ticket.getArticulosArray();
  }
}</pre>


<div class="frame note">
<div class="label">Nota</div>
<div class="content">Tanto el servicio como los tipos de datos utilizados en servicios
conversacionales deben ser <em>serializables</em>
</div>
</div>


<p>En este servicio utilizamos dos tipos de datos propios: <span class="codefrag">Articulo</span>, que 
encapsula los datos de un producto, y <span class="codefrag">Ticket</span> que contiene la lista
de art&iacute;culos vendidos. La clase <span class="codefrag">Articulo</span> se define como:</p>


<pre class="code">package es.ua.jtech.servcweb.carrito.to;

import java.io.Serializable;

public class Articulo implements Serializable {

  private static final long serialVersionUID = 6539187825881995855L;

  String nombre;
  double precio;
	
  public Articulo() {		
  }
  public Articulo(String nombre, double precio) {
    this.nombre = nombre;
    this.precio = precio;
  }
  public String getNombre() {
    return nombre;
  }
  public void setNombre(String nombre) {
    this.nombre = nombre;
  }
  public double getPrecio() {
    return precio;
  }
  public void setPrecio(double precio) {
    this.precio = precio;
  }
  public String toString() {
    return nombre + " (" + precio + ")";
  }	
}</pre>


<p>Por otro lado, la clase <span class="codefrag">Ticket</span> se define como:</p>


<pre class="code">package es.ua.jtech.servcweb.carrito.to;

import java.io.Serializable;
import java.util.ArrayList;

public class Ticket implements Serializable {

  private static final long serialVersionUID = 7124933176493493152L;

  ArrayList articulos;
  String cliente;
  double total;
	
  public Ticket() {	
  }
	
  public Ticket(String cliente) {
    this.cliente = cliente;
    this.articulos = new ArrayList();
    this.total = 0.0;
  }

  public Articulo [] getArticulosArray() {
    Articulo [] articulosArray = new Articulo [this.articulos.size()];
    this.articulos.toArray(articulosArray);
    return articulosArray;
  }
	
  public void addArticulo(Articulo art) {
    this.articulos.add(art);
  }

  public ArrayList getArticulos() {
    return articulos;
  }

  public void setArticulos(ArrayList articulos) {
    this.articulos = articulos;
  }

  public String getCliente() {
    return cliente;
  }

  public void setCliente(String cliente) {
    this.cliente = cliente;
  }

  public double getTotal() {
    return total;
  }

  public void setTotal(double total) {
    this.total = total;
  }
	
  public void calcularTotal() {
    this.total = 0.0;
    for(Object o: articulos) {
      Articulo a = (Articulo)o;
      this.total += a.getPrecio();
    }
  }
}</pre>


</li>


<li>Una vez implementado el servicio podremos probarlo desde <em>WebLogic Test 
Client</em>. En un principio veremos &uacute;nicamente las operaciones de tipo 
<span class="codefrag">START</span>. Cuando invoquemos cualquiera de estas operaciones se iniciar&aacute;
una nueva conversaci&oacute;n y entonces tendremos disponibles tanto las operaciones de tipo
<span class="codefrag">CONTINUE</span> como las de tipo <span class="codefrag">FINISH</span>, pero ya no las de tipo
<span class="codefrag">START</span>. Este cliente de prueba soporta m&uacute;ltiples conversaciones simult&aacute;neas, 
de forma que en cualquier momento podremos comenzar una nueva conversaci&oacute;n y 
posteriormente volver a conversaciones anteriores.

<div class="frame note">
<div class="label">Nota</div>
<div class="content">Cuando invoquemos un servicio conversacional desde un cliente propio deberemos
tener cuidado, ya que en determinados tipos de clientes si m&uacute;ltiples usuarios acceden
al servicio utilizando un mismo <em>stub</em> podr&iacute;an estar compartiendo la
misma conversaci&oacute;n.</div>
</div>


</li>


</ol>
</div>


<a name="N10661"></a><a name="Handlers+de+mensajes"></a>
<h2 class="underlined_10">Handlers de mensajes</h2>
<div class="section">
<p>Los <em>handlers</em> de mensajes son un componente que podremos utilizar para 
  interceptar los mensajes de petici&oacute;n y respuesta de un servicio. Su funci&oacute;n 
  es similar a la funci&oacute;n de los filtros que interceptan las peticiones 
  al servidor web, pero actuando sobre los mensajes SOAP que se utilizan para 
  invocar y dar la respuestas de un servicio.</p>
<p>Posibles usos de los <em>handlers</em> son:</p>
<ul>
  
<li>
<em>Encriptaci&oacute;n de los mensajes</em>: Podemos escribir un <em>handler</em> 
    que encripte los mensajes de salida, y que desencripte los mensajes de entrada. 
    De esta forma los datos viajar&aacute;n seguros por la red, y esta encriptaci&oacute;n 
    ser&aacute; transparente para JAX-RPC, que ser&aacute; capaz de leer sin problemas 
    los mensajes que le lleguen.</li>
  
<li>
<em>Restricci&oacute;n de acceso</em>: Podemos escribir un <em>handler</em> 
    que evite el paso de ciertos mensajes, como por ejemplo los de usuarios no 
    registrados. En caso de que no queramos admitir un mensaje, podemos contestar 
    directamente mediante un mensaje de error SOAP.</li>
  
<li>
<em>Inspecci&oacute;n de los mensajes</em>: En el momento en que interceptamos 
    un mensaje, podemos acceder a su contenido y consultar el mensaje que se est&aacute; 
    enviando realmente en cada caso.</li>
  
<li>
<em>Registro de mensajes</em>: Si tenemos acceso al mensaje, podremos registrarlos 
    en alguna base de datos por si necesitamos tener un registro de las operaciones 
    que se han invocado sobre nuestro servicio.</li>

</ul>
<p>Estos <em>handlers</em> van a poder ser instalados tanto en el cliente como 
  en el servidor. Sin los <em>handlers</em> no ser&iacute;amos capaces de acceder 
  al mensaje SOAP, ya que es JAX-RPC quien se encarga de componer y analizar el 
  mensaje de forma transparente al usuario. Por lo tanto, necesitaremos utilizar 
  <em>handlers</em> para interceptar este mensaje, ya que de otra forma no podr&iacute;amos 
  acceder a &eacute;l y modificarlo si hiciese falta.</p>
<a name="N1069C"></a><a name="Creaci%C3%B3n+de+un+handler"></a>
<h3 class="underlined_5">Creaci&oacute;n de un handler</h3>
<p>Para crear un <em>handler</em> deberemos crear una clase que implemente la 
  interfaz <span class="codefrag">Handler</span>. Esta interfaz nos obligar&aacute; a definir 
  una serie de m&eacute;todos con los que interceptaremos los distintos mensajes. 
  Esta clase variar&aacute; seg&uacute;n si utilizamos JAX-RPC o JAX-WS.</p>
<a name="N106AB"></a><a name="Handlers+en+JAX-RPC"></a>
<h4>Handlers en JAX-RPC</h4>
<p>En JAX-RPC los <em>handlers</em> deber&aacute;n definir los siguientes m&eacute;todos:</p>
<ul>
  
<li>
<span class="codefrag">handleRequest(MessageContext)</span>: Intercepta los mensajes 
    de petici&oacute;n SOAP al servicio.</li>
  
<li>
<span class="codefrag">handleResponse(MessageContext)</span>: Intercepta los mensajes 
    de respuesta SOAP del servicio.</li>
  
<li>
<span class="codefrag">handleFault(MessageContext)</span>: Intercepta los mensajes de 
    error SOAP producidos por el servicio.</li>

</ul>
<p>Adem&aacute;s, deberemos implementar los m&eacute;todos de inicializaci&oacute;n 
  y destrucci&oacute;n del componente, que controlan su ciclo de vida:</p>
<ul>
  
<li>
<span class="codefrag">init(HandlerInfo)</span>: Inicializa el componente. Se proporciona 
    un objeto <span class="codefrag">HandlerInfo</span> con configuraci&oacute;n que se le 
    puede proporcionar a este componente. Este objeto contendr&aacute; informaci&oacute;n 
    sobre la clase del <em>handler</em>, un mapa (<span class="codefrag">Map</span>) con propiedades 
    de configuraci&oacute;n, y la lista con los elementos de la cabecera SOAP 
    que procesa.</li>
  
<li>
<span class="codefrag">destroy()</span>: Se invoca cuando el ciclo de vida del componente 
    termina y debe ser destruido, liberando todos los recursos que estuviese utilizando.</li>

</ul>
<p>Adem&aacute;s tendremos que definir el siguiente m&eacute;todo:</p>
<ul>
  
<li>
<span class="codefrag">getHeaders()</span>: Devolver&aacute; un <em>array</em> de objetos 
    <span class="codefrag">QName</span> indicando los distintos elementos contenidos en la 
    cabecera de los mensajes SOAP (<span class="codefrag">header</span>) que procesar este <em>handler</em>.</li>

</ul>
<p>Existe una forma m&aacute;s sencilla de crear un <em>handler</em>, que es heredando 
  de <span class="codefrag">GenericHandler</span>. Esta es una clase abstracta que implementa 
  <span class="codefrag">Handler</span> y define la mayor&iacute;a de sus m&eacute;todos. De 
  esta forma s&oacute;lo tendremos que redefinir los m&eacute;todos para los que 
  queramos personalizar el comportamiento, sin tener que preocuparnos del resto.</p>
<p>Los <em>handlers</em> est&aacute;n contenidos dentro de una cadena de handlers 
  (<span class="codefrag">HandlerChain</span>). A cada <em>handler</em> de la cadena le llegar&aacute; 
  el resultado producido por el anterior <em>handler</em>. Podremos establecer 
  la ordenaci&oacute;n de <em>handlers</em> dentro de esta cadena en el fichero 
  de configuraci&oacute;n de Servicios Web. El orden de invocaci&oacute;n de los 
  <em>handlers</em> para capturar la respuesta ser&aacute; el inverso del orden 
  en el que se captur&oacute; la petici&oacute;n:</p>
<p>
<img alt="Cadena de handlers en el servidor" content-width="11cm" height="85" src="imagenes/handler-srv.gif" width="538"></p>
<p>Los m&eacute;todos para interceptar la petici&oacute;n, respuesta o error devolver&aacute;n 
  un valor <em>booleano</em>. Seg&uacute;n lo que devuelvan estos m&eacute;todos 
  tendremos diferentes comportamientos de la cadena:</p>
<ul>
  
<li>
<span class="codefrag">true</span>: El mensaje SOAP pasa al siguiente <em>handler</em> 
    de la cadena.</li>
  
<li>
<span class="codefrag">false</span>: Se bloquea la cadena de <em>handlers</em> en este 
    punto. Ser&aacute; el <em>handler</em> actual el responsable de dar manualmente 
    una respuesta al mensaje que le haya llegado.</li>
  
<li>
<span class="codefrag">SOAPFaultException</span>: Si al interceptar la petici&oacute;n 
    <span class="codefrag">handleRequest</span> lanza esta excepci&oacute;n, se indica que se devuelva 
    al cliente un mensaje de error SOAP.</li>
  
<li>
<span class="codefrag">JAXRPCException</span>: Indica que ha ocurrido un error en el 
    procesamiento del mensaje.</li>

</ul>
<p>A estos m&eacute;todos se les pasa un objeto <span class="codefrag">MessageContext</span> 
  como par&aacute;metro. Este objeto contiene una serie de propiedades. Podemos 
  hacer una conversi&oacute;n <em>cast</em> de este objeto a <span class="codefrag">SOAPMessageContext</span>, 
  que es una superclase de <span class="codefrag">MessageContext</span>, y nos proporcionar&aacute; 
  acceso a m&aacute;s informaci&oacute;n. En &eacute;l tendremos definidos los 
  m&eacute;todos <span class="codefrag">getMessage</span> y <span class="codefrag">setMessage</span> con 
  los que podremos obtener el mensaje interceptado, y sustituirlo en caso de que 
  queramos que el <em>handler</em> modifique el mensaje.</p>
<p>Un posible esqueleto para un <em>handler</em> es el siguiente:</p>
<pre class="code">public class MiHandler implements <strong>Handler</strong>

  private <strong>HandlerInfo</strong> handlerInfo;

  public void <strong>init</strong>(<strong>HandlerInfo</strong> hi) {
    handlerInfo = hi;
  }

  public void <strong>destroy</strong>() {}

  public QName[] <strong>getHeaders</strong>() {
    return handlerInfo.<strong>getHeaders</strong>();
  }

  public boolean <strong>handleRequest</strong>(<strong>MessageContext</strong> context) { 
    try { 
      // Accede al mensaje SOAP de peticion
<strong>      SOAPMessageContext</strong> smc = (<strong>SOAPMessageContext</strong>)context;    
<strong>      SOAPMessage</strong> msg = smc.<strong>getMessage</strong>(); 
      // Procesar mensaje SOAP
      ...
      // Si hemos hecho cambios, enviamos el mensaje modificado
      smc.<strong>setMessage</strong>(msg);
    } catch(Exception ex) { } 

    return true; 
  } 

  public boolean <strong>handleResponse</strong>(<strong>MessageContext</strong> context) { 
    try { 
      // Accede al mensaje SOAP de respuesta
<strong>      SOAPMessageContext</strong> smc = (<strong>SOAPMessageContext</strong>)context;    
<strong>      SOAPMessage</strong> msg = smc.<strong>getMessage</strong>(); 
      // Procesar mensaje SOAP
      ...
      // Si hemos hecho cambios, enviamos el mensaje modificado
      smc.<strong>setMessage</strong>(msg);
    } catch(Exception ex) { } 

    return true; 
  } 

  public boolean <strong>handleFault</strong>(<strong>MessageContext</strong> context) {
    return true;
  }
}</pre>
<p>Donde una vez obtenido el mensaje podemos leerlo y/o modificarlo, seg&uacute;n 
  la funci&oacute;n que queremos que desempe&ntilde;e el <em>handler</em>. Los 
  m&eacute;todos devuelven <span class="codefrag">true</span> para indicar que se siga procesando la 
  cadena de <em>handlers</em> de forma normal.</p>
<a name="N107BF"></a><a name="Handlers+en+JAX-WS"></a>
<h4>Handlers en JAX-WS</h4>
<p>La principal diferencia de los <em>handlers</em> de JAX-WS respecto a los de JAX-RPC 
es que en el primer caso no se distingue entre mensajes de petici&oacute;n y respuesta. En
los <em>handlers</em> de JAX-WS implementaremos <span class="codefrag">SOAPHandler</span>, en lugar
de <span class="codefrag">Handler</span>, y podremos utilizar gen&eacute;ricos para recibir como par&aacute;metro de
los m&eacute;todos directamente un objeto <span class="codefrag">SOAPMessageContext</span> y no tener que hacer
una conversi&oacute;n <em>cast</em>. Al implementar esta interfaz tendremos 
un &uacute;nico m&eacute;todo <span class="codefrag">handleMessage</span> que
intercepta cualquier mensaje, ya sea de petici&oacute;n o de respuesta.</p>
<pre class="code">public class MiHandler implements <strong>SOAPHandler&lt;SOAPMessageContext&gt;</strong> {
    
  public boolean <strong>handleMessage</strong>(SOAPMessageContext smc) {      
    try {
      // Accede al mensaje SOAP de peticion
      <strong>SOAPMessage</strong> msg = smc.<strong>getMessage</strong>(); 
      // Procesar mensaje SOAP
      ...
      // Si hemos hecho cambios, enviamos el mensaje modificado
      smc.<strong>setMessage</strong>(msg);
    } catch(Exception ex) { } 

    return true; 
  }
    
  public boolean handleFault(SOAPMessageContext context) {
    return true;
  }
    
  public Set&lt;QName&gt; getHeaders() {
    return null;
  }
    
  public void close(MessageContext context) {
  }    
}
</pre>
<p>Por ejemplo podr&iacute;amos definir un <em>handler</em> esp&iacute;a que intercepte los mensajes SOAP
y que muestre su contenido en la consola. Este <em>handler</em> se podr&iacute;a implementar
de la siguiente forma:</p>
<pre class="code">public class HandlerEspia implements SOAPHandler&lt;SOAPMessageContext&gt; {
    
  public boolean handleMessage(SOAPMessageContext context) {
    System.out.println("Mensaje interceptado :");
        
    try {
      SOAPMessageContext smc = (SOAPMessageContext)context;
      SOAPMessage msg = smc.getMessage();
            
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      msg.writeTo(baos);
      System.out.println(baos.toString());
    } catch(Exception ex) { }
        
    return true;
  }
    
  public boolean handleFault(SOAPMessageContext context) {
    return true;
  }
    
  public Set&lt;QName&gt; getHeaders() {
    return null;
  }
    
  public void close(MessageContext context) {
  }    
}
</pre>
<a name="N107FF"></a><a name="Registro+de+handlers+en+el+servicio"></a>
<h3 class="underlined_5">Registro de handlers en el servicio</h3>
<p>Deberemos registrar los <em>handlers</em> que queramos que intercepten 
  los mensajes en el servidor utilizando la anotaci&oacute;n <span class="codefrag">SOAPMessageHandlers</span>, tal como se muestra a continuaci&oacute;n:
</p>
<pre class="code">
<strong>@SOAPMessageHandlers</strong> ( {
  <strong>@SOAPMessageHandler</strong> (
    className="utils.MiHandler"),
  <strong>@SOAPMessageHandler</strong> (
    className="utils.MiSegundoHandler")
} )</pre>
<p>Mediante esta anotaci&oacute;n definiremos la cadena de <em>handlers</em> que interceptar&aacute; las llamadas a nuestros servicio. Deberemos especificar los <em>handlers</em> que formar&aacute;n parte de esta cadena mediante la anotaci&oacute;n <span class="codefrag">SOAPMessageHandler</span>, indicando para cada uno de ellos el nombre de la clase en la que est&aacute; implementado.
Estas clases deber&aacute;n encontrarse 
  entre las clases de la aplicaci&oacute;n que se despliegue en el servidor. Podemos copiar estas clases en el directorio <span class="codefrag">APP-INF/classes</span> del EAR de nuestro servicio, ya que todas las clases que copiemos aqu&iacute; estar&aacute;n disponibles para nuestro servicio.</p>
<a name="N1082A"></a><a name="Registrar+el+handler+en+el+cliente"></a>
<h3 class="underlined_5">Registrar el handler en el cliente</h3>
<p>Tambi&eacute;n podremos registrar los <em>handlers</em> en el lado del
  cliente del servicio, de forma que cuando entre o salga un mensaje sea interceptado 
  por nuestro <em>handler</em>. La forma de registrar el <em>handler</em> en el
  lado del cliente tambi&eacute;n variar&aacute; seg&uacute;n si utilizamos JAX-RPC o 
  JAX-WS. A continuaci&oacute;n mostraremos las dos formas de hacerlo.</p>
<a name="N1083C"></a><a name="Registro+de+handlers+con+JAX-RPC"></a>
<h4>Registro de handlers con JAX-RPC</h4>
<p>El <em>handler</em> deber&aacute; ser registrado 
  dentro del objeto <span class="codefrag">Service</span> correspondiente al servicio que estemos 
  invocando:</p>
<pre class="code">
<strong>Service</strong> serv = ... // Obtener servicio</pre>
<p>En el caso en el que accedamos mediante un <em>stub</em> est&aacute;tico, no 
  se usa directamente un objeto <span class="codefrag">Service</span>, sino una subclase del 
  mismo, adaptada al caso concreto de nuestro servicio. En este caso podremos 
  utilizar este objeto para registrarlo, ya que al ser subclase de <span class="codefrag">Service</span> 
  podremos utilizarlo de la misma forma.</p>
<p>A trav&eacute;s de este objeto <span class="codefrag">Service</span> podremos acceder al 
  registro de <em>handlers</em> (<span class="codefrag">HandlerRegistry</span>) de la siguiente 
  forma:</p>
<pre class="code">
<strong>HandlerRegistry</strong> hr = serv.<strong>getHandlerRegistry</strong>();</pre>
<p>A partir de este registro podremos obtener la cadena (<em>chain</em>) de <em>handlers</em> 
  instalados en este servicio. Proporcionaremos el nombre del puerto para el que 
  queremos registrar el <em>handler</em>, mediante un objeto <span class="codefrag">QName</span>:</p>
<pre class="code">List chain = hr.<strong>getHandlerChain</strong>(
             new QName("http://jtech.ua.es", 
                       "ConversionPortTypeSoapPort"));</pre>
<p>Esto nos devolver&aacute; una lista con informaci&oacute;n sobre todos los 
  <em>handlers</em> instalados en el cliente para el servicio y puerto indicados. 
  Esta lista nos dar&aacute; el orden de invocaci&oacute;n de la cadena de <em>handlers</em> 
  en el cliente, tal como se muestra en la siguiente figura:</p>
<p>
<img alt="Cadena de handlers en el cliente" content-width="11cm" height="84" src="imagenes/handler-cli.gif" width="536"></p>
<p>Cada elemento de esta lista ser&aacute; un objeto <span class="codefrag">HandlerInfo</span>, 
  que contendr&aacute; informaci&oacute;n sobre cada <em>handler</em> instalado. 
  Para registrar un nuevo <em>handler</em> deberemos crearnos un objeto <span class="codefrag">HandlerInfo</span> 
  que haga referencia a nuestro <em>handler</em>. En dicho objeto deberemos indicar 
  la clase de nuestro <em>handler</em>, y adem&aacute;s podemos proporcionar una 
  serie de par&aacute;metros de configuraci&oacute;n gen&eacute;ricos que se enviar&aacute;n 
  al <em>handler</em> en el momento de su creaci&oacute;n.</p>
<pre class="code">
<strong>HandlerInfo</strong> hi = new <strong>HandlerInfo</strong>(HandlerEspia.class,null,null);</pre>
<p>Una vez hecho esto, el &uacute;ltimo paso ser&aacute; a&ntilde;adir este objeto 
  a la cadena de <em>handlers</em>:</p>
<pre class="code">chain.add(hi);</pre>
<p>Con esto tendremos ya nuestro <em>handler</em> registrado. A continuaci&oacute;n 
  deberemos acceder al puerto correspondiente para hacer la llamada al servicio, 
  con cualquiera de los tres m&eacute;todos que hemos visto anteriormente (<em>stub</em> 
  est&aacute;tico, <em>proxy</em> din&aacute;mico, o DII). En el momento en el 
  que se env&iacute;e el mensaje SOAP con la petici&oacute;n, nuestro <em>handler</em> 
  lo interceptar&aacute; justo antes de que salga a trav&eacute;s de la red. Cuando 
  llegue la respuesta, el <em>handler</em> tambi&eacute;n la interceptar&aacute; 
  antes de que la lea nuestra aplicaci&oacute;n cliente. </p>
<a name="N108D7"></a><a name="Registro+de+handlers+con+JAX-WS"></a>
<h4>Registro de handlers con JAX-WS</h4>
<p>En este caso no registraremos el <em>handler</em> en el objeto 
<span class="codefrag">Service</span>, sino que lo haremos directamente en el <em>stub</em> (<span class="codefrag">port</span>).
Por ejemplo, para registrar el mismo <em>handler</em> que en el caso anterior lo 
har&iacute;amos de la siguiente forma:</p>
<pre class="code">HandlerEspia handler = new HandlerEspia();
List&lt;Handler&gt; cadena = new ArrayList&lt;Handler&gt;();
cadena.add(handler);
((BindingProvider)port).getBinding().<strong>setHandlerChain</strong>(cadena);</pre>
</div>


<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2007 Depto. CCIA</div>
</div>
</body>
</html>
