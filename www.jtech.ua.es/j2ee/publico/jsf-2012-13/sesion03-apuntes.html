<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>El ciclo de vida de JSF </title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Experto Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="../../../index.html"><img class="logoImage" alt="Componentes de presentaci&oacute;n" src="images/baner_j2ee_der.gif" title="Componentes de presentaci&oacute;n"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">JSF</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Componentes de presentacion</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Componentes de presentaci&oacute;n">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 3</div>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion03-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>El ciclo de vida de JSF </h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#La+arquitectura+JSF">La arquitectura JSF</a>
</li>
<li>
<a href="#Ciclo+de+vida">Ciclo de vida</a>
</li>
<li>
<a href="#Un+programa+de+ejemplo">Un programa de ejemplo</a>
<ul class="minitoc">
<li>
<a href="#Vista">Vista</a>
<ul class="minitoc">
<li>
<a href="#C%C3%B3digo+fuente">C&oacute;digo fuente</a>
</li>
<li>
<a href="#Renderizado+de+componentes">Renderizado de componentes</a>
</li>
<li>
<a href="#Hoja+de+estilos">Hoja de estilos</a>
</li>
<li>
<a href="#Errores+de+validaci%C3%B3n">Errores de validaci&oacute;n</a>
</li>
</ul>
</li>
<li>
<a href="#Modelo">Modelo</a>
</li>
<li>
<a href="#Controlador">Controlador</a>
</li>
</ul>
</li>
<li>
<a href="#Conversi%C3%B3n+de+formatos+entre+la+interfaz+y+los+beans">Conversi&oacute;n de formatos entre la interfaz y los beans</a>
<ul class="minitoc">
<li>
<a href="#Custom+converters">Custom converters</a>
</li>
</ul>
</li>
<li>
<a href="#Validaci%C3%B3n">Validaci&oacute;n</a>
<ul class="minitoc">
<li>
<a href="#JSR+303">JSR 303</a>
</li>
<li>
<a href="#Custom+validators">Custom validators</a>
</li>
</ul>
</li>
<li>
<a href="#Contexto+asociado+a+la+petici%C3%B3n">Contexto asociado a la petici&oacute;n</a>
</li>
<li>
<a href="#%C3%81rbol+de+componentes">&Aacute;rbol de componentes</a>
</li>
<li>
<a href="#Ligando+componentes+a+beans+gestionados">Ligando componentes a beans gestionados</a>
</li>
<li>
<a href="#Gesti%C3%B3n+de+eventos">Gesti&oacute;n de eventos</a>
<ul class="minitoc">
<li>
<a href="#Value+Change+Events">Value Change Events</a>
</li>
<li>
<a href="#Action+events">Action events</a>
</li>
<li>
<a href="#Los+tags">Los tags f:actionListener y f:valueChangeListener</a>
</li>
<li>
<a href="#Pasando+informaci%C3%B3n+desde+la+interfaz+al+componente%3A+el+tag">Pasando informaci&oacute;n desde la interfaz al componente: el tag f:setPropertyActionListener</a>
</li>
<li>
<a href="#Phase+Events">Phase Events</a>
</li>
<li>
<a href="#System+Events">System Events</a>
</li>
<li>
<a href="#Usando+el+tag+f%3Aevent+para+validaciones+m%C3%BAltiples">Usando el tag f:event para validaciones m&uacute;ltiples</a>
</li>
<li>
<a href="#Tomando+decisiones+antes+de+renderizar+la+vista">Tomando decisiones antes de renderizar la vista</a>
</li>
</ul>
</li>
</ul>
</div>

    
<a name="N1000E"></a><a name="La+arquitectura+JSF"></a>
<h2 class="underlined_10">La arquitectura JSF</h2>
<div class="section">
<p>
        En esta sesi&oacute;n vamos a estudiar en profundidad c&oacute;mo se gestionan
        las
        peticiones a JavaServer Faces, incluyendo detalles de la
        implementaci&oacute;n de esta arquitectura. Igual que en las sesiones
        pasadas, utilizaremos un ejemplo concreto para ilustrar todos los
        aspectos. Ser&aacute; una sencilla aplicaci&oacute;n web que
        llamaremos
        <em>Calculadora</em>
        que permite al usuario realizar
        operaciones matem&aacute;ticas.
      </p>
<p>Veremos los conceptos del ciclo de vida de una petici&oacute;n JSF, qu&eacute;
        es
        una petici&oacute;n, c&oacute;mo se validan los datos que el usuario introduce
        en el
        componente, c&oacute;mo obtiene el componente los datos del modelo y
        c&oacute;mo
        se
        procesan y definen los eventos asociados.</p>
<p>
        Tal y como ve&iacute;amos en la sesi&oacute;n anterior, y defini&eacute;ndolo de una
        forma muy simple, JSF es un framework orientado a recoger
        datos del
        usuario, pasarlos a la capa del modelo de la aplicaci&oacute;n,
        realizar las
        acciones correspondientes en la aplicaci&oacute;n
        y
        <em>pintar</em>
        los datos resultantes. Todo ello en un entorno web,
        con peticiones
        HTTP y p&aacute;ginas HTML.
      </p>
<p>
        Los datos se introducen y se muestran en forma de texto, y se
        almacenan en un formato dependiente de la aplicaci&oacute;n. Por ejemplo,
        una
        fecha se puede representar con un formato
        <span class="codefrag">dd-mm-aaaa</span>
        mientras que su representaci&oacute;n interna puede ser un objeto de la
        clase
        <span class="codefrag">java.util.Date</span>
        . Para realizar esta conversi&oacute;n entre
        el texto y el formato interno,
        se asocian al
        componente
        <em>validadores</em>
        y
        <em>conversores</em>
        .
      </p>
<p>
        Como vimos en la sesi&oacute;n pasada, esta separaci&oacute;n entre la parte
        visual del componente (c&oacute;digo HTML en la p&aacute;gina web), el modelo de
        datos (
        <em>managed beans</em>
        ) y las acciones (c&oacute;digo Java que procesa
        el modelo y controla la
        vista) es un esquema tradicional en todos
        los framework de gesti&oacute;n de
        interfaces de usuario que se
        denomina
        <em>patr&oacute;n Modelo/Vista/Controlador (MVC)</em>
        .
      </p>
<p>
        La aportaci&oacute;n fundamental de la tecnolog&iacute;a JSF es la adaptaci&oacute;n del
        patr&oacute;n MVC al entorno web. Para ello, el c&oacute;digo final en el que se
        define un componente es c&oacute;digo HTML y los eventos disparados por el
        usuario se guardan en la petici&oacute;n HTTP. Un
        <em>servlet</em>
        de la
        clase
        <span class="codefrag">javax.faces.webapp.FacesServlet</span>
        es el motor de
        cualquier aplicaci&oacute;n JSF. Este servlet procesa la
        petici&oacute;n, gestiona
        todos los componentes relacionados y termina
        generando el c&oacute;digo HTML
        en el que se traducen estos componentes.
      </p>
<p>
        Recordemos, como vimos en la sesi&oacute;n pasada, que el funcionamiento
        b&aacute;sico de JSF cuando recibe una petici&oacute;n JSF consiste en obtener la
        vista JSF, procesarla con los datos introducidos por el usuario y
        que
        llegan en la petici&oacute;n y generar una p&aacute;gina HTML como resultado.
        Este
        proceso (petici&oacute;n, procesamiento y generaci&oacute;n de p&aacute;gina HTML) es
        lo
        que se denomina el
        <strong>ciclo de vida JSF</strong>
        . Veremos con
        detalle los pasos que realiza la arquitectura JSF
        dentro de este ciclo
        de procesamiento. La siguiente figura muestra un
        ejemplo concreto de
        la aplicaci&oacute;n Calculadora que utilizaremos en
        esta sesi&oacute;n.
      </p>
<p>
        
<img alt="" content-width="14cm" src="imagenes/tema02/generacion-html-calculadora.png" width="600">
      </p>
</div>

    
<a name="N10054"></a><a name="Ciclo+de+vida"></a>
<h2 class="underlined_10">Ciclo de vida</h2>
<div class="section">
<p>
        Cuando se carga la aplicaci&oacute;n web en el servidor se inicializa el
        framework JSF. Se lee el fichero de
        configuraci&oacute;n
        <span class="codefrag">faces-config.xml</span>
        y se crean los beans
        gestionados definidos con el &aacute;mbito
        <span class="codefrag">application</span>
        ,
        realizando las sentencias de incializaci&oacute;n necesarias. Despu&eacute;s el
        motor de JSF est&aacute; listo para recibir peticiones y para lanzar el
        ciclo
        de vida de JSF con cada una.
      </p>
<p>
        Lo que en JSF se denomina ciclo de vida no es m&aacute;s que una secuencia
        de fases por las que pasa una petici&oacute;n JSF desde que se recibe en el
        servidor hasta que se genera la p&aacute;gina HTML resultante. El servlet
        que
        implementa el framework (
        <span class="codefrag">javax.faces.webapp.FacesServlet</span>
        )
        recibe la petici&oacute;n y realiza todo el ciclo, creando y utilizando
        los
        objetos Java que representan los componentes JSF y los beans
        gestionados. La relaci&oacute;n entre estos objetos y la generaci&oacute;n de
        c&oacute;digo
        HTML a partir del &aacute;rbol de componentes constituyen la base del
        funcionamiento del framework.
      </p>
<p>Las fases del ciclo de vida son las siguientes:</p>
<ol>
        
<li>
          
<strong>Restaurar la vista</strong>
          (
          <em>restore view</em>
          ). En
          este paso se obtiene el &aacute;rbol de componentes correspondiente a
          la
          vista JSF de la petici&oacute;n. Si se ha generado antes se recupera, y
          si
          es la primera vez que el usuario visita la p&aacute;gina, se genera a
          partir de la descripci&oacute;n JSF.
        </li>

        
<li>
          
<strong>Aplicar los valores de la petici&oacute;n</strong>
          (
          <em>apply
            request values</em>
          ). Una vez obtenido el &aacute;rbol de componentes, se
          procesan todos los
          valores asociados a los mismos. Se convierten
          todos los datos de la
          petici&oacute;n a tipos de datos Java y, para
          aquellos que tienen la
          propiedad
          <span class="codefrag">inmediate</span>
          a cierta,
          se validan, adelant&aacute;ndose a la siguiente fase.
        </li>

        
<li>
          
<strong>Procesar las validaciones</strong>
          (
          <em>process
            validations</em>
          ). Se validan todos los datos. Si existe alg&uacute;n
          error, se encola un
          mensaje de error y se termina el ciclo de vida,
          saltando al &uacute;ltimo
          paso (renderizar respuesta).
        </li>

        
<li>
          
<strong>Actualizar los valores del modelo</strong>
          (
          <em>update
            model values</em>
          ). Cuando se llega a esta fase, todos los valores
          se han procesado y
          se han validado. Se actualizan entonces las
          propiedades de los beans
          gestionados asociados a los
          componentes.
        </li>

        
<li>
          
<strong>Invocar a la aplicaci&oacute;n</strong>
          (
          <em>invoke
            application)</em>
          . Cuando se llega a esta fase, todas las
          propiedades de los beans
          asociados a componentes de entrada
          (
          <em>input</em>
          ) se han actualizado. Se llama en este momento a la
          acci&oacute;n
          seleccionada por el usuario.
        </li>

        
<li>
          
<strong>
            <em>Renderizar</em>
            la respuesta
          </strong>
          (
          <em>render
            response</em>
          ).
        </li>
      
</ol>
<p>
        
<img alt="Ciclo de vida de una petici&oacute;n JSF" content-width="12cm" src="imagenes/tema02/ciclo-de-vida.gif" width="600">
      </p>
<p>
        Al final de cada una de las fases, se comprueba si hay alg&uacute;n evento
        que debe ser procesado en esa fase en concreto y se llama a su
        manejador. Tambi&eacute;n se llaman a los manejadores de los eventos que
        deben ser procesados en cualquier fase. Los manejadores, a su vez,
        pueden saltar a la &uacute;ltima fase del ciclo para renderizar el &aacute;rbol de
        componentes llamando al m&eacute;todo
        <span class="codefrag">renderResponse()</span>
        del
        <span class="codefrag">FacesContext</span>
        . Tambi&eacute;n pueden renderizar el componente
        asociado al evento y llamar
        al m&eacute;todo
        <span class="codefrag">responseComplete()</span>
        del
        <span class="codefrag">FacesContext</span>
        para terminar el ciclo de vida.
      </p>
<p>
        JSF emite un evento
        <span class="codefrag">PhaseListener</span>
        al comienzo y al
        final de cada fase del ciclo de vida de la petici&oacute;n.
        Para capturar el
        evento, debemos definir una clase que implemente la
        interfaz
        <span class="codefrag">PhaseListener</span>
        y sus
        m&eacute;todos
        <span class="codefrag">beforePhase</span>
        y
        <span class="codefrag">afterPhase</span>
        .
      </p>
<p>
        En el ejemplo que vamos a ver m&aacute;s adelante
        (
        <span class="codefrag">calculator</span>
        ) se podr&iacute;a hacer de la siguiente forma:
      </p>
<pre class="brush:java;">package calculator.controller;

import javax.faces.application.FacesMessage;
import javax.faces.context.FacesContext;
import javax.faces.event.PhaseEvent;
import javax.faces.event.PhaseId;
import javax.faces.event.PhaseListener;

public class CalculatorPhaseListener implements PhaseListener {

  public void beforePhase(PhaseEvent pe) {
    FacesContext context = FacesContext.getCurrentInstance();
    if (pe.getPhaseId() == PhaseId.RESTORE_VIEW) 
      context.addMessage(
        null,  
        new FacesMessage("Procesando una nueva peticion!")
      );
      context.addMessage(
        null, 
        new FacesMessage("antes de - " + pe.getPhaseId().toString())
      );
  }
    
  public void afterPhase(PhaseEvent pe) {      
    FacesContext context = FacesContext.getCurrentInstance();
    context.addMessage(
      null, 
      new FacesMessage("despues de - " + pe.getPhaseId().toString())
    );
    
    if (pe.getPhaseId() == PhaseId.RENDER_RESPONSE)
      context.addMessage(
        null, 
        new FacesMessage("Peticion terminada!")
      );
  }
    
  public PhaseId getPhaseId() {
    return PhaseId.ANY_PHASE;
  }
}</pre>
<p>
        Para que el framework llame a este manejador hay que
        a&ntilde;adir en el
        fichero
        <span class="codefrag">faces-config.xml</span>
        la siguiente
        declaraci&oacute;n:
      </p>
<pre class="brush:xml;">&lt;lifecycle&gt;
   &lt;phase-listener&gt;
      calculator.controller.CalculatorPhaseListener
   &lt;/phase-listener&gt;
&lt;/lifecycle&gt; </pre>
<p>
        Se pueden ver los mensajes con la etiqueta
        <span class="codefrag">h:messages</span>
        dentro de cualquier vista (
        <span class="codefrag">&lt;f:view&gt;</span>
        )
      </p>
</div>


    
<a name="N100F5"></a><a name="Un+programa+de+ejemplo"></a>
<h2 class="underlined_10">Un programa de ejemplo</h2>
<div class="section">
<p>Veamos en primer lugar un sencillo programa ejemplo en el que
        vamos
        a presentar algunas de las caracter&iacute;sticas presentadas. Se
        trata de
        un
        programa que implementa una simple calculadora de n&uacute;meros
        enteros. Su
        apariencia es la siguiente:</p>
<p>
        
<img alt="" content-width="8cm" src="imagenes/tema02/calculadora-01.png" width="400">
      </p>
<p>
        Vemos que la interfaz de usuario se construye en una &uacute;nica p&aacute;gina,
        en la que se definen dos campos de texto para introducir los n&uacute;meros
        a
        operar y un bot&oacute;n para realizar la operaci&oacute;n matem&aacute;tica. Por
        defecto,
        se utiliza la operaci&oacute;n suma, pero es posible cambiar esta
        operaci&oacute;n
        pinchando en la opci&oacute;n
        <em>Cambiar operaci&oacute;n</em>
        . Entonces, en la
        misma p&aacute;gina, se muestra una lista de operaciones
        de las que el
        usuario puede seleccionar una, pulsando el bot&oacute;n
        <em>Selecciona
          operaci&oacute;n</em>
        :
      </p>
<p>
        
<img alt="" content-width="8cm" src="imagenes/tema02/calculadora-02.png" width="400">
      </p>
<p>Una vez seleccionada la nueva operaci&oacute;n, se vuelve a una
        configuraci&oacute;n similar a la primera figura, pero con la nueva
        operaci&oacute;n.</p>
<p>Vamos a utilizar esta aplicaci&oacute;n para explicar con un poco de m&aacute;s
        detalle el ciclo de vida de las peticiones y la validaci&oacute;n de los
        datos. Comencemos estudiando su c&oacute;digo fuente, analizando los
        elementos que funcionan como vista, modelo y controlador.</p>
<ul>
        
<li>
          
<strong>Vista</strong>
          : Toda la vista de la aplicaci&oacute;n se
          implementa con un &uacute;nico fichero
          JSF, el
          fichero
          <span class="codefrag">calculator.xhtml</span>
          . En &eacute;l se definen varios
          componentes, organizados en dos elementos
          de
          tipo
          <span class="codefrag">h:form</span>
          . El primero contiene la calculadora
          propiamente dicha: los campos
          para los n&uacute;meros, la operaci&oacute;n, el
          bot&oacute;n para calcular el resultado
          y el resultado propiamente
          dicho. Al final se a&ntilde;ade un enlace con
          una acci&oacute;n para activar el
          cambio de operaci&oacute;n. El segundo elemento
          es la lista de operaciones
          y el bot&oacute;n para confirmar el cambio de la
          operaci&oacute;n activa. Este
          componente y el enlace para activarlo se
          ocultan y se muestran,
          dependiendo del estado de la interfaz.
          Veremos c&oacute;mo se consigue
          este efecto.
        </li>

        
<li>
          
<strong>Modelo</strong>
          . Se utiliza un &uacute;nico bean,
          llamado
          <span class="codefrag">calculatorBean</span>
          , en el que se han definido las
          propiedades
          <span class="codefrag">firstNumber</span>
          ,
          <span class="codefrag">secondNumber</span>
          ,
          <span class="codefrag">operation</span>
          y
          <span class="codefrag">result</span>
          . Adem&aacute;s, se utiliza la
          clase
          <span class="codefrag">CalculatorBO</span>
          que implementa la "l&oacute;gica de
          negocio" y que es con la que que
          realizamos finalmente la
          operaci&oacute;n.
        </li>

        
<li>
          
<strong>Controlador</strong>
          . El controlador es un objeto de la
          clase
          <span class="codefrag">CalculatorController</span>
          que tiene la
          responsabilidad de realizar la operaci&oacute;n entre los dos
          n&uacute;meros y
          actualizar el bean con el resultado y tambi&eacute;n de guardar y
          modificar las propiedades que determinan la visibilidad de los
          componentes. El controlador debe tener acceso al
          bean
          <span class="codefrag">calculatorBean</span>
          que define el modelo. Para eso se
          define en el controlador la
          propiedad
          <span class="codefrag">numbers</span>
          que se
          inicializa con el bean
          <span class="codefrag">calculatorBean</span>
          en el fichero de
          configuraci&oacute;n
          <span class="codefrag">faces-config.xml</span>
          .
        </li>
      
</ul>
<p>Veamos con detalle c&oacute;mo se implementan estos elementos.</p>
<a name="N1015E"></a><a name="Vista"></a>
<h3 class="underlined_5">Vista</h3>
<a name="N10164"></a><a name="C%C3%B3digo+fuente"></a>
<h4>C&oacute;digo fuente</h4>
<p>
            Comenzamos por la
            <strong>vista</strong>
            definida en el fichero
            <span class="codefrag">calculator.xhtml</span>
            .
          </p>
<p>
            
<strong>
              Fichero
              <span class="codefrag">calculator.xhtml</span>
            </strong>
            :
          </p>
<pre class="brush:xml;">&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:h="http://java.sun.com/jsf/html"
      xmlns:f="http://java.sun.com/jsf/core"&gt;
&lt;h:head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;LINK href="&lt;%=request.getContextPath()%&gt;/css/mystyle.css"
  rel="stylesheet" type="text/css"&gt;
&lt;title&gt;Calculadora&lt;/title&gt;
&lt;/h:head&gt;
&lt;h:body&gt;
  &lt;h1&gt;Calculadora&lt;/h1&gt;
  &lt;h:form&gt;
    &lt;h:panelGrid columns="3"&gt;
      &lt;h:outputLabel value="Primer n&uacute;mero"/&gt;
      &lt;h:inputText id="firstNumber" 
          value="#{calculatorBean.firstNumber}" 
          required="true"/&gt;
      &lt;h:message for="firstNumber"/&gt;
            
      &lt;h:outputLabel value="Segundo n&uacute;mero"/&gt;
      &lt;h:inputText id="secondNumber" 
          value="#{calculatorBean.secondNumber}" 
          required="true"/&gt;
      &lt;h:message for="secondNumber" /&gt;
            
      &lt;h:outputLabel value="Operaci&oacute;n"/&gt;
      &lt;h:outputLabel value="#{calculatorBean.operation}" 
                            styleClass="strong"/&gt;
      &lt;h:outputLabel value=""/&gt;
    &lt;/h:panelGrid&gt;
          
    &lt;h:commandButton value="Calcular" 
        action="#{calculatorController.doOperation}"/&gt;
    &lt;h:outputText value="Resultado: #{calculatorBean.result}"/&gt;&lt;br/&gt;
    
    &lt;p&gt;&lt;/p&gt;  
    
    &lt;h:commandLink rendered="#{calculatorController.newOperationCommandRendered}"
        action="#{calculatorController.doNewOperation}"  
        value="Cambiar operaci&oacute;n"/&gt;
    &lt;/h:form&gt;&lt;br/&gt;
    
    &lt;p&gt;&lt;/p&gt;
    
    &lt;h:form  rendered="#{calculatorController.selectOperationFormRendered}"&gt;
      &lt;h:selectOneListbox value="#{calculatorBean.operation}"&gt;
        &lt;f:selectItem itemValue="+" itemLabel="suma"/&gt;
        &lt;f:selectItem itemValue="-" itemLabel="resta"/&gt;
        &lt;f:selectItem itemValue="*" itemLabel="multiplicaci&oacute;n"/&gt;
        &lt;f:selectItem itemValue="/" itemLabel="divisi&oacute;n"/&gt;             
      &lt;/h:selectOneListbox&gt;&lt;br/&gt;
      &lt;h:commandButton action="#{calculatorController.doSelectOperation}" 
          value="Selecciona operaci&oacute;n"/&gt;
    &lt;/h:form&gt;
&lt;/h:body&gt;
&lt;/html&gt;</pre>
<p>
            Primero se define el componente que contiene la calculadora
            propiamente dicha. Se trata de un
            <span class="codefrag">h:form</span>
            que contiene
            un
            <span class="codefrag">h:panelGrid</span>
            con 3 columnas. En la primera columnas se
            colocan los
            <span class="codefrag">h:outputLabel</span>
            que describen el elemento de la
            calculadora que hay a su derecha.
            En la segunda columna se colocan los
            datos propiamente dichos,
            conectados con las distintas propiedades del
            bean
            <span class="codefrag">calculatorBean</span>
            :
            <span class="codefrag">firstNumber</span>
            ,
            <span class="codefrag">secondNumber</span>
            y
            <span class="codefrag">operation</span>
            .
          </p>
<p>
            
<img alt="" content-width="6cm" src="imagenes/tema02/calculadora-03.png" width="355">
          </p>
<p>
            El segundo bloque de componentes de la p&aacute;gina es
            un
            <span class="codefrag">h:form</span>
            que contiene una caja de selecci&oacute;n,
            un
            <span class="codefrag">h:selectOnListbox</span>
            , con todas las posibles operaciones
            y un
            <span class="codefrag">h:commandButton</span>
            asociado a la acci&oacute;n para confirmar
            el cambio de operaci&oacute;n.
          </p>
<p>
            
<img alt="" content-width="3cm" src="imagenes/tema02/calculadora-04.png" width="181">
          </p>
<a name="N101B8"></a><a name="Renderizado+de+componentes"></a>
<h4>Renderizado de componentes</h4>
<p>
            Vamos ahora a uno de los puntos importantes del ejemplo. &iquest;C&oacute;mo se
            hace aparecer y desaparecer los componentes en la p&aacute;gina? Podemos
            ver
            en este componente, y en el
            <em>commandLink</em>
            <em>Cambiar
              operaci&oacute;n</em>
            , la opci&oacute;n
            <span class="codefrag">rendered</span>
            , que indica si el
            componente va a ser renderizado y volcado en el
            HTML que se env&iacute;a al
            navegador.
          </p>
<pre class="brush:xml;">...
&lt;h:commandLink rendered="#{calculatorController.newOperationCommandRendered}"
    action="#{calculatorController.doNewOperation}"  
 ...
&lt;h:form rendered="#{calculatorController.selectOperationFormRendered}"
   &lt;h:selectOneListbox value="#{calculatorBean.operation}"&gt;
         &lt;f:selectItem itemValue="+" itemLabel="suma"/&gt;
...</pre>
<p>
            Si fij&aacute;ramos en el atributo
            <span class="codefrag">rendered</span>
            el
            valor
            <span class="codefrag">true</span>
            o
            <span class="codefrag">false</span>
            har&iacute;amos que siempre se
            mostraran o se escondieran los componentes.
            Esto no es muy &uacute;til. Esta
            opci&oacute;n (como muchas otras de los
            componentes JSF) se vuelve
            interesante de verdad cuando hacemos lo
            que aparece en el
            ejemplo. Ligamos el atributo a una propiedad del
            bean de forma que
            podemos modificar el estado del componente en
            funci&oacute;n de los valores
            de los objetos del modelo y de las opciones
            seleccionadas por el
            usuario. En este caso ligamos al atributo
            <span class="codefrag">redered</span>
            las
            propiedades
            <span class="codefrag">newOperationCommandRendered</span>
            y
            <span class="codefrag">selectOperationFormRendered</span>
            del bean que hace de
            controlador. De esta forma podemos hacer que
            aparezca o desaparezcan
            los componentes poniendo a
            <span class="codefrag">true</span>
            o
            <span class="codefrag">false</span>
            esas
            propiedades. Como la fase de render es la &uacute;ltima de todas las
            fases,
            el estado de los componentes depender&aacute; de las modificaciones
            que las
            acciones y eventos hayan realizado en las propiedades del
            bean.
          </p>
<a name="N101EB"></a><a name="Hoja+de+estilos"></a>
<h4>Hoja de estilos</h4>
<p>Un detalle tambi&eacute;n interesante es la forma de a&ntilde;adir CSS a la
            p&aacute;gina. Incluimos la hoja de estilos con la directiva:</p>
<pre class="brush:xml;">&lt;LINK href="&lt;%=request.getContextPath()%&gt;/css/mystyle.css"
  rel="stylesheet" type="text/css"&gt;</pre>
<p>
            Y despu&eacute;s indicamos la clase CSS del
            <span class="codefrag">outputlabel</span>
            con el atributo
            <span class="codefrag">styleClass</span>
            :
          </p>
<pre class="brush:xml;">&lt;h:outputLabel value="#{calculatorBean.operation}" styleClass="strong"/&gt;</pre>
<p>El contenido del fichero con la hoja de estilos es sencillo:</p>
<p>
            Fichero
            <strong>
              <span class="codefrag">WebContent/css/mystyle.css</span>
            </strong>
          
</p>
<pre class="brush:css;">.strong {
  font-weight:bold;
  color: red;
}</pre>
<a name="N10219"></a><a name="Errores+de+validaci%C3%B3n"></a>
<h4>Errores de validaci&oacute;n</h4>
<p>Como se puede comprobar en el c&oacute;digo JSF, se han definido en la
            tercera columna del panel de la calculadora los mensajes de error
            JSF
            asociados a los componentes y que pueden generarse en la
            conversi&oacute;n o
            validaci&oacute;n de los n&uacute;meros introducidos por el usuario.
            La
            siguiente
            figura muestra los mensajes de error generados por un
            valor que es
            imposible de convertir al tipo de datos de la
            propiedad.</p>
<p>
            
<img alt="" content-width="10cm" src="imagenes/tema02/calculadora-05.png" width="600">
          </p>
<a name="N1022D"></a><a name="Modelo"></a>
<h3 class="underlined_5">Modelo</h3>
<p>
          El c&oacute;digo Java que da soporte a estos componentes se implementa en
          las clases
          <span class="codefrag">calculator.model.Calculator</span>
          y
          <span class="codefrag">calculator.controller.CalculatorController</span>
          . El primero
          define la
          <em>capa de negocio</em>
          de la aplicaci&oacute;n con los posibles casos de
          uso y su implementaci&oacute;n
          en c&oacute;digo Java.
        </p>
<p>
          
<strong>
            Fichero
            <span class="codefrag">es.ua.jtech.jsf.CalculatorBO</span>
          </strong>
          :
        </p>
<pre class="brush:java;">package es.ua.jtech.jsf;

public class CalculatorBO {
   
   public int add(int a, int b) {
      return a + b;
   }

   public int substract(int a, int b) {
      return a - b;
   }

   public int multiply(int a, int b) {
      return a * b;
   }

   public int divide(int a, int b) {
      return a / b;
   }
}
</pre>
<pre class="brush:java;">package es.ua.jtech.jsf;

public class CalculatorBean {
  private int firstNumber = 0;
  private int secondNumber = 0;
  private String operation = "+";
  private int result = 0;

  public void setFirstNumber(int firstNumber) {
    this.firstNumber = firstNumber;
  }

  public void setResult(int result) {
    this.result = result;
  }

  public int getFirstNumber() {
    return firstNumber;
  }

  public void setSecondNumber(int secondNumber) {
    this.secondNumber = secondNumber;
  }

  public int getSecondNumber() {
    return secondNumber;
  }

  public void setOperation(String operation) {
    this.operation = operation;
  }

  public String getOperation() {
    return operation;
  }

  public int getResult() {
    return result;
  }
}
</pre>
<a name="N10253"></a><a name="Controlador"></a>
<h3 class="underlined_5">Controlador</h3>
<p>
          La segunda clase,
          <span class="codefrag">calculator.controller.CalculatorController</span>
          define el
          <em>bean</em>
          gestionado y el m&eacute;todo de acci&oacute;n que realiza la
          operaci&oacute;n matem&aacute;tica
          seleccionada por el usuario.
        </p>
<p>
          
<strong>
            Fichero
            <span class="codefrag">es.ua.jtech.jsf.CalculatorController</span>
          </strong>
          :
        </p>
<pre class="brush:java;">package es.ua.jtech.jsf;

public class CalculatorController {
 
  private CalculatorBean numbers;
  private CalculatorBO calculator = new CalculatorBO();
  private boolean selectOperationFormRendered=false;
  private boolean newOperationCommandRendered=true;
   
  public boolean isSelectOperationFormRendered() {
    return selectOperationFormRendered;
  }

  public void setSelectOperationFormRendered(boolean selectOperationFormRendered) {
    this.selectOperationFormRendered = selectOperationFormRendered;
  }

  public boolean isNewOperationCommandRendered() {
    return newOperationCommandRendered;
  }

  public void setNewOperationCommandRendered(boolean newOperationCommandRendered) {
    this.newOperationCommandRendered = newOperationCommandRendered;
  }
  
  public CalculatorBean getNumbers() {
    return numbers;
  }

  public void setNumbers(CalculatorBean numbers) {
    this.numbers = numbers;
  }

  public String doNewOperation() {
    selectOperationFormRendered=true;
    newOperationCommandRendered=false;
    return null;
  }
   
  public String doSelectOperation() {
    selectOperationFormRendered=false;
    newOperationCommandRendered=true;
    doOperation();
    return null;
  }

  public String doOperation() {
    String operation = numbers.getOperation();
    int firstNumber = numbers.getFirstNumber();
    int secondNumber = numbers.getSecondNumber();
    int result = 0;
    String resultStr = "OK";

    if (operation.equals("+"))
      result = calculator.add(firstNumber, secondNumber);
    else if (operation.equals("-"))
      result = calculator.substract(firstNumber, secondNumber);
    else if (operation.equals("*"))
      result = calculator.multiply(firstNumber, secondNumber);
    else if (operation.equals("/"))
      result = calculator.divide(firstNumber, secondNumber);
    else
      resultStr="not-OK";
         
    numbers.setResult(result);
    return resultStr;
  }
}</pre>
<p>
          Por &uacute;ltimo, el fichero de
          configuraci&oacute;n
          <span class="codefrag">faces-config.xml</span>
          relaciona el nombre l&oacute;gico
          del
          <em>bean</em>
          <span class="codefrag">calculatorController</span>
          con la
          clase
          <span class="codefrag">calculator.Controller.CalculatorController</span>
          y le
          asigna un alcance de sesi&oacute;n. Tambi&eacute;n define el
          bean
          <span class="codefrag">calculatorBean</span>
          con alcance sesi&oacute;n e inicializa la
          propiedad
          <span class="codefrag">numbers</span>
          de
          <span class="codefrag">calculatorController</span>
          con este bean reci&eacute;n creado. De esta forma es posible acceder al
          bean
          que representa el modelo desde el controlador, cuando haya que
          realizar una acci&oacute;n.
        </p>
<p>
          Tambi&eacute;n se definen en este fichero las reglas de navegaci&oacute;n entre
          las vistas JSF. Tras la p&aacute;gina
          <span class="codefrag">/calculator.xhtml</span>
          se
          muestra (si el resultado de la acci&oacute;n es "
          <span class="codefrag">OK</span>
          ") la
          p&aacute;gina
          <span class="codefrag">/result.xhtml</span>
          . Y tras realizar una acci&oacute;n en la
          p&aacute;gina
          <span class="codefrag">/result.xhtml</span>
          se muestra (si el resultado de la
          acci&oacute;n es la cadena
          <span class="codefrag">OK</span>
          la
          p&aacute;gina
          <span class="codefrag">/calculator.xhtml</span>
          ).
        </p>
<p>
          Fichero
          <strong>
            <span class="codefrag">faces-config.xml</span>
          </strong>
          :
        </p>
<pre class="brush:xml;">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;faces-config
    xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
    http://java.sun.com/xml/ns/javaee/web-facesconfig_1_2.xsd"
    version="1.2"&gt;
  &lt;managed-bean&gt;
    &lt;managed-bean-name&gt;calculatorBean&lt;/managed-bean-name&gt;
    &lt;managed-bean-class&gt;es.ua.jtech.jsf.CalculatorBean&lt;/managed-bean-class&gt;
    &lt;managed-bean-scope&gt;session&lt;/managed-bean-scope&gt;
  &lt;/managed-bean&gt;
  &lt;managed-bean&gt;
    &lt;managed-bean-name&gt;calculatorController&lt;/managed-bean-name&gt;
    &lt;managed-bean-class&gt;es.ua.jtech.jsf.CalculatorController&lt;/managed-bean-class&gt;
    &lt;managed-bean-scope&gt;session&lt;/managed-bean-scope&gt;
    &lt;managed-property&gt;
      &lt;property-name&gt;numbers&lt;/property-name&gt;
      &lt;property-class&gt;es.ua.jtech.jsf.CalculatorBean&lt;/property-class&gt;
      &lt;value&gt;#{calculatorBean}&lt;/value&gt;
    &lt;/managed-property&gt;
  &lt;/managed-bean&gt;
&lt;/faces-config&gt;</pre>
</div>

    
<a name="N102AD"></a><a name="Conversi%C3%B3n+de+formatos+entre+la+interfaz+y+los+beans"></a>
<h2 class="underlined_10">Conversi&oacute;n de formatos entre la interfaz y los beans</h2>
<div class="section">
<p>
        Una de las ayudas que nos proporciona JSF es la conversi&oacute;n de
        formatos entre los componentes y los beans. Los datos de la interfaz
        suelen ser cadenas de texto. Los tipos de los datos de los beans
        dependen del modelo. JSF debe realizar esta conversi&oacute;n de formatos
        en
        la fase
        <em>Apply Request Value</em>
        para convertir los datos del
        usuario a datos del modelo y en la fase
        <em>Render Response</em>
        para
        hacer la conversi&oacute;n inversa. En concreto, el m&eacute;todo JSF que
        realiza
        esta conversi&oacute;n es
        <span class="codefrag">decode()</span>
        , que est&aacute; definido en todos
        los objetos componentes.
      </p>
<p>
        Por ejemplo, en el caso de la aplicaci&oacute;n Calculadora, los dos
        n&uacute;meros introducidos por el usuario se guardan en las
        propiedades
        <span class="codefrag">firstNumber</span>
        y
        <span class="codefrag">secondNumber</span>
        . Y el
        n&uacute;mero resultante se guarda en la propiedad
        <span class="codefrag">result</span>
        . Todas
        las propiedades son de tipo
        <span class="codefrag">int</span>
        . Cuando el usuario
        introduce los n&uacute;meros se deben convertir a este
        tipo. Y al rev&eacute;s;
        cuando se genera la p&aacute;gina se debe transformar del
        tipo de
        datos
        <span class="codefrag">int</span>
        a la cadena que se introduce en la p&aacute;gina
        HTML.
      </p>
<p>
        Si no se especifica nada en el componente, JSF utilizar el
        conversor
        por defecto de texto al tipo de datos del bean. Es posible
        tambi&eacute;n
        escoger el conversor que queremos utilizar en el componente,
        incluyendo en el componente la etiqueta
        <span class="codefrag">f:converter</span>
        y un
        identificador del conversor. Por ejemplo, para indicar que
        queremos
        aplicar un conversor de fecha con un formato corto a un
        componente de
        salida de texto, debemos especificar lo siguiente:
      </p>
<pre class="brush:xml;">&lt;h:outputText value="Fecha de salida: #{bean.fechaSalida}"&gt;
   &lt;f:convertDateTime dateStyle="short"/&gt;
&lt;/h:outputText&gt;</pre>
<p>Los posibles formatos de fecha son los siguientes, en el locale
        Ingl&eacute;s:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
        
<tr>
          
<th colspan="1" rowspan="1">Tipo</th>
          <th colspan="1" rowspan="1">Formato</th>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <span class="codefrag">default</span>
          </td>
          <td colspan="1" rowspan="1">Sep 9, 2003 5:41:15 PM</td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <span class="codefrag">short</span>
          </td>
          <td colspan="1" rowspan="1">9/9/03 5:41 PM</td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <span class="codefrag">medium</span>
          </td>
          <td colspan="1" rowspan="1">Sep 9, 2003 5:41:15 PM</td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <span class="codefrag">long</span>
          </td>
          <td colspan="1" rowspan="1">September 9, 2003 5:41:15 PM PST</td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <span class="codefrag">full</span>
          </td>
          <td colspan="1" rowspan="1">Tuesday, September 9, 2003 5:41:15 PM PST</td>
        
</tr>
      
</table>
<p>
        La conversi&oacute;n de la fecha depende del
        <span class="codefrag">locale</span>
        activo
        para la aplicaci&oacute;n. El locale, y el fichero de recursos
        asociado, se
        configura en el fichero
        <span class="codefrag">faces-config</span>
        :
      </p>
<pre class="brush:xml;">&lt;application&gt;
&lt;locale-config&gt;
  &lt;default-locale&gt;es&lt;/default-locale&gt;
  &lt;supported-locale&gt;en&lt;/supported-locale&gt;
&lt;/locale-config&gt;
&lt;message-bundle&gt;
  es.ua.jtech.MessageResources
&lt;/message-bundle&gt;
&lt;/application&gt;</pre>
<p>
        Si durante la conversi&oacute;n algo va mal y se produce un error (debido,
        por ejemplo, a que el usuario no ha introducido correctamente el
        valor), se marca el valor como no v&aacute;lido y se a&ntilde;ade un mensaje de
        error a la lista mantenida en el contexto de la sesi&oacute;n JSF,
        implementado por un objeto de la clase
        <span class="codefrag">FacesContext</span>
        . Esta
        es la misma lista que ser&aacute; utilizada tambi&eacute;n por los
        validadores. Los
        mensajes de error pueden mostrarse con las
        etiquetas
        <span class="codefrag">h:messages</span>
        (todos los mensajes)
        y
        <span class="codefrag">h:message for:</span>
        <em>identificador</em>
        . Por ejemplo, en
        el siguiente fragmento de p&aacute;gina JSF definimos un
        componente con el
        identificador
        <span class="codefrag">firstNumber</span>
        y escribimos a continuaci&oacute;n el
        mensaje de error que se pueda generar
        en &eacute;l:
      </p>
<pre class="brush:xml;">&lt;h:outputLabel value="Primer n&uacute;mero"/&gt;
&lt;h:inputText id="firstNumber" 
         value="#{calculatorBean.firstNumber}" 
 required="true"/&gt;
&lt;h:message for="firstNumber"/&gt;
</pre>
<a name="N10364"></a><a name="Custom+converters"></a>
<h3 class="underlined_5">Custom converters</h3>
<p>JSF nos permite crearnos conversores espec&iacute;ficos
          para cubrir
          necesidades m&aacute;s espec&iacute;ficas, como por ejemplo
          DNIs/pasaportes,
          n&uacute;meros de cuenta bancaria y, en general, cualquier objeto que
          necesitemos.
      </p>
<p>Un conversor es una clase que convierte de String a objeto y
          viceversa. Debe implementar la interfaz Converter, que proporciona
          los m&eacute;todos:</p>
<ul>
          
<li>
            
<em>Object getAsObject(FacesContext context, UIComponent
              component,
              String newValue)</em>: Convierte un String en un objeto del tipo
            deseado. Lanza una
            ConverterException si la conversi&oacute;n no se puede
            llevar a cabo.
          </li>

          
<li>
            
<em>String getAsString(FacesContext context, UIComponent
              component,
              Object value)</em>: Convierte un objeto en String para que pueda
            mostrarse en la
            pantalla del usuario.
          </li>
        
</ul>
<pre class="brush:java;">package es.ua.jtech.jsf.converter;

import javax.faces.application.FacesMessage;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import javax.faces.convert.ConverterException;
import javax.faces.convert.FacesConverter;

import es.ua.jtech.jsf.beans.DniBean;

@FacesConverter("conversorDni")
public class DniConverter implements Converter {

  public Object getAsObject(FacesContext context, UIComponent component, String value) 
          throws ConverterException {
    boolean situacionDeError = false;
    DniBean dni = new DniBean();
    dni.setNumero(value.substring(0, 8));
    dni.setLetra(value.substring(8, 9));

    if (situacionDeError) {
      FacesMessage message = new FacesMessage(FacesMessage.SEVERITY_ERROR, 
           "Se ha producido un error en la conversi&oacute;n", 
           "Detalle del error");
      throw new ConverterException(message);
    }

    return dni;
  }

  public String getAsString(FacesContext context, UIComponent component, Object value) 
        throws ConverterException {
    DniBean dni = (DniBean) value;
    return dni.getNumero() + dni.getLetra();
  }
}</pre>
<p>Como hemos visto, definimos nuestro conversor con la anotaci&oacute;n
          <em>@FacesConverter</em>, a la que se le ha asignado un ID (en este caso,
          conversorDni). As&iacute;, para validar el dni del usuario,
          habr&aacute; que usar el conversor como hemos visto anteriormente:</p>
<pre class="brush:xml;">&lt;h:inputText value="#{usuario.dni}"&gt;
   &lt;f:converter converterId="conversorDni"/&gt;
&lt;/h:inputText&gt;</pre>
<p>o bien</p>
<pre class="brush:xml;">&lt;h:inputText value="#{usuario.dni}" converter="conversorDni"/&gt;</pre>
<p>Yendo un poco m&aacute;s all&aacute;, podemos anotar nuestro conversor de la siguiente manera, para que se 
        aplique siempre que usemos un objeto del tipo Dni.class</p>
<pre class="brush:java;">@FacesConverter(forClass=Dni.class)
...</pre>
<p>De esta manera, y simplemente usando <em>&lt;h:inputText value="#{usuario.dni}" /&gt;</em>, la implementaci&oacute;n de 
        JSF buscar&aacute; los conversores definidos para esta clase.</p>
<p>En algunas ocasiones, puede que sea necesario enviar alg&uacute;n par&aacute;metro adicional a nuestro conversor. Para ello, usamos el tag <em>f:attribute</em>.</p>
<pre class="brush:xml;">&lt;h:outputText value="#{usuario.dni}"&gt;
   &lt;f:converter converterId="es.ua.jtech.Dni"/&gt;
   &lt;f:attribute name="separador" value="-"/&gt;
&lt;/h:outputText&gt;</pre>
<p>As&iacute;, en nuestro conversor recogeremos el atributo de la siguiente manera:</p>
<pre class="brush:xml;">String separator = (String) component.getAttributes().get("separator");</pre>
</div>
    
    
<a name="N103BA"></a><a name="Validaci%C3%B3n"></a>
<h2 class="underlined_10">Validaci&oacute;n</h2>
<div class="section">
<p>Una vez que se ha convertido con &eacute;xito el valor, los validadores se encargan de asegurar 
      que los datos de nuestra aplicaci&oacute;n tienen los valores esperados, como por ejemplo:</p>
<ul>
        
<li>Una fecha tiene el formato dd/MM/yyyy</li>
        
<li>Un float se encuentra entre los valores 1.0 y 100.0</li>
      
</ul>
<p>La implementaci&oacute;n JSF provee un mecanismo que nos permite realizar una serie de validaciones sobre un 
      componente, simplemente a&ntilde;adiendo un tag dentro del mismo:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
        
<tr>
          
<th colspan="1" rowspan="1">Tag</th>
          <th colspan="1" rowspan="1">Validator</th>
          <th colspan="1" rowspan="1">Atributos</th>
          <th colspan="1" rowspan="1">Descripci&oacute;n</th>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1"><span class="codefrag">f:validateDoubleRange</span></td>
          <td colspan="1" rowspan="1"><span class="codefrag">DoubleRangeValidator</span></td>
          <td colspan="1" rowspan="1"><span class="codefrag">minimum, maximum</span></td>
          <td colspan="1" rowspan="1">Un valor <span class="codefrag">double</span>, con un rango opcional</td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1"><span class="codefrag">f:validateLongRange</span></td>
          <td colspan="1" rowspan="1"><span class="codefrag">LongRangeValidator</span></td>
          <td colspan="1" rowspan="1"><span class="codefrag">minimum, maximum</span></td>
          <td colspan="1" rowspan="1">Un valor <span class="codefrag">long</span>, con un rango opcional</td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1"><span class="codefrag">f:validateLength</span></td>
          <td colspan="1" rowspan="1"><span class="codefrag">LengthValidator</span></td>
          <td colspan="1" rowspan="1"><span class="codefrag">minimum, maximum</span></td>
          <td colspan="1" rowspan="1">Un <span class="codefrag">String</span>, con un m&iacute;nimo y un m&aacute;ximo de caracteres</td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1"><span class="codefrag">f:validateRequired</span></td>
          <td colspan="1" rowspan="1"><span class="codefrag">RequiredValidator</span></td>
          <td colspan="1" rowspan="1"></td>
          <td colspan="1" rowspan="1">Valida la presencia de un valor</td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1"><span class="codefrag">f:validateRegex</span></td>
          <td colspan="1" rowspan="1"><span class="codefrag">RegexValidator</span></td>
          <td colspan="1" rowspan="1"><span class="codefrag">pattern</span></td>
          <td colspan="1" rowspan="1">Valida un <span class="codefrag">String</span> contra una expresi&oacute;n regular</td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1"><span class="codefrag">f:validateBean</span></td>
          <td colspan="1" rowspan="1"><span class="codefrag">BeanValidator</span></td>
          <td colspan="1" rowspan="1"><span class="codefrag">validation-Groups</span></td>
          <td colspan="1" rowspan="1">Especifica grupos de validaci&oacute;n para los validadores</td>
        
</tr>
      
</table>
<div class="frame warning">
<div class="label">Aviso</div>
<div class="content">Los espacios en blanco por defecto cuentan como valores v&aacute;lidos en un <span class="codefrag">required</span>. Si no nos interesa que esto ocurrra, en 
JSF 2.0 podemos modificar este comportamiento estableciendo, en el fichero <span class="codefrag">web.xml</span>, el par&aacute;metro de contexto 
<span class="codefrag">javax.faces.INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL</span> a <span class="codefrag">true</span>
</div>
</div>
<p>
        Al igual que con los conversores, si alg&uacute;n valor no cumple la
        validaci&oacute;n se marca como no v&aacute;lido y se a&ntilde;ade un mensaje de error
        al
        <span class="codefrag">FacesContext</span>
        . Por ejemplo, el siguiente c&oacute;digo
        comprobar&iacute;a que el n&uacute;mero
        introducido es mayor que cero
      </p>
<pre class="brush:xml;">&lt;h:outputLabel value="Primer n&uacute;mero"/&gt;
&lt;h:inputText id="firstNumber"
   value="#{calculatorBean.firstNumber}" 
   required="true"&gt;
      &lt;f:validateLongRange minimum="0"/&gt;
&lt;/h:inputText&gt;
&lt;h:message for="firstNumber"/&gt;</pre>
<p>Desde JSF 1.2 podemos definir un mensaje personalizado para un componente, 
    estableciendo valores a los atributos <span class="codefrag">requiredMessage</span> y/o <span class="codefrag">validatorMessage</span>:</p>
<pre class="brush:xml;">&lt;h:inputText id="card" value="#{usuario.dni}" required="true"
      requiredMessage="El DNI es obligatorio"
      validatorMessage="El DNI no es v&aacute;lido"&gt;
   &lt;f:validateLength minimum="9"/&gt;
&lt;/h:inputText&gt;</pre>
<p>Adem&aacute;s, podemos sobreescribir lso mensajes de error de los validadores est&aacute;ndar en un fichero de propiedades:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
    
<tr>
      
<th colspan="1" rowspan="1">Resource ID</th>
      <th colspan="1" rowspan="1">Texto por defecto</th>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">javax.faces.component.UIInput.REQUIRED</span></td>
      <td colspan="1" rowspan="1">{0}: Validation Error: Value is required</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">javax.faces.validator.DoubleRangeValidator.NOT_IN_RANGE; javax.faces.validator.LongRangeValidator.NOT_IN_RANGE</span></td>
      <td colspan="1" rowspan="1">{2}: ValidationError: Specified attribute is not between the expeced values of {0} and {1}</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">javax.faces.validator.DoubleRangeValidator.MAXIMUM; javax.faces.validator.LongRangeValidator.MAXIMUM</span></td>
      <td colspan="1" rowspan="1">{1}: Validation Error: Value is greater than allowable maximum of  {0}</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">javax.faces.validator.DoubleRangeValidator.MINIMUM; javax.faces.validator.LongRangeValidator.MINIMUM</span></td>
      <td colspan="1" rowspan="1">{1}: Validation Error: Value is less than allowable minimum of  {0}</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">javax.faces.validator.DoubleRangeValidator.TYPE; javax.faces.validator.LongRangeValidator.TYPE</span></td>
      <td colspan="1" rowspan="1">{1}: Validation Error: Value is not of the correct type</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">javax.faces.validator.LengthValidator.MAXIMUM</span></td>
      <td colspan="1" rowspan="1">{1}: ValidationError: Value is greater than allowable maximum of {0}</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">javax.faces.validator.LengthValidator.MINIMUM</span></td>
      <td colspan="1" rowspan="1">{1}: ValidationError: Value is less than allowable maximum of {0}</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">javax.faces.valiadtor.BeanValidator.MESSAGE</span></td>
      <td colspan="1" rowspan="1">{0}</td>
    
</tr>
  
</table>
<div class="frame warning">
<div class="label">Aviso</div>
<div class="content">Por defecto, los validadores se ejecutar&aacute;n siempre a no ser que indiquemos lo contrario. 
  Es decir, que si estoy en una pantalla de registro, le doy al bot&oacute;n CANCELAR y he introducido 
  alg&uacute;n valor no v&aacute;lido, no podr&eacute; salir de ah&iacute; hasta que lo solvente. Como esto se trata de un 
  comportamiento no deseado, ya que queremos salir de ah&iacute; sin importarnos la validaci&oacute;n, podemos 
  salt&aacute;rnosla estableciendo a true el valor <span class="codefrag">immediate</span> de nuestros <span class="codefrag">commandButton</span> o 
  <span class="codefrag">commandLink</span>.</div>
</div>
<a name="N10545"></a><a name="JSR+303"></a>
<h3 class="underlined_5">JSR 303</h3>
<p>JSF 2.0 se integra con el Bean Validation Framework (JSR303), un framework que especifica <em>validation constraints</em>. Estos validadores son anotaciones ligadas a atributos de una clase java o a sus getters:</p>
<pre class="brush:java;">public class PagoBean {
   @Size(min=13) private String card;
   @Future public Date getDate() { ... }
   ...
}</pre>
<p>Las anotaciones que nos ofrece JSR303 son:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
        
<th colspan="1" rowspan="1">Anotaci&oacute;n</th>
        <th colspan="1" rowspan="1">Atributos</th>
        <th colspan="1" rowspan="1">Descripci&oacute;n</th>
      
</tr>
      
<tr>
        
<td colspan="1" rowspan="1"><span class="codefrag">@Null, @NotNull</span></td>
        <td colspan="1" rowspan="1">Ninguno</td>
        <td colspan="1" rowspan="1">Comprueba que un valor sea nulo o no lo sea</td>
      
</tr>
      
<tr>
        
<td colspan="1" rowspan="1"><span class="codefrag">@Min, @Max</span></td>
        <td colspan="1" rowspan="1">El l&iacute;mite como <span class="codefrag">long</span></td>
        <td colspan="1" rowspan="1">Comprueba que un valor es, como m&aacute;ximo o como m&iacute;nimo, el valor l&iacute;mite descrito. El tipo debe ser <span class="codefrag">int, long, short, byte</span>, o a de sus <em>wrappers</em> (<span class="codefrag">BigInteger, BigDecimal, String</span>)</td>
      
</tr>
      
<tr>
        
<td colspan="1" rowspan="1"><span class="codefrag">@DecimalMin, @DecimalMax</span></td>
        <td colspan="1" rowspan="1">El l&iacute;mite como <span class="codefrag">String</span></td>
        <td colspan="1" rowspan="1">Igual que la anterior, puede aplicarse a un <span class="codefrag">String</span></td>
      
</tr>
      
<tr>
        
<td colspan="1" rowspan="1"><span class="codefrag">@Digits</span></td>
        <td colspan="1" rowspan="1"><span class="codefrag">integer, fraction</span></td>
        <td colspan="1" rowspan="1">Comprueba que un valor tiene, como m&aacute;ximo, el n&uacute;mero dado de d&iacute;gitos enteros o fraccionales. Se aplica a <span class="codefrag">int, long, short, byte</span>, o a de sus <em>wrappers</em> (<span class="codefrag">BigInteger, BigDecimal, String</span>)</td>
      
</tr>
      
<tr>
        
<td colspan="1" rowspan="1"><span class="codefrag">@AssertTrue, @AssertFalse</span></td>
        <td colspan="1" rowspan="1">Ninguno</td>
        <td colspan="1" rowspan="1">Comprueba que un booleano es verdadero o false</td>
      
</tr>
      
<tr>
        
<td colspan="1" rowspan="1"><span class="codefrag">@Past, @Future</span></td>
        <td colspan="1" rowspan="1">Ninguno</td>
        <td colspan="1" rowspan="1">Comprueba que una fecha est&eacute; en el pasado o en el futuro</td>
      
</tr>
      
<tr>
        
<td colspan="1" rowspan="1"><span class="codefrag">@Size</span></td>
        <td colspan="1" rowspan="1"><span class="codefrag">min, max</span></td>
        <td colspan="1" rowspan="1">Comprueba que el tama&ntilde;o de una cadena, array, colecci&oacute;n o mapa est&aacute; en los l&iacute;mites definidos</td>
      
</tr>
      
<tr>
        
<td colspan="1" rowspan="1"><span class="codefrag">@Pattern</span></td>
        <td colspan="1" rowspan="1"><span class="codefrag">regexp, flags</span></td>
        <td colspan="1" rowspan="1">Una expresi&oacute;n regular, y sus flags opcionales de compilaci&oacute;n</td>
      
</tr>
    
</table>
<p>El uso de JSR303 tiene una clara ventaja sobre la validaci&oacute;n a nivel de p&aacute;gina: supongamos que realizamos una actualizaci&oacute;n importante en un bean, que es usado en muchas p&aacute;ginas. De esta manera no necesitamos cambiar las reglas de validaci&oacute;n m&aacute;s que en la clase para que se aplique a todas las p&aacute;ginas por igual, y as&iacute; no se nos escapar&aacute; por error ninguna de ellas.</p>
<p>Para sobreescribir los mensajes de error, hay que crear un fichero ValidationMessages.properties en la ra&iacute;z del paquete, e introducir all&iacute; los mensajes:</p>
<pre class="brush:java;">javax.validation.constraints.Min.message=El valor debe ser como m&iacute;nimo {value}</pre>
<p>Adem&aacute;s, para dar un valor espec&iacute;fico para un caso concreto, podemos referenciar a la clave del mensaje en la anotaci&oacute;n:</p>
<pre class="brush:java;">@Size(min=9, max=9, message="{es.ua.jtech.longitudDni}")
private String dni = "";</pre>
<p>E introducir ese mensaje en nuestro ValidationMessages.properties</p>
<pre class="brush:java;">es.ua.jtech.longitudDni = El DNI debe tener 9 caracteres</pre>
<div class="frame warning">
<div class="label">Aviso</div>
<div class="content">Si usamos un servidor de aplicaciones compatible con Java EE 6, tendremos autom&aacute;ticamente acceso a la implementaci&oacute;n de JSR 303. En otro caso, deberemos incluir el jar de Hibernate Calidator en el directorio <span class="codefrag">WEB-INF/lib</span>
</div>
</div>
<a name="N10642"></a><a name="Custom+validators"></a>
<h3 class="underlined_5">Custom validators</h3>
<p>Para implementar nuestro propio validador, tendremos que crear una clase que implemente la interfaz <span class="codefrag">javax.faces.validator.Validator</span>, que nos ofrece el m&eacute;todo <span class="codefrag">public void validate(FacesContext context, UIComponent component,  Object value)</span>
</p>
<p>
        Es posible adem&aacute;s programar validadores adicionales a los ya
        existentes en el framework. Estos nuevos validadores definidos
        deber&iacute;an ser, en lo posible, reusables para m&aacute;s de un formulario y
        m&aacute;s
        de una aplicaci&oacute;n. Por ejemplo, podr&iacute;amos construir un validador
        que
        comprobara si una cadena es un c&oacute;digo correcto de tarjeta Visa
        (la
        implementaci&oacute;n de JSF de Apache
        <em>MyFaces</em>
        lo hace).
      </p>
<p>Como ejemplo de implementaci&oacute;n de nuevos validadores, vamos a
        definir un validador que s&oacute;lo permita introducir n&uacute;meros pares en
        nuestra calculadora. No es un ejemplo realista de validaci&oacute;n, pero
        nos
        sirve para explicar el funcionamiento del framework.</p>
<p>Los pasos para definir un validador propio son los siguientes:</p>
<ol>
        
<li>
          Crear una clase que implemente la
          interfaz
          <span class="codefrag">javax.faces.validator.Validator</span>
          e implementar
          en esa clase el m&eacute;todo
          <span class="codefrag">validate</span>
          .
        </li>
        
<li>
          Anotarlo con la interfaz <span class="codefrag">@FacesValidator("validator_Id")</span>.
        </li>
        
<li>
          Usar la etiqueta
          <span class="codefrag">&lt;f:validator validatorId="validator_Id" /&gt;</span>
          en las
          vistas JSF.
        </li>
      
</ol>
<p>
        He aqu&iacute; el c&oacute;digo que habr&iacute;a que a&ntilde;adir a la aplicaci&oacute;n
        <span class="codefrag">calculator</span>
        , paso a paso.
      </p>
<ol>
        
<li>
          
<p>
            
<strong>
              Implementamos la
              interfaz
              <span class="codefrag">Validator</span>
            </strong>
            .
          </p>
          
<p>
            El primer paso es definir una clase que implemente la
            interfaz
            <span class="codefrag">Validator.</span>
            y el
            m&eacute;todo
            <span class="codefrag">validate</span>
            . Para ello creamos el
            fichero
            <span class="codefrag">calculator.validator.PairNumberValidator</span>
            :
          </p>


<pre class="brush:java;">package calculator.validator;

import javax.faces.application.FacesMessage;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.validator.FacesValidator;
import javax.faces.validator.Validator;
import javax.faces.validator.ValidatorException;

@FacesValidator("calculator.isPair")
public class PairNumberValidaotr implements Validator{
  public void validate(FacesContext context, UIComponent component, Object value)
                      throws ValidatorException {
    int number = ((Integer)value).intValue();
    
    if(number%2 != 0){
      FacesMessage message = new FacesMessage(FacesMessage.SEVERITY_ERROR, 
             "No es un n&uacute;mero par", "No es un n&uacute;mero par");
    }
  }
}
</pre>

          
<p>
            El m&eacute;todo
            <span class="codefrag">validate()</span>
            recibe el
            objeto
            <span class="codefrag">value</span>
            , que en este caso ser&aacute; la conversi&oacute;n
            a
            <span class="codefrag">String</span>
            del valor que ha introducido el usuario.
          </p>
        
</li>
        
<li>
          Al anotarlo con la interfaz <span class="codefrag">@FacesValidator</span>, le hemos asignaod el ID <span class="codefrag">calculator.isPair</span>.
        </li>

        
<li>
          
<p>
            
<strong>
              Usamos la etiqueta
              <span class="codefrag">f:validator</span>
              en los
              ficheros XHTML
            </strong>
            .
          </p>
          
<p>
            A&ntilde;adimos el siguiente c&oacute;digo en los dos
            <span class="codefrag">inputText</span>
            del fichero
            <span class="codefrag">calculator.xhtml</span>
            , asociando el validador
            definido a los dos componentes de entrada.
          </p>


<pre class="brush:xml;">
&lt;h:inputText id="firstNumber" value="#{calcBean.firstNumber}" required="true"&gt;
    &lt;f:validator validatorId="calculator.isPair"/&gt;
&lt;/h:inputText&gt; </pre>
        
</li>
      
</ol>
<p>El resultado se puede comprobar en la siguiente p&aacute;gina HTML
        generada cuando se introducen n&uacute;meros impares en la calculadora.</p>
<p>
        
<img alt="P&aacute;gina que muestra el mensaje generado por el validador propio." content-width="8cm" src="img/sesion4/validator.gif" width="400">
      </p>
</div>

    
<a name="N106D7"></a><a name="Contexto+asociado+a+la+petici%C3%B3n"></a>
<h2 class="underlined_10">Contexto asociado a la petici&oacute;n</h2>
<div class="section">
<p>Hemos dicho que cada petici&oacute;n procesada por JSF est&aacute; asociada con
        un &aacute;rbol de componentes (llamado tambi&eacute;n una "vista") que se define
        en
        la vista JSF con el mismo nombre que la petici&oacute;n. Cuando se
        realiza
        una petici&oacute;n de una vista por primera vez se crea el &aacute;rbol de
        componentes asociado. Las peticiones siguientes que se hagan sobre
        la
        misma vista recuper&aacute;n el &aacute;rbol de componentes ya creado y asociado
        a
        la petici&oacute;n anteriormente creada.</p>
<p>
        Veamos un ejemplo con la aplicaci&oacute;n
        anterior
        <span class="codefrag">calculator</span>
        . Cuando desde el navegador
        solicitamos la
        URI
        <span class="codefrag">http://localhost:8080/jsf-calculadora/faces/calculator.xhtml</span>
        se accede a la p&aacute;gina
        <span class="codefrag">calculator.xhtml</span>
        .
      </p>
<p>
        En el fichero
        <span class="codefrag">web.xml</span>
        se configura el mapeo de
        peticiones para que las peticiones que
        contienen
        <span class="codefrag">/faces/</span>
        sean procesadas por el
        servlet
        <span class="codefrag">javax.faces.webapp.FacesServlet</span>
        .
      </p>
<pre class="brush:xml;">&lt;!-- Faces Servlet --&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
      &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
      &lt;load-on-startup&gt; 1 &lt;/load-on-startup&gt;
   &lt;/servlet&gt;

    &lt;!-- Faces Servlet Mapping --&gt;
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/faces/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
</pre>
<p>
        El servlet analiza la URI de la petici&oacute;n, y decodifica el nombre de
        la vista a mostrar (
        <span class="codefrag">calculator.xhtml</span>
        ). El identificador de
        la sesi&oacute;n sirve para recuperar la vista
        asociada a una petici&oacute;n previa
        de ese mismo recurso y esa misma
        sesi&oacute;n, en el caso de que ya se
        hubiera solicitado esa vista
        previamente. En este caso, sin embargo,
        se trata de la primera
        petici&oacute;n que se realiza en la sesi&oacute;n sobre
        esta
        vista. JSF construye
        entonces el &aacute;rbol de componentes definido por el
        fichero
        <span class="codefrag">calculator.xhtml</span>
        y se guarda en
        el
        <span class="codefrag">FacesContext</span>
        asociado a la petici&oacute;n actual.
      </p>
<p>
        Tambi&eacute;n es posible generar una petici&oacute;n desde el cliente cuando se
        pulsa en alg&uacute;n bot&oacute;n generado por una
        etiqueta
        <span class="codefrag">&lt;h:commandButton&gt;</span>
        o se pincha en un
        enlace resultante de una
        etiqueta
        <span class="codefrag">&lt;h:commandLink</span>
        . En nuestra
        aplicaci&oacute;n esto sucede, por ejemplo, cuando pulsamos en
        el enlace
        "calcular" de la p&aacute;gina principal de la aplicaci&oacute;n. En este
        caso la
        vista asociada a la petici&oacute;n que JSF recupera es la propia
        vista desde
        la que se realiza la petici&oacute;n, ya que es la que
        corresponde al
        formulario que debe ser procesado. En la petici&oacute;n se
        env&iacute;an los
        nuevos
        valores que el usuario ha modificado y la acci&oacute;n
        solicitada por el
        usuario ("calcular"). JSF realiza entonces el
        procesamiento de la
        petici&oacute;n que veremos m&aacute;s adelante.
      </p>
<p>
        Cada petici&oacute;n tiene asociado un contexto, en forma de una instancia
        de
        <span class="codefrag">FacesContext</span>
        . Este contexto se usa para almacenar los
        distintos objetos que
        necesarios para procesar la petici&oacute;n hasta
        generar el
        <em>render</em>
        de la interfaz que se est&aacute; construyendo. En
        concreto, gestiona los
        siguientes aspectos de la petici&oacute;n
        recibida:
      </p>
<ul>
        
<li>la cola de mensajes</li>
        
<li>el &aacute;rbol de componentes</li>
        
<li>objetos de configuraci&oacute;n de la aplicaci&oacute;n</li>
        
<li>m&eacute;todos de control del flujo del ciclo de vida</li>
      
</ul>
<p>
        Algunos de los m&eacute;todos definidos en el objeto
        <span class="codefrag">FacesContext</span>
        se listan en la siguiente tabla.
      </p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
        
<tr>
          
<th colspan="1" rowspan="1">M&eacute;todo</th>
          <th colspan="1" rowspan="1">Descripci&oacute;n</th>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <span class="codefrag">addMessage()</span>
          </td>
          <td colspan="1" rowspan="1">A&ntilde;ade un mensaje a la cola de mensajes de la petici&oacute;n.</td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <span class="codefrag">getExternalContext()</span>
          </td>
          <td colspan="1" rowspan="1">
            Obtiene el contexto externo (normalmente el contexto del
            servlet
            <span class="codefrag">FacesServlet</span>
            ) en el que se est&aacute; procesando la
            petici&oacute;n.
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <span class="codefrag">getMessages()</span>
          </td>
          <td colspan="1" rowspan="1">
            Obtiene un
            <span class="codefrag">Iterator</span>
            sobre los mensajes que han
            sido encolados.
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <span class="codefrag">getRenderKit()</span>
          </td>
          <td colspan="1" rowspan="1">
            Obtiene la instancia de
            <span class="codefrag">RenderKit</span>
            especificada
            para el
            <span class="codefrag">UIViewRoot</span>
            , si existe.
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <span class="codefrag">getViewRoot()</span>
          </td>
          <td colspan="1" rowspan="1">
            Obtiene el
            <span class="codefrag">UIViewRoot</span>
            asociado a la
            petici&oacute;n.
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <span class="codefrag">renderResponse()</span>
          </td>
          <td colspan="1" rowspan="1">
            Se&ntilde;ala a la implementaci&oacute;n de JSF que, tan pronto como la fase
            actual del procesamiento de la petici&oacute;n se haya completado, se
            debe pasar el control a la fase
            <em>Render Response</em>
            pasando
            por alto todas las fases que no se hayan ejecutado
            todav&iacute;a.
          </td>
        
</tr>
      
</table>
<p>
        La cola de mensajes de una petici&oacute;n mantiene un conjunto de
        mensajes
        de error que se pueden producir en las distintas fases del
        ciclo de
        vida de la misma. El m&eacute;todo
        <span class="codefrag">addMessage</span>
        se usa
        para a&ntilde;adir un nuevo mensaje de error en la cola. Es posible
        usar el
        m&eacute;todo
        <span class="codefrag">getMessages()</span>
        sobre el
        <span class="codefrag">FacesContext</span>
        para obtener una colecci&oacute;n de todos los mensajes de error asociados
        a
        una petici&oacute;n. Tambi&eacute;n es posible mostrar todos los mensajes
        del
        <span class="codefrag">FacesContext</span>
        en el propio componente que se est&aacute;
        construyendo mediante la
        etiqueta
        <span class="codefrag">&lt;h:messages/&gt;</span>
        .
      </p>
<p>
        El m&eacute;todo
        <span class="codefrag">getViewRoot</span>
        devuelve el
        componente
        <span class="codefrag">UIViewRoot</span>
        asociado a la petici&oacute;n. Este
        componente es un tipo especial de
        componente que representa la ra&iacute;z
        del &aacute;rbol.
      </p>
<p>
        Vamos a ver un ejemplo de programaci&oacute;n con los distintos elementos
        del
        <span class="codefrag">FacesContext</span>
        usando nuestra
        aplicaci&oacute;n
        <span class="codefrag">calculator</span>
        .
      </p>
<p>
        En primer lugar, para poder trabajar con
        el
        <span class="codefrag">FacesContext</span>
        hay que obtener la instancia asociada a
        la petici&oacute;n actual. Para ello
        basta con llamar al m&eacute;todo
        est&aacute;tico
        <span class="codefrag">getCurrentInstance()</span>
        de la
        clase
        <span class="codefrag">FacesContext</span>
        :
      </p>
<pre class="brush:java;">
import javax.faces.context.FacesContext;
...
FacesContext context = FacesContext.getCurrentInstance();
...
</pre>
<p>
        Podemos hacer esta llamada en el m&eacute;todo
        <span class="codefrag">validate()</span>
        de
        un
        <span class="codefrag">Validator</span>
        , en el m&eacute;todo
        <span class="codefrag">decode()</span>
        de
        un
        <span class="codefrag">Renderer</span>
        , en un manejador de una acci&oacute;n o en cualquier
        otro punto en el que
        escribamos c&oacute;digo que extiende
        el framework. Una vez obtenido el
        <span class="codefrag">FacesContext</span>
        asociado a la petici&oacute;n actual es posible acceder a sus elementos.
      </p>
<p>
        Vamos a modificar el m&eacute;todo
        <span class="codefrag">validate</span>
        que hemos
        implementado anteriormente para acceder al
        <span class="codefrag">FacesContext</span>
        y
        a uno de sus elementos m&aacute;s importantes: el &aacute;rbol de componetes. El
        siguiente c&oacute;digo consigue esto.
      </p>
<pre class="brush:java;">package calculator.validator;
...
import javax.faces.component.UIComponentBase;
import javax.faces.component.UIViewRoot;
import javax.faces.context.FacesContext;

public class PairNumberValidator implements Validator {
  public void validate(FacesContext arg0, 
      UIComponent component, Object value)
      throws ValidatorException {
    FacesContext context = FacesContext.getCurrentInstance();
    UIViewRoot viewRoot = context.getViewRoot();
    String ids = getComponentIds(viewRoot);
    FacesMessage message = new FacesMessage("Componentes: "+ ids);
    context.addMessage(null,message);
    ...
  }


  // Obtiene los identificadores y tipos de un componente y de sus hijos.
  // Se llama a si misma de forma recursiva
  private String getComponentIds(UIComponentBase component) {
    String ids = "";
    ids += component.getFamily() + " (" + component.getId() + ") ";
    Iterator it = component.getFacetsAndChildren();
    while (it.hasNext()) {
      UIComponentBase childComponent = (UIComponentBase) it.next();
      ids += getComponentIds(childComponent);
    }
    return ids;
  }
}</pre>
<p>
        Una vez obtenido el
        <span class="codefrag">FacesContext</span>
        , lo usamos para
        conseguir el
        <span class="codefrag">UIViewRoot</span>
        de la petici&oacute;n, el componente
        ra&iacute;z del &aacute;rbol de componentes asociado
        a la petici&oacute;n JSF. Una vez
        obtenido, llamamos al m&eacute;todo
        <span class="codefrag">getComponentIds()</span>
        , un m&eacute;todo
        que est&aacute; implementado m&aacute;s adelante que recorre
        recursivamente el &aacute;rbol
        de componentes y devuelve una cadena con
        todos los tipos de
        componente
        y su identificador.
      </p>
<p>
        En el m&eacute;todo
        <span class="codefrag">getComponentIds()</span>
        se llama
        a
        <span class="codefrag">getFacetsAndChildren</span>
        , un m&eacute;todo del componente que
        devuelve un iterador con los hijos
        inmediatos y
        los
        <span class="codefrag">Facets</span>
        asociados.
      </p>
<p>
        Una vez obtenida la cadena con los tipos e identificadores de los
        componentes, se a&ntilde;ade en la cola de mensajes del contexto de la
        petici&oacute;n con el m&eacute;todo
        <span class="codefrag">addMessage()</span>
        . Estos mensajes
        podemos mostrarlos con la
        etiqueta
        <span class="codefrag">&lt;h:messages/&gt;</span>
        colocada en la parte
        inferior de la p&aacute;gina.
      </p>
<p>La siguiente imagen muestra lo que aparece en pantalla. Hay que
        notar que esta pantalla s&oacute;lo aparece cuando introducimos un error en
        la validaci&oacute;n del n&uacute;mero.</p>
<p>
        
<img alt="&Aacute;rbol de componentes" content-width="12cm" src="imagenes/tema02/componentes.png" width="600">
      </p>
</div>

    
<a name="N10835"></a><a name="%C3%81rbol+de+componentes"></a>
<h2 class="underlined_10">&Aacute;rbol de componentes</h2>
<div class="section">
<p>Recordemos JSF funciona en tres fases: primero genera un &aacute;rbol de
        componentes (objetos Java) a partir de la vista JSF asociada a la
        petici&oacute;n, despu&eacute;s activa el ciclo de vida de los componentes en el
        que
        se eval&uacute;an las expresiones EL y se procesan los eventos
        generados, y
        por &uacute;ltimo se renderizan los componentes resultantes.
      </p>
<p>
        En JSF los componentes se organizan en
        <em>vistas</em>
        . Cuando el
        framework recibe una petici&oacute;n, se construye una vista con
        los
        componentes relacionados con la petici&oacute;n. Una vista es un &aacute;rbol
        de
        componentes, cuya ra&iacute;z debe ser una instancia
        de
        <span class="codefrag">UIViewRoot</span>
        , una clase que no tiene rendering y que
        s&oacute;lo sirve como ra&iacute;z del
        &aacute;rbol de componentes. Los componentes en el
        &aacute;rbol pueden ser an&oacute;nimos
        o pueden tener un identificador de
        componente proporcionado por el
        usuario del framework. Los
        componentes
        en el &aacute;rbol pueden ser
        localizados en base a estos identificadores de
        componentes, que deben
        ser &uacute;nicos en el espacio de nombres definido
        por los componentes
        hijos del antecesor m&aacute;s cercano que sea
        un
        <span class="codefrag">NamingContainer</span>
        .
      </p>
<p>&iquest;Qu&eacute; caracter&iacute;sticas tienen los componentes JSF (instancias que
        forman el &aacute;rbol de componentes)? En este apartado vamos a repasar
        algunas de las m&aacute;s importantes. </p>
<p>
        En primer lugar, todos los componentes JSF extienden la clase
        abstracta
        <span class="codefrag">javax.faces.component.UIComponentBase</span>
        , que
        proporciona la implementaci&oacute;n por defecto de los m&eacute;todos
        soportados
        por los componentes JSF.
      </p>
<p>Cada componente JSF contiene:</p>
<ul>
        
<li>Una lista de componentes hijos.</li>
        
<li>Una tabla hash de atributos.</li>
        
<li>Uno o m&aacute;s validadores.</li>
        
<li>Uno o m&aacute;s manejadores de eventos.</li>
        
<li>Un identificador para un renderer opcional.</li>
      
</ul>
<p>Todos los componentes JSF son potencialmente contenedores de otros
        componentes. De esta forma es posible construir componentes
        compuestos, una caracter&iacute;stica compartida por la mayor&iacute;a de
        frameworks
        de interfaces de usuario como Swing o Smalltalk.</p>
<p>Los componentes JSF mantienen una lista de atributos almacenados
        en
        una tabla hash e indexados por el nombre del atributo. Como valor
        del
        atributo es posible insertar cualquier objeto, como una direcci&oacute;n
        URL,
        un entero o una imagen.</p>
<p>Todos los componentes realizan tres tareas fundamentales:</p>
<ul>
        
<li>Validar los valores del componente.</li>
        
<li>Manejar los eventos del componente.</li>
        
<li>Renderizar el componente, normalmente generando c&oacute;digo HTML.
        </li>
      
</ul>
<p>Los componentes JSF pueden tener uno o m&aacute;s validadores que validan
        la entrada. Estos validadores, habitualmente creados por la
        implementaci&oacute;n JSF o por el usuario, se almancenan por componentes
        en
        un array list.</p>
<p>
        La gesti&oacute;n de eventos del componente puede manejarse directamente
        por un componente o se puede delegar en un manejador de eventos. Se
        pueden registrar uno o m&aacute;s manejadores de eventos para un componente
        en la fase
        <em>Apply Request Values</em>
        del ciclo de vida del
        componente. Los manejadores son registrados por
        el renderer del
        componente o por el componente mismo.
      </p>
<p>
        Los componentes JSF pueden renderizarse ellos mismos o delegar el
        renderizado a un renderer. El m&eacute;todo
        booleano
        <span class="codefrag">UIComponent.rendersSelf()</span>
        dice a la
        implementaci&oacute;n JSF si un componente se renderiza a si mismo
        o no. Si
        no, la implementaci&oacute;n JSF obtiene una referencia al renderer
        del
        componente con la llamada
        <span class="codefrag">UIComponent.getRendererType()</span>
        y
        despu&eacute;s llama al renderer para producir el c&oacute;digo HTML del
        componente.
      </p>
</div>

    
<a name="N10890"></a><a name="Ligando+componentes+a+beans+gestionados"></a>
<h2 class="underlined_10">Ligando componentes a beans gestionados</h2>
<div class="section">
<p>
        Mediante el atributo
        <span class="codefrag">binding</span>
        de una etiqueta es
        posible ligar un componente con una propiedad de
        un bean. Despu&eacute;s, en
        cualquier llamada a c&oacute;digo de la aplicaci&oacute;n, es
        posible acceder a
        esa
        propiedad y consultar o modificar el componente.
        Por ejemplo, en el
        siguiente c&oacute;digo ligamos el generado por la
        etiqueta
        <span class="codefrag">&lt;h:inputText&gt;</span>
        con la
        propiedad
        <span class="codefrag">inputText</span>
        del
        bean
        <span class="codefrag">todoController</span>
        :
      </p>
<pre class="brush:xml;">&lt;h:panelGroup&gt;
   &lt;h:inputText binding="#{todoController.inputText}" 
                size="30"/&gt;&lt;br/&gt;
   &lt;h:commandLink value="A&ntilde;adir projecto"
                actionListener="#{todoController.addNewProject}"
                immediate="true"/&gt;
&lt;/h:panelGroup&gt;
...
&lt;h:selectOneMenu id="project" required="true"
  value="#{todo.project}"&gt;
  &lt;f:selectItems value="#{todoController.projects}" /&gt;
&lt;/h:selectOneMenu&gt;
</pre>
<p>
        Despu&eacute;s, en el c&oacute;digo del m&eacute;todo
        <span class="codefrag">addNewProject</span>
        del
        bean podemos acceder al valor introducido por el usuario en
        el
        <span class="codefrag">inputText</span>
        , utilizando el objeto
        <span class="codefrag">UIInput</span>
        que hab&iacute;amos ligado con la etiqueta
        <span class="codefrag">binding</span>
        y que JSF ha
        guardado en la propiedad del bean:
      </p>
<pre class="brush:java;">public class TodoController {
  ...
  private UIInput inputText;
  ...
   
  public UIInput getInputText() {
    return inputText;
  }

  public void setInputText(UIInput inputText) {
    this.inputText = inputText;
  }
   
  public void addNewProject(ActionEvent event) {
    String newProject = (String)inputText.getSubmittedValue();
    inputText.setSubmittedValue(null);
    projects.add(newProject);
  }
  ...
}</pre>
<p>
        Cuando ligamos un componente a una propiedad de un bean, debemos
        declarar la propiedad de la misma clase que el componente. La
        siguiente tabla muestra las clases Java de los componentes de cada
        una
        de las etiquetas b&aacute;sicas JSF que se transforman en c&oacute;digo HTML
        (de ah&iacute;
        viene el prefijo
        <span class="codefrag">h:</span>
        ):
      </p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
        
<tr>
          
<th colspan="1" rowspan="1">Etiqueta</th>
          <th colspan="1" rowspan="1">Clase Java</th>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:column&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIColumn</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:commandButton&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UICommand</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:commandLink&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UICommand</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:dataTable&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIData</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:form&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIForm</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:graphicImage&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIGraphic</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:inputHidden&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIInput</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:inputSecret&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIInput</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:inputText&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIInput</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:inputTextarea&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIInput</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:message&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIMessage</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:messages&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIMessages</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:outputFormat&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIOutput</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:outputLabel&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIOutput</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:outputLink&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIOutput</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:outputText&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIOutput</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:panelGrid&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIPanel</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:panelGroup&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UIPanel</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:selectBooleanCheckbox&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UISelectBoolean</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:selectManyCheckbox&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UISelectMany</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:selectManyListbox&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UISelectMany</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:selectManyMenu&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UISelectMany</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:selectOneListbox&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UISelectOne</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:selectOneMenu&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UISelectOne</span>
            </strong>
          </td>
        
</tr>
        
<tr>
          
<td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">&lt;h:selectOneRadio&gt;</span>
            </strong>
          </td>
          <td colspan="1" rowspan="1">
            <strong>
              <span class="codefrag">UISelectOne</span>
            </strong>
          </td>
        
</tr>
      
</table>
<p>En el programa ejemplo de la sesi&oacute;n de ejercicios se utilizan
        algunos de estos componentes.</p>
<p>
        En todas estas etiquetas se pueden a&ntilde;adir elementos propios del
        HTML
        que se trasladar&aacute;n tal cual cuando se realice el renderizado. Por
        ejemplo, en todos los elementos es posible asignar un c&oacute;digo
        Javascript a eventos gestionados por el HTML,
        como
        <span class="codefrag">onclick</span>
        ,
        <span class="codefrag">ondblclick</span>
        ,
        <span class="codefrag">onmouseover</span>
        ,
        etc. En principio, el c&oacute;digo que se introduce en esos atributos no
        tiene ninguna implicaci&oacute;n en el ciclo de vida JSF. Sin embargo,
        algunas implementaciones de renders HTML incorporan algunas
        funcionalidades interesantes. Por ejemplo, aunque no es est&aacute;ndar, en
        la mayor&iacute;a de implementaciones de JSF, si el Javascript del
        atributo
        <span class="codefrag">onclick</span>
        de un
        <span class="codefrag">&lt;h:command&gt;</span>
        devuelve
        <span class="codefrag">false</span>
        no se lanza la petici&oacute;n asociada al
        comando. As&iacute; hemos implementado
        en el ejemplo la t&iacute;pica ventana de
        di&aacute;logo para confirmar un borrado:
      </p>
<pre class="brush:xml;">&lt;h:commandLink value="delete" action="#{todoController.delete}"
   onclick="if (!confirm('&iquest;Seguro que quieres borrar #{todo.title}?')) return false"&gt;
   ...
&lt;/h:commandLink&gt;</pre>
</div>
    
    
<a name="N10B63"></a><a name="Gesti%C3%B3n+de+eventos"></a>
<h2 class="underlined_10">Gesti&oacute;n de eventos</h2>
<div class="section">
<p>La gesti&oacute;n de eventos hace referencia a la necesidad de nuestras aplicaciones a responder a acciones del usuario, como pueden ser la selecci&oacute;n de &iacute;tems de un men&uacute; o hacer clic en un bot&oacute;n.</p>
<p>JSF soporta cuatro tipos distintos de eventos:</p>
<ul>
        
<li>Value change events.</li>
        
<li>Action events</li>
        
<li>Phase events</li>
        
<li>System events (a partir de JSF 2.0)</li>
      
</ul>
<a name="N10B7E"></a><a name="Value+Change+Events"></a>
<h3 class="underlined_5">Value Change Events</h3>
<p>Los lanzan los "editable value holders" (h:inputText, h:selectOneRadio, h:selectManyMenu,...) cuando cambia el valor del componente.</p>
<p>Es &uacute;til porque en muchos casos, los valores / contenidos de un componente dependen de los valores de otro. Un ejemplo cl&aacute;sico son las combinaciones de men&uacute;s pa&iacute;s/provincia. O, como en el siguiente ejemplo, uno que establece el idioma de la aplicaci&oacute;n en funci&oacute;n del elemento seleccionado</p>
<pre class="brush:xml;">&lt;h:selectOneMenu 
    value="#{form.country}" 
    onchange="submit()" 
    valueChangeListener="#{form.countryChanged}"&gt;
  &lt;f:selectItems value="#{form.countries}" 
    var="loc" 
    itemLabel="#{loc.displayCountry}" 
    itemValue="#{loc.country}"/&gt;
&lt;/h:selectOneMenu&gt;</pre>
<p>Aqu&iacute;, forzamos que el formulario se env&iacute;e una vez se ha seleccionado un pa&iacute;s, y se lance el m&eacute;todo countryChanged del Bean Gestionado Form. &Eacute;ste cambiar&aacute; el Locale de la aplicaci&oacute;n en funci&oacute;n del pa&iacute;s</p>
<pre class="brush:java;">public void countryChanged(ValueChangeEvent event) { 
  for (Locale loc : countries)
    if (loc.getCountry().equals(event.getNewValue()))
      FacesContext.getCurrentInstance().getViewRoot().setLocale(loc);
}</pre>
<p>Cabe destacar los m&eacute;todos del objeto <span class="codefrag">javax.faces.event.ValueChangeEvent</span>:</p>
<ul>
          
<li>
<span class="codefrag">UIComponent getComponent()</span> - Devuelve el components que dispar&oacute; el evento</li>
          
<li>
<span class="codefrag">Object getNewValue()</span> - Devuelve el nuevo valor del components, una vez ha sido convertido y validado</li>
          
<li>
<span class="codefrag">Object getOldValue()</span> - Devuelve el valor previo del componente</li>
        
</ul>
<a name="N10BB0"></a><a name="Action+events"></a>
<h3 class="underlined_5">Action events</h3>
<p>Los action events son los que lanzan botones y enlaces. Se disparan durante la "Invoke Application phase", cerca del final del ciclo de vida de la aplicaci&oacute;n. Se a&ntilde;aden de la siguiente manera:</p>
<pre class="brush:xml;">&lt;h:commandLink actionListener="#{bean.linkActivated}"&gt;
  ...
&lt;/h:commandLink&gt;</pre>
<p>Es importante diferenciar entre actionListener y action. Una acci&oacute;n implica cierta l&oacute;gica de negocio y participa en la navegaci&oacute;n, mientras los actionListeners no participan en la navegaci&oacute;n. Normalmente trabajan junto con las acciones cuando una acci&oacute;n necesita realizar ciertas acciones sobre la interfaz de usuario.</p>
<p>JSF siempre invoca a los actionListeners antes que a las acciones.</p>
<a name="N10BC5"></a><a name="Los+tags"></a>
<h3 class="underlined_5">Los tags f:actionListener y f:valueChangeListener</h3>
<p>&Eacute;stos tags son an&aacute;logos a los atributos que acabamos de ver. Por ejemplo, en el caso del men&uacute; visto anteriormente, tambi&eacute;n podr&iacute;amos presentarlo de la siguiente manera:</p>
<pre class="brush:xml;">&lt;h:selectOneMenu value="#{form.country}" onchange="submit()"&gt;
  &lt;f:valueChangeListener type="org.expertojee.CountryListener"/&gt;
  &lt;f:selectItems value="#{form.countryNames}"/&gt;
&lt;/h:selectOneMenu&gt;</pre>
<p>Los tags tienen una ventaja sobre los atributos, y es que permiten asociar varios listeners al mismo componente.</p>
<p>Vemos que hay una diferencia importante: mientras que en el atributo asoci&aacute;bamos un m&eacute;todo, en el tag estamos vinculando una clase Java. &Eacute;sta debe implementar la interfaz <span class="codefrag">ValueChangeListener</span>:</p>
<pre class="brush:java;">public class CountryListener implements ValueChangeListener { 
  public void processValueChange(ValueChangeEvent event) {
    FacesContext context = FacesContext.getCurrentInstance(); 
    if ("ES".equals(event.getNewValue()))
      context.getViewRoot().setLocale(Locale.ES); 
    else
      context.getViewRoot().setLocale(Locale.EN);
    }
}</pre>
<p>Para el caso de los action listeners, deben implementar la interfaz <span class="codefrag">ActionListener</span> y se presenta de forma id&eacute;ntica al caso anterior:</p>
<pre class="brush:xml;">&lt;h:commandButton image="logo-experto.jpg" action="#{ation.navigate}"&gt;
  &lt;f:actionListener type="org.expertojee.ClickListener"/&gt;
&lt;/h:commandButton&gt;</pre>
<a name="N10BF2"></a><a name="Pasando+informaci%C3%B3n+desde+la+interfaz+al+componente%3A+el+tag"></a>
<h3 class="underlined_5">Pasando informaci&oacute;n desde la interfaz al componente: el tag f:setPropertyActionListener</h3>
<p>Hasta la especificaci&oacute;n 1.2 de JSF pod&iacute;amos pasar datos de la interfaz a un componente, mediante los tags f:param y f:attribute. Sin embargo, ten&iacute;amos que "excavar" dentro del componente para obtener esta informaci&oacute;n.</p>
<p>Con el tag <span class="codefrag">f:setPropertyActionListener</span>, conseguimos setear una propiedad en nuestro bean gestionado. Un ejemplo sencillo ser&iacute;a un men&uacute; de cambio de idioma:</p>
<pre class="brush:xml;">&lt;h:commandLink immediate="true" action="#{localeChanger.changeLocale}"&gt;
  &lt;f:setPropertyActionListener target="#{localeChanger.languageCode}" value="es"/&gt;
  &lt;h:graphicImage library="images" name="es_flag.gif" style="border: 0px"/&gt;
&lt;/h:commandLink&gt;

&lt;h:commandLink immediate="true" action="#{localeChanger.changeLocale}"&gt;
  &lt;f:setPropertyActionListener target="#{localeChanger.languageCode}" value="en"/&gt;
  &lt;h:graphicImage library="images" name="en_flag.gif" style="border: 0px"/&gt;
&lt;/h:commandLink&gt;</pre>
<p>En el c&oacute;digo anterior, le decimos a JSF que establezca la propiedad languageCode del bean localeChanger a los valores <em>es</em> o <em>en</em>. </p>
<pre class="brush:java;">public class LocaleChanger { 
  private String languageCode;

  public String changeLocale() {
    FacesContext context = FacesContext.getCurrentInstance();
    context.getViewRoot().setLocale(new Locale(languageCode)); return null;
  }
  
  public void setLanguageCode(String newValue) {
    languageCode = newValue; 
  }
}</pre>
<a name="N10C17"></a><a name="Phase+Events"></a>
<h3 class="underlined_5">Phase Events</h3>
<p>Las implementaciones de JSF lanzan eventos antes y despu&eacute;s de cada una de las fases del ciclo de vida. Estos eventos son interceptados por los phase listeneners.</p>
<p>Al contrario que los vistos anteriormente, los phase listeners tienen que asociarse a la ra&iacute;z de la vista, mediante el tag <span class="codefrag">f:phaseListener</span>
</p>
<pre class="brush:xml;">&lt;f:phaseListener type="es.ua.jtech.PhaseTracker"/&gt;</pre>
<p>Adem&aacute;s, podemos declarar phase listeners globales en el fichero <span class="codefrag">faces-config.xml</span>.</p>
<pre class="brush:xml;">&lt;faces-config&gt;
  &lt;lifecycle&gt;
    &lt;phase-listener&gt;es.ua.jtech.PhaseTracker&lt;/phase-listener&gt;
  &lt;/lifecycle&gt;
&lt;/faces-config&gt;</pre>
<p>Nuestros phase listeners deber&aacute;n implementar la interfaz <span class="codefrag">javax.faces.event.PhaseListener</span>, que define los siguientes tres m&eacute;todos:</p>
<ul>
          
<li>
            
<span class="codefrag">PhaseId getPhaseId()</span>. Dice a la implementaci&oacute;n de JSF en qu&eacute; fase enviar los eventos al listener. Estas fases pueden ser:
            <ul>
              
<li>
<span class="codefrag">PhaseId.ANY_PHASE</span>
</li>
              
<li>
<span class="codefrag">PhaseId.APPLY_REQUEST_VALUES</span>
</li>
              
<li>
<span class="codefrag">PhaseId.INVOKE_APPLICATION</span>
</li>
              
<li>
<span class="codefrag">PhaseId.PROCESS_VALIDATIONS</span>
</li>
              
<li>
<span class="codefrag">PhaseId.RENDER_RESPONSE</span>
</li>
              
<li>
<span class="codefrag">PhaseId.RESTORE_VIEW</span>
</li>
              
<li>
<span class="codefrag">PhaseId.UPDATE_MODEL_VALUES</span>
</li>
            
</ul>
          
</li>
          
<li>
<span class="codefrag">void afterPhase(PhaseEvent)</span>
</li>
          
<li>
<span class="codefrag">void beforePhase (PhaseEvent)</span>
</li>
        
</ul>
<p>Imagin&eacute;monos un listener cuyo <span class="codefrag">getPhaseId()</span> devolviese <span class="codefrag">PhaseId.APPLY_REQUEST_VALUES</span>. En ese caso, los m&eacute;todos <span class="codefrag">beforePhase()</span> y <span class="codefrag">afterPhase()</span> se llamar&iacute;an una vez por cada ejecuci&oacute;n del ciclo de vida. Sin embargo, con <span class="codefrag">PhaseId.ANY_PHASE</span>, los m&eacute;todos <span class="codefrag">beforePhase()</span> y <span class="codefrag">afterPhase()</span> se ejecutar&aacute;n seis veces por cada ejecuci&oacute;n del ciclo de vida.</p>
<p>De manera alternativa, podemos envolver una vista JSF en un tag <span class="codefrag">f:view</span> con atributos <span class="codefrag">beforePhase</span> y/o <span class="codefrag">afterPhase</span>. Estos atributos deben apuntar a m&eacute;todos del tipo <span class="codefrag">void listener(javax.faces.event.PhaseEvent)</span>:</p>
<pre class="brush:xml;">&lt;f:view beforePhase="#{backingBean.beforeListener}"&gt;
  ...
&lt;/f:view&gt;</pre>
<p>Los phase listeners constituyen un mecanismo muy &uacute;til para el debugging de nuestras aplicaciones.</p>
<a name="N10C9B"></a><a name="System+Events"></a>
<h3 class="underlined_5">System Events</h3>
<p>A partir de la especificaci&oacute;n 2.0 de JSF, se introduce un sistema de notificaciones en el cual tanto la propia implementaci&oacute;n como los distintos componentes pueden notificar a distintos listeners acerca de una serie de eventos potencialmente interesantes.</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
          
<tr>
            
<th colspan="1" rowspan="1">Clase del evento</th>
            <th colspan="1" rowspan="1">Descripci&oacute;n</th>
            <th colspan="1" rowspan="1">Origen</th>
          
</tr>
          
<tr>
            
<td colspan="1" rowspan="1"><span class="codefrag">PostConstructApplicationEvent; PreDestroyApplicationEvent</span></td>
            <td colspan="1" rowspan="1">Inmediatamente despu&eacute;s del inicio de la aplicaci&oacute;n; inmediatamente antes del apagado de la aplicaci&oacute;n</td>
            <td colspan="1" rowspan="1"><span class="codefrag">Application</span></td>
          
</tr>
          
<tr>
            
<td colspan="1" rowspan="1"><span class="codefrag">PostAddToViewEvent; PreRemoveFromViewEvent</span></td>
            <td colspan="1" rowspan="1">Despu&eacute;s de que un componente haya sido aladido al &aacute;rbol de la vista; justo antes de que vaya a ser eliminado</td>
            <td colspan="1" rowspan="1"><span class="codefrag">UIComponent</span></td>
          
</tr>
          
<tr>
            
<td colspan="1" rowspan="1"><span class="codefrag">PostRestoreStateEvent</span></td>
            <td colspan="1" rowspan="1">Despu&eacute;s de que el estado de un componente haya sido restaurado</td>
            <td colspan="1" rowspan="1"><span class="codefrag">UIComponent</span></td>
          
</tr>
          
<tr>
            
<td colspan="1" rowspan="1"><span class="codefrag">PreValidateEvent; PostValidateEvent</span></td>
            <td colspan="1" rowspan="1">Antes y despu&eacute;s de que un componente haya sido validado</td>
            <td colspan="1" rowspan="1"><span class="codefrag">UIComponent</span></td>
          
</tr>
          
<tr>
            
<td colspan="1" rowspan="1"><span class="codefrag">PreRenderViewEvent</span></td>
            <td colspan="1" rowspan="1">Antes de que la vista ra&iacute;z vaya a renderizarse</td>
            <td colspan="1" rowspan="1"><span class="codefrag">UIViewRoot</span></td>
          
</tr>
          
<tr>
            
<td colspan="1" rowspan="1"><span class="codefrag">PreRenderComponentEvent</span></td>
            <td colspan="1" rowspan="1">Antes de que vaya a renderizarse un componente</td>
            <td colspan="1" rowspan="1"><span class="codefrag">UIComponent</span></td>
          
</tr>
          
<tr>
            
<td colspan="1" rowspan="1"><span class="codefrag">PostConstructViewMapEvent; PreDestroyViewMapEvent</span></td>
            <td colspan="1" rowspan="1">Despu&eacute;s de que el componente ra&iacute;z ha constru&iacute;do el mapa de &aacute;mbito vista; cuando el mapa de la vista se limpia</td>
            <td colspan="1" rowspan="1"><span class="codefrag">UIViewRoot</span></td>
          
</tr>
          
<tr>
            
<td colspan="1" rowspan="1"><span class="codefrag">PostConstructCustomScopeEvent; PreDestroyCustomScopeEvent</span></td>
            <td colspan="1" rowspan="1">Tras la construcci&oacute;n de un &aacute;mbito de tipo <em>custom</em>; justo antes de su destrucci&oacute;n</td>
            <td colspan="1" rowspan="1"><span class="codefrag">ScopeContext</span></td>
          
</tr>
          
<tr>
            
<td colspan="1" rowspan="1"><span class="codefrag">ExceptionQueuedEvent</span></td>
            <td colspan="1" rowspan="1">Despu&eacute;s de haber encolado una excepci&oacute;n</td>
            <td colspan="1" rowspan="1"><span class="codefrag">ExceptionQueuedEventContext</span></td>
          
</tr>
        
</table>
<p>Hay cuatro maneras por las cuales una clase puede recibir <span class="codefrag">system events</span>:</p>
<p>La primera de ellas es mediante el tag <span class="codefrag">f:event</span>. &Eacute;sta constituye la manera m&aacute;s adecuada para realizar un <em>listening</em> de eventos a nivel de componente o vista</p>
<pre class="brush:xml;">&lt;h:inputText value="#{...}"&gt;
  &lt;f:event name="postValidate" listener="#{bean.method}"/&gt;
&lt;/h:inputText&gt;</pre>
<p>El m&eacute;todo debe tener la forma <span class="codefrag">public void listener(ComponentSystemEvent) throws AbortProcessingException</span>.</p>
<p>La segunda manera es utilizando una anotaci&oacute;n para una clase del tipo <span class="codefrag">UIComponent</span> o <span class="codefrag">Renderer</span>:</p>
<pre class="brush:java;">@ListenerFor(systemEventClass=PreRenderViewEvent.class)</pre>
<p>Este mecanismo es muy &uacute;til para el desarrollo de componentes, aunque esta materia queda fuera del objetivo de este curso.</p>
<p>En tercer lugar, podemos declararlos en el fichero de configuraci&oacute;n <span class="codefrag">faces-config.xml</span>.Este mecanismo es &uacute;ltil para instalar un listener para los eventos de la aplicaci&oacute;n</p>
<pre class="brush:xml;">&lt;application&gt; 
  &lt;system-event-listener&gt;
    &lt;system-event-listener-class&gt;listenerClass&lt;/system-event-listener-class&gt;
    &lt;system-event-class&gt;eventClass&lt;/system-event-class&gt;
  &lt;/system-event-listener&gt;
&lt;/application&gt;</pre>
<p>Por &uacute;ltimo, podemos llamar al m&eacute;todo <span class="codefrag">subscribeToEvent</span> de las clases <span class="codefrag">UIComponent</span> o <span class="codefrag">Application</span>. Este m&eacute;todo est&aacute; destinado a desarrolladores de <em>frameworks</em>, quedando tambi&eacute;n fuera del objeto del curso.</p>
<a name="N10DB6"></a><a name="Usando+el+tag+f%3Aevent+para+validaciones+m%C3%BAltiples"></a>
<h3 class="underlined_5">Usando el tag f:event para validaciones m&uacute;ltiples</h3>
<p>JSF no provee de ning&uacute;n mecanismo para la validaci&oacute;n de un grupo de componentes. 
        Por ejemplo, si usamos tres campos distintos para la introducci&oacute;n de una fecha, 
        la &uacute;nica manera de comprobar su validez es, por ejemplo, mediante un evento <span class="codefrag">PostValidateEvent</span>.</p>
<pre class="brush:xml;">&lt;h:panelGrid id="date" columns="2"&gt;
  &lt;f:event type="postValidate" listener="#{bb.validateDate}"/&gt;
  D&iacute;a: &lt;h:inputText id="day" value="#{bb.day}" size="2" required="true"/&gt;
  Mes: &lt;h:inputText id="month" value="#{bb.month}" size="2" required="true"/&gt;
  A&ntilde;o: &lt;h:inputText id="year" value="#{bb.year}" size="4" required="true"/&gt; 
&lt;/h:panelGrid&gt;
&lt;h:message for="date" styleClass="errorMessage"/&gt;</pre>
<p> En nuestro listener: obtendremos los valores introducidos por el usuario y verificaremos 
        que se corresponden con una fecha v&aacute;lida. Sino, a&ntilde;adiremos un mensaje de error al componente e invocaremos al m&eacute;todo <span class="codefrag">renderResponse</span>:</p>
<pre class="brush:java;">public void validateDate(ComponentSystemEvent event) { 
  UIComponent source = event.getComponent();
  UIInput dayInput = (UIInput) source.findComponent("day"); 
  UIInput monthInput = (UIInput) source.findComponent("month"); 
  UIInput yearInput = (UIInput) source.findComponent("year"); 

  int d = ((Integer) dayInput.getLocalValue()).intValue();
  int m = ((Integer) monthInput.getLocalValue()).intValue(); 
  int y = ((Integer) yearInput.getLocalValue()).intValue(); 

  if (!isValidDate(d, m, y)) {
    FacesMessage message = es.ua.jtech.util.Messages.getMessage(
      "es.ua.jtech.messages", 
      "invalidDate", 
      null
    );
    message.setSeverity(FacesMessage.SEVERITY_ERROR); 
    FacesContext context = FacesContext.getCurrentInstance();
    context.addMessage(source.getClientId(), message);
    context.renderResponse();
  } 
}</pre>
<p>Otros ejemplos de validaciones de este tipo y que nos encontramos pr&aacute;cticamente a diario podr&iacute;an ser, por ejemplo, la verificaci&oacute;n de la segunda contrase&ntilde;a introducida en el caso de un registro o, verificar que una provincia seleccionada se corresponde con el pa&iacute;s seleccionado previamente.</p>
<a name="N10DD6"></a><a name="Tomando+decisiones+antes+de+renderizar+la+vista"></a>
<h3 class="underlined_5">Tomando decisiones antes de renderizar la vista</h3>
<p>A veces, tenemos la necesidad de ser notificados antes de renderizar una vista, 
        por ejemplo, para cargar datos, realizar cambios sobre alg&uacute;n componente o incluso navegar a otra vista. 
        Por ejemplo: si nos queremos asegurar de que un usuario est&aacute; loqueado antes de mostrar una p&aacute;gina, 
        podemos envolver la vista en un tag <span class="codefrag">f:view</span> y a&ntilde;adir un <em>listener</em>:</p>
<pre class="brush:xml;">&lt;f:view&gt;
  &lt;f:event type="preRenderView" listener="#{user.checkLogin}"/&gt;
  &lt;h:head&gt;
    &lt;title&gt;...&lt;/title&gt; 
  &lt;/h:head&gt;
  &lt;h:body&gt; 
    ...
  &lt;/h:body&gt;
&lt;/f:view&gt;</pre>
<p>En el listener, verificaremos si el usuario est&aacute; loqueado. En caso contrario, le redirigiremos a la p&aacute;gina de login:</p>
<pre class="brush:java;">public void checkLogin(ComponentSystemEvent event) { 
  if (!loggedIn) {
    FacesContext context = FacesContext.getCurrentInstance();
    ConfigurableNavigationHandler handler = (ConfigurableNavigationHandler)context.
      getApplication().
      getNavigationHandler();
      
    handler.performNavigation("login");
  }
}</pre>
</div>

    
<p class="pageBreakAfter"></p>
  
</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
