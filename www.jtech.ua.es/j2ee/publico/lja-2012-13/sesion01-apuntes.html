<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Introducci&oacute;n al lenguaje Java</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Experto en Desarrollo de Aplicaciones y Servicios con Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Lenguaje Java Avanzado" src="images/baner_j2ee_der.gif" title="Lenguaje Java Avanzado"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Java y Herramientas de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Java y Herramientas de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menupage">
<div class="menupagetitle">Sesion 1</div>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion01-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Introducci&oacute;n al lenguaje Java</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Java">Java</a>
<ul class="minitoc">
<li>
<a href="#Certificaci%C3%B3n+Sun+%2F+Oracle">Certificaci&oacute;n Sun / Oracle</a>
</li>
<li>
<a href="#Recursos+adicionales">Recursos adicionales</a>
<ul class="minitoc">
<li>
<a href="#Bibliograf%C3%ADa">Bibliograf&iacute;a</a>
</li>
<li>
<a href="#Enlaces">Enlaces</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Conceptos+previos+de+POO">Conceptos previos de POO</a>
<ul class="minitoc">
<li>
<a href="#Concepto+de+clase+y+objeto">Concepto de clase y objeto</a>
</li>
<li>
<a href="#Concepto+de+campo%2C+m%C3%A9todo+y+constructor">Concepto de campo, m&eacute;todo y constructor</a>
</li>
<li>
<a href="#Concepto+de+herencia+y+polimorfismo">Concepto de herencia y polimorfismo</a>
</li>
<li>
<a href="#Modificadores+de+acceso">Modificadores de acceso</a>
</li>
<li>
<a href="#Clases+abstractas+e+interfaces">Clases abstractas e interfaces</a>
</li>
</ul>
</li>
<li>
<a href="#Componentes+de+un+programa+Java">Componentes de un programa Java</a>
<ul class="minitoc">
<li>
<a href="#Clases">Clases</a>
</li>
<li>
<a href="#Campos+y+variables">Campos y variables</a>
</li>
<li>
<a href="#M%C3%A9todos">M&eacute;todos</a>
</li>
<li>
<a href="#Constructores">Constructores</a>
</li>
<li>
<a href="#Paquetes">Paquetes</a>
</li>
<li>
<a href="#Tipo+enumerado">Tipo enumerado</a>
</li>
<li>
<a href="#Modificadores+de+acceso-N102FF">Modificadores de acceso</a>
</li>
<li>
<a href="#Otros+modificadores">Otros modificadores</a>
</li>
<li>
<a href="#Imports+est%C3%A1ticos">Imports est&aacute;ticos</a>
</li>
<li>
<a href="#Argumentos+variables">Argumentos variables</a>
</li>
<li>
<a href="#Metainformaci%C3%B3n+o+anotaciones">Metainformaci&oacute;n o anotaciones</a>
</li>
<li>
<a href="#Ejecuci%C3%B3n+de+clases%3A+m%C3%A9todo">Ejecuci&oacute;n de clases: m&eacute;todo main</a>
</li>
</ul>
</li>
<li>
<a href="#Herencia+e+interfaces">Herencia e interfaces</a>
<ul class="minitoc">
<li>
<a href="#Herencia">Herencia</a>
</li>
<li>
<a href="#Punteros">Punteros this y super</a>
</li>
<li>
<a href="#Interfaces+y+clases+abstractas">Interfaces y clases abstractas</a>
</li>
</ul>
</li>
<li>
<a href="#Hilos">Hilos</a>
<ul class="minitoc">
<li>
<a href="#Creaci%C3%B3n+de+hilos">Creaci&oacute;n de hilos</a>
</li>
<li>
<a href="#Ciclo+de+vida+y+prioridades">Ciclo de vida y prioridades</a>
</li>
<li>
<a href="#Sincronizaci%C3%B3n+de+hilos">Sincronizaci&oacute;n de hilos</a>
</li>
</ul>
</li>
<li>
<a href="#Clases+%C3%BAtiles">Clases &uacute;tiles</a>
<ul class="minitoc">
<li>
<a href="#Object">Object</a>
</li>
<li>
<a href="#Properties">Properties</a>
</li>
<li>
<a href="#System">System</a>
</li>
<li>
<a href="#Runtime">Runtime</a>
</li>
<li>
<a href="#Math">Math</a>
</li>
<li>
<a href="#Otras+clases">Otras clases</a>
</li>
</ul>
</li>
<li>
<a href="#Estructuras+de+datos">Estructuras de datos</a>
<ul class="minitoc">
<li>
<a href="#BeanUtils">BeanUtils</a>
</li>
</ul>
</li>
</ul>
</div>

<a name="N1000C"></a><a name="Java"></a>
<h2 class="underlined_10">Java</h2>
<div class="section">
<p>
<strong>Java</strong> es un lenguaje de programaci&oacute;n creado por <em>Sun Microsystems</em>,
		(empresa que posteriormente fue comprada por <em>Oracle</em>)
	         para poder funcionar en distintos tipos de procesadores. Su sintaxis es muy parecida a la de C o C++, e
		 incorpora como propias algunas
	caracter&iacute;sticas que en otros lenguajes son extensiones: gesti&oacute;n de hilos, ejecuci&oacute;n 
	    remota, etc.   </p>
<p>El c&oacute;digo Java, una   vez compilado, puede 
	 llevarse sin modificaci&oacute;n alguna sobre   cualquier m&aacute;quina, 
	 y ejecutarlo. Esto se debe a que el c&oacute;digo se ejecuta sobre una m&aacute;quina 
	 hipot&eacute;tica o virtual, la <strong>Java   Virtual Machine</strong>, que se encarga 
	 de interpretar el c&oacute;digo (ficheros compilados <span class="codefrag">.class</span>) y convertirlo   a c&oacute;digo particular 
	 de la CPU que se est&eacute; utilizando (siempre que se soporte dicha m&aacute;quina
	virtual).
	</p>
<a name="N10028"></a><a name="Certificaci%C3%B3n+Sun+%2F+Oracle"></a>
<h3 class="underlined_5">Certificaci&oacute;n Sun / Oracle</h3>
<p>Aunque el resto del curso de Experto est&aacute; orientado a certificaciones en el &aacute;mbito de JEE, este m&oacute;dulo de Java y Herramientas de Desarrollo se basa en las certificaciones para Java b&aacute;sico o est&aacute;ndar. Dichas certificaciones son dos:</p>
<ul>
	
<li>
<em>Oracle Certified Professional Java Programmer</em> (antes SCJP - <em>Sun Certified Java Programmer</em>): <a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=320">http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=320</a>
</li>
	
<li>
<em>Oracle Certified Master, Java SE 6 Developer</em> (antes SCJD - <em>Sun Certified Java Developper</em>): <a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=321">http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=321</a>
</li>
	
</ul>
<p>Para la primera (<strong>SCJP</strong>), se debe completar un examen. En el caso del certificado para la plataforma Java 1.5, el examen abarca los siguientes apartados generales:</p>
<ul>
	
<li>
<strong>Secci&oacute;n 1: Declaraciones, inicializaciones y &aacute;mbitos:</strong> eval&uacute;a si el alumno es capaz de escribir c&oacute;digo que declare clases o interfaces, utilice adecuadamente la estructura de paquetes e imports, utilice c&oacute;digo con tipos simples, arrays, objetos est&aacute;ticos, variables locales, constructores, m&eacute;todos est&aacute;ticos y no est&aacute;ticos, sobrecarga de m&eacute;todos, etc</li>
	
<li>
<strong>Secci&oacute;n 2: Control de flujo:</strong> uso de sentencias <span class="codefrag">if</span>, <span class="codefrag">switch</span>, bucles (<span class="codefrag">for, do, while, break, continue</span>), manejo y uso de excepciones (<span class="codefrag">try-catch-finally</span>), etc</li>
	
<li>
<strong>Secci&oacute;n 3: Contenidos del API:</strong> uso de wrappers b&aacute;sicos (<span class="codefrag">Integer, Boolean</span>, etc), entrada/salida de ficheros, serializaci&oacute;n de objetos para E/S, formateo de datos con el paquete <span class="codefrag">java.text</span>, y parseo de cadenas mediante expresiones regulares y similares (paquetes <span class="codefrag">java.util</span> y <span class="codefrag">java.util.regex</span>)</li>
	
<li>
<strong>Secci&oacute;n 4: Concurrencia:</strong> manejo de hilos (mediante <span class="codefrag">Thread</span> y mediante <span class="codefrag">Runnable</span>), estados de los hilos, interbloqueos y sincronizaci&oacute;n</li>
	
<li>
<strong>Secci&oacute;n 5: Conceptos sobre orientaci&oacute;n a objetos:</strong> desarrollo de c&oacute;digo que cumpla los requerimientos de encapsulamiento, cohesi&oacute;n y acoplamiento entre clases (mucha cohesi&oacute;n, poco acoplamiento). Uso del polimorfismo y del casting. Uso de m&eacute;todos sobrecargados, llamadas a la superclase, etc.</li>
	
<li>
<strong>Secci&oacute;n 6: Colecciones:</strong> determinar qu&eacute; tipos de colecciones (listas, hashmaps, etc) utilizar en diferentes supuestos. Comparaciones y ordenaciones entre objetos de una colecci&oacute;n, etc</li>
	
<li>
<strong>Secci&oacute;n 7: Fundamentos:</strong> uso correcto de los modificadores de acceso, declaraciones de paquetes, imports. Seguimiento de trazas. Manejo de referencias a objetos. Uso del recolector de basura... etc</li>
	
</ul>
<p>Para la segunda (<strong>SCJD</strong>) es necesario haber obtenido antes la primera certificaci&oacute;n (SCJP). Despu&eacute;s, se deben superar dos pruebas: un supuesto de programaci&oacute;n, y un examen.</p>
<p>La primera prueba (el supuesto de programaci&oacute;n), consiste en escribir c&oacute;digo para implementar una supuesta aplicaci&oacute;n para empresa. Se evaluar&aacute;n aspectos como documentaci&oacute;n, dise&ntilde;o orientado a objetos, desarrollo de la interfaz gr&aacute;fica, interbloqueos, etc.</p>
<p>La segunda prueba (el examen), es una explicaci&oacute;n sobre el desarrollo que hayamos hecho en el supuesto de programaci&oacute;n anterior, explicando las decisiones principales que hemos tenido que tomar, ventajas y desventajas de las mismas, y justificaci&oacute;n de dichas decisiones, en funci&oacute;n de los objetivos propuestos para la implementaci&oacute;n.</p>
<p>M&aacute;s informaci&oacute;n sobre las certificaciones en los enlaces respectivos vistos antes.</p>
<a name="N100A4"></a><a name="Recursos+adicionales"></a>
<h3 class="underlined_5">Recursos adicionales</h3>
<a name="N100AA"></a><a name="Bibliograf%C3%ADa"></a>
<h4>Bibliograf&iacute;a</h4>
<ul>
	
<li>
<strong>Curso de Java</strong>, Ian F. Darwin, <em>Ed. Anaya Multimedia, Colecci&oacute;n O'Reilly</em>
</li>
	
<li>
<strong>Java 2 v5.0</strong>, Varios autores, <em>Ed. Anaya Multimedia, Colecci&oacute;n Wrox</em>
</li>
	
<li>
<strong>Piensa en Java</strong>, Bruce Eckel, <em>Ed. Prentice Hall</em>
</li>
	
<li>
<strong>Core Java 2</strong>, Cay Horstmann y Gary Cornell, <em>Ed. Prentice Hall PTR</em>
</li>
	
<li>
<strong>Java in a Nutshell</strong>, David Flanagan, <em>Ed. O'Reilly Media</em>
</li>
	
</ul>
<a name="N100D7"></a><a name="Enlaces"></a>
<h4>Enlaces</h4>
<ul>
	
<li>
<a href="http://www.oracle.com/technetwork/java/index.html">Web oficial de Java, http://www.oracle.com/technetwork/java/index.html</a>
</li>
	
</ul>
</div>


<a name="N100E8"></a><a name="Conceptos+previos+de+POO"></a>
<h2 class="underlined_10">Conceptos previos de POO</h2>
<div class="section">
<p>Java es un lenguaje orientado a objetos (OO), por lo que, antes de empezara ver qu&eacute; elementos componen los programas Java, conviene tener claros algunos conceptos de la programaci&oacute;n orientada a objetos (POO).</p>
<a name="N100F1"></a><a name="Concepto+de+clase+y+objeto"></a>
<h3 class="underlined_5">Concepto de clase y objeto</h3>
<p>El elemento fundamental a la hora de hablar de programaci&oacute;n orientada a objetos es el concepto de objeto en s&iacute;, as&iacute; como el concepto abstracto de clase. Un <strong>objeto</strong> es un conjunto de variables junto con los m&eacute;todos relacionados con &eacute;stas. Contiene la informaci&oacute;n (las variables) y la forma de manipular la informaci&oacute;n (los m&eacute;todos). Una <strong>clase</strong> es el prototipo que define las variables y m&eacute;todos que va a emplear un determinado tipo de objeto, es la definici&oacute;n abstracta de lo que luego supone un objeto en memoria.</p>
<p>Poniendo un s&iacute;mil fuera del mundo de la inform&aacute;tica, la clase podr&iacute;a ser el concepto de <em>coche</em>, donde nos vienen a la memoria los par&aacute;metros que definen un coche (dimensiones, cilindrada, maletero, etc), y las operaciones que podemos hacer con un coche (acelerar, frenar, adelantar, estacionar). La idea abstracta de coche que tenemos es lo que equivaldr&iacute;a a la clase, y la representaci&oacute;n concreta de coches concretos (por ejemplo, Peugeot 307, Renault Megane, Volkswagen Polo...) ser&iacute;an los objetos de tipo coche.</p>
<a name="N10107"></a><a name="Concepto+de+campo%2C+m%C3%A9todo+y+constructor"></a>
<h3 class="underlined_5">Concepto de campo, m&eacute;todo y constructor</h3>
<p>Toda clase u objeto se compone internamente de constructores, campos y/o m&eacute;todos. Veamos qu&eacute; representa cada uno de estos conceptos: un <strong>campo</strong> es un elemento que contiene informaci&oacute;n relativa a la clase, y un <strong>m&eacute;todo</strong> es un elemento que permite manipular la informaci&oacute;n de los campos. Por otra parte, un <strong>constructor</strong> es un elemento que permite reservar memoria para almacenar los campos y m&eacute;todos de la clase, a la hora de crear un objeto de la misma.</p>
<a name="N1011A"></a><a name="Concepto+de+herencia+y+polimorfismo"></a>
<h3 class="underlined_5">Concepto de herencia y polimorfismo</h3>
<p>Con la <strong>herencia</strong> podemos definir una clase a partir de otra que ya exista, de forma que la nueva clase tendr&aacute; todas las variables y m&eacute;todos de la clase a partir de la que se crea, m&aacute;s las variables y m&eacute;todos nuevos que necesite. A la clase base a partir de la cual se crea la nueva clase se le llama superclase.</p>
<p>Por ejemplo, podr&iacute;amos tener una clase gen&eacute;rica <em>Animal</em>, y heredamos de ella para formar clases m&aacute;s espec&iacute;ficas, como <em>Pato</em>, <em>Elefante</em>, o <em>Le&oacute;n</em>. Estas clases tendr&iacute;an todo lo de la clase padre <em>Animal</em>, y adem&aacute;s cada una podr&iacute;a tener sus propios elementos adicionales.</p>
<p>Una caracter&iacute;stica derivada de la herencia es que, por ejemplo, si tenemos un m&eacute;todo <span class="codefrag">dibuja(Animal a)</span>, que se encarga de hacer un dibujo del animal que se le pasa como par&aacute;metro, podremos pasarle a este m&eacute;todo como par&aacute;metro tanto un <em>Animal</em> como un <em>Pato</em>, <em>Elefante</em>, o cualquier otro subtipo directo o indirecto de <em>Animal</em>. Esto se conoce como <strong>polimorfismo</strong>.</p>
<a name="N1014E"></a><a name="Modificadores+de+acceso"></a>
<h3 class="underlined_5">Modificadores de acceso</h3>
<p>Tanto las clases como sus elementos (constructores, campos y m&eacute;todos) pueden verse modificados por lo que se suelen llamar modificadores de acceso, que indican hasta d&oacute;nde es accesible el elemento que modifican. Tenemos tres tipos de modificadores:</p>
<ul>
    
<li>
<strong>privado:</strong> el elemento es accesible &uacute;nicamente dentro de la clase en la que se encuentra.</li>
    
<li>
<strong>protegido:</strong> el elemento es accesible desde la clase en la que se encuentra, y adem&aacute;s desde las subclases que hereden de dicha clase.</li>
    
<li>
<strong>p&uacute;blico:</strong> el elemento es accesible desde cualquier clase.</li>

</ul>
<a name="N1016A"></a><a name="Clases+abstractas+e+interfaces"></a>
<h3 class="underlined_5">Clases abstractas e interfaces</h3>
<p>Mediante las <strong>clases abstractas</strong> y los <strong>interfaces</strong> podemos
definir el esqueleto de una familia de clases, de forma que los subtipos
de la clase abstracta o la interfaz implementen ese esqueleto para dicho
subtipo concreto. Por ejemplo, volviendo con el ejemplo anterior, podemos definir en la clase <em>Animal</em>
el m&eacute;todo <em>dibuja()</em> y el m&eacute;todo <em>imprime()</em>, y
que <em>Animal</em> sea una clase abstracta o un interfaz.&nbsp;

</p>
<p>Vemos la diferencia entre clase, clase abstracta e interfaz con este supuesto:
</p>
<ul>

<li>
En una <strong>clase</strong>, al definir <em>Animal</em> tendr&iacute;amos que implementar
el c&oacute;digo de los m&eacute;todos <em>dibuja()</em> e <em>imprime()</em>. Las subclases
que hereden de <em>Animal </em>
no tendr&iacute;an por qu&eacute; implementar los m&eacute;todos, a no
ser que quieran redefinirlos para adaptarlos a sus propias necesidades.</li>


<li>
En una <strong>clase abstracta</strong> podr&iacute;amos implementar los m&eacute;todos
que nos interese, dejando sin implementar los dem&aacute;s (dej&aacute;ndolos
como m&eacute;todos abstractos). Dichos m&eacute;todos tendr&iacute;an
que implementarse en las clases hijas.</li>


<li>
En un <strong>interfaz</strong> no podemos implementar ning&uacute;n m&eacute;todo
en la clase padre, y cada clase hija tiene que hacer sus propias implementaciones
de los m&eacute;todos. Adem&aacute;s, las clases hijas podr&iacute;an implementar
otros interfaces.</li>

</ul>
</div>


<a name="N101A9"></a><a name="Componentes+de+un+programa+Java"></a>
<h2 class="underlined_10">Componentes de un programa Java</h2>
<div class="section">
<p>
En un programa Java
podemos distinguir varios elementos:</p>
<a name="N101B2"></a><a name="Clases"></a>
<h3 class="underlined_5">Clases</h3>
<p>Para definir una clase se utiliza la palabra reservada <span class="codefrag">class</span>,
  seguida del nombre de la clase:</p>
<pre class="brush:java;">class MiClase
{
  ...
}</pre>
<p>Es recomendable que los nombres de las clases sean sustantivos (ya que suelen representar entidades), 
pudiendo estar formados por varias palabras. La primera letra de cada palabra estar&aacute; en may&uacute;scula y el
resto de letras en min&uacute;scula. Por ejemplo, <span class="codefrag">DatosUsuario</span>, <span class="codefrag">Cliente</span>, 
<span class="codefrag">GestorMensajes</span>.</p>
<p>Cuando se trate de una clase encargada &uacute;nicamente de agrupar un conjunto de recursos o de 
constantes, su nombre se escribir&aacute; en plural. Por ejemplo, <span class="codefrag">Recursos</span>, 
<span class="codefrag">MensajesError</span>.</p>
<a name="N101D9"></a><a name="Campos+y+variables"></a>
<h3 class="underlined_5">Campos y variables</h3>
<p>Dentro de una clase, o de un m&eacute;todo, podemos definir campos o variables,
  respectivamente, que pueden ser de tipos simples, o clases complejas, bien de
  la API de Java, bien que hayamos definido nosotros mismos, o bien que hayamos
  copiado de otro lugar.&nbsp;</p>
<p>Al igual que los nombres de las clases, suele ser conveniente utilizar sustantivos que describan
el significado del campo, pudiendo estar formados tambi&eacute;n por varias palabras. En este caso, la primera 
palabra comenzar&aacute; por min&uacute;scula, y el resto por may&uacute;scula. Por ejemplo, <span class="codefrag">apellidos</span>,
<span class="codefrag">fechaNacimiento</span>, <span class="codefrag">numIteraciones</span>.</p>
<p>De forma excepcional, cuando se trate de variables auxiliares de corto alcance se puede poner como
nombre las iniciales del tipo de datos correspondiente:</p>
<pre class="brush:java;">int i;
Vector v;
MiOtraClase moc;</pre>
<p>Por otro lado, las constantes se declaran como <span class="codefrag">final static</span>, y sus nombres es escribir&aacute;n 
totalmente en may&uacute;sculas, separando las distintas palabras que los formen por caracteres de subrayado 
(<span class="codefrag">'_'</span>). Por ejemplo, <span class="codefrag">ANCHO_VENTANA</span>, <span class="codefrag">MSG_ERROR_FICHERO</span>.</p>
<a name="N10206"></a><a name="M%C3%A9todos"></a>
<h3 class="underlined_5">M&eacute;todos</h3>
<p>Los m&eacute;todos o funciones se definen de forma similar a como se hacen en C:
  indicando el tipo de datos que devuelven, el nombre del m&eacute;todo, y luego los
  argumentos entre par&eacute;ntesis:</p>
<pre class="brush:java;">void imprimir(String mensaje)
{
	... // C&oacute;digo del m&eacute;todo
}

double sumar(double... numeros){
	    //N&uacute;mero variable de argumentos
	    //Se accede a ellos como a un vector: 
	    //numeros[0], numeros[1], ...
}

Vector insertarVector(Object elemento, int posicion)
{
	... // C&oacute;digo del m&eacute;todo
}</pre>
<p>Al igual que los campos, se escriben con la primera palabra en min&uacute;sculas y el resto comenzando
por may&uacute;sculas. En este caso normalmente utilizaremos verbos.</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Una vez hayamos creado cualquier clase, campo o m&eacute;todo, podremos modificarlo
pulsando con el bot&oacute;n derecho sobre &eacute;l en el explorador de Eclipse y seleccionando la opci&oacute;n 
<em>Refactor &gt; Rename...</em> del men&uacute; emergente. Al cambiar el nombre de cualquiera de estos elementos, 
Eclipse actualizar&aacute; autom&aacute;ticamente todas las referencias que hubiese en otros lugares del c&oacute;digo. Adem&aacute;s
de esta opci&oacute;n para renombrar, el men&uacute; <em>Refactor</em> contiene bastantes m&aacute;s opciones que nos 
permitir&aacute;n reorganizar autom&aacute;ticamente el c&oacute;digo de la aplicaci&oacute;n de diferentes formas.</div>
</div>
<a name="N10222"></a><a name="Constructores"></a>
<h3 class="underlined_5">Constructores</h3>
<p>Podemos interpretar los constructores como m&eacute;todos que se llaman igual que
  la clase, y que se ejecutan con el operador <span class="codefrag">new</span> para reservar memoria
  para los objetos que se creen de dicha clase:</p>
<pre class="brush:java;">MiClase()
{
	... // C&oacute;digo del constructor
}

MiClase(int valorA, Vector valorV)
{
	... // C&oacute;digo de otro constructor
}</pre>
<p>
  No tenemos que preocuparnos de liberar la memoria
del objeto al dejar de utilizarlo. Esto lo hace autom&aacute;ticamente
el <strong>garbage collector</strong>. A&uacute;n as&iacute;, podemos usar el m&eacute;todo
<span class="codefrag">finalize()</span> para liberar manualmente.</p>
<p>Si estamos utilizando una clase que hereda de otra, y dentro del constructor de la subclase 
queremos llamar a un determinado constructor de la superclase, utilizaremos <span class="codefrag">super</span>. Si no
se hace la llamada a <span class="codefrag">super</span>, por defecto la superclase se construir&aacute; con su constructor
vac&iacute;o. Si esta superclase no tuviese definido ning&uacute;n constructor vac&iacute;o, o bien quisiesemos utilizar otro
constructor, podremos llamar a <span class="codefrag">super</span> proporcionando los par&aacute;metros correspondientes
al constructor al que queramos llamar. Por ejemplo, si heredamos de <span class="codefrag">MiClase</span> y desde la
subclase queremos utilizar el segundo constructor de la superclase, al comienzo del constructor
haremos la siguiente llamada a <span class="codefrag">super</span>:</p>
<pre class="brush:java;">SubMiClase()
{
    super(0, new Vector());
    ... // C&oacute;digo de constructor subclase
}</pre>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Podemos generar el constructor de una clase autom&aacute;ticamente con Eclipse, pulsando
con el bot&oacute;n derecho sobre el c&oacute;digo y seleccionando <em>Source &gt; Generate Constructor Using Fields...</em>
o <em>Source &gt; Generate Constructors From Superclass...</em>
</div>
</div>
<a name="N1025D"></a><a name="Paquetes"></a>
<h3 class="underlined_5">Paquetes</h3>
<p>Las clases en Java se organizan (o pueden organizarse) en paquetes, de
  forma que cada paquete contenga un conjunto de clases. Tambi&eacute;n puede haber
  subpaquetes especializados dentro de un paquete o subpaquete, formando as&iacute;
  una jerarqu&iacute;a de paquetes, que despu&eacute;s se plasma en el disco duro en una
  estructura de directorios y subdirectorios igual a la de paquetes y
  subpaquetes (cada clase ir&aacute; en el directorio/subdirectorio correspondiente a
  su paquete/subpaquete).</p>
<p>Cuando queremos indicar que una clase pertenece a un determinado paquete o
  subpaquete, se coloca al principio del fichero la palabra reservada <span class="codefrag">package</span>
  seguida por los paquetes/subpaquetes, separados por '.' :</p>
<pre class="brush:java;">package paq1.subpaq1;
...
class MiClase {
...</pre>
<p>Si queremos desde otra clase utilizar una clase de un paquete o subpaquete
  determinado (diferente al de la clase en la que estamos), incluimos una
  sentencia <span class="codefrag">import</span> antes de la clase (y despu&eacute;s de la l&iacute;nea <span class="codefrag">package</span>
  que pueda tener la clase, si la tiene), indicando qu&eacute; paquete o subpaquete
  queremos importar:</p>
<pre class="brush:java;">import paq1.subpaq1.*;</pre>
<pre class="brush:java;">import paq1.subpaq1.MiClase;</pre>
<p>La primera opci&oacute;n (*) se utiliza para importar todas las clases del
  paquete (se utiliza cuando queremos utilizar muchas clases del paquete, para
  no ir importando una a una). La segunda opci&oacute;n se utiliza para importar una
  clase en concreto.</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Es recomendable indicar siempre las clases concretas que se est&aacute;n importando y
  no utilizar el <span class="codefrag">*</span>. De esta forma quedar&aacute; m&aacute;s claro cuales son las clases que se 
  utilizan realmente en nuestro c&oacute;digo. Hay diferentes paquetes que contienen clases con el
  mismo nombre, y si se importasen usando <span class="codefrag">*</span> podr&iacute;amos tener un problema de 
  ambig&uuml;edad.</div>
</div>
<p>Al importar, ya podemos utilizar el nombre de la clase importada
  directamente en la clase que estamos construyendo. Si no coloc&aacute;semos el <span class="codefrag">import</span>
  podr&iacute;amos utilizar la clase igual, pero al referenciar su nombre tendr&iacute;amos
  que ponerlo completo, con paquetes y subpaquetes:</p>
<pre class="brush:java;">MiClase mc;              // Si hemos hecho el 'import' antes</pre>
<pre class="brush:java;">paq1.subpaq1.MiClase mc; // Si NO hemos hecho el 'import' antes</pre>
<p>Existe un paquete en la API de Java, llamado <span class="codefrag">java.lang</span>, que no es
  necesario importar. Todas las clases que contiene dicho paquete son
  directamente utilizables. Para el resto de paquetes (bien sean de la API o
  nuestros propios), ser&aacute; necesario importarlos cuando estemos creando una
  clase fuera de dichos paquetes.</p>
<p>Los paquetes normalmente se escribir&aacute;n totalmente en min&uacute;sculas. Es recomendable utilizar nombres 
de paquetes similares a la URL de nuestra organizaci&oacute;n pero a la inversa, es decir, de m&aacute;s general a 
m&aacute;s concreto. Por ejemplo, si nuestra URL es <span class="codefrag">http://www.jtech.ua.es</span> los paquetes de nuestra aplicaci&oacute;n
podr&iacute;an recibir nombres como <span class="codefrag">es.ua.jtech.proyecto.interfaz</span>, <span class="codefrag">es.ua.jtech.proyecto.datos</span>,
etc.</p>
<div class="frame note">
<div class="label">Importante</div>
<div class="content">Nunca se debe crear una clase sin asignarle nombre de paquete. En este
caso la clase se encontrar&iacute;a en el paquete <span class="codefrag">sin nombre</span>, y no podr&iacute;a ser referenciada
por las clases del resto de paquetes de la aplicaci&oacute;n.</div>
</div>
<p>Con Eclipse podemos importar de forma autom&aacute;tica los paquetes necesarios. Para ello podemos pulsar sobre
el c&oacute;digo con el bot&oacute;n derecho y seleccionar <em>Source &gt; Organize imports</em>. Esto a&ntilde;adir&aacute; y 
ordenar&aacute; todos los <span class="codefrag">imports</span> necesarios. Sin embargo, esto no funcionar&aacute; si el c&oacute;digo
tiene errores de sintaxis. En ese caso si que podr&iacute;amos a&ntilde;adir un <span class="codefrag">import</span> individual, 
situando el cursor
sobre el nombre que se quiera importar, pulsando con el bot&oacute;n derecho, y seleccionando
<em>Source &gt; Add import</em>.</p>
<a name="N102CA"></a><a name="Tipo+enumerado"></a>
<h3 class="underlined_5">Tipo enumerado</h3>
<p>El tipo <span class="codefrag">enum</span> permite definir un conjunto de
        posibles valores o estados, que luego podremos utilizar donde queramos:</p>
<p>
<strong>Ejemplo</strong>
</p>
<pre class="brush:java;">// Define una lista de 3 valores y luego comprueba en un switch 
// cu&aacute;l es el valor que tiene un objeto de ese tipo
enum EstadoCivil {soltero, casado, divorciado};
EstadoCivil ec = EstadoCivil.casado;
ec = EstadoCivil.soltero;
switch(ec)
{
	case soltero:	System.out.println("Es soltero");
			break;
	case casado:	System.out.println("Es casado");
			break;
	case divorciado:System.out.println("Es divorciado");
			break;
}</pre>
<p>Los elementos de una enumeraci&oacute;n se comportan como objetos Java. Por lo tanto, la forma de nombrar
las enumeraciones ser&aacute; similar a la de las clases (cada palabra empezando por may&uacute;scula, y el resto de
clases en min&uacute;scula).</p>
<p>Como objetos Java que son, estos elementos pueden tener definidos campos, m&eacute;todos e incluso constructores.
Imaginemos por ejemplo que de cada tipo de estado civil nos interesase conocer la retenci&oacute;n que se les aplica
en el sueldo. Podr&iacute;amos introducir esta informaci&oacute;n de la siguiente forma:</p>
<pre class="brush:java;">enum EstadoCivil {soltero(0.14f), casado(0.18f), divorciado(0.14f);
	private float retencion;
	
	EstadoCivil(float retencion) {
		this.retencion = retencion;
	}
	
	public float getRetencion() {
		return retencion;
	}
};</pre>
<p>De esta forma podr&iacute;amos calcular de forma sencilla la retenci&oacute;n que se le aplica a una persona dado su 
salario y su estado civil de la siguiente forma:</p>
<pre class="brush:java;">public float calculaRetencion(EstadoCivil ec, float salario) {
    return salario * ec.getRetencion();		
}</pre>
<p>Dado que los elementos de la enumeraci&oacute;n son objetos, podr&iacute;amos crear nuevos m&eacute;todos o bien sobrescribir 
m&eacute;todos de la clase <span class="codefrag">Object</span>. Por ejemplo, podr&iacute;amos redefinir el m&eacute;todo <span class="codefrag">toString</span>
para especificar la forma en la que se imprime cada elemento de la enumeraci&oacute;n (por defecto imprime una
cadena con el nombre del elemento, por ejemplo <span class="codefrag">"soltero"</span>).</p>
<a name="N102FF"></a><a name="Modificadores+de+acceso-N102FF"></a>
<h3 class="underlined_5">Modificadores de acceso</h3>
<p>Tanto las clases como los campos y m&eacute;todos admiten modificadores de
  acceso, para indicar si dichos elementos tienen &aacute;mbito <em>p&uacute;blico, protegido
  </em>o <em>privado</em>. Dichos modificadores se marcan con las palabras
  reservadas <span class="codefrag">public, protected </span>y <span class="codefrag">private</span>, respectivamente, y se
  colocan al principio de la declaraci&oacute;n:</p>
<pre class="brush:java;">public class MiClase {
...
protected int b;
...
private int miMetodo(int b) {
...</pre>
<p>El modificador <span class="codefrag">protected</span> implica que los elementos que lo llevan son 
  visibles desde la clase, sus subclases, y las dem&aacute;s clases del mismo paquete 
  que la clase. </p>
<p>Si no se especifica ning&uacute;n modificador, el elemento ser&aacute; considerado 
  de tipo <em>paquete</em>. Este tipo de elementos podr&aacute;n ser visibles 
  desde la clase o desde clases del mismo paquete, pero no desde las subclases.</p>
<p>Cada fichero Java que creemos debe tener una y s&oacute;lo una <strong>clase p&uacute;blica</strong>
  (que ser&aacute; la clase principal del fichero). Dicha clase debe llamarse igual
  que el fichero. Aparte, el fichero podr&aacute; tener otras clases internas, pero ya
  no podr&aacute;n ser p&uacute;blicas.</p>
<p>Por ejemplo, si tenemos un fichero <span class="codefrag">MiClase.java</span>,
  podr&iacute;a tener esta apariencia:</p>
<pre class="brush:java;">public class MiClase 
{
	...
}

class OtraClase
{
	...
}

class UnaClaseMas
{
	...
}</pre>
<p>Si queremos tener acceso a estas clases internas desde otras clases, deberemos declararlas como 
est&aacute;ticas. Por ejemplo, si queremos definir una etiqueta para incluir en los puntos 2D definidos
en el ejemplo anterior, podemos definir esta etiqueta como clase interna (para dejar claro de esta
forma que dicha etiqueta es para utilizarse en <span class="codefrag">Punto2D</span>). Para poder manipular esta clase 
interna desde fuera deberemos declararla como est&aacute;tica de la siguiente forma:</p>
<pre class="brush:java;">public class Punto2D {
    ...	
	static class Etiqueta {
		String texto;
		int tam;
		Color color;
	}
}</pre>
<p>Podremos hacer referencia a ella desde fuera de <span class="codefrag">Punto2D</span> de la siguiente forma:</p>
<pre class="brush:java;">Punto2D.Etiqueta etiq = new Punto2D.Etiqueta();</pre>
<a name="N1034D"></a><a name="Otros+modificadores"></a>
<h3 class="underlined_5">Otros modificadores</h3>
<p>Adem&aacute;s de los modificadores de acceso vistos antes, en clases, m&eacute;todos
  y/o campos se pueden utilizar tambi&eacute;n estos modificadores:</p>
<ul>


<li>

<span class="codefrag">abstract</span>: elemento base para la herencia (los objetos
subtipo deber&aacute;n definir este elemento). Se utiliza para definir clases
abstractas, y m&eacute;todos abstractos dentro de dichas clases, para que los
implementen las subclases que hereden de ella.</li>


<li>

<span class="codefrag">static</span>: elemento compartido por todos los objetos
de la misma clase. Con este modificador, no se crea una copia del elemento en
cada objeto que se cree de la clase, sino que todos comparten una sola copia en
memoria del elemento, que se crea sin necesidad de crear un objeto de la clase
que lo contiene. Como se ha visto anteriormente, tambi&eacute;n puede ser aplicado
sobre clases, con un significado diferente en este caso.</li>


<li>

<span class="codefrag">final</span>: objeto final, no modificable (se utiliza para definir
constantes) ni heredable (en caso de aplicarlo a clases).</li>


<li>

<span class="codefrag">synchronized</span>: para elementos a los que no se puede acceder al mismo tiempo
desde distintos hilos de ejecuci&oacute;n.</li>

</ul>
<p>Estos modificadores se colocan tras los modificadores de acceso:</p>
<pre class="brush:java;">// Clase abstracta para heredar de ella
public abstract class Ejemplo 		
{
  // Constante est&aacute;tica de valor 10
  public static final TAM = 10;	

  // M&eacute;todo abstracto a implementar
  public abstract void metodo();	
	
  public synchronized void otroMetodo()
  {
    ... // Aqu&iacute; dentro s&oacute;lo puede haber un hilo a la vez
  }
}</pre>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Si tenemos un m&eacute;todo est&aacute;tico (<span class="codefrag">static</span>), dentro de
  &eacute;l s&oacute;lo podremos utilizar elementos est&aacute;ticos (campos o m&eacute;todos
  est&aacute;ticos), o bien campos y m&eacute;todos de objetos que hayamos creado dentro del
  m&eacute;todo.</div>
</div>
<p>Por ejemplo, si tenemos:</p>
<pre class="brush:java;">public class UnaClase
{
  public int a;

  public static int metodo()
  {
    return a + 1;
  }
}</pre>
<p>Dar&aacute; error, porque el campo <span class="codefrag">a</span> no es est&aacute;tico, y lo estamos
  utilizando dentro del m&eacute;todo est&aacute;tico. Para solucionarlo tenemos dos
  posibilidades: definir <span class="codefrag">a</span> como est&aacute;tico (si el dise&ntilde;o del programa lo
  permite), o bien crear un objeto de tipo <span class="codefrag">UnaClase</span> en el m&eacute;todo, y
  utilizar su campo <span class="codefrag">a</span> (que ya no har&aacute; falta que sea est&aacute;tico, porque
  hemos creado un objeto y ya podemos acceder a su campo <span class="codefrag">a</span>):</p>
<pre class="brush:java;">public class UnaClase
{
  public int a;

  public static int metodo()
  {
    UnaClase uc = new UnaClase();
    // ... Aqu&iacute; har&iacute;amos que uc.a tuviese el valor adecuado
    return uc.a + 1;
  }
}</pre>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Para hacer referencia a un elemento est&aacute;tico utilizaremos siempre el nombre de 
la clase a la que pertenece, y no la referencia a una instancia concreta de dicha clase.</div>
</div>
<p>Por ejemplo, si hacemos lo siguiente:</p>
<pre class="brush:java;">UnaClase uc = new UnaClase();
uc.metodo();</pre>
<p>Aparecer&aacute; un <em>warning</em>, debido a que el m&eacute;todo <span class="codefrag">metodo</span> no es propio de la 
instancia concreta <span class="codefrag">uc</span>, sino da la clase <span class="codefrag">UnaClase</span> en general. Por lo tanto, 
deberemos llamarlo con:</p>
<pre class="brush:java;">UnaClase.metodo();</pre>
<a name="N103C0"></a><a name="Imports+est%C3%A1ticos"></a>
<h3 class="underlined_5">Imports est&aacute;ticos</h3>
<p>Los <em>imports</em> est&aacute;ticos permiten importar los elementos
        est&aacute;ticos de una clase, de forma que para referenciarlos no tengamos
        que poner siempre como prefijo el nombre de la clase. Por ejemplo,
        podemos utilizar las constantes de color de la clase <span class="codefrag">java.awt.Color</span>,
        o bien los m&eacute;todos matem&aacute;ticos de la case <span class="codefrag">Math</span>.</p>
<p>
<strong>Ejemplo</strong>
</p>
<pre class="brush:java;">import static java.awt.Color;
import static java.lang.Math;

public class... 
{
...
  JLabel lbl = new JLabel();
  lbl.setBackground(white);      // Antes ser&iacute;a Color.white
...
  double raiz = sqrt(1252.2);	 // Antes ser&iacute;a Math.sqrt(...)
}</pre>
<a name="N103DC"></a><a name="Argumentos+variables"></a>
<h3 class="underlined_5">Argumentos variables</h3>
<p>Java permite pasar un n&uacute;mero variable de argumentos a una
        funci&oacute;n (como sucede con funciones como <span class="codefrag">printf</span> en C). Esto se
        consigue mediante la expresi&oacute;n "..." a partir del momento en
        que queramos tener un n&uacute;mero variable de argumentos.</p>
<p>
<strong>Ejemplo</strong>
</p>
<pre class="brush:java;">// Funcion que tiene un par&aacute;metro <span class="codefrag">String</span> obligatorio
// y n par&aacute;metros int opcionales

public void miFunc(String param, int... args) 
{
...
	// Una forma de procesar n parametros variables
	for (int argumento: args)
	{
		...
	}
...
}

...
miFunc("Hola", 1, 20, 30, 2);
miFunc("Adios");</pre>
<a name="N103F5"></a><a name="Metainformaci%C3%B3n+o+anotaciones"></a>
<h3 class="underlined_5">Metainformaci&oacute;n o anotaciones</h3>
<p>Se tiene la posibilidad de a&ntilde;adir ciertas <strong>anotaciones</strong> en campos,
        m&eacute;todos, clases y otros elementos, que permitan a las herramientas de
        desarrollo o de despliegue leerlas y realizar ciertas tareas. Por
        ejemplo, generar ficheros fuentes, ficheros XML, o un <em>Stub</em> de
        m&eacute;todos para utilizar remotamente con RMI.</p>
<p>Un ejemplo m&aacute;s claro lo tenemos en las anotaciones que ya se
        utilizan para la herramienta Javadoc. Las marcas <span class="codefrag">@deprecated</span> no
        afectan al comportamiento de los m&eacute;todos que las llevan, pero previenen
        al compilador para que muestre una advertencia indicando que el m&eacute;todo
        que se utiliza est&aacute; desaconsejado. Tambi&eacute;n se tienen otras marcas <span class="codefrag">@param</span>,
        <span class="codefrag">@return</span>, @<span class="codefrag">see</span>, etc, que utiliza Javadoc para generar las
        p&aacute;ginas de documentaci&oacute;n y las relaciones entre ellas.</p>
<a name="N10414"></a><a name="Ejecuci%C3%B3n+de+clases%3A+m%C3%A9todo"></a>
<h3 class="underlined_5">Ejecuci&oacute;n de clases: m&eacute;todo main</h3>
<p>En las clases principales de una aplicaci&oacute;n (las clases que queramos
  ejecutar) debe haber un m&eacute;todo <span class="codefrag">main</span> con la siguiente estructura:</p>
<pre class="brush:java;">public static void main(String[] args)
{
	... // C&oacute;digo del m&eacute;todo
}</pre>
<p>Dentro pondremos el c&oacute;digo que queramos ejecutar desde esa clase. Hay que
  tener en cuenta que <span class="codefrag">main</span> es est&aacute;tico, con lo que dentro s&oacute;lo podremos
  utilizar campos y m&eacute;todos est&aacute;ticos, o bien campos y m&eacute;todos de objetos que
  creemos dentro del <span class="codefrag">main</span>.</p>
</div>


<a name="N10432"></a><a name="Herencia+e+interfaces"></a>
<h2 class="underlined_10">Herencia e interfaces</h2>
<div class="section">
<a name="N10438"></a><a name="Herencia"></a>
<h3 class="underlined_5">Herencia</h3>
<p>Cuando queremos que una clase herede de otra, se utiliza al declararla la palabra <span class="codefrag">extends</span> 
  tras el nombre de la clase, para decir de qu&eacute; 
    clase se hereda. Para hacer que <span class="codefrag">Pato </span>herede de <span class="codefrag">Animal</span>:</p>
<pre class="brush:java;">class Pato extends Animal</pre>
<p>Con esto autom&aacute;ticamente <span class="codefrag">Pato</span> tomar&iacute;a todo lo que tuviese <span class="codefrag">Animal</span>
(aparte, <span class="codefrag">Pato</span> puede a&ntilde;adir sus caracter&iacute;sticas propias). Si <span class="codefrag">Animal</span> fuese una clase abstracta,
<span class="codefrag">Pato </span>deber&iacute;a implementar los m&eacute;todos
abstractos que tuviese.</p>
<a name="N10462"></a><a name="Punteros"></a>
<h3 class="underlined_5">Punteros this y super</h3>
<p>El puntero <span class="codefrag">this</span> apunta al objeto en el que nos encontramos. 
  Se utiliza normalmente cuando hay variables locales con el mismo nombre que variables
  de instancia de nuestro objeto:</p>
<pre class="brush:java;">public class MiClase 
{
  int i;
  public MiClase(int i) 
  {
    this.i = i; 	// i de la clase = parametro i
  }
}</pre>
<p>Tambi&eacute;n se suele utilizar para remarcar que se est&aacute; accediendo a variables de instancia.</p>
<p>El puntero <span class="codefrag">super</span> se usa para acceder a un elemento en la clase padre. Si la clase
<span class="codefrag">Usuario</span> tiene un m&eacute;todo <span class="codefrag">getPermisos</span>, y una subclase <span class="codefrag">UsuarioAdministrador</span>
sobrescribe dicho m&eacute;todo, podr&iacute;amos llamar al m&eacute;todo de la super-clase con:</p>
<pre class="brush:java;">public class UsuarioAdministrador extends Usuario {
  public List&lt;String&gt; getPermisos() {
    List&lt;String&gt; permisos = super.getPermisos();
    permisos.add(PERMISO_ADMINISTRADOR);
    return permisos;
  }
}</pre>
<p>Tambi&eacute;n podemos utilizar <span class="codefrag">this</span> y <span class="codefrag">super</span> como primera instrucci&oacute;n
dentro de un constructor para invocar a otros constructores. Dado que toda clase en Java
hereda de otra clase, siempre ser&aacute; necesario llamar a alguno de los constructores de la super-clase
para que se construya la parte relativa a ella. Por lo tanto, si al comienzo del constructor no se 
especifica ninguna llamada a <span class="codefrag">this</span> o <span class="codefrag">super</span>, se considera que hay
una llamada impl&iacute;cita al constructor sin par&aacute;metros de la super-clase (<span class="codefrag">super()</span>). Es
decir, los dos constructores siguientes son equivalentes:</p>
<pre class="brush:java;">public Punto2D(int x, int y, String etiq) {
    // Existe una llamada implicita a super()

    this.x = x;
    this.y = y;
    this.etiq = etiq;
}

public Punto2D(int x, int y, String etiq) {
    super();
    
    this.x = x;
    this.y = y;
    this.etiq = etiq;
}</pre>
<p>Pero es posible que la super-clase no disponga de un constructor sin par&aacute;metros. En ese caso, si 
no hacemos una llamada expl&iacute;cita a <span class="codefrag">super</span> nos dar&aacute; un error de compilaci&oacute;n, ya que estar&aacute;
intentando llamar a un constructor inexistente de forma impl&iacute;cita. Es posible tambi&eacute;n, que aunque 
el constructor sin par&aacute;metros exista, nos interese llamar a otro constructor a la hora de construir la
parte relativa a la super-clase. Imaginemos por ejemplo que la clase <span class="codefrag">Punto2D</span> anterior
deriva de una clase <span class="codefrag">PrimitivaGeometrica</span> que almacena, como informaci&oacute;n com&uacute;n de todas 
las primitivas, una etiqueta de texto, y ofrece un constructor que toma como par&aacute;metro dicha etiqueta. 
Podr&iacute;amos utilizar dicho constructor desde la subclase de la siguiente forma: </p>
<pre class="brush:java;">public Punto2D(int x, int y, String etiq) {
    super(etiq);
    
    this.x = x;
    this.y = y;
}</pre>
<p>Tambi&eacute;n puede ocurrir que en lugar de querer llamar directamente al constructor de la super-clase
nos interese basar nuestro constructor en otro de los constructores de nuestra misma clase. En tal caso
llamaremos a <span class="codefrag">this</span> al comienzo de nuestro constructor, pas&aacute;ndole los par&aacute;metros correspondientes
al constructor en el que queremos basarnos. Por ejemplo, podr&iacute;amos definir un constructor sin par&aacute;metros
de nuestra clase punto, que se base en el constructor anterior (m&aacute;s espec&iacute;fico) para crear un punto
con una serie de datos por defecto:</p>
<pre class="brush:java;">public Punto2D() {
    this(DEFAULT_X, DEFAULT_Y, DEFAULT_ETIQ);
}</pre>
<p>Es importante recalcar que las llamadas a <span class="codefrag">this</span> o <span class="codefrag">super</span> deben ser siempre
la primera instrucci&oacute;n del constructor.</p>
<a name="N104CC"></a><a name="Interfaces+y+clases+abstractas"></a>
<h3 class="underlined_5">Interfaces y clases abstractas</h3>
<p>Ya hemos visto c&oacute;mo definir clases normales, y clases abstractas. Si queremos definir
un interfaz, se utiliza la palabra reservada <span class="codefrag">interface</span>, en lugar de <span class="codefrag">class</span>,
y dentro declaramos (no implementamos), los m&eacute;todos que queremos que tenga la
interfaz:</p>
<pre class="brush:java;">public interface MiInterfaz 
{
	public void metodoInterfaz();
	public float otroMetodoInterfaz();
}</pre>
<p>Despu&eacute;s, para que una clase implemente los m&eacute;todos de esta interfaz, se
utiliza la palabra reservada <span class="codefrag">implements</span> tras el nombre de la clase:</p>
<pre class="brush:java;">public class UnaClase implements MiInterfaz 
{
	public void metodoInterfaz()
	{
		... // C&oacute;digo del m&eacute;todo
	}

	public float otroMetodoInterfaz()
	{
		... // C&oacute;digo del m&eacute;todo
	}
}</pre>
<p>Notar que si en lugar de poner <span class="codefrag">implements</span> ponemos <span class="codefrag">extends</span>, en
ese caso <span class="codefrag">UnaClase</span> deber&iacute;a ser un <span class="codefrag">interfaz</span>, que heredar&iacute;a del
interfaz <span class="codefrag">MiInterfaz</span> para definir m&aacute;s m&eacute;todos, pero no para implementar
los que tiene la interfaz. Esto se utilizar&iacute;a para definir interfaces partiendo
de un interfaz base, para a&ntilde;adir m&aacute;s m&eacute;todos a implementar.</p>
<p>Una clase puede heredar s&oacute;lo de otra &uacute;nica clase, pero puede implementar
cuantos interfaces necesite:</p>
<pre class="brush:java;">public class UnaClase extends MiClase 
           implements MiInterfaz, MiInterfaz2, MiInterfaz3
{
	...
}</pre>
<p>Cuando una clase implementa una interfaz se est&aacute; asegurando que dicha clase va a ofrecer los m&eacute;todos
definidos en la interfaz, es decir, que la clase al menos nos ofrece esa interfaz para acceder a ella.
Cuando heredamos de una clase abstracta, heredamos todos los campos y el comportamiento de la 
superclase, y adem&aacute;s deberemos definir algunos m&eacute;todos que no hab&iacute;an sido implementados en la 
superclase.</p>
<p>Desde el punto de vista del dise&ntilde;o, podemos ver la herencia como una relaci&oacute;n <em>ES</em>, mientras
que la implementaci&oacute;n de una interfaz ser&iacute;a una relaci&oacute;n <em>ACT&Uacute;A COMO</em>.</p>
</div>


<a name="N10513"></a><a name="Hilos"></a>
<h2 class="underlined_10">Hilos</h2>
<div class="section">
<p>En este curso no vamos a profundizar en la programaci&oacute;n de hilos. Si bien las aplicaciones
        en servidor funcionan sobre m&uacute;ltiples hilos, de su gesti&oacute;n ya se ocupan los servidores
        de aplicaciones, como se ver&aacute;. Independientemente de esto, es positivo conocer 
        el mecanismo de hilos y sobre todo, su sincronizaci&oacute;n.</p>
<p> Un hilo es un flujo de control dentro de un programa. Creando varios hilos   			
        podremos realizar varias tareas simult&aacute;neamente. Cada hilo tendr&aacute;   			
        s&oacute;lo un contexto de ejecuci&oacute;n (contador de programa, pila de ejecuci&oacute;n).   			
        Es decir, a diferencia de los procesos UNIX, no tienen su propio espacio de   			
        memoria sino que acceden todos al mismo espacio de memoria com&uacute;n, por   			
        lo que ser&aacute; importante su sincronizaci&oacute;n cuando tengamos varios   			
        hilos accediendo a los mismos objetos. </p>
<a name="N1051F"></a><a name="Creaci%C3%B3n+de+hilos"></a>
<h3 class="underlined_5">Creaci&oacute;n de hilos</h3>
<p>En Java los hilos est&aacute;n encapsulados en la clase <span class="codefrag">Thread</span>. 
		   Para crear un hilo tenemos dos posibilidades:</p>
<ul>
		  
<li>Heredar de <span class="codefrag">Thread</span> redefiniendo el m&eacute;todo <span class="codefrag">run()</span>.</li>
		  
<li>Crear una clase que implemente la interfaz <span class="codefrag">Runnable</span> que nos obliga       
		      a definir el m&eacute;todo <span class="codefrag">run()</span>.</li>
		
</ul>
<p>En ambos casos debemos definir un m&eacute;todo <span class="codefrag">run()</span> que ser&aacute;     
		   el que contenga el c&oacute;digo del hilo. Desde dentro de este m&eacute;todo     
		   podremos llamar a cualquier otro m&eacute;todo de cualquier objeto, pero este     
		   m&eacute;todo <span class="codefrag">run()</span> ser&aacute; el m&eacute;todo que se invoque cuando     
		   iniciemos la ejecuci&oacute;n de un hilo. El hilo terminar&aacute; su ejecuci&oacute;n     
		   cuando termine de ejecutarse este m&eacute;todo <span class="codefrag">run()</span>.</p>
<p>Para crear nuestro hilo mediante herencia haremos lo siguiente:</p>
<pre class="brush:java;">
public class EjemploHilo extends Thread  
{      
	public void run()() 
	{
		// C&oacute;digo del hilo      
	}  
}
		</pre>
<p>Una vez definida la clase de nuestro hilo deberemos instanciarlo y ejecutarlo     
		    de la siguiente forma:</p>
<pre class="brush:java;">
Thread t = new EjemploHilo();
t.start();
		</pre>
<p>Al llamar al m&eacute;todo <span class="codefrag">start</span> del hilo, comenzar&aacute; ejecutarse 
		    su m&eacute;todo <span class="codefrag">run</span>. Crear un hilo heredando de <span class="codefrag">Thread</span> 
		    tiene el problema de que al no haber herencia m&uacute;ltiple en Java, si heredamos 
		    de <span class="codefrag">Thread</span> no podremos heredar de ninguna otra clase, y por lo tanto un 
		    hilo no podr&iacute;a heredar de ninguna otra clase.</p>
<p>Este problema desaparece si utilizamos la interfaz <span class="codefrag">Runnable</span> para crear     
		    el hilo, ya que una clase puede implementar varios interfaces. Definiremos la     
		    clase que contenga el hilo como se muestra a continuaci&oacute;n:</p>
<pre class="brush:java;">
public class EjemploHilo implements Runnable
{
	public void run() 
	{          
		// C&oacute;digo del hilo      
	}  
}
		</pre>
<p>Para instanciar y ejecutar un hilo de este tipo deberemos hacer lo siguiente:</p>
<pre class="brush:java;">
Thread t = new Thread(new EjemploHilo());  
t.start();
		</pre>
<p>Esto es as&iacute; debido a que en este caso <span class="codefrag">EjemploHilo</span> no deriva     
		   de una clase <span class="codefrag">Thread</span>, por lo que no se puede considerar un hilo, lo &uacute;nico     
		   que estamos haciendo implementando la interfaz es asegurar que vamos a tener     
		   definido el m&eacute;todo <span class="codefrag">run()</span>. Con esto lo que haremos ser&aacute;     
		   proporcionar esta clase al constructor de la clase <span class="codefrag">Thread</span>, para que el     
		   objeto <span class="codefrag">Thread</span> que creemos llame al m&eacute;todo <span class="codefrag">run()</span> de la     
		   clase que hemos definido al iniciarse la ejecuci&oacute;n del hilo, ya que implementando     
		   la interfaz le aseguramos que esta funci&oacute;n existe.</p>
<a name="N10593"></a><a name="Ciclo+de+vida+y+prioridades"></a>
<h3 class="underlined_5">Ciclo de vida y prioridades</h3>
<p>Un hilo pasar&aacute; por varios estados durante su ciclo de vida. </p>
<pre class="brush:java;">Thread t = new Thread(this);</pre>
<p>Una vez se ha instanciado el objeto del hilo, diremos que est&aacute; en estado     
		    de <em> Nuevo hilo</em>.</p>
<pre class="brush:java;">t.start();</pre>
<p>Cuando invoquemos su m&eacute;todo <span class="codefrag">start()</span> el hilo pasar&aacute; a ser     
		    un hilo <em>vivo</em>, comenz&aacute;ndose a ejecutar su m&eacute;todo <span class="codefrag">run()</span>.     
		    Una vez haya salido de este m&eacute;todo pasar&aacute; a ser un hilo <em>muerto</em>.</p>
<p>La &uacute;nica forma de parar un hilo es hacer que salga del m&eacute;todo <span class="codefrag">run()</span> 
		    de forma natural. Podremos conseguir esto haciendo que se cumpla  
		    una condici&oacute;n de salida de <span class="codefrag">run()</span> (l&oacute;gicamente, la condici&oacute;n que  
		    se nos ocurra depender&aacute; del tipo de programa que estemos haciendo).     
		    Las funciones para parar, pausar y reanudar hilos est&aacute;n desaprobadas     
		    en las versiones actuales de Java.</p>
<p>Mientras el hilo est&eacute; <em>vivo</em>, podr&aacute; encontrarse en dos estados: 
		    <em> Ejecutable</em> y <em> No ejecutable</em>. El hilo pasar&aacute; de <em> Ejecutable</em> a 
		    <em> No ejecutable</em> en los siguientes casos:</p>
<ul>
		  
<li>Cuando se encuentre dormido por haberse llamado al m&eacute;todo <span class="codefrag">sleep()</span>,      
			permanecer&aacute; <em> No ejecutable</em> hasta haber transcurrido el n&uacute;mero       
			de milisegundos especificados.</li>
		  
<li>Cuando se encuentre bloqueado en una llamada al m&eacute;todo <span class="codefrag">wait()</span> 
		      esperando que otro hilo lo desbloquee llamando a <em>notify()</em> o <em>notifyAll()</em>.      
		      Veremos c&oacute;mo utilizar estos m&eacute;todos m&aacute;s adelante.</li>
		  
<li>Cuando se encuentre bloqueado en una petici&oacute;n de E/S, hasta que se       
		      complete la operaci&oacute;n de E/S.</li>
		
</ul>
<p>
<img alt="Ciclo de vida de los hilos" content-width="6cm" height="154" src="imagenes/lenguaje/3-2.gif" width="405"></p>
<p>Lo &uacute;nico que podremos saber es si un hilo se encuentra vivo o no, llamando     
		    a su m&eacute;todo <span class="codefrag">isAlive()</span>.</p>
<p>
<strong>Prioridades de los hilos</strong>
</p>
<p>Adem&aacute;s, una propiedad importante de los hilos ser&aacute; su prioridad.     
		    Mientras el hilo se encuentre vivo, el <em>scheduler</em> de la m&aacute;quina     
		    virtual Java le asignar&aacute; o lo sacar&aacute; de la CPU, coordinando as&iacute;     
		    el uso de la CPU por parte de todos los hilos activos bas&aacute;ndose en su     
		    prioridad. Se puede forzar la salida de un hilo de la CPU llamando a su m&eacute;todo <span class="codefrag">yield()</span>. 
		    Tambi&eacute;n se sacar&aacute; un hilo de la CPU cuando un hilo de mayor prioridad se haga 
		    <em>Ejecutable</em>, o cuando el tiempo que se le haya asignado expire.</p>
<p>Para cambiar la prioridad de un hilo se utiliza el m&eacute;todo <span class="codefrag">setPriority()</span>,     
		    al que deberemos proporcionar un valor de prioridad entre <span class="codefrag">MIN_PRIORITY</span> y 
		    <span class="codefrag">MAX_PRIORITY</span> (ten&eacute;is constantes de prioridad disponibles dentro de  
		    la clase <span class="codefrag">Thread</span>, consultad el API de Java para ver qu&eacute; valores de  
		    constantes hay).</p>
<a name="N1061E"></a><a name="Sincronizaci%C3%B3n+de+hilos"></a>
<h3 class="underlined_5">Sincronizaci&oacute;n de hilos</h3>
<p>Muchas veces los hilos deber&aacute;n trabajar de forma coordinada, por lo     
		    que es necesario un mecanismo de sincronizaci&oacute;n entre ellos.</p>
<p>Un primer mecanismo de comunicaci&oacute;n es la variable cerrojo incluida     
		    en todo objeto <span class="codefrag">Object</span>, que permitir&aacute; evitar que m&aacute;s de     
		    un hilo entre en la secci&oacute;n cr&iacute;tica para un objeto determinado. 
		    Los m&eacute;todos declarados como <span class="codefrag">synchronized</span> utilizan el cerrojo del 
		    objeto al que pertenecen evitando que m&aacute;s de un hilo entre en ellos al mismo tiempo.</p>
<pre class="brush:java;">
public synchronized void seccion_critica()  
{ 
	// C&oacute;digo secci&oacute;n cr&iacute;tica 
}
		</pre>
<p>Todos los m&eacute;todos <span class="codefrag">synchronized</span> de un mismo objeto (no clase, sino  
		    objeto de esa clase), comparten el mismo cerrojo, y es distinto al cerrojo de  
		    otros objetos (de la misma clase, o de otras).</p>
<p>Tambi&eacute;n podemos utilizar cualquier otro objeto para la sincronizaci&oacute;n     
		    dentro de nuestro m&eacute;todo de la siguiente forma:</p>
<pre class="code">
synchronized(objeto_con_cerrojo) 
{ 
  // C&oacute;digo secci&oacute;n cr&iacute;tica 
}
		</pre>
<p>de esta forma sincronizar&iacute;amos el c&oacute;digo que escribi&eacute;semos dentro, con el  
		    c&oacute;digo <span class="codefrag">synchronized</span> del objeto <span class="codefrag">objeto_con_cerrojo</span>. </p>
<p>Adem&aacute;s podemos hacer que un hilo quede bloqueado a la espera de que     
		    otro hilo lo desbloquee cuando suceda un determinado evento. Para bloquear un     
		    hilo usaremos la funci&oacute;n <span class="codefrag">wait()</span>, para lo cual el hilo que llama     
		    a esta funci&oacute;n debe estar en posesi&oacute;n del monitor, cosa que ocurre     
		    dentro de un m&eacute;todo <span class="codefrag">synchronized</span>, por lo que s&oacute;lo podremos     
		    bloquear a un proceso dentro de estos m&eacute;todos. </p>
<p>Para desbloquear a los hilos que haya bloqueados se utilizar&aacute; <em>notifyAll()</em>,     
		    o bien <span class="codefrag">notify()</span> para desbloquear s&oacute;lo uno de ellos aleatoriamente.     
		    Para invocar estos m&eacute;todos ocurrir&aacute; lo mismo, el hilo deber&aacute;     
		    estar en posesi&oacute;n del monitor.</p>
<p>Cuando un hilo queda bloqueado liberar&aacute; el cerrojo para que otro hilo     
		    pueda entrar en la secci&oacute;n cr&iacute;tica del objeto y desbloquearlo.</p>
<p>Por &uacute;ltimo, puede ser necesario esperar a que un determinado hilo haya     
		    finalizado su tarea para continuar. Esto lo podremos hacer llamando al m&eacute;todo 
		    <span class="codefrag">join()</span> de dicho hilo, que nos bloquear&aacute; hasta que el hilo haya     
		    finalizado.</p>
</div>



<a name="N10668"></a><a name="Clases+%C3%BAtiles"></a>
<h2 class="underlined_10">Clases &uacute;tiles</h2>
<div class="section">
<p>Cuando se programa con Java, se dispone de antemano de un conjunto de clases 
  ya implementadas. Estas clases (aparte de las que pueda hacer el usuario) forman 
  parte del propio lenguaje (lo que se conoce como <strong>API</strong> (<em>Application 
  Programming Interface</em>) de Java). </p>
<p>En esta secci&oacute;n vamos a ver una serie de clases que conviene conocer 
  ya que nos ser&aacute;n de gran utilidad para realizar nuestros programas:</p>
<a name="N1067A"></a><a name="Object"></a>
<h3 class="underlined_5">Object</h3>
<p>Esta es la clase base de todas las clases en Java, toda clase hereda en &uacute;ltima 
  instancia de la clase <span class="codefrag">Object</span>, por lo que los m&eacute;todos 
  que ofrece estar&aacute;n disponibles en cualquier objeto Java, sea de la clase 
  que sea.</p>
<p>En Java es importante distinguir claramente entre lo que es una variable, y 
  lo que es un objeto. Las variables simplemente son referencias a objetos, mientras 
  que los objetos son las entidades instanciadas en memoria que podr&aacute;n 
  ser manipulados mediante las referencias que tenemos a ellos (mediante variable 
  que apunten a ellos) dentro de nuestro programa. Cuando hacemos lo siguiente:</p>
<pre class="brush:java;">new MiClase()</pre>
<p>Se est&aacute; instanciando en memoria un nuevo objeto de clase MiClase y nos 
  devuelve una referencia a dicho objeto. Nosotros deberemos guardarnos dicha 
  referencia en alguna variable con el fin de poder acceder al objeto creado desde 
  nuestro programa:</p>
<pre class="brush:java;">MiClase mc = new MiClase();</pre>
<p>Es importante declarar la referencia del tipo adecuado (en este caso tipo MiClase) 
  para manipular el objeto, ya que el tipo de la referencia ser&aacute; el que 
  indicar&aacute; al compilador las operaciones que podremos realizar con dicho 
  objeto. El tipo de esta referencia podr&aacute; ser tanto el mismo tipo del 
  objeto al que vayamos a apuntar, o bien el de cualquier clase de la que herede 
  o interfaz que implemente nuestro objeto. Por ejemplo, si MiClase se define 
  de la siguiente forma:</p>
<pre class="brush:java;">public class MiClase extends Thread implements List {
	...
}</pre>
<p>Podremos hacer referencia a ella de diferentes formas:</p>
<pre class="brush:java;">MiClase mc = new MiClase();
Thread t = new MiClase();
List l = new MiClase();
Object o = new MiClase();</pre>
<p>Esto es as&iacute; ya que al heredar tanto de <span class="codefrag">Thread</span> como 
  de <span class="codefrag">Object</span>, sabemos que el objeto tendr&aacute; todo lo que 
  tienen estas clases m&aacute;s lo que a&ntilde;ada <span class="codefrag">MiClase</span>, 
  por lo que podr&aacute; comportarse como cualquiera de las clases anteriores. 
  Lo mismo ocurre al implementar una interfaz, al forzar a que se implementen 
  sus m&eacute;todos podremos hacer referencia al objeto mediante la interfaz 
  ya que sabemos que va a contener todos esos m&eacute;todos. Siempre vamos a 
  poder hacer esta asignaci&oacute;n 'ascendente' a clases o interfaces de las 
  que deriva nuestro objeto.</p>
<p>Si hacemos referencia a un objeto <span class="codefrag">MiClase</span> mediante una referencia 
  <span class="codefrag">Object</span> por ejemplo, s&oacute;lo podremos acceder a los m&eacute;todos 
  de <span class="codefrag">Object</span>, aunque el objeto contenga m&eacute;todos adicionales 
  definidos en <span class="codefrag">MiClase</span>. Si conocemos que nuestro objeto es de 
  tipo <span class="codefrag">MiClase</span>, y queremos poder utilizarlo como tal, podremos 
  hacer una asignaci&oacute;n 'descendente' aplicando una conversi&oacute;n cast 
  al tipo concreto de objeto:</p>
<pre class="brush:java;">Object o = new MiClase();
...
MiClase mc = (MiClase) o;</pre>
<p>Si resultase que nuestro objeto no es de la clase a la que hacemos cast, ni 
  hereda de ella ni la implementa, esta llamada resultar&aacute; en un <span class="codefrag">ClassCastException</span> 
  indicando que no podemos hacer referencia a dicho objeto mediante esa interfaz 
  debido a que el objeto no la cumple, y por lo tanto podr&aacute;n no estar disponibles 
  los m&eacute;todos que se definen en ella.</p>
<p>Una vez hemos visto la diferencia entre las variables (referencias) y objetos 
  (entidades) vamos a ver como se har&aacute; la asignaci&oacute;n y comparaci&oacute;n 
  de objetos. Si hiciesemos lo siguiente:</p>
<pre class="brush:java;">MiClase mc1 = new MiClase();
MiClase mc2 = mc1;</pre>
<p>Puesto que hemos dicho que las variables simplemente son referencias a objetos, 
  la asignaci&oacute;n estar&aacute; copiando una referencia, no el objeto. Es 
  decir, tanto la variable <em>mc1 </em>como <em>mc2 </em>apuntar&aacute;n a un 
  mismo objeto.</p>
<p>Si lo que queremos es copiar un objeto, teniendo dos entidades independientes, 
  deberemos invocar el m&eacute;todo <span class="codefrag">clone</span> del objeto a copiar:</p>
<pre class="brush:java;">MiClase mc2 = (MiClase)mc1.clone();</pre>
<p>El m&eacute;todo <span class="codefrag">clone</span> es un m&eacute;todo de la clase <span class="codefrag">Object 
  </span>que estar&aacute; disponible para cualquier objeto Java, y nos devuelve 
  un <span class="codefrag">Object</span> gen&eacute;rico, ya que al ser un m&eacute;todo que 
  puede servir para cualquier objeto nos debe devolver la copia de este tipo. 
  De &eacute;l tendremos que hacer una conversi&oacute;n cast a la clase de la 
  que se trate como hemos visto en el ejemplo. Al hacer una copia con <span class="codefrag">clone</span>
  se copiar&aacute;n los valores de todas las variables de instancia, pero si estas variables
  son referencias a objetos s&oacute;lo se copiar&aacute; la referencia, no el objeto. Es decir, no se
  har&aacute; una copia en profundidad. Si queremos hacer una copia en profundidad deberemos 
  sobrescribir el m&eacute;todo <span class="codefrag">clone</span> para hacer una copia de cada uno de estos
  objetos. Para copiar objetos tambi&eacute;n podr&iacute;amos definir un constructor de copia, al
  que se le pase como par&aacute;metro el objeto original a copiar.</p>
<p>Por otro lado, para la comparaci&oacute;n, si hacemos lo siguiente:</p>
<pre class="brush:java;">mc1 == mc2</pre>
<p>Estaremos comparando referencias, por lo que estaremos viendo si las dos referencias 
  apuntan a un mismo objeto, y no si los objetos a los que apuntan son iguales. 
  Para ver si los objetos son iguales, aunque sean entidades distintas, tenemos:</p>
<pre class="brush:java;">mc1.equals(mc2)</pre>
<p>Este m&eacute;todo tambi&eacute;n es propio de la clase <span class="codefrag">Object</span>, 
  y ser&aacute; el que se utilice para comparar internamente los objetos. Para que funcione 
  correctamente, este m&eacute;todo deber&aacute;n ser redefinido en nuestras clases para indicar 
  cuando se considera que dos objetos son iguales. Por ejemplo podemos tener una clase
  como la siguiente:</p>
<pre class="brush:java;">public class Punto2D {

	public int x, y;	

	...

	public boolean equals(Object o) {
		Punto2D p = (Punto2D)o;
		// Compara objeto this con objeto p
		return (x == p.x &amp;&amp; y == p.y);
	}</pre>
<p>Un &uacute;ltimo m&eacute;todo interesante de la clase <span class="codefrag">Object</span> es <span class="codefrag">toString</span>. 
  Este m&eacute;todo nos devuelve una cadena (<span class="codefrag">String</span>) que representa dicho 
  objeto. Por defecto nos dar&aacute; un identificador del objeto, pero nosotros 
  podemos sobrescribirla en nuestras propias clases para que genere la cadena 
  que queramos. De esta manera podremos imprimir el objeto en forma de cadena 
  de texto, mostrandose los datos con el formato que nosotros les hayamos dado 
  en<span class="codefrag"> toString</span>. Por ejemplo, si tenemos una clase <span class="codefrag">Punto2D</span>, ser&iacute;a 
  buena idea hacer que su conversi&oacute;n a cadena muestre las coordenadas <em>(x,y)</em> 
  del punto:</p>
<pre class="brush:java;">public class Punto2D {

	public int x,y;

	...

	public String toString() {
		String s = "(" + x + "," + y + ")";
		return s;
	}
}</pre>
<a name="N10733"></a><a name="Properties"></a>
<h3 class="underlined_5">Properties</h3>
<p>Esta clase es un subtipo de <span class="codefrag">Hastable</span>, que se encarga de almacenar 
  una serie de propiedades asociando un valor a cada una de ellas. Estas propiedades 
  las podremos utilizar para registrar la configuraci&oacute;n de nuestra aplicaci&oacute;n. 
  Adem&aacute;s esta clase nos permite cargar o almacenar esta informaci&oacute;n 
  en alg&uacute;n dispositivo, como puede ser en disco, de forma que sea persistente.</p>
<p>Puesto que hereda de <span class="codefrag">Hashtable</span>, podremos utilizar sus m&eacute;todos, 
  pero tambi&eacute;n aporta m&eacute;todos propios para a&ntilde;adir propiedades:</p>
<pre class="code">Object <strong>setProperty(Object clave, Object valor)</strong>
</pre>
<p>Equivalente al m&eacute;todo <em>put</em>.</p>
<pre class="code">Object <strong>getProperty(Object clave)</strong>
</pre>
<p>Equivalente al m&eacute;todo <em>get</em>.</p>
<pre class="code">Object <strong>getProperty(Object clave, Object default)</strong>
</pre>
<p>Esta variante del m&eacute;todo resulta &uacute;til cuando queremos que determinada 
  propiedad devuelva alg&uacute;n valor por defecto si todav&iacute;a no se le 
  ha asignado ning&uacute;n valor.</p>
<p>Adem&aacute;s, como hemos dicho anteriormente, para hacer persistentes estas 
  propiedades de nuestra aplicaci&oacute;n, se proporcionan m&eacute;todos para 
  almacenarlas o leerlas de alg&uacute;n dispositivo de E/S:</p>
<pre class="code">void <strong>load(InputStream entrada)</strong>
</pre>
<p>Lee las propiedades del flujo de entrada proporcionado. Este flujo puede por 
  ejemplo referirse a un fichero del que se leer&aacute;n los datos.</p>
<pre class="code">void <strong>store(OutputStream salida, String cabecera)</strong>
</pre>
<p>Almacena las informaci&oacute;n de las propiedades escribiendolas en el flujo 
  de salida especificado. Este flujo puede por ejemplo referirse a un fichero 
  en disco, en el que se guardar&aacute; nuestro conjunto de propiedades, pudiendo 
  especificar una cadena que se pondr&aacute; como cabecera en el fichero, y que 
  nos permite a&ntilde;adir alg&uacute;n comentario sobre dicho fichero.</p>
<a name="N1077C"></a><a name="System"></a>
<h3 class="underlined_5">System</h3>
<p>Esta clase nos ofrece una serie de m&eacute;todos y campos &uacute;tiles del 
  sistema. Esta clase no se debe instanciar, todos estos m&eacute;todos y campos 
  son est&aacute;ticos.</p>
<p>Podemos encontrar los objetos que encapsulan la entrada, salida y salida de 
  error est&aacute;ndar, as&iacute; como m&eacute;todos para redireccionarlas, 
  que veremos con m&aacute;s detalle en el tema de entrada/salida.</p>
<p>Tambi&eacute;n nos permite acceder al gestor de seguridad instalado, como veremos 
  en el tema sobre seguridad.</p>
<p>Otros m&eacute;todos &uacute;tiles que encontramos son:</p>
<pre class="code">void <strong>exit(int estado)</strong>
</pre>
<p>Finaliza la ejecuci&oacute;n de la aplicaci&oacute;n, devolviendo un c&oacute;digo 
  de estado. Normalmente el c&oacute;digo 0 significa que ha salido de forma normal, 
  mientras que con otros c&oacute;digos indicaremos que se ha producido alg&uacute;n 
  error. </p>
<pre class="code">void <strong>gc()</strong>
</pre>
<p>Fuerza una llamada al colector de basura para limpiar la memoria. Esta es una 
  operaci&oacute;n costosa. Normalmente no lo llamaremos explicitamente, sino 
  que dejaremos que Java lo invoque cuando sea necesario.</p>
<pre class="code">long <strong>currentTimeMillis()</strong>
</pre>
<p>Nos devuelve el tiempo medido en el n&uacute;mero de milisegundos transcurridos 
  desde el 1 de Enero de 1970 a las 0:00.</p>
<pre class="code">void <strong>arraycopy(Object fuente, int pos_fuente, 
               Object destino, int pos_dest, int n)</strong>
</pre>
<p>Copia n elementos del array fuente, desde la posici&oacute;n pos_fuente, al 
  array destino a partir de la posici&oacute;n pos_dest.</p>
<pre class="code">Properties <strong>getProperties()</strong>
</pre>
<p>Devuelve un objeto Properties con las propiedades del sistema. En estas propiedades 
  podremos encontrar la siguiente informaci&oacute;n:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Clave</strong></td>
    <td colspan="1" rowspan="1"><strong>Contenido</strong></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">file.separator</span></td>
    <td colspan="1" rowspan="1">Separador entre directorios en la ruta de los ficheros. Por ejemplo "/" 
      en UNIX.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">java.class.path</span></td>
    <td colspan="1" rowspan="1">Classpath de Java</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">java.class.version</span></td>
    <td colspan="1" rowspan="1">Versi&oacute;n de las clases de Java</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">java.home</span></td>
    <td colspan="1" rowspan="1">Directorio donde est&aacute; instalado Java</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">java.vendor</span></td>
    <td colspan="1" rowspan="1">Empresa desarrolladora de la implementaci&oacute;n de la plataforma Java 
      instalada</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">java.vendor.url</span></td>
    <td colspan="1" rowspan="1">URL de la empresa</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">java.version</span></td>
    <td colspan="1" rowspan="1">Versi&oacute;n de Java</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">line.separator</span></td>
    <td colspan="1" rowspan="1">Separador de fin de l&iacute;neas utilizado</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">os.arch</span></td>
    <td colspan="1" rowspan="1">Arquitectura del sistema operativo</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">os.name</span></td>
    <td colspan="1" rowspan="1">Nombre del sistema operativo</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">os.version</span></td>
    <td colspan="1" rowspan="1">Versi&oacute;n del sistema operativo</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">path.separator</span></td>
    <td colspan="1" rowspan="1">Separador entre los distintos elementos de una variable de entorno tipo 
      PATH. Por ejemplo ":"</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">user.dir</span></td>
    <td colspan="1" rowspan="1">Directorio actual</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">user.home</span></td>
    <td colspan="1" rowspan="1">Directorio de inicio del usuario actual</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">user.name</span></td>
    <td colspan="1" rowspan="1">Nombre de la cuenta del usuario actual</td>
  
</tr>

</table>
<a name="N108A0"></a><a name="Runtime"></a>
<h3 class="underlined_5">Runtime</h3>
<p>Toda aplicaci&oacute;n Java tiene una instancia de la clase <span class="codefrag">Runtime</span> 
  que se encargar&aacute; de hacer de interfaz con el entorno en el que se est&aacute; 
  ejecutando. Para obtener este objeto debemos utilizar el siguiente m&eacute;todo 
  est&aacute;tico:</p>
<pre class="code">Runtime rt = <strong>Runtime.getRuntime()</strong>;</pre>
<p>Una de las operaciones que podremos realizar con este objeto, ser&aacute; ejecutar 
  comandos como si nos encontr&aacute;semos en la l&iacute;nea de comandos del 
  sistema operativo. Para ello utilizaremos el siguiente m&eacute;todo:</p>
<pre class="code">rt.<strong>exec</strong>(comando);</pre>
<p>De esta forma podremos invocar programas externos desde nuestra aplicaci&oacute;n 
  Java. </p>
<a name="N108C1"></a><a name="Math"></a>
<h3 class="underlined_5">Math</h3>
<p>La clase<span class="codefrag"> Math</span> nos ser&aacute; de gran utilidad cuando necesitemos 
  realizar operaciones matem&aacute;ticas. Esta clase no necesita ser instanciada, 
  ya que todos sus m&eacute;todos son est&aacute;ticos. Entre estos m&eacute;todos 
  podremos encontrar todas las operaciones matem&aacute;ticas b&aacute;sicas que 
  podamos necesitar, como logaritmos, exponenciales, funciones trigonom&eacute;tricas, 
  generaci&oacute;n de n&uacute;meros aleatorios, conversi&oacute;n entre grados 
  y radianes, etc. Adem&aacute;s nos ofrece las constantes de los n&uacute;meros 
  <em>PI</em> y <em>E</em>.</p>
<a name="N108D4"></a><a name="Otras+clases"></a>
<h3 class="underlined_5">Otras clases</h3>
<p>Si miramos dentro del paquete <span class="codefrag">java.util</span>, podremos encontrar 
  una serie de clases que nos podr&aacute;n resultar &uacute;tiles para determinadas 
  aplicaciones.</p>
<p>Entre ellas tenemos la clase <span class="codefrag">Locale</span> que almacena informaci&oacute;n sobre 
  una determinada regi&oacute;n del mundo (pa&iacute;s e idioma), y que podr&aacute; ser utilizada
  para internacionalizar nuestra aplicaci&oacute;n de forma sencilla. Una clase relacionada con esta &uacute;ltima es
  <span class="codefrag">ResourceBundle</span>, con la que podemos definir las cadenas de texto de nuestra 
  aplicaci&oacute;n en una serie de ficheros de propiedades (uno para cada idioma). Por ejemplo,
  podr&iacute;amos tener dos ficheros <span class="codefrag">Textos_en.properties</span> y <span class="codefrag">Textos_es.properties</span>
  con los textos en ingl&eacute;s y en castellano respectivamente. Si abrimos el <em>bundle</em> de nombre
  <span class="codefrag">Textos</span>, se utilizar&aacute; el <em>locale</em> de nuestro sistema para cargar los textos
  del fichero que corresponda. Tambi&eacute;n encontramos otras clases relacionadas con <span class="codefrag">Locale</span>, 
  como por ejemplo <span class="codefrag">Currency</span> con informaci&oacute;n monetaria adaptada a nuestra zona,
  clases que nos permiten formatear n&uacute;meros o fechas (<span class="codefrag">NumberFormat</span> y <span class="codefrag">DateFormat</span>
  respectivamente) seg&uacute;n las convenciones de nuestra zona, o bien de forma personalizada, y la clase
  <span class="codefrag">Calendar</span>, que nos ser&aacute; &uacute;til cuando trabajemos con fechas y horas, para realizar 
  operaciones con fechas, compararlas, o acceder a sus campos por separado.</p>
</div>


<a name="N10909"></a><a name="Estructuras+de+datos"></a>
<h2 class="underlined_10">Estructuras de datos</h2>
<div class="section">
<p>En nuestras aplicaciones normalmente trabajamos con diversos conjuntos
de atributos que son siempre utilizados de forma conjunta (por ejemplo, los
datos de un punto en un mapa: coordenada x, coordenada y, descripcion). Estos datos 
se deber&aacute;n ir pasando entre las diferentes capas de la aplicaci&oacute;n.</p>
<p>Podemos utilizar el patr&oacute;n <em>Transfer Object</em> para encapsular estos
datos en un objeto, y tratarlos as&iacute; de forma eficiente. Este objeto tendr&aacute; 
como campos los datos que encapsula. En el caso de que estos campos sean privados,
nos deber&aacute; proporcionar m&eacute;todos para acceder a ellos. Estos m&eacute;todos son 
conocidos como <em>getters</em> y <em>setters</em>, y nos permitir&aacute;n consultar o modificar
su valor respectivamente. Una vez escritos los campos privados, Eclipse puede generar los 
<em>getters</em> y <em>setters</em> de forma autom&aacute;tica pinchando sobre el c&oacute;digo fuente con el 
bot&oacute;n derecho del rat&oacute;n y seleccionando la opci&oacute;n <em>Source &gt; Generate Getters and Setters...</em>. 
Por ejemplo, si creamos una clase como la siguiente:</p>
<pre class="brush:java;">public class Punto2D {
	private int x;
	private int y;
	private String descripcion;
}</pre>
<p>Al generar los <em>getters</em> y <em>setters</em> con Eclipse aparecer&aacute;n los siguientes m&eacute;todos:</p>
<pre class="brush:java;">	public String getDescripcion() {
		return descripcion;
	}
	public void setDescripcion(String descripcion) {
		this.descripcion = descripcion;
	}
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}</pre>
<p>Con Eclipse tambi&eacute;n podremos generar diferentes tipos de constructores
para estos objetos. Por ejemplo, con la opci&oacute;n <em>Source &gt; Generate Constructor Using Fields...</em>
generar&aacute; un constructor que tomar&aacute; como entrada los campos del objeto que le indiquemos.</p>
<a name="N10940"></a><a name="BeanUtils"></a>
<h3 class="underlined_5">BeanUtils</h3>
<p>Idealmente un mismo campo s&oacute;lo estar&aacute; en una clase, por ejemplo, los campos correspondientes 
    a los datos personales de un cliente no tienen por qu&eacute; repetirse una y otra vez en distintas clases.
    Sin embargo cuando construimos un Transfer Object es bastante com&uacute;n que copiemos datos entre campos
    que tienen una correspondencia exacta. Por ejemplo, tenemos el siguiente Transfer Object que es muy
    similar al <span class="codefrag">Punto2D</span>:
    </p>
<pre class="brush:java;">public class Punto3D {
private int x;
private int y;
private int z;
private String descripcion;
/* ...y los getters y setters para los cuatro campos */
}</pre>
<p>Si necesitamos copiar los datos de <span class="codefrag">Punto3D</span> a <span class="codefrag">Punto2D</span>, tres de los 
   campos coinciden. (Esta operaci&oacute;n ser&iacute;a una proyecci&oacute;n del punto sobre el plano XY). Manualmente
   necesitar&iacute;amos hacer:</p>
<pre class="brush:java;">punto2D.setX(punto3D.getX());
punto2D.setY(punto3D.getY());
punto2D.setDescripcion(punto3D.getDescripcion());
</pre>
<p>La clase <span class="codefrag">BeanUtils</span>, perteneciente a la biblioteca <span class="codefrag">commons-beanutils</span> de Apache,
   nos proporciona el m&eacute;todo <span class="codefrag">copyProperties(objetoDestino, objetoOrigen)</span> que permite
   hacer lo mismo en una sola l&iacute;nea. Se trata de un wrapper que hace uso de la API de <span class="codefrag">Reflection</span>.
   Esta API nos permite, entre otras cosas, examinar modificadores, tipos y campos de un objeto en tiempo de ejecuci&oacute;n.</p>
<pre class="brush:java;">BeanUtils.copyProperties(punto2D, punto3D);</pre>
<p>Lo que importa es que los getters y setters que se vayan a copiar coincidan en 
   el tipo y en su nombre a partir del prefijo <span class="codefrag">get</span>
   y <span class="codefrag">set</span>. Aparte de incluir la biblioteca <span class="codefrag">commons-beanutils</span> tambi&eacute;n se requiere incluir
   <span class="codefrag">commons-logging</span>, de la cu&aacute;l hace uso el m&eacute;todo <span class="codefrag">copyProperties(...)</span>.</p>
</div>



<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
