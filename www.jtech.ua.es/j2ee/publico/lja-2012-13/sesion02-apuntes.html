<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Colecciones de datos</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Experto en Desarrollo de Aplicaciones y Servicios con Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Lenguaje Java Avanzado" src="images/baner_j2ee_der.gif" title="Lenguaje Java Avanzado"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Java y Herramientas de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Java y Herramientas de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 2</div>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion02-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Colecciones de datos</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Colecciones">Colecciones</a>
<ul class="minitoc">
<li>
<a href="#Listas+de+elementos">Listas de elementos</a>
</li>
<li>
<a href="#Conjuntos">Conjuntos</a>
</li>
<li>
<a href="#Mapas">Mapas</a>
</li>
<li>
<a href="#Wrappers">Wrappers</a>
</li>
<li>
<a href="#Gen%C3%A9ricos">Gen&eacute;ricos</a>
</li>
<li>
<a href="#Recorrer+las+colecciones">Recorrer las colecciones</a>
</li>
<li>
<a href="#Cuestiones+de+eficiencia">Cuestiones de eficiencia</a>
</li>
</ul>
</li>
<li>
<a href="#Comparaci%C3%B3n+de+objetos">Comparaci&oacute;n de objetos</a>
<ul class="minitoc">
<li>
<a href="#Sobrecarga+de+equals">Sobrecarga de equals</a>
</li>
<li>
<a href="#Implementaci%C3%B3n+de+Comparable">Implementaci&oacute;n de Comparable</a>
</li>
<li>
<a href="#Comparador+externo">Comparador externo</a>
</li>
</ul>
</li>
<li>
<a href="#Polimorfismo+e+interfaces">Polimorfismo e interfaces</a>
<ul class="minitoc">
<li>
<a href="#Ejemplo%3A+Algoritmos">Ejemplo: Algoritmos</a>
</li>
</ul>
</li>
<li>
<a href="#Tipos+de+datos+b%C3%A1sicos+en+las+colecciones">Tipos de datos b&aacute;sicos en las colecciones</a>
<ul class="minitoc">
<li>
<a href="#Wrappers+de+tipos+b%C3%A1sicos">Wrappers de tipos b&aacute;sicos</a>
</li>
<li>
<a href="#Autoboxing">Autoboxing</a>
</li>
</ul>
</li>
</ul>
</div>        
          

<p>La plataforma Java nos proporciona un amplio conjunto de clases dentro del 
  que podemos encontrar tipos de datos que nos resultar&aacute;n muy &uacute;tiles 
  para realizar la programaci&oacute;n de aplicaciones en Java. Estos tipos de 
  datos nos ayudar&aacute;n a generar c&oacute;digo m&aacute;s limpio de una forma 
  sencilla. </p>

<p>Se proporcionan una serie de operadores para acceder a los elementos de estos 
  tipos de datos. Decimos que dichos operadores son <em>polim&oacute;rficos</em>, 
  ya que un mismo operador se puede emplear para acceder a distintos tipos de 
  datos. Por ejemplo, un operador <em>add</em> utilizado para a&ntilde;adir un 
  elemento, podr&aacute; ser empleado tanto si estamos trabajando con una lista 
  enlazada, con un array, o con un conjunto por ejemplo. </p>

<p>Este <em>polimorfismo</em> se debe a la definici&oacute;n de interfaces que 
  deben implementar los distintos tipos de datos. Siempre que el tipo de datos 
  contenga una colecci&oacute;n de elementos, implementar&aacute; la interfaz 
  <span class="codefrag">Collection</span>. Esta interfaz proporciona m&eacute;todos para acceder a la 
  colecci&oacute;n de elementos, que podremos utilizar para cualquier tipo de 
  datos que sea una colecci&oacute;n de elementos, independientemente de su implementaci&oacute;n 
  concreta.</p>

<p>Podemos encontrar los siguientes elementos dentro del marco de colecciones 
  de Java:</p>

<ul>
  
<li>Interfaces para distintos tipos de datos: Definir&aacute;n las operaciones 
    que se pueden realizar con dichos tipos de datos. Podemos encontrar aqu&iacute; 
    la interfaz para cualquier colecci&oacute;n de datos, y de manera m&aacute;s 
    concreta para listas (secuencias) de datos, conjuntos, etc.</li>
  
<li>Implementaciones de tipos de datos reutilizables: Son clases que implementan 
    tipos de datos concretos que podremos utilizar para nuestras aplicaciones, 
    implementando algunas de las interfaces anteriores para acceder a los elementos 
    de dicho tipo de datos. Por ejemplo, dentro de las listas de elementos, podremos 
    encontrar distintas implementaciones de la lista como puede ser listas enlazadas, 
    o bien arrays de capacidad variable, pero al implementar la misma interfaz 
    podremos acceder a sus elementos mediante las mismas operaciones (polimorfismo).</li>
  
<li>Algoritmos para trabajar con dichos tipos de datos, que nos permitan realizar 
    una ordenaci&oacute;n de los elementos de una lista, o diversos tipos de b&uacute;squeda 
    de un determinado elemento por ejemplo.</li>

</ul>


<a name="N10030"></a><a name="Colecciones"></a>
<h2 class="underlined_10">Colecciones</h2>
<div class="section">
<p>Las colecciones representan grupos de objetos, denominados elementos. Podemos 
  encontrar diversos tipos de colecciones, seg&uacute;n si sus elementos est&aacute;n 
  ordenados, o si permitimos repetici&oacute;n de elementos o no.</p>
<p>Es el tipo m&aacute;s gen&eacute;rico en cuanto a que se refiere a cualquier 
  tipo que contenga un grupo de elementos. Viene definido por la interfaz <span class="codefrag">Collection</span>, 
  de la cual heredar&aacute; cada subtipo espec&iacute;fico. En esta interfaz 
  encontramos una serie de m&eacute;todos que nos servir&aacute;n para acceder 
  a los elementos de cualquier colecci&oacute;n de datos, sea del tipo que sea. 
  Estos m&eacute;todos generales son:</p>
<pre class="code">boolean <strong>add(Object o)</strong>
</pre>
<p>A&ntilde;ade un elemento (objeto) a la colecci&oacute;n. Nos devuelve<em> true</em> 
  si tras a&ntilde;adir el elemento la colecci&oacute;n ha cambiado, es decir, 
  el elemento se ha a&ntilde;adido correctamente, o <em>false</em> en caso contrario.</p>
<pre class="code">void <strong>clear()</strong>
</pre>
<p>Elimina todos los elementos de la colecci&oacute;n.</p>
<pre class="code">boolean <strong>contains(Object o)</strong>
</pre>
<p>Indica si la colecci&oacute;n contiene el elemento (objeto) indicado.</p>
<pre class="code">boolean <strong>isEmpty()</strong>
</pre>
<p>Indica si la colecci&oacute;n est&aacute; vac&iacute;a (no tiene ning&uacute;n 
  elemento). </p>
<pre class="code">Iterator <strong>iterator()</strong>
</pre>
<p>Proporciona un iterador para acceder a los elementos de la colecci&oacute;n.</p>
<pre class="code">boolean <strong>remove(Object o)</strong>
</pre>
<p>Elimina un determinado elemento (objeto) de la colecci&oacute;n, devolviendo 
  <em>true</em> si dicho elemento estaba contenido en la colecci&oacute;n, y <em>false</em> 
  en caso contrario.</p>
<pre class="code">int <strong>size()</strong>
</pre>
<p>Nos devuelve el n&uacute;mero de elementos que contiene la colecci&oacute;n.</p>
<pre class="code">Object [] <strong>toArray()</strong>
</pre>
<p>Nos devuelve la colecci&oacute;n de elementos como un array de objetos. Si 
  sabemos de antemano que los objetos de la colecci&oacute;n son todos de un determinado 
  tipo (como por ejemplo de tipo <span class="codefrag">String</span>) podremos obtenerlos en un array 
  del tipo adecuado, en lugar de usar un array de objetos gen&eacute;ricos. En 
  este caso NO podremos hacer una conversi&oacute;n cast descendente de array 
  de objetos a array de un tipo m&aacute;s concreto, ya que el array se habr&aacute; 
  instanciado simplemente como array de objetos:</p>
<pre class="code">// <strong>Esto no se puede hacer!!!</strong>
String [] cadenas = (String []) coleccion.toArray();</pre>
<p>Lo que si podemos hacer es instanciar nosotros un array del tipo adecuado y 
  hacer una conversi&oacute;n cast ascendente (de tipo concreto a array de objetos), 
  y utilizar el siguiente m&eacute;todo:</p>
<pre class="code">String [] cadenas = new String[coleccion.size()];
coleccion.<strong>toArray</strong>(cadenas);		// Esto si que funcionar&aacute;</pre>
<p>Esta interfaz es muy gen&eacute;rica, y por lo tanto no hay ning&uacute;n tipo 
  de datos que la implemente directamente, sino que implementar&aacute;n subtipos 
  de ellas. A continuaci&oacute;n veremos los subtipos m&aacute;s comunes.</p>
<a name="N100AA"></a><a name="Listas+de+elementos"></a>
<h3 class="underlined_5">Listas de elementos</h3>
<p>Este tipo de colecci&oacute;n se refiere a listas en las que los elementos 
  de la colecci&oacute;n tienen un orden, existe una secuencia de elementos. En 
  ellas cada elemento estar&aacute; en una determinada posici&oacute;n (&iacute;ndice) 
  de la lista.</p>
<p>Las listas vienen definidas en la interfaz <span class="codefrag">List</span>, que adem&aacute;s 
  de los m&eacute;todos generales de las colecciones, nos ofrece los siguientes 
  para trabajar con los &iacute;ndices:</p>
<pre class="code">void <strong>add(int indice, Object obj)</strong>
</pre>
<p>Inserta un elemento (objeto) en la posici&oacute;n de la lista dada por el 
  &iacute;ndice indicado. </p>
<pre class="code">Object <strong>get(int indice)</strong>
</pre>
<p>Obtiene el elemento (objeto) de la posici&oacute;n de la lista dada por el 
  &iacute;ndice indicado. </p>
<pre class="code">int <strong>indexOf(Object obj)</strong>
</pre>
<p>Nos dice cual es el &iacute;ndice de dicho elemento (objeto) dentro de la lista. 
  Nos devuelve -1 si el objeto no se encuentra en la lista.</p>
<pre class="code">Object <strong>remove(int indice)</strong>
</pre>
<p>Elimina el elemento que se encuentre en la posici&oacute;n de la lista indicada 
  mediante dicho &iacute;ndice, devolvi&eacute;ndonos el objeto eliminado.</p>
<pre class="code">Object <strong>set(int indice, Object obj)</strong>
</pre>
<p>Establece el elemento de la lista en la posici&oacute;n dada por el &iacute;ndice 
  al objeto indicado, sobrescribiendo el objeto que hubiera anteriormente en dicha 
  posici&oacute;n. Nos devolver&aacute; el elemento que hab&iacute;a previamente 
  en dicha posici&oacute;n.</p>
<p>Podemos encontrar diferentes implementaciones de listas de elementos en Java:</p>
<p>
<strong>ArrayList</strong>
</p>
<p>Implementa una lista de elementos mediante un array de tama&ntilde;o variable. 
  Conforme se a&ntilde;aden elementos el tama&ntilde;o del array ir&aacute; creciendo 
  si es necesario. El array tendr&aacute; una capacidad inicial, y en el momento 
  en el que se rebase dicha capacidad, se aumentar&aacute; el tama&ntilde;o del 
  array.</p>
<p>Las operaciones de a&ntilde;adir un elemento al final del array (<em>add</em>), 
  y de establecer u obtener el elemento en una determinada posici&oacute;n (<em>get</em>/<em>set</em>) 
  tienen un coste temporal constante. Las inserciones y borrados tienen un coste 
  lineal <em>O(n)</em>, donde <em>n</em> es el n&uacute;mero de elementos del 
  array.</p>
<p>Hemos de destacar que la implementaci&oacute;n de <span class="codefrag">ArrayList</span> 
  no est&aacute; sincronizada, es decir, si m&uacute;ltiples hilos acceden a un 
  mismo <span class="codefrag">ArrayList</span> concurrentemente podriamos tener problemas 
  en la consistencia de los datos. Por lo tanto, deberemos tener en cuenta cuando 
  usemos este tipo de datos que debemos controlar la concurrencia de acceso. Tambi&eacute;n 
  podemos hacer que sea sincronizado como veremos m&aacute;s adelante.</p>
<p>
<strong>Vector</strong>
</p>
<p>El <span class="codefrag">Vector</span> es una implementaci&oacute;n similar al <span class="codefrag">ArrayList</span>, 
  con la diferencia de que el <span class="codefrag">Vector</span> si que <strong>est&aacute; 
  sincronizado</strong>. Este es un caso especial, ya que la implementaci&oacute;n 
  b&aacute;sica del resto de tipos de datos no est&aacute; sincronizada.</p>
<p>Esta clase existe desde las primeras versiones de Java, en las que no exist&iacute;a 
  el marco de las colecciones descrito anteriormente. En las &uacute;ltimas versiones 
  el <span class="codefrag">Vector</span> se ha acomodado a este marco implementando la interfaz 
  <span class="codefrag">List</span>.</p>
<p>Sin embargo, si trabajamos con versiones previas de JDK, hemos de tener en 
  cuenta que dicha interfaz no exist&iacute;a, y por lo tanto esta versi&oacute;n 
  previa del vector no contar&aacute; con los m&eacute;todos definidos en ella. 
  Los m&eacute;todos propios del vector para acceder a su contenido, que han existido 
  desde las primeras versiones, son los siguientes:</p>
<pre class="code">void <strong>addElement(Object obj)</strong>
</pre>
<p>A&ntilde;ade un elemento al final del vector.</p>
<pre class="code">Object <strong>elementAt(int indice)</strong>
</pre>
<p>Devuelve el elemento de la posici&oacute;n del vector indicada por el &iacute;ndice.</p>
<pre class="code">void <strong>insertElementAt(Object obj, int indice)</strong>
</pre>
<p>Inserta un elemento en la posici&oacute;n indicada.</p>
<pre class="code">boolean <strong>removeElement(Object obj)</strong>
</pre>
<p>Elimina el elemento indicado del vector, devolviendo <em>true</em> si dicho 
  elemento estaba contenido en el vector, y <em>false</em> en caso contrario.</p>
<pre class="code">void <strong>removeElementAt(int indice)</strong>
</pre>
<p>Elimina el elemento de la posici&oacute;n indicada en el &iacute;ndice.</p>
<pre class="code">void <strong>setElementAt(Object obj, int indice)</strong>
</pre>
<p>Sobrescribe el elemento de la posici&oacute;n indicada con el objeto especificado.</p>
<pre class="code">int <strong>size()</strong>
</pre>
<p>Devuelve el n&uacute;mero de elementos del vector.</p>
<p>Por lo tanto, si programamos para versiones antiguas de la m&aacute;quina virtual 
  Java, ser&aacute; recomendable utilizar estos m&eacute;todos para asegurarnos 
  de que nuestro programa funcione. Esto ser&aacute; importante en la programaci&oacute;n 
  de Applets, ya que la m&aacute;quina virtual incluida en muchos navegadores 
  corresponde a versiones antiguas.</p>
<p>Sobre el vector se construye el tipo pila (<span class="codefrag">Stack</span>), que apoy&aacute;ndose 
  en el tipo vector ofrece m&eacute;todos para trabajar con dicho vector como 
  si se tratase de una pila, apilando y desapilando elementos (operaciones <em>push 
  </em>y<em> pop</em> respectivamente). La clase <span class="codefrag">Stack</span> hereda 
  de <span class="codefrag">Vector</span>, por lo que en realidad ser&aacute; un vector que 
  ofrece m&eacute;todos adicionales para trabajar con &eacute;l como si fuese 
  una pila.</p>
<p>
<strong>LinkedList</strong>
</p>
<p>En este caso se implementa la lista mediante una lista doblemente enlazada. 
  Por lo tanto, el coste temporal de las operaciones ser&aacute; el de este tipo 
  de listas. Cuando realicemos inserciones, borrados o lecturas en los extremos 
  inicial o final de la lista el tiempo ser&aacute; constante, mientras que para 
  cualquier operaci&oacute;n en la que necesitemos localizar un determinado &iacute;ndice 
  dentro de la lista deberemos recorrer la lista de inicio a fin, por lo que el 
  coste ser&aacute; lineal con el tama&ntilde;o de la lista <em>O(n)</em>, siendo 
  <em>n </em>el tama&ntilde;o de la lista.</p>
<p>Para aprovechar las ventajas que tenemos en el coste temporal al trabajar con 
  los extremos de la lista, se proporcionan m&eacute;todos propios para acceder 
  a ellos en tiempo constante:</p>
<pre class="code">void <strong>addFirst(Object obj)</strong> / void <strong>addLast(Object obj)</strong>
</pre>
<p>A&ntilde;ade el objeto indicado al principio / final de la lista respectivamente.</p>
<pre class="code">Object <strong>getFirst()</strong> / Object <strong>getLast()</strong>
</pre>
<p>Obtiene el primer / &uacute;ltimo objeto de la lista respectivamente.</p>
<pre class="code">Object <strong>removeFirst()</strong> / Object <strong>removeLast()</strong>
</pre>
<p>Extrae el primer / &uacute;ltimo elemento de la lista respectivamente, devolvi&eacute;ndonos 
  dicho objeto y elimin&aacute;ndolo de la lista.</p>
<p>Hemos de destacar que estos m&eacute;todos nos permitir&aacute;n trabajar con 
  la lista como si se tratase de una pila o de una cola. En el caso de la pila 
  realizaremos la inserci&oacute;n y la extracci&oacute;n de elementos por el 
  mismo extremo, mientras que para la cola insertaremos por un extremo y extraeremos 
  por el otro.</p>
<a name="N101BC"></a><a name="Conjuntos"></a>
<h3 class="underlined_5">Conjuntos</h3>
<p>Los conjuntos son grupos de elementos en los que no encontramos ning&uacute;n 
  elemento repetido. Consideramos que un elemento est&aacute; repetido si tenemos 
  dos objetos <em>o1</em> y <em>o2</em> iguales, comparandolos mediante el operador 
  <em>o1.equals(o2)</em>. De esta forma, si el objeto a insertar en el conjunto 
  estuviese repetido, no nos dejar&aacute; insertarlo. Recordemos que el m&eacute;todo 
  add devolv&iacute;a un valor <em>booleano</em>, que servir&aacute; para este 
  caso, devolviendonos <em>true</em> si el elemento a a&ntilde;adir no estaba 
  en el conjunto y ha sido a&ntilde;adido, o <em>false</em> si el elemento ya 
  se encontraba dentro del conjunto. Un conjunto podr&aacute; contener a lo sumo 
  un elemento <em>null</em>.</p>
<p>Los conjuntos se definen en la interfaz <span class="codefrag">Set</span>, a partir de la 
  cu&aacute;l se construyen diferentes implementaciones:</p>
<p>
<strong>HashSet</strong> 
</p>
<p>Los objetos se almacenan en una tabla de dispersi&oacute;n (<em>hash</em>). 
  El coste de las operaciones b&aacute;sicas (inserci&oacute;n, borrado, b&uacute;squeda) 
  se realizan en tiempo constante siempre que los elementos se hayan dispersado 
  de forma adecuada. La iteraci&oacute;n a trav&eacute;s de sus elementos es m&aacute;s 
  costosa, ya que necesitar&aacute; recorrer todas las entradas de la tabla de 
  dispersi&oacute;n, lo que har&aacute; que el coste est&eacute; en funci&oacute;n 
  tanto del n&uacute;mero de elementos insertados en el conjunto como del n&uacute;mero 
  de entradas de la tabla. El orden de iteraci&oacute;n puede diferir del orden 
  en el que se insertaron los elementos.</p>
<p>
<strong>LinkedHashSet</strong> 
</p>
<p>Es similar a la anterior pero la tabla de dispersi&oacute;n es doblemente enlazada. 
  Los elementos que se inserten tendr&aacute;n enlaces entre ellos. Por lo tanto, 
  las operaciones b&aacute;sicas seguir&aacute;n teniendo coste constante, con 
  la carga adicional que supone tener que gestionar los enlaces. Sin embargo habr&aacute; 
  una mejora en la iteraci&oacute;n, ya que al establecerse enlaces entre los 
  elementos no tendremos que recorrer todas las entradas de la tabla, el coste 
  s&oacute;lo estar&aacute; en funci&oacute;n del n&uacute;mero de elementos insertados. 
  En este caso, al haber enlaces entre los elementos, estos enlaces definir&aacute;n 
  el orden en el que se insertaron en el conjunto, por lo que el orden de iteraci&oacute;n 
  ser&aacute; el mismo orden en el que se insertaron.</p>
<p>
<strong>TreeSet</strong> 
</p>
<p>Utiliza un &aacute;rbol para el almacenamiento de los elementos. Por lo tanto, 
  el coste para realizar las operaciones b&aacute;sicas ser&aacute; logar&iacute;tmico 
  con el n&uacute;mero de elementos que tenga el conjunto <em>O(log n)</em>.</p>
<a name="N101FF"></a><a name="Mapas"></a>
<h3 class="underlined_5">Mapas</h3>
<p>Aunque muchas veces se hable de los mapas como una colecci&oacute;n, en realidad 
  no lo son, ya que no heredan de la interfaz <span class="codefrag">Collection</span>.</p>
<p>Los mapas se definen en la interfaz <span class="codefrag">Map</span>. Un mapa es un objeto 
  que relaciona una clave (<em>key</em>) con un valor. Contendr&aacute; un conjunto 
  de claves, y a cada clave se le asociar&aacute; un determinado valor. En versiones 
  anteriores este mapeado entre claves y valores lo hac&iacute;a la clase <span class="codefrag">Dictionary</span>, 
  que ha quedado obsoleta. Tanto la clave como el valor puede ser cualquier objeto.</p>
<p>Los m&eacute;todos b&aacute;sicos para trabajar con estos elementos son los 
  siguientes:</p>
<pre class="code">Object <strong>get(Object clave)</strong>
</pre>
<p>Nos devuelve el valor asociado a la clave indicada</p>
<pre class="code">Object <strong>put(Object clave, Object valor)</strong>
</pre>
<p>Inserta una nueva clave con el valor especificado. Nos devuelve el valor que 
  ten&iacute;a antes dicha clave, o <em>null</em> si la clave no estaba en la 
  tabla todav&iacute;a.</p>
<pre class="code">Object <strong>remove(Object clave)</strong>
</pre>
<p>Elimina una clave, devolviendonos el valor que ten&iacute;a dicha clave.</p>
<pre class="code">Set <strong>keySet()</strong>
</pre>
<p>Nos devuelve el conjunto de claves registradas</p>
<pre class="code">int <strong>size()</strong>
</pre>
<p>Nos devuelve el n&uacute;mero de parejas (clave,valor) registradas.</p>
<p>Encontramos distintas implementaciones de los mapas:</p>
<p>
<strong>HashMap</strong>
</p>
<p>Utiliza una tabla de dispersi&oacute;n para almacenar la informaci&oacute;n 
  del mapa. Las operaciones b&aacute;sicas (<em>get</em> y <em>put</em>) se har&aacute;n 
  en tiempo constante siempre que se dispersen adecuadamente los elementos. Es 
  coste de la iteraci&oacute;n depender&aacute; del n&uacute;mero de entradas 
  de la tabla y del n&uacute;mero de elementos del mapa. No se garantiza que se 
  respete el orden de las claves.</p>
<p>
<strong>TreeMap</strong>
</p>
<p>Utiliza un &aacute;rbol rojo-negro para implementar el mapa. El coste de las 
  operaciones b&aacute;sicas ser&aacute; logar&iacute;tmico con el n&uacute;mero 
  de elementos del mapa <em>O(log n)</em>. En este caso los elementos se encontrar&aacute;n 
  ordenados por orden ascendente de clave.</p>
<p>
<strong>Hashtable</strong>
</p>
<p>Es una implementaci&oacute;n similar a <span class="codefrag">HashMap</span>, pero con alguna 
  diferencia. Mientras las anteriores implementaciones no est&aacute;n sincronizadas, 
  esta si que lo est&aacute;. Adem&aacute;s en esta implementaci&oacute;n, al 
  contrario que las anteriores, no se permitir&aacute;n claves nulas (<em>null</em>). 
  Este objeto extiende la obsoleta clase <span class="codefrag">Dictionary</span>, ya que viene 
  de versiones m&aacute;s antiguas de JDK. Ofrece otros m&eacute;todos adem&aacute;s 
  de los anteriores, como por ejemplo el siguiente:</p>
<pre class="code">Enumeration <strong>keys()</strong>
</pre>
<p>Este m&eacute;todo nos devolver&aacute; una enumeraci&oacute;n de todas las 
  claves registradas en la tabla.</p>
<a name="N1027E"></a><a name="Wrappers"></a>
<h3 class="underlined_5">Wrappers</h3>
<p>La clase <span class="codefrag">Collections</span> 
  aporta una serie m&eacute;todos para cambiar ciertas propiedades de las listas. 
  Estos m&eacute;todos nos proporcionan los denominados <em>wrappers</em> de los 
  distintos tipos de colecciones. Estos <em>wrappers</em> son objetos que 'envuelven' 
  al objeto de nuestra colecci&oacute;n, pudiendo de esta forma hacer que la colecci&oacute;n 
  est&eacute; sincronizada, o que la colecci&oacute;n pase a ser de solo lectura.</p>
<p>Como dijimos anteriormente, todos los tipos de colecciones no est&aacute;n 
  sincronizados, excepto el <span class="codefrag">Vector</span> que es un caso especial. Al no estar 
  sincronizados, si m&uacute;ltiples hilos utilizan la colecci&oacute;n concurrentemente, 
  podr&aacute;n estar ejecut&aacute;ndose simult&aacute;neamente varios m&eacute;todos 
  de una misma colecci&oacute;n que realicen diferentes operaciones sobre ella. 
  Esto puede provocar inconsistencias en los datos. A continuaci&oacute;n veremos 
  un posible ejemplo de inconsistencia que se podr&iacute;a producir:</p>
<ol>
  
<li>Tenemos un <span class="codefrag">ArrayList</span> de nombre <em>letras</em> formada 
    por los siguiente elementos: [ "A", "B", "C", 
    "D" ]</li>
  
<li>Imaginemos que un hilo de baja prioridad desea eliminar el objeto "C". 
    Para ello har&aacute; una llamada al m&eacute;todo <em>letras.remove("C")</em>.</li>
  
<li>Dentro de este m&eacute;todo primero deber&aacute; determinar cu&aacute;l 
    es el &iacute;ndice de dicho objeto dentro del array, para despu&eacute;s 
    pasar a eliminarlo. </li>
  
<li>Se encuentra el objeto "C" en el &iacute;ndice 2 del array (recordemos 
    que se empieza a numerar desde 0).</li>
  
<li>El problema viene en este momento. Imaginemos que justo en este momento 
    se le asigna el procesador a un hilo de mayor prioridad, que se encarga de 
    eliminar el elemento "A" del array, qued&aacute;ndose el array de 
    la siguiente forma: [ "B", "C", "D" ]</li>
  
<li>Ahora el hilo de mayor prioridad es sacado del procesador y nuestro hilo 
    sigue ejecut&aacute;ndose desde el punto en el que se qued&oacute;.</li>
  
<li>Ahora nuestro hilo lo &uacute;nico que tiene que hacer es eliminar el elemento 
    del &iacute;ndice que hab&iacute;a determinado, que resulta ser &iexcl;el 
    &iacute;ndice 2!. Ahora el &iacute;ndice 2 est&aacute; ocupado por el objeto 
    "D", y por lo tanto ser&aacute; dicho objeto el que se elimine.</li>

</ol>
<p>Podemos ver que haciendo una llamada a <em>letras.remove("C")</em>, 
  al final se ha eliminado el objeto "D", lo cual produce una inconsistencia 
  de los datos con las operaciones realizadas, debido al acceso concurrente.</p>
<p>Este problema lo evitaremos sincronizando la colecci&oacute;n. Cuando una colecci&oacute;n 
  est&aacute; sincronizada, hasta que no termine de realizarse una operaci&oacute;n 
  (inserciones, borrados, etc), no se podr&aacute; ejecutar otra, lo cual evitar&aacute; 
  estos problemas.</p>
<p>Podemos conseguir que las operaciones se ejecuten de forma sincronizada envolviendo 
  nuestro objeto de la colecci&oacute;n con un <em>wrapper</em>, que ser&aacute; 
  un objeto que utilice internamente nuestra colecci&oacute;n encarg&aacute;ndose 
  de realizar la sincronizaci&oacute;n cuando llamemos a sus m&eacute;todos. Para 
  obtener estos <em>wrappers</em> utilizaremos los siguientes m&eacute;todos est&aacute;ticos 
  de <span class="codefrag">Collections</span>:</p>
<pre class="code">Collection <strong>synchronizedCollection(Collection c)</strong>
List <strong>synchronizedList(List l)</strong>
Set <strong>synchronizedSet(Set s)</strong>
Map <strong>synchronizedMap(Map m)</strong>
SortedSet <strong>synchronizedSortedSet(SortedSet ss)</strong>
SortedMap <strong>synchronizedSortedMap(SortedMap sm)</strong>
</pre>
<p>Como vemos tenemos un m&eacute;todo para envolver cada tipo de datos. Nos devolver&aacute; 
  un objeto con la misma interfaz, por lo que podremos trabajar con &eacute;l 
  de la misma forma, sin embargo la implementaci&oacute;n interna estar&aacute; 
  sincronizada.</p>
<p>Podemos encontrar tambi&eacute;n una serie de <em>wrappers</em> para obtener 
  versiones de s&oacute;lo lectura de nuestras colecciones. Se obtienen con los 
  siguientes m&eacute;todos:</p>
<pre class="code">Collection <strong>unmodifiableCollection(Collection c)</strong>
List <strong>unmodifiableList(List l)</strong>
Set <strong>unmodifiableSet(Set s)</strong>
Map <strong>unmodifiableMap(Map m)</strong>
SortedSet <strong>unmodifiableSortedSet(SortedSet ss)</strong>
SortedMap <strong>unmodifiableSortedMap(SortedMap sm)</strong>
</pre>
<a name="N10300"></a><a name="Gen%C3%A9ricos"></a>
<h3 class="underlined_5">Gen&eacute;ricos</h3>
<p>Podemos tener colecciones de tipos concretos de datos, lo
        que permite asegurar que los datos que se van a almacenar van a ser
        compatibles con un determinado tipo o tipos. Por ejemplo, podemos crear
        un <span class="codefrag">ArrayList</span> que s&oacute;lo almacene <span class="codefrag">Strings</span>, o una <span class="codefrag">HashMap</span>
        que tome como claves <span class="codefrag">Integers</span> y como valores <span class="codefrag">ArrayLists</span>. Adem&aacute;s,
        con esto nos ahorramos las conversiones <em>cast</em> al tipo que
        deseemos, puesto que la colecci&oacute;n ya se asume que ser&aacute; de dicho tipo.</p>
<p>
<strong>Ejemplo</strong>
</p>
<pre class="brush:java;">// Vector de cadenas
ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();
a.add("Hola");
String s = a.get(0);
a.add(new Integer(20));			// Dar&iacute;a error!!

// HashMap con claves enteras y valores de vectores
HashMap&lt;Integer, ArrayList&gt; hm = new HashMap&lt;Integer, ArrayList&gt;();
hm.put(1, a);
ArrayList a2 = hm.get(1);</pre>
<p>A partir de JDK 1.5 deberemos utilizar gen&eacute;ricos siempre que sea posible. Si
creamos una colecci&oacute;n sin especificar el tipo de datos que contendr&aacute; normalmente
obtendremos un <em>warning</em>.</p>
<p>Los gen&eacute;ricos no son una caracter&iacute;stica exclusiva de las colecciones, 
sino que se pueden utilizar en muchas otras clases, incluso podemos parametrizar
de esta forma nuestras propias clases.</p>
<a name="N1032E"></a><a name="Recorrer+las+colecciones"></a>
<h3 class="underlined_5">Recorrer las colecciones</h3>
<p>Vamos a ver ahora como podemos iterar por los elementos de una colecci&oacute;n 
de forma eficiente y segura, evitando salirnos del rango de datos. Dos elementos utilizados comunmente 
  para ello son las enumeraciones y los iteradores. </p>
<p>Las enumeraciones, definidas mediante la interfaz <span class="codefrag">Enumeration</span>, 
  nos permiten consultar los elementos que contiene una colecci&oacute;n de datos. 
  Muchos m&eacute;todos de clases Java que deben devolver m&uacute;ltiples valores, 
  lo que hacen es devolvernos una enumeraci&oacute;n que podremos consultar mediante 
  los m&eacute;todos que ofrece dicha interfaz.</p>
<p>La enumeraci&oacute;n ir&aacute; recorriendo secuencialmente los elementos 
  de la colecci&oacute;n. Para leer cada elemento de la enumeraci&oacute;n deberemos 
  llamar al m&eacute;todo:</p>
<pre class="code">Object item = enum.<strong>nextElement()</strong>;</pre>
<p>Que nos proporcionar&aacute; en cada momento el siguiente elemento de la enumeraci&oacute;n 
  a leer. Adem&aacute;s necesitaremos saber si quedan elementos por leer, para 
  ello tenemos el m&eacute;todo:</p>
<pre class="code">enum.<strong>hasMoreElements()</strong>
</pre>
<p>Normalmente, el bucle para la lectura de una enumeraci&oacute;n ser&aacute; 
  el siguiente:</p>
<pre class="brush:java;">while (enum.hasMoreElements()) {
  Object item = enum.nextElement();
  // Hacer algo con el item leido
}</pre>
<p>Vemos como en este bucle se van leyendo y procesando elementos de la enumeraci&oacute;n 
  uno a uno mientras queden elementos por leer en ella.</p>
<p>Otro elemento para acceder a los datos de una colecci&oacute;n son los iteradores. 
  La diferencia est&aacute; en que los iteradores adem&aacute;s de leer los datos 
  nos permitir&aacute;n eliminarlos de la colecci&oacute;n. Los iteradores se 
  definen mediante la interfaz<span class="codefrag"> Iterator</span>, que proporciona de forma 
  an&aacute;loga a la enumeraci&oacute;n el m&eacute;todo:</p>
<pre class="code">Object item = iter.<strong>next()</strong>;</pre>
<p>Que nos devuelve el siguiente elemento a leer por el iterador, y para saber 
  si quedan m&aacute;s elementos que leer tenemos el m&eacute;todo:</p>
<pre class="code">iter.<strong>hasNext()</strong>
</pre>
<p>Adem&aacute;s, podemos borrar el &uacute;ltimo elemento que hayamos leido. 
  Para ello tendremos el m&eacute;todo:</p>
<pre class="code">iter.<strong>remove()</strong>;</pre>
<p>Por ejemplo, podemos recorrer todos los elementos de una colecci&oacute;n utilizando 
  un iterador y eliminar aquellos que cumplan ciertas condiciones:</p>
<pre class="brush:java;">while (iter.hasNext())
{ 
	Object item = iter.next();
	if(condicion_borrado(item)) 
		iter.remove();
}</pre>
<p>Las enumeraciones y los iteradores no son tipos de datos, sino elementos que 
  nos servir&aacute;n para acceder a los elementos dentro de los diferentes tipos de colecciones.</p>
<p>A partir de JDK 1.5 podemos recorrer colecciones y arrays sin
        necesidad de acceder a sus iteradores,
        previniendo &iacute;ndices fuera de rango.</p>
<p>
<strong>Ejemplo</strong>
</p>
<pre class="brush:java;">// Recorre e imprime todos los elementos de un array
int[] arrayInt = {1, 20, 30, 2, 3, 5};
for(int elemento: arrayInt)
	System.out.println (elemento);

// Recorre e imprime todos los elementos de un ArrayList
ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();
for(String cadena: a)
	System.out.println (cadena);</pre>
<a name="N10393"></a><a name="Cuestiones+de+eficiencia"></a>
<h3 class="underlined_5">Cuestiones de eficiencia</h3>
<p>Tradicionalmente Java se ha considerado un lenguaje lento. Hoy en d&iacute;a Java
    se utiliza en aplicaciones con alt&iacute;simas exigencias de rendimiento y rapidez
    de respuesta, por ejemplo, <a href="http://en.wikipedia.org/wiki/Apache_Solr">Apache SolR</a>.
    Para obtener un rendimiento adecuado es fundamental utilizar las estructuras de datos id&oacute;neas
    para cada caso, as&iacute; como los m&eacute;todos adecuados.</p>
<p>Por ejemplo hay que tener en cuenta que una lista mantiene un orden (anterior y siguiente),
        mientras que un <span class="codefrag">ArrayList</span> mantiene elementos en posiciones. Si eliminamos
        un elemento al principio de la lista, todos los dem&aacute;s son desplazados una posici&oacute;n.</p>
<p>M&eacute;todos como <span class="codefrag">addAll</span> o <span class="codefrag">removeAll</span> son preferibles a un bucle que
        itere sobre la lista. </p>
<p>En general es bueno pensar en cu&aacute;l va a ser el principal uso de una estructura de datos
        y considerar su complejidad computacional. Hacer una prueba de tiempos con una cantidad
        limitada de datos puede darnos una idea err&oacute;nea, si no probamos distintos tama&ntilde;os de 
        los datos. En la siguiente figura se muestran las complejidades computacionales de algunos
        m&eacute;todos de colecciones:</p>
<p>   
	
<img alt="Complejidad computacional de m&eacute;todos de colecciones" content-width="8cm" src="imagenes/lenguaje/complexities.png" width="455">
 </p>
<p>Otras curiosidades que vale la pena conocer est&aacute;n enumeradas en "5 things you
        didn't know about the Java Collecitons Api":</p>
<p>
<a href="http://www.ibm.com/developerworks/java/library/j-5things2/index.html">http://www.ibm.com/developerworks/java/library/j-5things2/index.html</a>
<br>
        
<a href="http://www.ibm.com/developerworks/java/library/j-5things3/index.html">http://www.ibm.com/developerworks/java/library/j-5things3/index.html</a>.</p>
</div>


<a name="N103CA"></a><a name="Comparaci%C3%B3n+de+objetos"></a>
<h2 class="underlined_10">Comparaci&oacute;n de objetos</h2>
<div class="section">
<p>Comparar objetos es fundamental para hacer ciertas operaciones y manipulaciones
        en estructuras de datos. Por ejemplo, saber si un objeto es igual a otro es
        necesario a la hora de buscarlo en una estructura de datos. </p>
<a name="N103D3"></a><a name="Sobrecarga+de+equals"></a>
<h3 class="underlined_5">Sobrecarga de equals</h3>
<p>Todos los <span class="codefrag">Object</span> y clases derivadas tienen un m&eacute;todo <span class="codefrag">equals(Object o)</span>
    	    que compara un objeto con otro devolviendo un booleano verdadero en caso de igualdad.
    	    El criterio de igualdad puede ser personalizado, seg&uacute;n la clase. Para personalizarlo
    	    se puede sobrecargar el m&eacute;todo de comparaci&oacute;n:
    	</p>
<pre class="brush:java;">
public class MiClase {
	...
	@Override 
	public boolean equals(Object o) {
		// return true o false, seg&uacute;n un criterio
	}
}	
    	</pre>
<p>El m&eacute;todo <span class="codefrag">equals</span> no debe sobrecargarse si no es necesario.
    	    Sobre todo hay que evitar sobrecargarlo en casos como los siguientes:</p>
<ul>
    	    
<li>Cada instancia es intr&iacute;nsecamente &uacute;nica. Por ejemplo, instancias de hilos,
    	        que representan entidades activas, y no tan s&oacute;lo un conjunto de valores.</li>
    	    
<li>Cuando no es necesaria una comparaci&oacute;n l&oacute;gica. Por ejemplo, dos n&uacute;meros aleatorios,
    	        donde la igualdad puede ocurrir pero su comprobaci&oacute;n no es necesaria.</li>
    	    
<li>Una superclase ya sobrecarga <span class="codefrag">equals</span>, y el comportamiento de &eacute;ste
    	        es apropiado para la clase actual.</li>
    	
</ul>
<p>Cuando se sobrecarga el m&eacute;todo <span class="codefrag">equals</span> se deben cumplir las siguientes propiedades:</p>
<ul>
    	    
<li>Reflexividad: <span class="codefrag">x.equals(x)</span> devuelve siempre verdadero, si no es nulo.
    	    </li>
    	    
<li>Simetr&iacute;a: para cualquier par de instancias no nulas, <span class="codefrag">x.equals(y)</span> devuelve verdadero si y s&oacute;lo si
    	        <span class="codefrag">y.equals(x)</span> tambi&eacute;n devuelve verdadero.
    	        
    	    </li>
    	    
<li>Transitividad: si <span class="codefrag">x.equals(y)==true</span> y <span class="codefrag">y.equals(z)==true</span>, entonces
    	        <span class="codefrag">x.equals(z)</span> tambi&eacute;n ser&aacute; verdadero, para cualesquiera instancias no nulas.
    	        
    	    </li>
    	    
<li>Consistencia: m&uacute;ltiples llamadas al m&eacute;todo con las mismas instancias devuelven el mismo resultado.
    	        
    	    </li>
    	    
<li>Comparaci&oacute;n con <span class="codefrag">null</span> falsa: <span class="codefrag">x.equals(null)</span> devuelve falso</li>
    	
</ul>
<p>Para asegurar la propiedad de consistencia tambi&eacute;n conviene sobrecargar el m&eacute;todo <span class="codefrag">hashCode</span>,
    	    que es necesario para que funcionen correctamente todas las colecciones basadas en c&oacute;digos hash, como
    	    <span class="codefrag">HashMap, HashSet, Hashtable</span>. Objetos que se consideren iguales deben devolver
    	    <span class="codefrag">hashCode</span> iguales. Debe cumplirse:</p>
<ul>
    	    
<li>
    	        Cuando <span class="codefrag">hashCode</span> es invocado varias veces para el mismo objeto, debe devolver
    	        consistentemente el mismo entero, siempre que no se haya modificado ninguna informaci&oacute;n que
    	        afecte al resultado de <span class="codefrag">equals</span>. Esta consistencia debe mantenerse entre
    	        distintas ejecuciones de la misma aplicaci&oacute;n.
    	    </li>
    	    
<li>
    	        Si dos objetos son iguales seg&uacute;n <span class="codefrag">equals</span>, entonces los m&eacute;todos
    	        <span class="codefrag">hashCode</span> de ambos deben devolver el mismo entero.
    	    </li>
    	    
<li>
    	        Si dos objetos no son iguales seg&uacute;n <span class="codefrag">equals</span>, <strong>no</strong> se require
    	        que devuelvan <span class="codefrag">hashCode</span> diferentes. No obstante en la medida de lo posible
    	        deben ser distintos porque esto puede mejorar la eficiencia de las tablas hash.
    	    </li>
    	
</ul>
<a name="N10459"></a><a name="Implementaci%C3%B3n+de+Comparable"></a>
<h3 class="underlined_5">Implementaci&oacute;n de Comparable</h3>
<p>Hay algoritmos, como <span class="codefrag">Collections.sort( )</span>, que requieren que los objetos tengan un 
            m&eacute;todo <span class="codefrag">compareTo()</span> que devuelva un n&uacute;mero negativo, positivo o cero,
            seg&uacute;n si un objeto es menor que el otro, mayor, o igual. Este m&eacute;todo no viene en
            <span class="codefrag">Object</span> para poder sobrecargarlo, sino en la interfaz <span class="codefrag">Comparable</span>
            que tenemos que implementar, y que nos obligar&aacute; a implementar tambi&eacute;n el m&eacute;todo <span class="codefrag">compareTo</span>.
            </p>
<p>Por supuesto, no todos los objetos se pueden comparar en t&eacute;rminos de mayor o menor.
               As&iacute;, el hecho de que una clase implemente <span class="codefrag">Comparable</span> nos indica que se trata
               de una estructura de datos cuyos objetos s&iacute; son comparables, y por tanto podr&iacute;an ordenarse.
               </p>
<p>Un ejemplo de implementaci&oacute;n de <span class="codefrag">Comparable</span>:</p>
<pre class="brush:java;">
public class Persona implements Comparable&lt;Persona&gt; {
	public int id;
	public String apellido;
	...
	@Override
	public int compareTo(Persona p) {
		return this.id - p.id;
	}
	
}
            </pre>
<a name="N10483"></a><a name="Comparador+externo"></a>
<h3 class="underlined_5">Comparador externo</h3>
<p>En muchas estructuras de datos la ordenaci&oacute;n podr&iacute;a ser subjetiva. Por ejemplo, las fichas
                de clientes podr&iacute;an considerarse mayores o menores seg&uacute;n el identificador, seg&uacute;n el apellido
                o seg&uacute;n la fecha de alta. La estructura de datos no tiene por qu&eacute; ofrecer todas las posibilidades
                de comparaci&oacute;n. En estos casos, en los que no hay un s&oacute;lo orden inherente a la estructura de datos,
                podemos utilizar un comparador externo.</p>
<p>Para ello tenemos que implementar la interfaz <span class="codefrag">Comparator</span> que nos obliga a implementar
                el m&eacute;todo <span class="codefrag">compare</span>. Al tratarse, una vez m&aacute;s,
                de una interfaz, podr&iacute;amos hacerlo dentro de la propia clase cuyas instancias vamos a comparar,
                o bien en otra clase aparte, como en el siguiente ejemplo: </p>
<pre class="brush:java;">
public class ComparaPersonaPorNombre implements Comparator&lt;Persona&gt;{
	public int compare(Persona p1, Persona p2) {
		return p1.apellido.compareToIgnoreCase(p2.apellido);
	}
}
            </pre>
<p>Para hacer uso de ese comparador externo en alg&uacute;n m&eacute;todo, debemos indicarlo pasando una 
                instancia del <span class="codefrag">Comparator</span>. En cambio si queremos utilizar el m&eacute;todo de comparaci&oacute;n
                <span class="codefrag">Comparable.compareTo( )</span>, sobra con que la clase implemente <span class="codefrag">Comparable</span>.</p>
<pre class="brush:java;">
List personas = new ArrayList&lt;Persona&gt;();
personas.add(p1); personas.add(p2); personas.add(p3); //...

Collections.sort(personas); //Comparable.compareTo
Collections.sort(personas, new ComparaPersonaPorNombre()); //Comparator.compare
            </pre>
</div>


<a name="N104AD"></a><a name="Polimorfismo+e+interfaces"></a>
<h2 class="underlined_10">Polimorfismo e interfaces</h2>
<div class="section">
<p>En Java podemos conseguir tener objetos polim&oacute;rficos mediante la implementaci&oacute;n
de interfaces. Un claro ejemplo est&aacute; en las colecciones vistas anteriormente. 
Por ejemplo, todos los tipos de listas implementan la interfaz <span class="codefrag">List</span>.
De esta forma, en un m&eacute;todo que acepte como entrada un objeto de tipo <span class="codefrag">List</span>
podremos utilizar cualquier tipo que implemente esta interfaz, independientemente
del tipo concreto del que se trate.</p>
<p>Es por lo tanto recomendable hacer referencia siempre a estos objetos mediante
la interfaz que implementa, y no por su tipo concreto. De esta forma posteriormente
podr&iacute;amos cambiar la implementaci&oacute;n del tipo de datos sin que afecte al resto del programa. 
Lo &uacute;nico que tendremos que cambiar es el momento en el que se instancia.</p>
<p>Por ejemplo, si tenemos una clase <span class="codefrag">Cliente</span> que contiene una serie 
de cuentas, tendremos algo como:</p>
<pre class="brush:java;">public class Cliente {
    String nombre;
    List&lt;Cuenta&gt; cuentas;
    
    public Cliente(String nombre) {
        this.nombre = nombre;
        this.cuentas = new ArrayList&lt;Cuenta&gt;();
    }

    public List&lt;Cuenta&gt; getCuentas() {
        return cuentas;
    }

    public void setCuentas(List&lt;Cuenta&gt; cuentas) {
        this.cuentas = cuentas;
    }

    public void addCuenta(Cuenta cuenta) {
        this.cuentas.add(cuenta);
    }
}</pre>
<p>Si posteriormente queremos cambiar la implementaci&oacute;n de la lista a
<span class="codefrag">LinkedList</span> por ejemplo, s&oacute;lo tendremos que cambiar la l&iacute;nea
del constructor en la que se hace la instanciaci&oacute;n.</p>
<p>Como ejemplo de la utilidad que tiene el polimorfismo podemos ver los algoritmos
predefinidos con los que contamos en el marco de colecciones.</p>
<a name="N104D3"></a><a name="Ejemplo%3A+Algoritmos"></a>
<h3 class="underlined_5">Ejemplo: Algoritmos</h3>
<p>Como hemos comentado anteriormente, adem&aacute;s de las interfaces y las implementaciones 
  de los tipos de datos descritos en los apartados previos, el marco de colecciones 
  nos ofrece una serie de algoritmos utiles cuando trabajamos con estos tipos 
  de datos, especialmente para las listas.</p>
<p>Estos algoritmos los podemos encontrar implementados como m&eacute;todos est&aacute;ticos 
  en la clase <span class="codefrag">Collections</span>. En ella encontramos m&eacute;todos 
  para la ordenaci&oacute;n de listas (<em>sort</em>), para la b&uacute;squeda 
  binaria de elementos dentro de una lista (<em>binarySearch</em>) y otras operaciones 
  que nos ser&aacute;n de gran utilidad cuando trabajemos con colecciones de elementos.</p>
<p>Estos m&eacute;todos tienen como par&aacute;metro de entrada un objeto de tipo <span class="codefrag">List</span>. De esta forma, 
podremos utilizar estos algoritmos para cualquier tipo de lista.</p>
</div>


<a name="N104F0"></a><a name="Tipos+de+datos+b%C3%A1sicos+en+las+colecciones"></a>
<h2 class="underlined_10">Tipos de datos b&aacute;sicos en las colecciones</h2>
<div class="section">
<a name="N104F6"></a><a name="Wrappers+de+tipos+b%C3%A1sicos"></a>
<h3 class="underlined_5">Wrappers de tipos b&aacute;sicos</h3>
<p>Hemos visto que en Java cualquier tipo de datos es un objeto, excepto los tipos 
  de datos b&aacute;sicos: <em>boolean, int, long, float, double, byte, short, 
  char</em>. </p>
<p>Cuando trabajamos con colecciones de datos los elementos que contienen &eacute;stas 
  son siempre objetos, por lo que en un principio no podr&iacute;amos insertar 
  elementos de estos tipos b&aacute;sicos. Para hacer esto posible tenemos una 
  serie de objetos que se encargar&aacute;n de envolver a estos tipos b&aacute;sicos, 
  permiti&eacute;ndonos tratarlos como objetos y por lo tanto insertarlos como 
  elementos de colecciones. Estos objetos son los llamados wrappers, y las clases 
  en las que se definen tienen nombre similares al del tipo b&aacute;sico que 
  encapsulan, con la diferencia de que comienzan con may&uacute;scula: <span class="codefrag">Boolean, 
  Integer, Long, Float, Double, Byte, Short, Character</span>.</p>
<p>Estas clases, adem&aacute;s de servirnos para encapsular estos datos b&aacute;sicos 
  en forma de objetos, nos proporcionan una serie de m&eacute;todos e informaci&oacute;n 
  &uacute;tiles para trabajar con estos datos. Nos proporcionar&aacute;n m&eacute;todos 
  por ejemplo para convertir cadenas a datos num&eacute;ricos de distintos tipos 
  y viceversa, as&iacute; como informaci&oacute;n acerca del valor m&iacute;nimo 
  y m&aacute;ximo que se puede representar con cada tipo num&eacute;rico.</p>
<a name="N1050C"></a><a name="Autoboxing"></a>
<h3 class="underlined_5">Autoboxing</h3>
<p>Esta caracter&iacute;stica aparecida en JDK 1.5 evita al programador tener que establecer
        correspondencias manuales entre los tipos simples (<span class="codefrag">int</span>, <span class="codefrag">double</span>,
        etc) y sus correspondientes <em>wrappers</em> o tipos complejos (<span class="codefrag">Integer,
        Double, </span>etc). Podremos utilizar un <span class="codefrag">int</span> donde se espere un
        objeto complejo (<span class="codefrag">Integer</span>), y viceversa.</p>
<p>
<strong>Ejemplo</strong>
</p>
<pre class="brush:java;">ArrayList&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;();
a.add(30);
Integer n = v.get(0);
n = n+1;
int num = n;</pre>
</div>







<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
