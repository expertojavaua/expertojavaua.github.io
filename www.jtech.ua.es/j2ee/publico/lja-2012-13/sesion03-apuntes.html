<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Tratamiento de errores</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Experto en Desarrollo de Aplicaciones y Servicios con Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Lenguaje Java Avanzado" src="images/baner_j2ee_der.gif" title="Lenguaje Java Avanzado"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Java y Herramientas de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Java y Herramientas de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 3</div>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion03-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Tratamiento de errores</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n">Introducci&oacute;n</a>
</li>
<li>
<a href="#Errores+en+tiempo+de+ejecuci%C3%B3n%3A+Excepciones">Errores en tiempo de ejecuci&oacute;n: Excepciones</a>
<ul class="minitoc">
<li>
<a href="#Tipos+de+excepciones">Tipos de excepciones</a>
</li>
<li>
<a href="#Captura+de+excepciones">Captura de excepciones</a>
</li>
<li>
<a href="#Lanzamiento+de+excepciones">Lanzamiento de excepciones</a>
</li>
<li>
<a href="#Creaci%C3%B3n+de+nuevas+excepciones">Creaci&oacute;n de nuevas excepciones</a>
</li>
<li>
<a href="#Nested+exceptions">Nested exceptions</a>
</li>
</ul>
</li>
<li>
<a href="#Errores+en+tiempo+de+compilaci%C3%B3n">Errores en tiempo de compilaci&oacute;n</a>
<ul class="minitoc">
<li>
<a href="#Tipos+de+errores">Tipos de errores</a>
</li>
<li>
<a href="#Comprobaci%C3%B3n+de+tipos%3A+Tipos+gen%C3%A9ricos">Comprobaci&oacute;n de tipos: Tipos gen&eacute;ricos</a>
<ul class="minitoc">
<li>
<a href="#Definici%C3%B3n+de+gen%C3%A9ricos">Definici&oacute;n de gen&eacute;ricos</a>
</li>
<li>
<a href="#Subtipos+y+comodines">Subtipos y comodines</a>
</li>
<li>
<a href="#Gen%C3%A9ricos+y+excepciones">Gen&eacute;ricos y excepciones</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>


<a name="N1000C"></a><a name="Introducci%C3%B3n"></a>
<h2 class="underlined_10">Introducci&oacute;n</h2>
<div class="section">
<p>
    Java es un lenguaje compilado, por tanto durante el desarrollo pueden darse dos tipos de errores: los
    de tiempo de compilaci&oacute;n y los de tiempo de ejecuci&oacute;n. En general es preferible
    que los lenguajes de compilaci&oacute;n est&eacute;n dise&ntilde;ados de tal manera que la compilaci&oacute;n
    pueda detectar el m&aacute;ximo n&uacute;mero posible de errores. Es preferible que los errores de tiempo de
    tiempo de ejecuci&oacute;n se deban a situaciones inesperadas y no a descuidos del programador.
    Errores de tiempo de ejecuci&oacute;n siempre habr&aacute;, y su gesti&oacute;n a trav&eacute;s de excepciones
    es fundamental en cualquier lenguaje de programaci&oacute;n actual.</p>
</div>    
        

<a name="N10015"></a><a name="Errores+en+tiempo+de+ejecuci%C3%B3n%3A+Excepciones"></a>
<h2 class="underlined_10">Errores en tiempo de ejecuci&oacute;n: Excepciones</h2>
<div class="section">
<p>Los errores en tiempo de ejecuci&oacute;n son aquellos que ocurren de manera inesperada:
    disco duro lleno, error de red, divisi&oacute;n por cero, cast inv&aacute;lido, etc. Todos estos
    errores pueden ser manejados a trav&eacute;s de excepciones. Tambi&eacute;n hay 
    errores debidos a tareas multihilo que ocurren en tiempo de ejecuci&oacute;n y no todos
    se pueden controlar. Por ejemplo un bloqueo
    entre hilos ser&iacute;a muy dif&iacute;cil de controlar y habr&iacute;a que a&ntilde;adir alg&uacute;n mecanismo 
    que detecte esta situaci&oacute;n y mate los hilos que corresponda.</p>
<p>Las excepciones son eventos que ocurren durante la ejecuci&oacute;n de un programa 
		y hacen que &eacute;ste salga de su flujo normal de instrucciones. Este mecanismo 
		permite tratar los errores de una forma elegante, ya que separa el c&oacute;digo 
		para el tratamiento de errores del c&oacute;digo normal del programa. Se 
		dice que una excepci&oacute;n es <em>lanzada</em> cuando se produce un error, 
		y esta excepci&oacute;n puede ser <em>capturada</em> para tratar dicho error.</p>
<a name="N10027"></a><a name="Tipos+de+excepciones"></a>
<h3 class="underlined_5">Tipos de excepciones</h3>
<p>Tenemos diferentes tipos de excepciones dependiendo del tipo de error que representen. 
		Todas ellas descienden de la clase <span class="codefrag">Throwable</span>, la cual tiene dos 
		descendientes directos:</p>
<ul>
		
<li> 
<strong><span class="codefrag">Error</span></strong>: Se refiere a errores graves en la m&aacute;quina 
			virtual de Java, como por ejemplo fallos al enlazar con alguna librer&iacute;a. 
			Normalmente en los programas Java no se tratar&aacute;n este tipo de errores.</li>
		
<li>
<strong><span class="codefrag">Exception</span></strong>: Representa errores que no son cr&iacute;ticos y 
			por lo tanto pueden ser tratados y continuar la ejecuci&oacute;n de la aplicaci&oacute;n. 
			La mayor&iacute;a de los programas Java utilizan estas excepciones para el 
			tratamiento de los errores que puedan ocurrir durante la ejecuci&oacute;n 
			del c&oacute;digo.</li>
		
	
</ul>
<p>Dentro de <span class="codefrag">Exception</span>, cabe destacar una subclase especial de excepciones 
		denominada <span class="codefrag">RuntimeException</span>, de la cual derivar&aacute;n todas 
		aquellas excepciones referidas a los errores que com&uacute;nmente se pueden 
		producir dentro de cualquier fragmento de c&oacute;digo, como por ejemplo hacer 
		una referencia a un puntero <span class="codefrag">null</span>, o acceder fuera de los l&iacute;mites 
		de un <em>array</em>. </p>
<p>Estas <span class="codefrag">RuntimeException</span> se diferencian del resto de excepciones 
		en que no son de tipo <em>checked</em>. Una excepci&oacute;n de tipo <em>checked</em> 
		debe ser capturada o bien especificar que puede ser lanzada de forma obligatoria, 
		y si no lo hacemos obtendremos un error de compilaci&oacute;n. Dado que las 
		<span class="codefrag">RuntimeException</span> pueden producirse en cualquier fragmento de c&oacute;digo, 
		ser&iacute;a impensable tener que a&ntilde;adir manejadores de excepciones y 
		declarar que &eacute;stas pueden ser lanzadas en todo nuestro c&oacute;digo. 
		Deberemos:</p>
<ul>
		
<li>Utilizar excepciones <em> unchecked </em> (no predecibles) para indicar errores 
			graves en la l&oacute;gica del programa, que normalmente no deber&iacute;an ocurrir. Se utilizar&aacute;n
			para comprobar la consistencia interna del programa. </li>
		
<li>Utilizar excepciones <em> checked</em> para mostrar errores que pueden ocurrir 
			durante la ejecuci&oacute;n de la aplicaci&oacute;n, normalmente debidos a 
			factores externos como por ejemplo la lectura de un fichero con formato incorrecto,  
			un fallo en la conexi&oacute;n, o la entrada de datos por parte del usuario.</li>
		
	
</ul>
<p>   
	
<img alt="Tipos de excepciones" content-width="10cm" height="254" src="imagenes/desarrollo/excepcion.gif" width="491">
 </p>
<p>Dentro de estos grupos principales de excepciones podremos encontrar tipos 
			concretos de excepciones o bien otros grupos que a su vez pueden contener m&aacute;s 
			subgrupos de excepciones, hasta llegar a tipos concretos de ellas. Cada tipo 
			de excepci&oacute;n guardar&aacute; informaci&oacute;n relativa al tipo de error 
			al que se refiera, adem&aacute;s de la informaci&oacute;n com&uacute;n a todas 
			las excepciones. Por ejemplo, una <span class="codefrag">ParseException</span> se suele utilizar 
			al procesar un fichero. Adem&aacute;s de almacenar un mensaje de error, guardar&aacute; 
			la l&iacute;nea en la que el <em>parser</em> encontr&oacute; el error.</p>
<a name="N10084"></a><a name="Captura+de+excepciones"></a>
<h3 class="underlined_5">Captura de excepciones</h3>
<p>Cuando un fragmento de c&oacute;digo sea susceptible de lanzar una excepci&oacute;n 
			y queramos tratar el error producido o bien por ser una excepci&oacute;n de 
			tipo <em>checked</em> debamos capturarla, podremos hacerlo mediante la estructura 
			<span class="codefrag">try-catch-finally</span>, que consta de tres bloques de c&oacute;digo:</p>
<ul>
			
<li> Bloque <span class="codefrag">try</span>: Contiene el c&oacute;digo regular de nuestro programa 
				que puede producir una excepci&oacute;n en caso de error.</li>
			
			
<li>Bloque <span class="codefrag">catch</span>: Contiene el c&oacute;digo con el que trataremos 
				el error en caso de producirse.</li>
			
<li>Bloque <span class="codefrag">finally</span>: Este bloque contiene el c&oacute;digo que se 
				ejecutar&aacute; al final tanto si se ha producido una excepci&oacute;n como 
				si no lo ha hecho. Este bloque se utiliza para, por ejemplo, cerrar alg&uacute;n 
				fichero que haya podido ser abierto dentro del c&oacute;digo regular del programa, 
				de manera que nos aseguremos que tanto si se ha producido un error como si 
				no este fichero se cierre. El bloque <span class="codefrag">finally</span> no es obligatorio 
				ponerlo.</li>
			
		
</ul>
<p>Para el bloque <span class="codefrag">catch</span> adem&aacute;s deberemos especificar el tipo 
			o grupo de excepciones que tratamos en dicho bloque, pudiendo incluir varios 
			bloques <span class="codefrag">catch</span>, cada uno de ellos para un tipo/grupo de excepciones 
			distinto. La forma de hacer esto ser&aacute; la siguiente:</p>
<pre class="brush:java;">try {
	// C&oacute;digo regular del programa
	// Puede producir excepciones
} catch(TipoDeExcepcion1 e1) {
	// C&oacute;digo que trata las excepciones de tipo 
	// TipoDeExcepcion1 o subclases de ella.
	// Los datos sobre la excepci&oacute;n los encontraremos 
	// en el objeto e1.
} catch(TipoDeExcepcion2 e2) {	
	// C&oacute;digo que trata las excepciones de tipo 
	// TipoDeExcepcion2 o subclases de ella.
	// Los datos sobre la excepci&oacute;n los encontraremos 
	// en el objeto e2.
...
} catch(TipoDeExcepcionN eN) {
	// C&oacute;digo que trata las excepciones de tipo 
	// TipoDeExcepcionN o subclases de ella.
	// Los datos sobre la excepci&oacute;n los encontraremos 
	// en el objeto eN.
} finally {
	// C&oacute;digo de finalizaci&oacute;n (opcional)
}</pre>
<p> Si como tipo de excepci&oacute;n especificamos un grupo de excepciones este 
			bloque se encargar&aacute; de la captura de todos los subtipos de excepciones 
			de este grupo. Por lo tanto, si especificamos <span class="codefrag">Exception</span> capturaremos 
			cualquier excepci&oacute;n, ya que est&aacute; es la superclase com&uacute;n 
			de todas las excepciones. </p>
<p> En el bloque <span class="codefrag">catch</span> pueden ser &uacute;tiles algunos m&eacute;todos de la excepci&oacute;n 
			(que podemos ver en la API de la clase padre <span class="codefrag">Exception</span>): </p>
<pre class="brush:java;">String getMessage()
void printStackTrace()</pre>
<p>con <span class="codefrag">getMessage</span> obtenemos una cadena descriptiva del error (si 
			la hay). Con <span class="codefrag">printStackTrace</span> se muestra por la salida est&aacute;ndar 
			la traza de errores que se han producido (en ocasiones la traza es muy larga 
			y no puede seguirse toda en pantalla con algunos sistemas operativos). </p>
<p>Un ejemplo de uso:
			
		</p>
<pre class="brush:java;">try {
	... // Aqui va el codigo que puede lanzar una excepcion
} catch (Exception e) {
	System.out.println ("El error es: " + e.getMessage());
	e.printStackTrace();
}</pre>
<p>Nunca deberemos dejar vac&iacute;o el cuerpo del <span class="codefrag">catch</span>, porque si se 
			produce el error, nadie se va a dar cuenta de que se ha producido. En especial, 
			cuando estemos con excepciones <em>no-checked</em>.</p>
<a name="N100E8"></a><a name="Lanzamiento+de+excepciones"></a>
<h3 class="underlined_5">Lanzamiento de excepciones</h3>
<p>Hemos visto c&oacute;mo capturar excepciones que se produzcan en el c&oacute;digo, 
			pero en lugar de capturarlas tambi&eacute;n podemos hacer que se propaguen al 
			m&eacute;todo de nivel superior (desde el cual se ha llamado al m&eacute;todo actual). Para esto,
			en el m&eacute;todo donde se vaya a lanzar la excepci&oacute;n, se siguen 2 pasos:</p>
<ul>
			
<li>Indicar en el m&eacute;todo que determinados tipos 
				de excepciones o grupos de ellas pueden ser lanzados, cosa que haremos de la siguiente
				forma, por ejemplo:</li>
		
</ul>
<pre class="brush:java;">public void lee_fichero() 
	throws IOException, FileNotFoundException
{
	// Cuerpo de la funci&oacute;n
}</pre>
<p>Podremos indicar tantos tipos de excepciones como queramos en la cla&uacute;sula 
				<span class="codefrag">throws</span>. Si alguna de estas clases de excepciones tiene subclases, 
				tambi&eacute;n se considerar&aacute; que puede lanzar todas estas subclases.</p>
<ul>
			
<li> Para lanzar la excepci&oacute;n utilizamos la instrucci&oacute;n <span class="codefrag">throw</span>, 
				proporcion&aacute;ndole un objeto correspondiente al tipo de excepci&oacute;n 
				que deseamos lanzar. Por ejemplo:</li>
		
</ul>
<pre class="code">
<strong>throw</strong> new IOException(mensaje_error);</pre>
<ul>
			
<li>Juntando estos dos pasos:</li>
		
</ul>
<pre class="brush:java;">public void lee_fichero() 
	throws IOException, FileNotFoundException
{
	...
	throw new IOException(mensaje_error);
	...
}</pre>
<p>Podremos lanzar as&iacute; excepciones en nuestras funciones para indicar que algo 
			no es como debiera ser a las funciones llamadoras. Por ejemplo, si estamos procesando 
			un fichero que debe tener un determinado formato, ser&iacute;a buena idea lanzar 
			excepciones de tipo <span class="codefrag">ParseException</span> en caso de que la sintaxis del 
			fichero de entrada no sea correcta.&nbsp;</p>
<p>NOTA: para las excepciones que no son de tipo <em> checked</em> no har&aacute; falta
			la cl&aacute;usula <em>throws</em> en la declaraci&oacute;n del m&eacute;todo, pero seguir&aacute;n el mismo comportamiento que el resto, si 
			no son capturadas pasar&aacute;n al m&eacute;todo de nivel superior, y seguir&aacute;n 
			as&iacute; hasta llegar a la funci&oacute;n principal, momento en el que si 
			no se captura provocar&aacute; la salida de nuestro programa mostrando el error 
			correspondiente.</p>
<a name="N1012B"></a><a name="Creaci%C3%B3n+de+nuevas+excepciones"></a>
<h3 class="underlined_5">Creaci&oacute;n de nuevas excepciones</h3>
<p>Adem&aacute;s de utilizar los tipos de excepciones contenidos en la distribuci&oacute;n 
			de Java, podremos crear nuevos tipos que se adapten a nuestros problemas.</p>
<p>Para crear un nuevo tipo de excepciones simplemente deberemos crear una clase 
			que herede de <span class="codefrag">Exception</span> o cualquier otro subgrupo de excepciones 
			existente. En esta clase podremos a&ntilde;adir m&eacute;todos y propiedades 
			para almacenar informaci&oacute;n relativa a nuestro tipo de error. Por ejemplo:</p>
<pre class="brush:java;">public class MiExcepcion extends Exception
{
	public MiExcepcion (String mensaje)
	{
		super(mensaje);
	}
}</pre>
<p>Adem&aacute;s podremos crear subclases de nuestro nuevo tipo de excepci&oacute;n, 
			creando de esta forma grupos de excepciones. Para utilizar estas excepciones 
			(capturarlas y/o lanzarlas) hacemos lo mismo que lo explicado antes para las 
			excepciones que se tienen definidas en Java.</p>
<a name="N10142"></a><a name="Nested+exceptions"></a>
<h3 class="underlined_5">Nested exceptions</h3>
<p>Cuando dentro de un m&eacute;todo de una librer&iacute;a se produce una excepci&oacute;n, normalmente se propagar&aacute;
dicha excepci&oacute;n al llamador en lugar de gestionar el error dentro de la librer&iacute;a, para que de esta
forma el llamador tenga constancia de que se ha producido un determinado error y pueda tomar las 
medidas que crea oportunas en cada momento. Para pasar esta excepci&oacute;n al nivel superior puede optar
por propagar la misma excepci&oacute;n que le ha llegado, o bien crear y lanzar una nueva excepci&oacute;n. En este
segundo caso la nueva excepci&oacute;n deber&aacute; contener la excepci&oacute;n anterior, ya que de no ser as&iacute; perder&iacute;amos
la informaci&oacute;n sobre la causa que ha producido el error dentro de la librer&iacute;a, que podr&iacute;a sernos de utilidad
para depurar la aplicaci&oacute;n. Para hacer esto deberemos proporcionar la excepci&oacute;n que ha causado el error
como par&aacute;metro del constructor de nuestra nueva excepci&oacute;n:</p>
<pre class="brush:java;">public class MiExcepcion extends Exception
{
	public MiExcepcion (String mensaje, Throwable causa)
	{
		super(mensaje, causa);
	}
}</pre>
<p>En el m&eacute;todo de nuestra librer&iacute;a en el que se produzca el error deberemos capturar la excepci&oacute;n
que ha causado el error y lanzar nuestra propia excepci&oacute;n al llamador:</p>
<pre class="brush:java;">try {
    ...
} catch(IOException e) {
    throw new MiExcepcion("Mensaje de error", e);
}</pre>
<p>Cuando capturemos una excepci&oacute;n, podemos consultar la excepci&oacute;n previa que la ha causado (si existe)
con el m&eacute;todo:</p>
<pre class="brush:java;">Exception causa = (Exception)e.getCause();</pre>
<p>Las <em>nested exceptions</em> son &uacute;tiles para:</p>
<ul>

<li>Encadenar errores producidos en la secuencia de m&eacute;todos a los que se ha llamado.</li>

<li>Facilitan la depuraci&oacute;n de la aplicaci&oacute;n, ya que nos permite conocer de d&oacute;nde viene el error y por qu&eacute; 
m&eacute;todos ha pasado.</li>

<li>El lanzar una excepci&oacute;n propia de cada m&eacute;todo permite ofrecer informaci&oacute;n m&aacute;s detallada que si
utiliz&aacute;semos una &uacute;nica excepci&oacute;n gen&eacute;rica. Por ejemplo, aunque en varios casos el origen del error
puede ser una <span class="codefrag">IOException</span>, nos ser&aacute; de utilidad saber si &eacute;sta se ha producido al guardar un fichero 
de datos, al guardar datos de la configuraci&oacute;n de la aplicaci&oacute;n, al intentar obtener datos de la red, etc.</li>

<li>Aislar al llamador de la implementaci&oacute;n concreta de una librer&iacute;a. Por ejemplo, cuando utilicemos 
los objetos de acceso a datos de nuestra aplicaci&oacute;n, en caso de error recibiremos una excepci&oacute;n
propia de nuestra capa de acceso a datos, en lugar de una excepci&oacute;n propia de la implementaci&oacute;n
concreta de esta capa, como pudiera ser <span class="codefrag">SQLException</span> si estamos utilizando una BD SQL o <span class="codefrag">IOException</span>
si estamos accediendo a ficheros.</li>

</ul>
</div> 
		

<a name="N10182"></a><a name="Errores+en+tiempo+de+compilaci%C3%B3n"></a>
<h2 class="underlined_10">Errores en tiempo de compilaci&oacute;n</h2>
<div class="section">
<p>En Java existen los errores de compilaci&oacute;n y las advertencias (warnings). Las advertencias no son de 
        resoluci&oacute;n obligatoria mientras que los errores s&iacute;, porque no dejan al compilador compilar el c&oacute;digo.
        Es preferible no dejar advertencias porque suelen indicar alg&uacute;n tipo de incorrecci&oacute;n. Adem&aacute;s, en versiones
        antiguas de Java, cosas que se consideraban una advertencia han pasado a ser un error. Sobre todo para
        el trabajo en equipo es una buena pr&aacute;ctica no dejar ninguna advertencia en el c&oacute;digo que subimos
        al repositorio.</p>
<p>Eclipse nos ayuda enormemente indicando los errores y advertencias conforme escribimos. Para obligarnos a
        mejorar la calidad de nuestro c&oacute;digo podemos indicar a Eclipse que incremente el nivel de advertencias/errores
        en gran diversidad de casos. Se puede configurar en el men&uacute; de <span class="codefrag">Preferences / Java / Compiler / Errors</span>. </p>
<p>   
	
<img alt="Configuraci&oacute;n de errrores y advertencias en Eclipse" content-width="11cm" src="imagenes/exceptions/eclipseerrors.png" width="500">
 </p>
<p>Adem&aacute;s existen herramientas m&aacute;s avanzadas que nos analizan el c&oacute;digo en busca de errores de m&aacute;s alto nivel que
 	    los que detecta el compilador. Por ejemplo las herramientas PMD, cuyo nombre se debe a que estas tres letras
 	    suenan bien juntas, nos detectan posibles bugs debidos a try/catch o switch vac&iacute;os, c&oacute;digo que no se alcanza o
 	    variables y par&aacute;metros que no se usan, expresiones innecesariamente complejas, c&oacute;digo que maneja strings y buffers
 	    de manera sub&oacute;ptima, clases con complejidad cyclom&aacute;tica alta, y c&oacute;digo duplicado. Es f&aacute;cil utilizar PMD
 	    a trav&eacute;s de su plugin para Eclipse.</p>
<a name="N1019C"></a><a name="Tipos+de+errores"></a>
<h3 class="underlined_5">Tipos de errores</h3>
<p>Los errores en tiempo de compilaci&oacute;n son un mal menor de la programaci&oacute;n, ya que el compilador
	    los detecta e indica la causa, a veces incluso proponiendo una soluci&oacute;n. Se pueden clasificar en los siguientes tipos
	    de error de compilaci&oacute;n:
	    </p>
<p>
<strong>Errores de sintaxis</strong>: el c&oacute;digo tecleado no cumple las reglas sint&aacute;cticas del lenguaje Java,
	        por ejemplo, falta un punto y coma al final de una sentencia o se teclea mal el nombre de una
	        variable (que hab&iacute;a sido declarada con otro nombre).</p>
<p>
<strong>Errores sem&aacute;nticos</strong>: c&oacute;digo que, siendo sint&aacute;cticamente correcto, no cumple reglas de m&aacute;s 
	        alto nivel, por ejemplo imprimir el valor de una variable a la que no se ha asignado valor tras declararla:</p>
<pre class="brush:java;">
public void funcion()
{
    int a;
    Console.println(a);
}	            
	        </pre>
<pre class="code">
Prueba.java:12: variable a might not have been initialized
Console.println(a);
                ^
1 error
	        </pre>
<p>
<strong>Errores en cascada</strong>: no son otro tipo de error, pero son errores que confunden
	        al compilador y el mensaje que &eacute;ste devuelve puede indicar la causa del error lejos de donde realmente est&aacute;.
	        Por ejemplo en el siguiente c&oacute;digo la sentencia <span class="codefrag">for</span> est&aacute; mal escrita:</p>
<pre class="brush:java;">
fo ( int i = 0; i &lt; 4; i++ )
{
}
	        </pre>
<pre class="code">
Prueba.java:24: '.class' expected
        fo ( int i = 0; i &lt; 4; i++ )
                 ^
Prueba.java:24: ')' expected
        fo ( int i = 0; i &lt; 4; i++ )
                      ^
Prueba.java:24: not a statement
        fo ( int i = 0; i &lt; 4; i++ )
                          ^
Pueba.java:24: ';' expected
        fo ( int i = 0; i &lt; 4; i++ )
                                   ^
Prueba.java:24: unexpected type
required: value
found   : class
        fo ( int i = 0; i &lt; 4; i++ )
             ^
Prueba.java:24: cannot resolve symbol
symbol  : variable i
location: class Prueba
        fo ( int i = 0; i &lt; 4; i++ )
                               ^
6 errors	        </pre>
<p>Otro problema que crea confusi&oacute;n con respecto a la localizaci&oacute;n del error son
				    las llaves mal cerradas. Esto se debe a que el compilador de Java no tiene en
				    cuenta la indentaci&oacute;n de nuestro c&oacute;digo. Mientras que el programador puede ver,
				    a trav&eacute;s de la indentaci&oacute;n, d&oacute;nde falta cerrar la llave de una funci&oacute;n, bucle o clase,
				    el compilador podr&iacute;a darse cuenta al terminar de leer el archivo e indicarlo ah&iacute;.</p>
<a name="N101CC"></a><a name="Comprobaci%C3%B3n+de+tipos%3A+Tipos+gen%C3%A9ricos"></a>
<h3 class="underlined_5">Comprobaci&oacute;n de tipos: Tipos gen&eacute;ricos</h3>
<p>En Java hay muchas estructuras de datos que est&aacute;n preparadas para almacenar cualquier tipo 
		de objeto. As&iacute;, en lugar de que exista un <span class="codefrag">ArrayList</span> que reciba y devuelva enteros,
		&eacute;ste recibe y devuelve objetos. Devolver objetos se convierte en una molestia porque hay que hacer un 
		cast expl&iacute;cito, por ejemplo, <span class="codefrag">Integer i = (Integer)v.get(0);</span> cuando el programador
		sabe perfectamente que este array s&oacute;lo podr&aacute; tener enteros. Pero el problema es mayor, este cast,
		si no es correcto, provoca un error en tiempo de ejecuci&oacute;n. V&eacute;ase el ejemplo:
		</p>
<pre class="brush:java;">
List v = new ArrayList();
v.add("test");
Integer i = (Integer)v.get(0); // Error en tiempo de ejecuci&oacute;n		    
		</pre>
<p>
	 	    Para evitar esta situaci&oacute;n a partir de Java 1.5 se introdujeron los tipos gen&eacute;ricos, que nos fuerzan a indicar
	 	    el tipo devuelto, &uacute;nicamente en la declaraci&oacute;n de la clase de la instancia. A partir de ah&iacute;
	 	    se har&aacute; uso de la estructura sin tener que hacer cast expl&iacute;citos. El anterior ejemplo quedar&iacute;a as&iacute;:
	 	</p>
<pre class="brush:java;">
List&lt;String&gt; v = new ArrayList&lt;String&gt;();
v.add("test");
String  s = v.get(0); // Correcto (sin necesidad de cast expl&iacute;cito)	    
Integer i = v.get(0); // Error en tiempo ce compilaci&oacute;n
	 	</pre>
<p>Los tipos b&aacute;sicos como <span class="codefrag">int, float,</span> etc, no se pueden utilizar en los tipos gen&eacute;ricos.</p>
<a name="N101ED"></a><a name="Definici%C3%B3n+de+gen%C3%A9ricos"></a>
<h4>Definici&oacute;n de gen&eacute;ricos</h4>
<p>Para definir que una clase trabaja con un tipo gen&eacute;rico, se a&ntilde;ade un identificador,
		        por ejemplo <span class="codefrag">&lt;E&gt;</span> entre los s&iacute;mbolos menor y mayor, al final del nombre de dicha clase.
		        En el siguiente c&oacute;digo se muestra un peque&ntilde;o extracto de la definici&oacute;n de las <strong>interfaces</strong> 
		        <span class="codefrag">List</span> e <span class="codefrag">Iterator</span>:</p>
<pre class="brush:java;">
public interface List&lt;E&gt; { 
    void add(E x);
    Iterator&lt;E&gt; iterator();
}
public interface Iterator&lt;E&gt; { 
    E next();
    boolean hasNext();
}		    
			</pre>
<p>No s&oacute;lo las interfaces pueden tener tipos gen&eacute;ricos, sino tambi&eacute;n las <strong>clases</strong>, siguiendo la misma 
			    sintaxis:</p>
<pre class="brush:java;">
public class Entry&lt;K, V&gt; {
 
  private final K key;
  private final V value;
 
  public Entry(K k,V v) {  
    key = k;
    value = v;   
  }
 
  public K getKey() {
    return key;
  }
 
  public V getValue() {
    return value;
  }
 
  public String toString() { 
    return "(" + key + ", " + value + ")";  
  }
}			</pre>
<p>Para usar la clase gen&eacute;rica del ejemplo anterior, declaramos objetos de esa clase, indicando
			    con qu&eacute; tipos concretos trabajan en cada caso:</p>
<pre class="brush:java;">
Entry&lt;String, String&gt;  grade440 = new Entry&lt;String, String&gt;("mike", "A");
Entry&lt;String, Integer&gt; marks440 = new Entry&lt;String, Integer&gt;("mike", 100);
System.out.println("grade: " + grade440);
System.out.println("marks: " + marks440);			    
			</pre>
<p>Por &uacute;ltimo, tambi&eacute;n los <strong>m&eacute;todos</strong> se pueden definir con tipos gen&eacute;ricos:</p>
<pre class="brush:java;">
public static &lt;T&gt; Entry&lt;T,T&gt; twice(T value) {
   return new SimpleImmutableEntry&lt;T,T&gt;(value, value);
}			    
			</pre>
<p>Este m&eacute;todo utiliza el tipo gen&eacute;rico para indicar qu&eacute; gen&eacute;ricos tiene la clase que el m&eacute;todo devuelve,
			    y tambi&eacute;n utiliza ese mismo tipo gen&eacute;rico para indicar de qu&eacute; tipo es el argumento del m&eacute;todo.
			    Al usar el m&eacute;todo, el tipo podr&iacute;a ser indicado o podr&iacute;a ser inferido por el compilador en lugar 
			    de declararlo:</p>
<pre class="brush:java;">
Entry&lt;String, String&gt; pair = this.&lt;String&gt;twice("Hello"); // Declarado
Entry&lt;String, String&gt; pair = twice("Hello");              // Inferido
			</pre>
<a name="N1022D"></a><a name="Subtipos+y+comodines"></a>
<h4>Subtipos y comodines</h4>
<p>Se debe advertir que, contrariamente a la intuici&oacute;n, si una clase <span class="codefrag">Hija</span> es
			    subtipo (subclase o subinterfaz) de una clase <span class="codefrag">Padre</span>, y por ejemplo <span class="codefrag">ArrayList</span> es una clase
			    gen&eacute;rica, entonces <span class="codefrag">ArrayList&lt;Hija&gt;</span> <strong>no</strong> es subtipo de
			    <span class="codefrag">ArrayList&lt;Padre&gt;</span> 
</p>
<p>Existe una forma de flexibilizar el tipado gen&eacute;rico a trav&eacute;s de "wildcards" o comodines.
			    Si queremos que una clase con gen&eacute;ricos funcione para tipos y sus subtipos, podemos utilizar
			    el comod&iacute;n <span class="codefrag">&lt;?&gt;</span> junto con la palabra clave <span class="codefrag">extends</span> para indicar
			    a continuaci&oacute;n cu&aacute;l es la clase/interfaz de la que hereda:
			    </p>
<pre class="brush:java;">
ArrayList&lt;? extends Padre&gt;
			</pre>
<p>De esta manera ser&iacute;an v&aacute;lidos tanto <span class="codefrag">Padre</span> como sus clases derivadas: <span class="codefrag">Hija</span>.
				    Supongamos ahora que <span class="codefrag">Padre</span> hereda de <span class="codefrag">Abuelo</span> y s&oacute;lo queremos que sean
				    v&aacute;lidas estas dos clases. Entonces utilizaremos la palabra clave <span class="codefrag">super</span>, como en el
				    siguiente ejemplo, que permitir&iacute;a <span class="codefrag">Padre</span>, <span class="codefrag">Abuelo</span> y <span class="codefrag">Object</span>,
				    suponiendo que no hay m&aacute;s superclases antes de llegar a <span class="codefrag">Object</span>:</p>
<pre class="brush:java;">
ArrayList&lt;? super Padre&gt;
			</pre>
<p>Tambi&eacute;n est&aacute; permitido utilizar el comod&iacute;n s&oacute;lo, indicando que cualquier tipo es v&aacute;lido.</p>
<a name="N1027C"></a><a name="Gen%C3%A9ricos+y+excepciones"></a>
<h4>Gen&eacute;ricos y excepciones</h4>
<p>
			    Es posible indicar a un m&eacute;todo o a una clase el tipo de excepci&oacute;n que debe lanzar,
			    a trav&eacute;s de un gen&eacute;rico.
			</p>
<pre class="brush:java;">
public &lt;T extends Throwable&gt; void metodo() throws T {
  throw new T();
}			
			</pre>
<p>O bien:
			</p>
<pre class="brush:java;">
public class Clase&lt;T extends Throwable&gt;
  public void metodo() throws T {
    throw new T();
  }  
}			
			</pre>
<p>Lo que no es posible es crear excepciones con tipos gen&eacute;ricos, por ejemplo, si
			    creamos nuestra propia excepci&oacute;n para que pueda incluir distintos tipos:
			</p>
<pre class="brush:java;">
public class MiExcepcion&lt;T extends Object&gt; extends Exception {
  private T someObject;

  public MiExcepcion(T someObject) {
    this.someObject = someObject;
  }

  public T getSomeObject() {
    return someObject;
  }
}

			</pre>
<p>
			Tendr&iacute;amos un problema con las cl&aacute;usulas <span class="codefrag">catch</span>, puesto que cada una
			debe corresponderse con determinado tipo:
			</p>
<pre class="brush:java;">
try {
  //C&oacute;digo que lanza o bien MiExcepcion&lt;String&gt;, o bien MiExcepcion&lt;Integer&gt;
}
catch(MiExcepcion&lt;String&gt; ex) {
  // A
}
catch(MiExcepcion&lt;Integer&gt; ex) {
  // B
}	    
			</pre>
<p>En este c&oacute;digo no ser&iacute;a posible saber en qu&eacute; bloque <span class="codefrag">catch</span> entrar,
			ya que ser&iacute;an id&eacute;nticos tras la compilaci&oacute;n debido al <strong>borrado de tipos</strong>, o 
			"type erasure".</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">
			    Lo que en realidad hace el compilador es comprobar si el uso de tipos gen&eacute;ricos es
			    consistente y despu&eacute;s borrarlos, dejando el c&oacute;digo sin tipos, como antes de Java 1.5.
			    Los tipos gen&eacute;ricos s&oacute;lo sirven para restringir el tipado en tiempo de compilaci&oacute;n,
			    poniendo en evidencia errores que de otra manera ocurrir&iacute;an en tiemo de ejecuci&oacute;n.
			</div>
</div>
<p>Teniendo eso en cuenta, entendemos por qu&eacute; no funciona el c&oacute;digo del anterior ejemplo. 
			Tras el borrado de tipos queda as&iacute;:</p>
<pre class="brush:java;">
try {
  //C&oacute;digo que lanza o bien MiExcepcion&lt;String&gt;, o bien MiExcepcion&lt;Integer&gt;
}
catch(MiExcepcion ex) {
  // A
}
catch(MiExcepcion ex) {
  // B
}	    
			</pre>
</div>	
	
	

<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
