<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Serializaci&oacute;n de datos</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Experto en Desarrollo de Aplicaciones y Servicios con Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Lenguaje Java Avanzado" src="images/baner_j2ee_der.gif" title="Lenguaje Java Avanzado"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Java y Herramientas de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Java y Herramientas de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 5</div>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion05-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Serializaci&oacute;n de datos</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n">Introducci&oacute;n</a>
</li>
<li>
<a href="#Flujos+de+datos+de+entrada%2Fsalida">Flujos de datos de entrada/salida</a>
</li>
<li>
<a href="#Entrada%2C+salida+y+salida+de+error+est%C3%A1ndar">Entrada, salida y salida de error est&aacute;ndar</a>
</li>
<li>
<a href="#Acceso+a+ficheros">Acceso a ficheros</a>
</li>
<li>
<a href="#Acceso+a+los+recursos">Acceso a los recursos</a>
</li>
<li>
<a href="#Acceso+a+la+red">Acceso a la red</a>
</li>
<li>
<a href="#Codificaci%C3%B3n+de+datos">Codificaci&oacute;n de datos</a>
</li>
<li>
<a href="#Serializaci%C3%B3n+de+objetos">Serializaci&oacute;n de objetos</a>
</li>
</ul>
</div>


<a name="N1000C"></a><a name="Introducci%C3%B3n"></a>
<h2 class="underlined_10">Introducci&oacute;n</h2>
<div class="section">
<p>Los programas muy a menudo necesitan enviar datos a un determinado destino, o
bien leerlos de una determinada fuente externa, como por ejemplo puede ser un
fichero para almacenar datos de forma permanente, o bien enviar datos a trav&eacute;s
de la red, a memoria, o a otros programas. Esta entrada/salida de datos en Java
la realizaremos por medio de <em>flujos (streams)</em> de datos, a trav&eacute;s de los
cuales un programa podr&aacute; recibir o enviar datos en serie. Si queremos transferir
estructuras de datos complejas, deberemos convertir estas estructuras en secuencias
de bytes que puedan ser enviadas a trav&eacute;s de un flujo. Esto es lo que se conoce 
como serializaci&oacute;n. Comenzaremos viendo los fundamentos de los flujos de entrada y
salida en Java, para a continuaci&oacute;n pasar a estudiar los flujos que nos permitir&aacute;n
serializar diferentes tipos de datos Java de forma sencilla.</p>
</div>

<a name="N10019"></a><a name="Flujos+de+datos+de+entrada%2Fsalida"></a>
<h2 class="underlined_10">Flujos de datos de entrada/salida</h2>
<div class="section">
<p>Existen varios objetos que hacen de flujos de datos, y que se distinguen por
la finalidad del flujo de datos y por el tipo de datos que viajen a trav&eacute;s de
ellos. Seg&uacute;n el tipo de datos&nbsp; que transporten podemos distinguir:</p>
<ul>
  
<li>Flujos de caracteres</li>
  
<li>Flujos de <em>bytes</em>
</li>

</ul>
<p>Dentro de cada uno de estos grupos tenemos varios pares de objetos, de los 
  cuales uno nos servir&aacute; para leer del flujo y el otro para escribir en &eacute;l. Cada 
  par de objetos ser&aacute; utilizado para comunicarse con distintos elementos (memoria, 
  ficheros, red u otros programas). Estas clases, seg&uacute;n sean de entrada o salida 
  y seg&uacute;n sean de caracteres o de <em>bytes</em> llevar&aacute;n distintos sufijos, seg&uacute;n 
  se muestra en la siguiente tabla:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr> 
    
<th colspan="1" rowspan="1">&nbsp;</th>
    <th colspan="1" rowspan="1"><strong>Flujo de entrada / lector</strong></th>
    <th colspan="1" rowspan="1"><strong>Flujo de salida / escritor</strong></th>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Caract&eacute;res</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">_Reader</span></td>

    <td colspan="1" rowspan="1"><span class="codefrag">_Writer</span></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Bytes</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">_InputStream</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">_OutputStream</span></td>
  
</tr>


</table>
<p>Donde el prefijo se referir&aacute; a la fuente o sumidero de los datos que puede 
  tomar valores como los que se muestran a continuaci&oacute;n:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">File_</span></td>
    <td colspan="4" rowspan="1">Acceso a ficheros</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">Piped_</span></td>
    <td colspan="4" rowspan="1">Comunicaci&oacute;n entre programas mediante tuber&iacute;as (<em>pipes</em>)</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">String_</span></td>
    <td colspan="4" rowspan="1">Acceso a una cadena en memoria (solo caracteres)</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">CharArray_</span></td>
    <td colspan="4" rowspan="1">Acceso a un <em>array</em> de caracteres en memoria (solo 
      caracteres)</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><span class="codefrag">ByteArray_</span></td>
    <td colspan="4" rowspan="1">Acceso a un <em>array</em> de <em>bytes</em> en memoria (solo 
      <em>bytes</em>)</td>
  
</tr>

</table>
<p>Adem&aacute;s podemos distinguir los flujos de datos seg&uacute;n su prop&oacute;sito, pudiendo
ser:</p>
<ul>
  
<li>Canales de datos, simplemente para leer o escribir datos directamente en
    una fuente o sumidero externo.</li>
  
<li>Flujos de procesamiento, que adem&aacute;s de enviar o recibir datos realizan alg&uacute;n 
    procesamiento con ellos. Tenemos por ejemplo flujos que realizan un filtrado 
    de los datos que viajan a trav&eacute;s de ellos (con prefijo <span class="codefrag">Filter</span>), 
    conversores datos (con prefijo <span class="codefrag">Data</span>), <em>bufferes</em> de datos 
    (con prefijo <span class="codefrag">Buffered</span>), preparados para la impresi&oacute;n de elementos 
    (con prefijo <span class="codefrag">Print</span>), etc.</li>


</ul>
<p>Un tipo de filtros de procesamiento a destacar son aquellos que nos permiten 
  convertir un flujo de <em>bytes</em> a flujo de caracteres. Estos objetos son 
  <span class="codefrag">InputStreamReader</span> y <span class="codefrag">OutputStreamWriter</span>. Como podemos 
  ver en su sufijo, son flujos de caracteres, pero se construyen a partir de flujos 
  de <em>bytes</em>, permitiendo de esta manera acceder a nuestro flujo de <em>bytes</em> 
  como si fuese un flujo de caracteres.</p>
<p>Para cada uno de los tipos b&aacute;sicos de flujo que hemos visto existe una superclase, 
  de la que heredaran todos sus subtipos, y que contienen una serie de m&eacute;todos 
  que ser&aacute;n comunes a todos ellos. Entre estos m&eacute;todos encontramos los m&eacute;todos 
  b&aacute;sicos para leer o escribir caracteres o <em>bytes</em> en el flujo a bajo 
  nivel. En la siguiente tabla se muestran los m&eacute;todos m&aacute;s importantes de cada 
  objeto:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
	
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
	  
<td colspan="1" rowspan="1"><strong><span class="codefrag">InputStream</span></strong></td>
	  <td colspan="2" rowspan="1"><strong><span class="codefrag">read</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">reset</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">available</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">close</span></strong><span class="codefrag">()</span></td>

  
</tr>
  
<tr> 
	  
<td colspan="1" rowspan="1"><strong><span class="codefrag">OutputStream</span></strong></td>
	  <td colspan="2" rowspan="1"><strong><span class="codefrag">write</span></strong><span class="codefrag">(int b), </span><strong><span class="codefrag">flush</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">close</span></strong><span class="codefrag">()</span></td>
  
</tr>
  
<tr> 
	  
<td colspan="1" rowspan="1"><strong><span class="codefrag">Reader</span></strong></td>
	  <td colspan="2" rowspan="1"><strong><span class="codefrag">read</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">reset</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">close</span></strong><span class="codefrag">()</span></td>
  
</tr>
  
<tr> 
	  
<td colspan="1" rowspan="1"><strong><span class="codefrag">Writer</span></strong></td>
	  <td colspan="2" rowspan="1"><strong><span class="codefrag">write</span></strong><span class="codefrag">(int c), </span><strong><span class="codefrag">flush</span></strong><span class="codefrag">(), </span><strong><span class="codefrag">close</span></strong><span class="codefrag">()</span></td>

  
</tr>

</table>
<p>A parte de estos m&eacute;todos podemos encontrar variantes de los m&eacute;todos de lectura 
  y escritura, otros m&eacute;todos, y adem&aacute;s cada tipo espec&iacute;fico de flujo contendr&aacute; 
  sus propios m&eacute;todos. Todas estas clases se encuentran en el paquete <span class="codefrag">java.io</span>. 
  Para m&aacute;s detalles sobre ellas se puede consultar la especificaci&oacute;n de la API 
  de Java.</p>
</div>

<a name="N101A1"></a><a name="Entrada%2C+salida+y+salida+de+error+est%C3%A1ndar"></a>
<h2 class="underlined_10">Entrada, salida y salida de error est&aacute;ndar</h2>
<div class="section">
<p>Al igual que en C, en Java tambi&eacute;n existen los conceptos de entrada, salida,
y salida de error est&aacute;ndar. La entrada est&aacute;ndar normalmente se refiere a lo
que el usuario escribe en la consola, aunque el sistema operativo puede hacer
que se tome de otra fuente. De la misma forma la salida y la salida de error
est&aacute;ndar lo que hacen normalmente es mostrar los mensajes y los errores del
programa respectivamente en la consola, aunque el sistema operativo tambi&eacute;n
podr&aacute; redirigirlas a otro destino.</p>
<p>En Java esta entrada, salida y salida de error est&aacute;ndar se tratan de la misma 
  forma que cualquier otro flujo de datos, estando estos tres elementos encapsulados 
  en tres objetos de flujo de datos que se encuentran como propiedades est&aacute;ticas 
  de la clase <span class="codefrag">System</span>:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr> 
    
<td colspan="1" rowspan="1">&nbsp;</td>
    <td colspan="1" rowspan="1"><strong>Tipo</strong></td>
    <td colspan="1" rowspan="1"><strong>Objeto</strong></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Entrada est&aacute;ndar</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">InputStream</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">System.</span><strong><span class="codefrag">in</span></strong></td>

  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Salida est&aacute;ndar</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">PrintStream</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">System.</span><strong><span class="codefrag">out</span></strong></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Salida de error est&aacute;ndar</strong></td>
    <td colspan="1" rowspan="1"><span class="codefrag">PrintStream</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">System.</span><strong><span class="codefrag">err</span></strong></td>
  
</tr>

</table>
<p>Para la entrada est&aacute;ndar vemos que se utiliza un objeto <span class="codefrag">InputStream</span> 
  b&aacute;sico, sin embargo para la salida se utilizan objetos <span class="codefrag">PrintWriter</span> 
  que facilitan la impresi&oacute;n de texto ofreciendo a parte del m&eacute;todo com&uacute;n de bajo 
  nivel <span class="codefrag">write</span> para escribir <em>bytes</em>, dos m&eacute;todos m&aacute;s: <span class="codefrag">print</span> 
  y <span class="codefrag">println</span>. Estas funciones nos permitir&aacute;n escribir cualquier cadena, 
  tipo b&aacute;sico, o bien cualquier objeto que defina el m&eacute;todo <span class="codefrag">toString</span> 
  que devuelva una representaci&oacute;n del objeto en forma de cadena. La &uacute;nica diferencia 
  entre los dos m&eacute;todos es que el segundo a&ntilde;ade autom&aacute;ticamente un salto de l&iacute;nea 
  al final del texto impreso, mientras que en el primero deberemos especificar 
  expl&iacute;citamente este salto.</p>
<p>Para escribir texto en la consola normalmente utilizaremos:</p>
<pre class="brush:java;">System.out.println("Hola mundo");</pre>
<p>En el caso de la impresi&oacute;n de errores por la salida de error de est&aacute;ndar,
deberemos utilizar:&nbsp;</p>
<pre class="brush:java;">System.err.println("Error: Se ha producido un error");</pre>
<p>Adem&aacute;s la clase <span class="codefrag">System</span> nos permite sustituir estos flujos por 
  defecto por otros flujos, cambiando de esta forma la entrada, salida y salida 
  de error est&aacute;ndar.</p>
<div class="frame note">
<div class="label">Truco</div>
<div class="content">Podemos ahorrar tiempo si en Eclipse en lugar de escribir 
<span class="codefrag">System.out.println</span> escribimos simplemente <span class="codefrag">sysout</span> y 
tras esto pulsamos <em>Ctrl + Espacio</em>.</div>
</div>
</div>

<a name="N1024B"></a><a name="Acceso+a+ficheros"></a>
<h2 class="underlined_10">Acceso a ficheros</h2>
<div class="section">
<p>Podremos acceder a ficheros bien por caracteres, o bien de forma binaria (por 
  <em>bytes</em>). Las clases que utilizaremos en cada caso son:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr> 
    
<td colspan="1" rowspan="1">&nbsp;</td>
    <td colspan="1" rowspan="1">Lectura</td>
    <td colspan="1" rowspan="1">Escritura</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1">Caracteres</td>
    <td colspan="1" rowspan="1"><span class="codefrag">FileReader</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">FileWriter</span></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1">Binarios</td>
    <td colspan="1" rowspan="1"><span class="codefrag">FileInputStream</span></td>
    <td colspan="1" rowspan="1"><span class="codefrag">FileOutputStream</span></td>
  
</tr>

</table>
<p>Para crear un lector o escritor de ficheros deberemos proporcionar al constructor 
  el fichero del que queremos leer o en el que queramos escribir. Podremos proporcionar 
  esta informaci&oacute;n bien como una cadena de texto con el nombre del fichero, o 
  bien construyendo un objeto <span class="codefrag">File</span> representando al fichero al que 
  queremos acceder. Este objeto nos permitir&aacute; obtener informaci&oacute;n adicional sobre 
  el fichero, a parte de permitirnos realizar operaciones sobre el sistema de 
  ficheros.</p>
<p>A continuaci&oacute;n vemos un ejemplo simple de la copia de un fichero car&aacute;cter a
car&aacute;cter:</p>
<pre class="brush:java;">public void copia_fichero() {
  int c;
  try {
    FileReader in = new FileReader("fuente.txt");
    FileWriter out = new FileWriter("destino.txt");
	
    while( (c = in.read()) != -1) {
      out.write(c);
    }
		
    in.close();
    out.close();
	
  } catch(FileNotFoundException e1) {
    System.err.println("Error: No se encuentra el fichero");
  } catch(IOException e2) {
    System.err.println("Error leyendo/escribiendo fichero");
  }
}</pre>
<p>
En el ejemplo podemos ver que para el acceso a un fichero es necesario
capturar dos excepciones, para el caso de que no exista el fichero al que
queramos acceder y por si se produce un error en la E/S.</p>
<p>Para la escritura podemos utilizar el m&eacute;todo anterior, aunque muchas veces 
  nos resultar&aacute; mucho m&aacute;s c&oacute;modo utilizar un objeto <span class="codefrag">PrintWriter </span>con 
  el que podamos escribir directamente l&iacute;neas de texto:</p>
<pre class="brush:java;">public void escribe_fichero() {
  FileWriter out = null;
  PrintWriter p_out = null;

  try {
    out = new FileWriter("result.txt");
    p_out = new PrintWriter(out);
    p_out.println(
      "Este texto ser&aacute; escrito en el fichero de salida");

  } catch(IOException e) {
    System.err.println("Error al escribir en el fichero");
  } finally {
    p_out.close();
  }
}</pre>
</div>


<a name="N102B1"></a><a name="Acceso+a+los+recursos"></a>
<h2 class="underlined_10">Acceso a los recursos</h2>
<div class="section">
<p>Hemos visto como leer y escribir ficheros, pero cuando ejecutamos una aplicaci&oacute;n 
  contenida en un fichero JAR, puede que necesitemos leer recursos contenidos 
  dentro de este JAR. </p>
<p>Para acceder a estos recursos deberemos abrir un flujo de entrada que se encargue 
  de leer su contenido. Para ello utilizaremos el m&eacute;todo <span class="codefrag">getResourceAsStream</span> 
  de la clase <span class="codefrag">Class</span>:</p>
<pre class="brush:java;">InputStream in = getClass().getResourceAsStream("/datos.txt");</pre>
<p>De esta forma podremos utilizar el flujo de entrada obtenido para leer el contenido 
  del fichero que hayamos indicado. Este fichero deber&aacute; estar contenido 
  en el JAR de la aplicaci&oacute;n.</p>
<p>Especificamos el car&aacute;cter '<span class="codefrag">/</span>' delante del nombre del recurso 
  para referenciarlo de forma relativa al directorio ra&iacute;z del JAR. Si no 
  lo especific&aacute;semos de esta forma se buscar&iacute;a de forma relativa 
  al directorio correspondiente al paquete de la clase actual.</p>
</div>


<a name="N102D2"></a><a name="Acceso+a+la+red"></a>
<h2 class="underlined_10">Acceso a la red</h2>
<div class="section">
<p>Podemos tambi&eacute;n obtener flujos para leer datos a trav&eacute;s de la red
a partir de una URL. De esta forma podremos
obtener por ejemplo informaci&oacute;n ofrecida por una aplicaci&oacute;n web. Lo 
primero que debemos hacer es crear un objeto <span class="codefrag">URL</span> especificando
la direcci&oacute;n a la que queremos acceder:</p>
<pre class="brush:java;">URL url = new URL("http://www.ua.es/es/index.html");</pre>
<p>A partir de esta URL podemos obtener directamente un flujo de entrada 
mediante el m&eacute;todo <span class="codefrag">openStream</span>:</p>
<pre class="brush:java;">InputStream in = url.openStream();</pre>
<p>Una vez obtenido este flujo de entrada podremos leer de &eacute;l o bien transformarlo 
  a otro tipo de flujo como por ejemplo a un flujo de caracteres o de procesamiento.
  La lectura se har&aacute; de la misma forma que cualquier otro tipo de flujo.</p>
</div>


<a name="N102F2"></a><a name="Codificaci%C3%B3n+de+datos"></a>
<h2 class="underlined_10">Codificaci&oacute;n de datos</h2>
<div class="section">
<p>Si queremos guardar datos en un fichero binario, enviarlos a trav&eacute;s de la red,
  o en general transferirlos mediante cualquier flujo de E/S, deberemos 
  codificar estos datos en forma de <em>array</em> de <em>bytes</em>. Los flujos 
  de procesamiento <span class="codefrag">DataInputStream</span> y <span class="codefrag">DataOutputStream</span> 
  nos permitir&aacute;n codificar y descodificar respectivamente los tipos de 
  datos simples en forma de <em>array</em> de <em>bytes</em> para ser enviados 
  a trav&eacute;s de un flujo de datos. </p>
<p>Por ejemplo, podemos codificar datos en un <em>array</em> 
  en memoria (<span class="codefrag">ByteArrayOutputStream</span>) de la siguiente forma:</p>
<pre class="brush:java;">String nombre = "Jose";
String edad = 25;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
DataOutputStream dos = new DataOutputStream(baos);

dos.writeUTF(nombre);
dos.writeInt(edad);
dos.close();
baos.close();

byte [] datos = baos.toByteArray();</pre>
<p>Podremos descodificar este <em>array</em> de <em>bytes</em> 
  realizando el procedimiento inverso, con un flujo que lea un <em>array</em> 
  de <em>bytes</em> de memoria (<span class="codefrag">ByteArrayInputStream</span>):</p>
<pre class="brush:java;">ByteArrayInputStream bais = new ByteArrayInputStream(datos);
DataInputStream dis = new DataInputStream(bais);
String nombre = dis.readUTF();
int edad = dis.readInt();
</pre>
<p>Si en lugar de almacenar estos datos codificados en una 
  <em>array</em> en memoria queremos guardarlos codificados en un fichero, haremos 
  lo mismo simplemente sustituyendo el flujo canal de datos <span class="codefrag">ByteArrayOutputStream</span> 
  por un <span class="codefrag">FileOutputStream</span>. De esta forma podremos utilizar cualquier 
  canal de datos para enviar estos datos codificados a trav&eacute;s de &eacute;l.</p>
</div>


<a name="N1033F"></a><a name="Serializaci%C3%B3n+de+objetos"></a>
<h2 class="underlined_10">Serializaci&oacute;n de objetos</h2>
<div class="section">
<p>Si queremos enviar un objeto a trav&eacute;s de un flujo de datos, deberemos convertirlo 
  en una serie de <em>bytes</em>. Esto es lo que se conoce como serializaci&oacute;n 
  de objetos, que nos permitir&aacute; leer y escribir objetos directamente. </p>
<p>Para leer o escribir objetos podemos utilizar los objetos <span class="codefrag">ObjectInputStream 
  </span> y <span class="codefrag">ObjectOutputStream</span> que incorporan los m&eacute;todos <span class="codefrag">readObject</span> 
  y <span class="codefrag">writeObject</span> respectivamente. Los objetos que escribamos en dicho 
  flujo deben tener la capacidad de ser <em>serializables</em>. </p>
<p>Ser&aacute;n <em>serializables </em>aquellos objetos que implementan la interfaz <span class="codefrag">Serializable</span>. 
  Cuando queramos hacer que una clase definida por nosotros sea <em>serializable 
  </em>deberemos implementar dicho interfaz, que no define ninguna funci&oacute;n, s&oacute;lo 
  se utiliza para identificar las clases que son <em>serializables</em>. Para que 
  nuestra clase pueda ser <em>serializable</em>, todas sus propiedades deber&aacute;n ser 
  de tipos de datos b&aacute;sicos o bien objetos que tambi&eacute;n sean<em> serializables</em>. 
</p>
<p>Un uso com&uacute;n de la serializaci&oacute;n se realiza en los <em>Transfer Objetcs</em>. Este 
tipo de objetos deben ser serializables para as&iacute; poderse intercambiar
entre todas las capas de la aplicaci&oacute;n, aunque se encuentren en m&aacute;quinas 
diferentes.</p>
<p>Por ejemplo, si tenemos un objeto como el siguiente:</p>
<pre class="brush:java;">public class Punto2D implements Serializable {
	private int x;
	private int y;

	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}
}</pre>
<p>Podr&iacute;amos enviarlo a trav&eacute;s de un flujo, independientemente
de su destino, de la siguiente forma:</p>
<pre class="brush:java;">Punto2D p = crearPunto();
FileOutputStream fos = new FileOutputStream(FICHERO_DATOS);
ObjectOutputStream oos = new ObjectOutputStream(fos);
oos.writeObject(p);
oos.close();</pre>
<p>En este caso hemos utilizado como canal de datos un flujo con destino a un
fichero, pero se podr&iacute;a haber utilizado cualquier otro tipo de canal (por ejemplo
para enviar un objeto Java desde un servidor web hasta una m&aacute;quina cliente). En 
aplicaciones distribuidas los objetos <em>serializables</em> nos permitir&aacute;n mover
estructuras de datos entre diferentes m&aacute;quinas sin que el desarrollador tenga que
preocuparse de la codificaci&oacute;n y transmisi&oacute;n de los datos.</p>
<p>Muchas clases de la API de Java son <em>serializables</em>, como por ejemplo las
colecciones. Si tenemos una serie de elementos en una lista, podr&iacute;amos serializar 
la lista completa, y de esa forma guardar todos nuestros objetos, con una &uacute;nica 
llamada a <span class="codefrag">writeObject</span>.</p>
<p>Cuando una clase implemente la interfaz <span class="codefrag">Serializable</span> veremos que Eclipse
nos da un <em>warning</em> si no a&ntilde;adimos un campo <span class="codefrag">serialVersionUID</span>. Este
es un c&oacute;digo num&eacute;rico que se utiliza para asegurarnos de que al recuperar un objeto
serializado &eacute;ste se asocie a la misma clase con la que se cre&oacute;. As&iacute; evitamos el problema
que puede surgir al tener dos clases que puedan tener el mismo nombre, pero que no sean
iguales (podr&iacute;a darse el caso que una de ellas est&eacute; en una m&aacute;quina cliente, y la otra en el servidor). 
Si no tuvi&eacute;semos ning&uacute;n c&oacute;digo para identificarlas, se podr&iacute;a intentar recuperar
un objeto en una clase incorrecta.</p>
<p>Eclipse nos ofrece dos formas de generar este c&oacute;digo pulsando sobre el icono del
<em>warning</em>: con un valor por defecto, o con
un valor generado autom&aacute;ticamente. Ser&aacute; recomendable utiliar esta segunda forma, que
nos asegura que dos clases distintas tendr&aacute;n c&oacute;digos distintos.</p>
</div>


<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
