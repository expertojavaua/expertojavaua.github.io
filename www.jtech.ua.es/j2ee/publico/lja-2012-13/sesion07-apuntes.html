<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Java Database Connectivity</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Experto en Desarrollo de Aplicaciones y Servicios con Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Lenguaje Java Avanzado" src="images/baner_j2ee_der.gif" title="Lenguaje Java Avanzado"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Java y Herramientas de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Java y Herramientas de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 7</div>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion07-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Java Database Connectivity</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introducci%C3%B3n+a+JDBC">Introducci&oacute;n a JDBC</a>
<ul class="minitoc">
<li>
<a href="#Drivers+de+acceso">Drivers de acceso</a>
<ul class="minitoc">
<li>
<a href="#Tipos+de+drivers">Tipos de drivers</a>
</li>
<li>
<a href="#Instalaci%C3%B3n+de+drivers">Instalaci&oacute;n de drivers</a>
</li>
</ul>
</li>
<li>
<a href="#Conexi%C3%B3n+a+la+BD">Conexi&oacute;n a la BD</a>
</li>
</ul>
</li>
<li>
<a href="#Consulta+a+una+base+de+datos+con+JDBC">Consulta a una base de datos con JDBC</a>
<ul class="minitoc">
<li>
<a href="#Creaci%C3%B3n+y+ejecuci%C3%B3n+de+sentencias+SQL">Creaci&oacute;n y ejecuci&oacute;n de sentencias SQL</a>
</li>
<li>
<a href="#Sentencias+de+consulta">Sentencias de consulta</a>
</li>
</ul>
</li>
<li>
<a href="#Restricciones+y+movimientos+en+el">Restricciones y movimientos en el ResultSet</a>
<ul class="minitoc">
<li>
<a href="#Actualizaci%C3%B3n+de+datos">Actualizaci&oacute;n de datos</a>
</li>
</ul>
</li>
<li>
<a href="#Sentencias+de+actualizaci%C3%B3n">Sentencias de actualizaci&oacute;n</a>
</li>
<li>
<a href="#Otras+llamadas+a+la+BD">Otras llamadas a la BD</a>
</li>
<li>
<a href="#Optimizaci%C3%B3n+de+sentencias">Optimizaci&oacute;n de sentencias</a>
<ul class="minitoc">
<li>
<a href="#SQL+injection">SQL injection</a>
</li>
</ul>
</li>
<li>
<a href="#Transacciones">Transacciones</a>
</li>
</ul>
</div>

<a name="N1000C"></a><a name="Introducci%C3%B3n+a+JDBC"></a>
<h2 class="underlined_10">Introducci&oacute;n a JDBC</h2>
<div class="section">
<p>En la mayor&iacute;a de las aplicaciones que nos vamos a encontrar,
aparecer&aacute; una base de datos como fuente de informaci&oacute;n.
JDBC nos va a permitir acceder a bases de datos (BD) desde Java. Con
JDBC no es necesario escribir distintos programas para distintas BD,
sino que un &uacute;nico programa sirve para acceder a BD de distinta
naturaleza. Incluso, podemos acceder a m&aacute;s de una BD de distinta
fuente (Oracle, Access, MySql, etc.) en la misma aplicaci&oacute;n.
Podemos pensar en JDBC como el puente entre una base de datos y nuestro
programa Java. Un ejemplo sencillo puede ser un applet que muestra
din&aacute;micamente informaci&oacute;n contenida en una base de datos.
El applet utilizar&aacute; JDBC para obtener dichos datos.</p>
<p>El esquema a seguir en un programa que use JDBC es el siguiente:
<img alt="Esquema general de conexi&oacute;n con una base de datos" content-width="12cm" src="imagenes/figura1.jpg"></p>
<p>Un programa Java que utilice JDBC primero deber&aacute; establecer
una conexi&oacute;n con el SGBD. Para realizar dicha conexi&oacute;n
haremos uso de un driver espec&iacute;fico para cada SGBD que estemos
utilizando. Una vez establecida la conexi&oacute;n ya podemos
interrogar la BD con cualquier comando SQL (select, update, create,
etc.). El resultado de un comando <em>select</em> es un objeto de la
clase ResultSet, que contiene los datos que devuelve la consulta.
Disponemos de m&eacute;todos en <em>ResultSet </em>para manejar los
datos devueltos. Tambi&eacute;n podemos realizar cualquier
operaci&oacute;n en SQL (creaci&oacute;n de tablas, gesti&oacute;n de
usuarios, etc.).
<img alt="Conexi&oacute;n a trav&eacute;s del API y un driver de JDBC" content-width="12cm" src="imagenes/figura2.jpg"></p>
<p>Para realizar estas operaciones necesitaremos contar con un SGBD
(sistema gestor de bases de datos) adem&aacute;s de un driver
espec&iacute;fico para poder acceder a este SGBD.&nbsp;Vamos a utilizar
dos SGBD: MySQL (disponible para Windows y Linux, de libre
distribuci&oacute;n) y PostGres (s&oacute;lo para Linux, tambi&eacute;n
de libre distribuci&oacute;n).</p>
<a name="N1002C"></a><a name="Drivers+de+acceso"></a>
<h3 class="underlined_5">Drivers de acceso</h3>
<p>Los drivers para poder acceder a cada SGBD no forman parte de la
distribuci&oacute;n de Java por lo que deberemos obtenerlos por
separado. &iquest;Por qu&eacute; hacer uso de un driver?. El
principal problema que se nos puede plantear es que cada SGBD dispone
de su propio API (la mayor&iacute;a propietario), por lo que un cambio
en el SGBD implica una modificaci&oacute;n de nuestro c&oacute;digo. Si
colocamos una capa intermedia, podemos abstraer la conectividad, de tal
forma que nosotros utilizamos un objeto para la conexi&oacute;n, y el
driver se encarga de traducir la llamada al API. El driver lo suelen
distribuir las propias empresas que fabrican el SGBD. </p>
<a name="N10035"></a><a name="Tipos+de+drivers"></a>
<h4>Tipos de drivers</h4>
<p>Existe un est&aacute;ndar establecido que divide los drivers en cuatro
grupos:</p>
<ul>
  
<li>
<strong>Tipo 1: Puente JDBC-ODBC</strong>. ODBC (Open Database Connectivity) fue creado 
    para proporcionar una conexi&oacute;n a bases de datos en Microsoft Windows.
    ODBC permite acceso a bases de datos desde diferentes lenguajes de programaci&oacute;n, 
    tales como C y Cobol. El puente JDBC-ODBC permite enlazar Java con cualquier 
    base de datos disponible en ODBC. No se aconseja el uso de este tipo de driver 
    cuando tengamos que acceder a bases de datos de alto rendimiento, pues las 
    funcionalidades est&aacute;n limitadas a las que marca ODBC. Cada cliente 
    debe tener instalado el driver. J2SE incluye este driver en su versi&oacute;n 
    Windows y Solaris.

    <img alt="Configuraci&oacute;n de un driver de tipo 1" content-width="10cm" src="imagenes/driver1.jpg">
  </li>
  
<li>
<strong>Tipo 2: Parte Java, parte driver nativo</strong>. Es una combinaci&oacute;n 
    de implementaci&oacute;n Java y API nativo para el acceso a la base de datos. 
    Este tipo de driver es m&aacute;s r&aacute;pido que el anterior, pues no se 
    realiza el paso por la capa ODBC. Las llamadas JDBC se traducen en llamadas 
    espec&iacute;ficas del API de la base de datos. Cada cliente debe tener instalado 
    el driver. Tiene menor rendimiento que los dos siguientes y no se pueden usar 
    en Internet, ya que necesita el API de forma local.
    <img alt="Configuraci&oacute;n de un driver de tipo 2" content-width="10cm" src="imagenes/driver2.jpg">
   </li>
  
<li>
<strong>Tipo 3: Servidor intermediario de acceso a base de datos</strong>.
Este tipo de driver
proporciona una abstracci&oacute;n de la conexi&oacute;n. El cliente se
conecta a los SGBD
mediante un componente servidor intermedio, que act&uacute;a como una
puerta para m&uacute;ltiples servidores. La ventaja de este tipo de
driver es el nivel de abstracci&oacute;n. El servidor
de aplicaciones WebLogic incorpora este tipo de driver.
<img alt="Configuraci&oacute;n de un driver de tipo 3" content-width="10cm" src="imagenes/driver3.jpg">
  </li>
  
<li>
<strong>Tipo 4: Drivers Java</strong>. Este es el m&aacute;s directo. La
llamada JDBC se traduce
directamente en una llamada de red a la base de datos, sin
intermediarios. Proporcionan
mejor rendimiento. La mayor&iacute;a de SGBD proporcionan drivers de
este tipo.
<img alt="Configuraci&oacute;n de un driver de tipo 4" content-width="8cm" src="imagenes/driver4.jpg">
</li>

</ul>
<a name="N1006A"></a><a name="Instalaci%C3%B3n+de+drivers"></a>
<h4>Instalaci&oacute;n de drivers</h4>
<p> La distribuci&oacute;n de JDBC incorpora los drivers para el puente JDBC-ODBC 
  que nos permite acceder a cualquier BD que se gestione con ODBC. Para MySQL, 
  deberemos descargar e instalar el SGBD y el driver, que puede ser obtenido en 
  la direcci&oacute;n <a href="http://www.mysql.com/downloads/connector/j/">http://www.mysql.com/downloads/connector/j/</a>. 
  El driver para PostGres se obtiene en <a href="http://jdbc.postgresql.org">http://jdbc.postgresql.org</a>
</p>
<p>Para instalar el driver lo &uacute;nico que deberemos hacer es
incluir el fichero JAR que lo contiene en el CLASSPATH. Por ejemplo,
para MySQL:</p>
<pre class="code">export CLASSPATH=$CLASSPATH:
  <strong>/directorio-donde-este/mysql-connector-java-3.0.15-ga-bin.jar</strong>

</pre>
<p>Con el driver instalado, podremos cargarlo desde nuestra
aplicaci&oacute;n simplemente cargando din&aacute;micamente la clase
correspondiente al driver:</p>
<pre class="code">Class.forName("<strong>com.mysql.jdbc.Driver</strong>");
</pre>
<p>El driver JDBC-ODBC se carga como se muestra a continuaci&oacute;n:</p>
<pre class="code">Class.forName("<strong>sun.jdbc.odbc.JdbcOdbcDriver</strong>");
</pre>
<p>Y de forma similar para PostGres:</p>
<pre class="code">Class.forName("<strong>org.postgresql.Driver</strong>");
</pre>
<p> La carga del driver se deber&iacute;a hacer siempre antes de
conectar con la BD. </p>
<p>Como hemos visto anteriormente, pueden existir distintos tipos de
drivers para la misma base de datos. Por ejemplo, a una BD en MySQL
podemos acceder mediante ODBC o mediante su propio driver.
Podr&iacute;amos pensar que la soluci&oacute;n m&aacute;s sencilla
ser&iacute;a utilizar ODBC para todos las conexiones a SGBD. Sin
embargo, dependiendo de la complejidad de la aplicaci&oacute;n a
desarrollar esto nos podr&iacute;a dar problemas. Determinados SGBD
permiten realizar operaciones (transacciones, mejora de rendimiento,
escabilidad, etc.) que se ven mermadas al realizar su conexi&oacute;n a
trav&eacute;s del driver ODBC. Por ello es preferible hacer uso de
driver espec&iacute;ficos para el SGBD en cuesti&oacute;n. </p>
<p>El ejemplo m&aacute;s claro de problemas en el uso de drivers es con
los <em>Applets</em>. Cuando utilicemos acceso a bases de datos mediante
JDBC desde un <em>Applet</em>, deberemos tener en cuenta que el <em>Applet</em>
se ejecuta en la m&aacute;quina del cliente, por lo que si la BD
est&aacute; alojada en nuestro servidor tendr&aacute; que establecer
una conexi&oacute;n remota. Aqu&iacute; encontramos el problema de que
si el <em>Applet</em> es visible desde Internet, es muy posible que el
puerto en el que escucha el servidor de base de datos puede estar
cortado por alg&uacute;n <em>firewall</em>, por lo que el acceso desde
el exterior no ser&iacute;a posible.</p>
<p>El uso del puente JDBC-ODBC tampoco es recomendable en <em>Applets</em>,
ya que requiere que cada cliente tenga configurada la fuente de datos
ODBC adecuada en su m&aacute;quina. Esto podemos controlarlo en el caso
de una intranet, pero en el caso de Internet ser&aacute; mejor utilizar
otros m&eacute;todos para la conexi&oacute;n.</p>
<p>En cuanto a las excepciones, debemos capturar la excepci&oacute;n <em>SQLException</em>
en casi todas las operaciones en las que se vea involucrado
alg&uacute;n objeto JDBC. </p>
<a name="N100C8"></a><a name="Conexi%C3%B3n+a+la+BD"></a>
<h3 class="underlined_5">Conexi&oacute;n a la BD</h3>
<p>Una vez cargado el driver apropiado para nuestro SGBD deberemos
establecer la conexi&oacute;n con la BD. Para ello utilizaremos el
siguiente m&eacute;todo:</p>
<pre class="brush:java;">Connection con = DriverManager.getConnection(url);
Connection con = DriverManager.getConnection(url, login, password);
</pre>
<p>La conexi&oacute;n a la BD est&aacute; encapsulada en un objeto <span class="codefrag">Connection</span>.
Para su creaci&oacute;n debemos proporcionar la <em> url</em> de la BD
y, si la BD est&aacute; protegida con contrase&ntilde;a, el <em>login</em>
y <em> password</em> para acceder a ella. El formato de la <em> url</em>
variar&aacute; seg&uacute;n el driver que utilicemos. Sin embargo,
todas las <em>url</em> tendr&aacute;n la siguiente forma general: <em>jdbc</em>:&lt;<em>subprotocolo</em>&gt;:&lt;<em>nombre</em>&gt;,
con <em>subprotocolo</em> indicando el tipo de SGBD y con <em>nombre</em>
indicando el nombre de la BD y aportando informaci&oacute;n adicional
para la conexi&oacute;n. </p>
<p>Para conectar a una fuente ODBC de nombre <em>bd</em>, por ejemplo,
utilizaremos la siguiente URL:</p>
<pre class="brush:java;">Connection con = DriverManager.getConnection("jdbc:odbc:bd");
</pre>
<p>En el caso de MySQL, si queremos conectarnos a una BD de nombre <em>bd</em>
alojada en la m&aacute;quina local (<em>localhost</em>) y con usuario <em>miguel</em>
y contrase&ntilde;a <em>m++24</em>, lo haremos de la siguiente forma:</p>
<pre class="brush:java;">Connection con = 
    DriverManager.getConnection("jdbc:mysql://localhost/bd", 
                                "miguel", "m++24");
</pre>
<p>En el caso de PostGres (notar que hemos indicado un puerto de
conexi&oacute;n, el 5432):</p>
<pre class="brush:java;">Connection con = DriverManager.getConnection(
    "jdbc:postgresql://localhost:5432/bd", "miguel", "m++24");
</pre>
<p>Podemos depurar la conexi&oacute;n y determinar qu&eacute; llamadas
est&aacute; realizando JDBC. Para ello haremos uso de un par de
m&eacute;todos que incorpora <span class="codefrag">DriverManager</span>. En el siguiente
ejemplo se indica que las operaciones que realice JDBC se
mostrar&aacute;n por la salida est&aacute;ndar:</p>
<pre class="brush:java;">DriverManager.setLogWriter(new PrintWriter(System.out, true));
</pre>
<p>Una vez realizada esta llamada tambi&eacute;n podemos mostrar
mensajes usando:</p>
<pre class="brush:java;">DriverManager.println("Esto es un mensaje");
</pre>
</div>

<a name="N10136"></a><a name="Consulta+a+una+base+de+datos+con+JDBC"></a>
<h2 class="underlined_10">Consulta a una base de datos con JDBC</h2>
<div class="section">
<a name="N1013C"></a><a name="Creaci%C3%B3n+y+ejecuci%C3%B3n+de+sentencias+SQL"></a>
<h3 class="underlined_5">Creaci&oacute;n y ejecuci&oacute;n de sentencias SQL</h3>
<p>Una vez obtenida la conexi&oacute;n a la BD, podemos utilizarla para
realizar consultas, inserci&oacute;n y/o borrado de datos de dicha BD.
Todas estas operaciones se realizar&aacute;n mediante lenguaje SQL. La
clase <span class="codefrag">Statement</span> es la que permite realizar todas estas
operaciones. La instanciaci&oacute;n de esta clase se realiza haciendo
uso del siguiente m&eacute;todo que proporciona el objeto <span class="codefrag">Connection</span>:</p>
<pre class="brush:java;">Statement stmt = con.createStatement();
</pre>
<p>Podemos dividir las sentencias SQL en dos grupos: las que actualizan
la BD y las que &uacute;nicamente la consultan. En las siguientes
secciones veremos c&oacute;mo podemos realizar estas dos acciones.</p>
<a name="N10154"></a><a name="Sentencias+de+consulta"></a>
<h3 class="underlined_5">Sentencias de consulta</h3>
<p>Para obtener datos almacenados en la BD podemos realizar una
consulta SQL (<em>query</em>). Podemos ejecutar la consulta utilizando el
objeto <span class="codefrag">Statement</span>, pero ahora haciendo uso del m&eacute;todo <span class="codefrag">executeQuery
</span> al que le pasaremos una cadena con la consulta SQL. Los datos
resultantes nos los devolver&aacute; como un objeto <span class="codefrag">ResultSet</span>.</p>
<pre class="brush:java;">ResultSet result = stmt.executeQuery(query);
</pre>
<p>La consulta SQL nos devolver&aacute; una tabla, que tendr&aacute;
una serie de campos y un conjunto de registros, cada uno de los cuales
consistir&aacute; en una tupla de valores correspondientes a los campos
de la tabla.&nbsp; </p>
<p> Los campos que tenga la tabla resultante depender&aacute;n de la
consulta que hagamos, de los datos que solicitemos que nos devuelva.
Por ejemplo, podemos solicitar que una consulta nos devuelva los campos
<em>expediente </em>y <em>nombre</em> de los alumnos o bien que nos
devuelva todos los campos de la tabla <em>alumnos</em>. </p>
<p>Veamos el funcionamiento de las consultas SQL mediante un ejemplo:</p>
<pre class="code">String query = "SELECT * FROM ALUMNOS WHERE sexo = 'M'";
ResultSet result = stmt.executeQuery(query);
</pre>
<p>En esta consulta estamos solicitando todos los registros de la tabla
ALUMNOS
en los que el sexo sea <em>mujer </em>(M), pidiendo que nos devuelva
todos los
campos (indicado con *) de dicha tabla. Nos devolver&aacute; una tabla
como la
siguiente:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">exp</span></td>
      <td colspan="1" rowspan="1"><span class="codefrag">nombre</span></td>
      <td colspan="1" rowspan="1"><span class="codefrag">sexo</span></td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1">1286</td>
      <td colspan="1" rowspan="1">Amparo</td>
      <td colspan="1" rowspan="1">M</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1">1287</td>
      <td colspan="1" rowspan="1">Manuela</td>
      <td colspan="1" rowspan="1">M</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1">1288</td>
      <td colspan="1" rowspan="1">Lucrecia</td>
      <td colspan="1" rowspan="1">M</td>
    
</tr>

</table>
<p>Estos datos nos los devolver&aacute; como un objeto <span class="codefrag">ResultSet</span>.
A continuaci&oacute;n veremos c&oacute;mo podemos acceder a los valores
de este objeto y c&oacute;mo podemos movernos por los distintos
registros.</p>
<p>El objeto <span class="codefrag">ResultSet </span>dispone de un <em>cursor</em> que
estar&aacute; situado en el registro que podemos consultar en cada
momento. Este <em>cursor</em> en un principio estar&aacute; situado en
una posici&oacute;n anterior al primer registro de la tabla. Podemos
mover el cursor al siguiente registro con el m&eacute;todo <span class="codefrag">next</span>
del <span class="codefrag">ResultSet</span>. La llamada a este m&eacute;todo nos
devolver&aacute; <span class="codefrag">true</span> mientras pueda pasar al siguiente
registro, y <span class="codefrag">false </span>en el caso de que ya estuvi&eacute;ramos en
el &uacute;ltimo registro de la tabla. Para la consulta de todos los
registros obtenidos utilizaremos normalmente un bucle como el siguiente:</p>
<pre class="brush:java;">while(result.next()) {
      // Leer registro
}
</pre>
<p>Ahora necesitamos obtener los datos del registro que marca el <em>cursor</em>,
para lo cual podremos acceder a los campos de dicho registro. Esto lo
haremos utilizando los m&eacute;todos <span class="codefrag">getXXXX(campo)</span> donde <span class="codefrag">XXXX</span>
ser&aacute; el tipo de datos de Java en el que queremos que nos
devuelva el valor del campo. Hemos de tener en cuenta que el tipo del
campo en la tabla debe ser convertible al tipo de datos Java
solicitado. Para especificar el campo que queremos leer podremos
utilizar bien su nombre en forma de cadena, o bien su &iacute;ndice que
depender&aacute; de la ordenaci&oacute;n de los campos que devuelve la
consulta. Tambi&eacute;n debemos tener en cuenta que no podemos acceder
al mismo campo dos veces seguidas en el mismo registro. Si lo hacemos
nos dar&aacute; una excepci&oacute;n.</p>
<p>Los tipos principales que podemos obtener son los siguientes:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">getInt</span></td>
      <td colspan="1" rowspan="1">Datos enteros</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">getDouble</span></td>
      <td colspan="1" rowspan="1">Datos reales</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">getBoolean</span></td>
      <td colspan="1" rowspan="1">Campos booleanos (si/no)</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">getString</span></td>
      <td colspan="1" rowspan="1">Campos de texto</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">getDate</span></td>
      <td colspan="1" rowspan="1">Tipo fecha (Devuelve <span class="codefrag">Date</span>)</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">getTime</span>
      </td>
      <td colspan="1" rowspan="1">Tipo hora (Devuelve<span class="codefrag"> Time</span>)
      </td>
    
</tr>

</table>
<p>Si queremos imprimir todos los datos obtenidos de nuestra tabla
ALUMNOS del ejemplo podremos hacer lo siguiente:</p>
<pre class="brush:java;">int exp;
String nombre;
String sexo;

while(result.next()){
    exp = result.getInt("exp");
    nombre = result.getString("nombre");
    sexo = result.getString("sexo");
    System.out.println(exp + "\t" + nombre + "\t" + sexo);
}
</pre>
<p>Cuando un campo de un registro de una tabla no tiene asignado
ning&uacute;n valor, la consulta de ese valor devuelve NULL. Esta
situaci&oacute;n puede dar problemas al intentar manejar ese dato. La
clase <span class="codefrag">ResultSet</span> dispone de un m&eacute;todo <span class="codefrag">wasNull</span> que
llamado despu&eacute;s de acceder a un registro nos dice si el valor
devuelto fue NULL. Esto no sucede as&iacute; para los datos
num&eacute;ricos, ya que devuelve el valor 0. Comprobemos qu&eacute;
sucede en el siguiente c&oacute;digo:</p>
<pre class="brush:java;">String sexo;

while(result.next()){
    exp = result.getInt("exp");
    nombre = result.getString("nombre");
    sexo = result.getString("sexo");
    System.out.println(exp + "\t" + nombre.trim() + "\t" + sexo);
}
</pre>
<p>La llamada al m&eacute;todo <span class="codefrag">trim</span> devolver&aacute; una
excepci&oacute;n si el objeto <span class="codefrag">nombre</span> es NULL. Por ello podemos
realizar la siguiente modificaci&oacute;n: </p>
<pre class="brush:java;">String sexo;

while(result.next()){
    exp = result.getInt("exp");
    System.out.print(exp + "\t");
    nombre = result.getString("nombre");	
    if (result.wasNull()) {
        System.out.print("Sin nombre asignado");
    else
        System.out.print(nombre.trim());
    sexo = result.getString("sexo");
    System.out.println("\t" + sexo);
}
</pre>
</div>

<a name="N1028E"></a><a name="Restricciones+y+movimientos+en+el"></a>
<h2 class="underlined_10">Restricciones y movimientos en el ResultSet</h2>
<div class="section">
<p>Cuando realizamos llamadas a BD de gran tama&ntilde;o el resultado
de la consulta puede ser demasiado grande y no deseable en
t&eacute;rminos de eficiencia y memoria. JDBC permite restringir el
n&uacute;mero de filas que se devolver&aacute;n en el <span class="codefrag">ResultSet</span>.
La clase <span class="codefrag">Statement</span> incorpora dos m&eacute;todos, <span class="codefrag">getMaxRows</span>
y <span class="codefrag">setMaxRows</span>, que permiten obtener e imponer dicha
restricci&oacute;n. Por defecto, el l&iacute;mite es cero, indicando
que no se impone la restricci&oacute;n. Si, por ejemplo, antes de
ejecutar la consulta imponemos un l&iacute;mite de 30 usando el
m&eacute;todo <span class="codefrag">setMaxRows(30)</span>, el resultado devuelto s&oacute;lo
contendr&aacute; las 30 primeras filas que cumplan con los criterios de
la consulta.</p>
<p>Hasta ahora, el manejo de los datos devueltos en una consulta se
realizaba con el m&eacute;todo <span class="codefrag">next</span> de <span class="codefrag">ResultSet</span>.
Podemos manejar otros m&eacute;todos para realizar un movimiento no
lineal por el <span class="codefrag">ResultSet</span>. Es lo que se conoce como <span class="codefrag">ResultSet</span>
arrastable. Para que esto sea posible debemos utilizar el siguiente
m&eacute;todo en la creaci&oacute;n del <span class="codefrag">Statement</span>:</p>
<pre class="brush:java;">Statement createStatement (int resultSetType, 
                                   int resultSetConcurrency)
</pre>
<p>Los posibles valores que puede tener <span class="codefrag">resultSetType</span> son: <span class="codefrag">ResultSet.TYPE_FORWARD_ONLY</span>,
<span class="codefrag">ResultSet.TYPE_SCROLL_INSENSITIVE</span>, <span class="codefrag">ResultSet.TYPE_SCROLL_SENSITIVE</span>.
El primer valor es el funcionamiento por defecto: el <span class="codefrag">ResultSet</span>
s&oacute;lo se mueve hacia adelante. Los dos siguientes permiten que el
resultado sea arrastable. Una caracter&iacute;stica importante en los
resultados arrastables es que los cambios que se produzcan en la BD se
reflejan en el resultado, aunque dichos cambios se hayan producido
despu&eacute;s de la consulta. <em>Esto depender&aacute; de si el
driver y/o la BD soporta este tipo de comportamiento</em>. En el caso de
<span class="codefrag">INSENSITIVE</span>, el resultado no es sensible a dichos cambios y en
el caso de <span class="codefrag">SENSITIVE</span>, s&iacute;. Los
m&eacute;todos que podemos
utilizar para movernos por el <span class="codefrag">ResultSet</span> son:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">next</span></td>
      <td colspan="1" rowspan="1">Pasa a la siguiente fila</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">previous</span></td>
      <td colspan="1" rowspan="1">&Iacute;dem fila anterior</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">last</span></td>
      <td colspan="1" rowspan="1">&Iacute;dem &uacute;ltima fila</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">first</span></td>
      <td colspan="1" rowspan="1">&Iacute;dem primera fila</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">absolute(int fila)</span></td>
      <td colspan="1" rowspan="1">Pasa a la fila n&uacute;mero fila</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">relative(int fila)</span></td>
      <td colspan="1" rowspan="1">Pasa a la fila n&uacute;mero fila desde la actual</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">getRow</span></td>
      <td colspan="1" rowspan="1">Devuelve la n&uacute;mero de fila actual</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">isLast</span></td>
      <td colspan="1" rowspan="1">Devuelve si la fila actual es la &uacute;ltima</td>
    
</tr>
    
<tr>
      
<td colspan="1" rowspan="1"><span class="codefrag">isFirst</span></td>
      <td colspan="1" rowspan="1">&Iacute;dem la primera</td>
    
</tr>

</table>
<p>El otro par&aacute;metro, <span class="codefrag">resultSetConcurrency</span>, puede ser
uno de estos dos valores: <span class="codefrag">ResultSet.CONCUR_READ_ONLY</span> y <span class="codefrag">ResultSet.CONCUR_UPDATABLE</span>.
El primero es el utilizado por defecto y no permite actualizar el
resultado. El segundo permite que los cambios realizados en el <span class="codefrag">ResultSet</span>
se actualicen en la base de datos. Si queremos modificar los datos
obtenidos en una consulta y queremos reflejar esos cambios en la BD
debemos crear una sentencia con <span class="codefrag">TYPE_FORWARD_SENSITIVE</span>
y <span class="codefrag">CONCUR_UPDATABLE</span>.</p>
<a name="N10373"></a><a name="Actualizaci%C3%B3n+de+datos"></a>
<h3 class="underlined_5">Actualizaci&oacute;n de datos</h3>
<p>Para actualizar un campo disponemos de m&eacute;todos <span class="codefrag">updateXXXX</span>,
de la misma forma que ten&iacute;amos m&eacute;todos <span class="codefrag">getXXXX</span>.
Estos m&eacute;todos reciben dos par&aacute;metros: el primero indica
el nombre del campo (o n&uacute;mero de orden dentro del <span class="codefrag">ResultSet</span>);
el segundo indica el nuevo valor que tomar&aacute; el campo del
registro actual. Para que los cambios tengan efecto en la BD debemos
llamar al m&eacute;todo <span class="codefrag">updateRow</span>. El siguiente c&oacute;digo
es un ejemplo de modificaci&oacute;n de datos:</p>
<pre class="brush:java;">rs.updateString("nombre","manolito");
rs.updateRow();
</pre>
<p>Si queremos desechar los cambios producidos en la fila actual (antes
de llamar a <span class="codefrag">updateRow</span>) podemos llamar a <span class="codefrag">cancelRowUpdates</span>.
Para borrar la fila actual tenemos el m&eacute;todo <span class="codefrag">deleteRow</span>.
La llamada a este m&eacute;todo deja una fila vac&iacute;a en el <span class="codefrag">ResultSet</span>.
Si intentamos acceder a los datos de esa fila nos dar&aacute; una
excepci&oacute;n. Podemos llamar al m&eacute;todo <span class="codefrag">rowDeleted</span> el
cual devuelve cierto si la fila actual ha sido eliminada (m&eacute;todo
no implementado en MySQL).</p>
<p>Debemos tener en cuenta varias restricciones a la hora de actualizar
un <span class="codefrag">ResultSet</span>: la sentencia SELECT que ha generado el <span class="codefrag">ResultSet</span>
debe:</p>
<ul>
  
<li>Referenciar s&oacute;lo una tabla.</li>
  
<li>No contener una cla&uacute;sula <em>join</em> o <em>group by</em>.</li>
  
<li>Seleccionar la clave primaria de la tabla.</li>

</ul>
<p>Existe un registro especial al que no se puede acceder como hemos
visto anteriormente, que es el registro de inserci&oacute;n. Este
registro se utiliza para insertar nuevos registros en la tabla. Para
situarnos en &eacute;l deberemos llamar al m&eacute;todo <span class="codefrag">moveToInsertRow</span>.
Una vez situados en &eacute;l deberemos asignar los datos con los
m&eacute;todos <span class="codefrag">updateXXXX</span> anteriormente descritos y una vez
hecho esto llamar a <span class="codefrag">insertRow </span>para que el registro se inserte
en la BD. Podemos volver al registro donde nos encontr&aacute;bamos
antes de movernos al registro de inserci&oacute;n llamando a <span class="codefrag">moveToCurrentRow</span>.</p>
</div>

<a name="N103CB"></a><a name="Sentencias+de+actualizaci%C3%B3n"></a>
<h2 class="underlined_10">Sentencias de actualizaci&oacute;n</h2>
<div class="section">
<p>La clase <span class="codefrag">Statement</span> dispone de un m&eacute;todo llamado <span class="codefrag">executeUpdate</span>
el cual recibe como par&aacute;metro la cadena de caracteres que
contiene la sentencia SQL a ejecutar. Este m&eacute;todo
&uacute;nicamente permite realizar sentencias de actualizaci&oacute;n
de la BD: creaci&oacute;n de tablas (CREATE), inserci&oacute;n
(INSERT), actualizaci&oacute;n (UPDATE) y borrado de datos (DELETE). El
m&eacute;todo a utilizar es el
siguiente:</p>
<pre class="brush:java;">stmt.executeUpdate(sentencia);
</pre>
<p>Vamos a ver a continuaci&oacute;n un ejemplo de estas operaciones.
Crearemos una tabla ALUMNOS en nuestra base de datos y
a&ntilde;adiremos datos a la misma. La sentencia para la
creaci&oacute;n de la tabla ser&aacute; la siguiente:</p>
<pre class="brush:java;">String st_crea = "CREATE TABLE ALUMNOS (
    exp INTEGER,
    nombre VARCHAR(32),
    sexo CHAR(1),
    PRIMARY KEY (exp)
)";
stmt.executeUpdate(st_crea);
</pre>
<p>Una vez creada la tabla podremos insertar datos en ella como se
muestra a continuaci&oacute;n:</p>
<pre class="brush:java;">String st_inserta = "INSERT INTO ALUMNOS(exp, nombre) 
    VALUES(1285, 'Manu', 'M')";
stmt.executeUpdate(st_inserta);
</pre>
<p>Cuando tengamos datos dentro de la tabla, podremos modificarlos
utilizando para ello una sentencia UPDATE:</p>
<pre class="brush:java;">String st_actualiza = "UPDATE FROM ALUMNOS 
    SET sexo = 'H' WHERE exp = 1285";
stmt.executeUpdate(st_actualiza);
</pre>
<p>Si queremos eliminar un registro de la tabla utilizaremos una
sentencia DELETE como se muestra a continuaci&oacute;n:</p>
<pre class="brush:java;">String st_borra = "DELETE FROM ALUMNOS
    WHERE exp = 1285";
stmt.executeUpdate(st_borra);
</pre>
<p>El m&eacute;todo <span class="codefrag">executeUpdate </span>nos devuelve un entero que
nos dice el n&uacute;mero de registros a los que ha afectado la
operaci&oacute;n, en caso de sentencias INSERT, UPDATE y DELETE. La
creaci&oacute;n de tablas nos devuelve siempre 0.</p>
</div>


<a name="N10406"></a><a name="Otras+llamadas+a+la+BD"></a>
<h2 class="underlined_10">Otras llamadas a la BD</h2>
<div class="section">
<p>En la interfaz <span class="codefrag">Statement</span> podemos observar un tercer
m&eacute;todo que podemos utilizar para la ejecuci&oacute;n de
sentencias SQL. Hasta ahora hemos visto como para la ejecuci&oacute;n
de sentencias que devuelven datos (consultas) debemos usar <span class="codefrag">executeQuery</span>,
mientras que para las sentencias INSERT, DELETE, UPDATE e instrucciones
DDL utilizamos <span class="codefrag">executeUpdate</span>. Sin embargo, puede haber
ocasiones en las que no conozcamos de antemano el tipo de la sentencia
que vamos a utilizar (por ejemplo si la sentencia la introduce el
usuario). En este caso podemos usar el m&eacute;todo <span class="codefrag">execute</span>.</p>
<pre class="brush:java;">boolean hay_result = stmt.execute(sentencia);
</pre>
<p>Podemos ver que el m&eacute;todo devuelve un valor <em>booleano</em>.
Este valor ser&aacute; <em>true</em> si la sentencia ha devuelto
resultados (uno o varios objetos <span class="codefrag">ResultSet</span>), y <em>false</em> en
el caso de que s&oacute;lo haya devuelto el n&uacute;mero de registros
afectados. Tras haber ejecutado la sentencia con el m&eacute;todo
anterior, para obtener estos datos devueltos proporciona una serie de
m&eacute;todos:</p>
<pre class="brush:java;">int n = stmt.getUpdateCount();
</pre>
<p>El m&eacute;todo <span class="codefrag">getUpdateCount</span> nos devuelve el
n&uacute;mero de registros a los que afecta la actualizaci&oacute;n,
inserci&oacute;n o borrado, al igual que el resultado que
devolv&iacute;a <span class="codefrag">executeUpdate</span>.</p>
<pre class="brush:java;">ResultSet rs = stmt.getResultSet();
</pre>
<p>El m&eacute;todo <span class="codefrag">getResultSet</span> nos devolver&aacute; el objeto
<span class="codefrag">ResultSet</span> que haya devuelto en el caso de ser una consulta, al
igual que hac&iacute;a <span class="codefrag">executeQuery</span>. Sin embargo, de esta forma
nos permitir&aacute; adem&aacute;s tener m&uacute;ltiples objetos <span class="codefrag">ResultSet</span>
como resultado de una llamada. Eso puede ser necesario, por ejemplo, en
el caso de una llamada a un procedimiento, que nos puede devolver
varios resultados como veremos m&aacute;s adelante. Para movernos al
siguiente <span class="codefrag">ResultSet</span> utilizaremos el siguiente m&eacute;todo:</p>
<pre class="brush:java;">boolean hay_mas_results = stmt.getMoreResults();
</pre>
<p>La llamada a este m&eacute;todo nos mover&aacute; al siguiente <span class="codefrag">ResultSet</span>
devuelto, devolvi&eacute;ndonos <em>true</em> en el caso de que exista,
y <em>false</em> en el caso de que no haya m&aacute;s resultados. Si
existe, una vez nos hayamos movido podremos consultar el nuevo <span class="codefrag">ResultSet</span>
llamando nuevamente al m&eacute;todo <span class="codefrag">getResultSet</span>.</p>
<p>Otra llamada disponible es el m&eacute;todo <span class="codefrag">executeBatch</span>.
Este m&eacute;todo nos permite enviar varias sentencias SQL a la vez.
No puede contener sentencias SELECT. Devuelve un array de enteros que
indicar&aacute; el n&uacute;mero de registros afectados por las
sentencias SQL. Para a&ntilde;adir sentencias haremos uso del
m&eacute;todo <span class="codefrag">addBatch</span>. Un ejemplo de ejecuci&oacute;n es el
siguiente: </p>
<pre class="brush:java;">stmt.addBatch("INSERT INTO ALUMNOS(exp, nombre) 
    VALUES(1285, 'Manu', 'M')");
stmt.addBatch("INSERT INTO ALUMNOS(exp, nombre) 
    VALUES(1299, 'Miguel', 'M')");

int[] res = stmt.executeBatch();
</pre>
<p>Por &uacute;ltimo, vamos a comentar el m&eacute;todo <span class="codefrag">getGeneratedKeys</span>, tambi&eacute;n
del objeto <span class="codefrag">Statement</span>. En muchas ocasiones hacemos inserciones
en tablas cuyo identificador es un autonum&eacute;rico. Por lo tanto, este valor
no lo especificaremos nosotros manualmente, sino que se asignar&aacute; de forma
autom&aacute;tica en la inserci&oacute;n. Sin embargo, muchas veces nos puede interesar
conocer cual ha sido dicho identificador, para as&iacute; por ejemplo poder
insertar a continuaci&oacute;n un registro de otra tabla que haga referencia al primero. 
Esto lo podremos hacer con el m&eacute;todo <span class="codefrag">getGeneratedKeys</span>, que
nos devuelve un <span class="codefrag">ResultSet</span> que contiene la clave generada:</p>
<pre class="brush:java;">ResultSet res = sentSQL.getGeneratedKeys();
int id = -1;
if(res.next()) {
    id = res.getInt(1);
}</pre>
</div>


<a name="N1048E"></a><a name="Optimizaci%C3%B3n+de+sentencias"></a>
<h2 class="underlined_10">Optimizaci&oacute;n de sentencias</h2>
<div class="section">
<p>Cuando ejecutamos una sentencia SQL, esta se compila y se manda al
SGBD. Si la vamos a invocar repetidas veces, puede ser conveniente
dejar esa sentencia preparada (precompilada) para que pueda ser
ejecutada de forma m&aacute;s eficiente. Para hacer esto utilizaremos
la interfaz <span class="codefrag">PreparedStatement</span>, que podr&aacute; obtenerse a
partir de la conexi&oacute;n a la BD de la siguiente forma:</p>
<pre class="brush:java;">
PreparedStatement ps = con.prepareStatement("UPDATE FROM alumnos
    SET sexo = 'H' WHERE exp&gt;1200 AND exp&lt;1300");
</pre>
<p>Vemos que a este objeto, a diferencia del objeto <span class="codefrag">Statement</span>
visto anteriormente, le proporcionamos la sentencia SQL en el momento
de su creaci&oacute;n, por lo que estar&aacute; preparado y optimizado
para la ejecuci&oacute;n de dicha sentencia posteriormente.</p>
<p>Sin embargo, lo m&aacute;s com&uacute;n es que necesitemos hacer
variaciones sobre la sentencia, ya que normalmente no ser&aacute;
necesario ejecutar repetidas veces la misma sentencia exactamente, sino
variaciones de ella. Por ello, este objeto nos permite parametrizar la
sentencia. Estableceremos las posiciones de los par&aacute;metros con
el car&aacute;cter '?' dentro de la cadena de la sentencia, tal como se
muestra a continuaci&oacute;n:</p>
<pre class="brush:java;">
PreparedStatement ps = con.prepareStatement("UPDATE FROM alumnos
    SET sexo = 'H' WHERE exp &gt; ? AND exp &lt; ?");
</pre>
<p>En este caso tenemos dos par&aacute;metros, que ser&aacute; el
n&uacute;mero de expediente m&iacute;nimo y el m&aacute;ximo del rango
que queremos actualizar. Cuando ejecutemos esta sentencia, el sexo de
los alumnos desde expediente inferior hasta expediente superior se
establecer&aacute; a 'H'.</p>
<p>Para dar valor a estos par&aacute;metros utilizaremos los
m&eacute;todos <span class="codefrag">setXXX</span> donde <span class="codefrag">XXX</span> ser&aacute; el tipo de
los datos que asignamos al par&aacute;metro (recordad los
m&eacute;todos del <span class="codefrag">ResultSet</span>), indicando el n&uacute;mero del
par&aacute;metro (que empieza desde 1) y el valor que le queremos dar.
Por ejemplo, para asignar valores enteros a los par&aacute;metros de
nuestro ejemplo haremos:</p>
<pre class="brush:java;">
ps.setInt(1,1200);
ps.setInt(2,1300);
</pre>
<p>Una vez asignados los par&aacute;metros, podremos ejecutar la
sentencia llamando al m&eacute;todo <span class="codefrag">executeUpdate</span> (ahora sin
par&aacute;metros) del objeto <span class="codefrag">PreparedStatement</span>:</p>
<pre class="brush:java;">
int n = ps.executeUpdate();
</pre>
<p>Igual que en el caso de los objetos <span class="codefrag">Statement</span>, podremos
utilizar cualquier otro de los m&eacute;todos para la ejecuci&oacute;n
de sentencias, <span class="codefrag">executeQuery</span> o <span class="codefrag">execute</span>, seg&uacute;n el
tipo de sentencia que vayamos a ejecutar.</p>
<p>Una caracter&iacute;stica importante es que los par&aacute;metros
s&oacute;lo sirven para datos, es decir, no podemos sustituir el nombre
de la tabla o de una columna por el signo '?'. Otra cosa a tener en
cuenta es que una vez asignados los par&aacute;metros, estos no
desaparecen, sino que se mantienen hasta que se vuelvan a asignar o se
ejecute una llamada al m&eacute;todo <span class="codefrag">clearParameters</span>.</p>
<a name="N104E1"></a><a name="SQL+injection"></a>
<h3 class="underlined_5">SQL injection</h3>
<p>Un problema de seguridad en la base de datos que se nos puede plantear es el SQL injection. 
Se trata de insertar c&oacute;digo SQL dentro de otro c&oacute;digo SQL, para alterar su funcionamiento y conseguir que se 
ejecute alguna sentencia maliciosa. Imaginad que tenemos el siguiente c&oacute;digo en una p&aacute;gina .jsp o en una clase Java:</p>
<pre class="brush:java;">
String s="SELECT * FROM usuarios WHERE nombre='"+nombre+"';";
</pre>
<p>La variable <span class="codefrag">nombre</span> es una cadena cuyo valor viene de un campo que es introducido por el usuario. 
Al introducir el usuario un nombre cualquiera, el c&oacute;digo SQL se ejecuta y nada extra&ntilde;o pasa. Pero esta opci&oacute;n nos
permite a&ntilde;adir c&oacute;digo propio que nos permita da&ntilde;ar o incluso permitirnos tomar el control de la BD. Imaginad que el
usuario ha introducido el siguiente c&oacute;digo: <span class="codefrag">Miguel'; drop table usuarios; select * from usuarios; grant all
privileges ...</span>. Entonces el c&oacute;digo que se ejecutar&iacute;a ser&iacute;a:
</p>
<pre class="code">
SELECT * FROM usuarios WHERE nombre='Miguel'; drop table usuarios; 
select * from usuarios; grant all privileges ...
</pre>
<p>
Para evitar la inyecci&oacute;n de SQL se recurre, en Java, a usar una sentencia preparada. De esta manera tendr&iacute;amos:
</p>
<pre class="brush:java;">PreparedStatement ps = con.prepareStatement(
                  "SELECT * FROM usuarios WHERE nombre=?");
ps.setString(nombre);
</pre>
<p>Y la sentencia SQL que se ejecutar&iacute;a, con la misma entrada que antes, es:</p>
<pre class="code">SELECT * FROM usuarios WHERE nombre="Miguel'; drop table usuarios; 
select * from usuarios; grant all privileges ...";
</pre>
</div>

<a name="N1050D"></a><a name="Transacciones"></a>
<h2 class="underlined_10">Transacciones</h2>
<div class="section">
<p>Muchas veces, cuando tengamos que realizar una serie de acciones,
queremos que todas se hayan realizado correctamente, o bien que no se
realice ninguna de ellas, pero no que se realicen algunas y otras no.</p>
<p>Podemos ver esto mediante un ejemplo, en el que se va a hacer una
reserva de vuelos para ir desde Alicante a Osaka. Para hacer esto
tendremos que hacer trasbordo en dos aeropuertos, por lo que tenemos
que reservar un vuelo Alicante-Madrid, un vuelo Madrid-Amsterdam y un
vuelo Amsterdam-Osaka. Si cualquiera de estos tres vuelos estuviese
lleno y no pudi&eacute;semos reservar, no queremos reservar ninguno de
los otros dos porque no nos servir&iacute;a de nada. Por lo tanto,
s&oacute;lo nos interesa que la reserva se lleve a cabo si podemos
reservar los tres vuelos.</p>
<p>Una transacci&oacute;n es un conjunto de sentencias que deben ser
ejecutadas como una unidad, de forma que si una de ellas no puede
realizarse, no se llevar&aacute; a cabo ninguna. Dicho de otra manera,
las transacciones hacen que la BD pase de un estado consistente al
siguiente. </p>
<p>Pero para hacer esto encontramos un problema. Pensemos en nuestro
ejemplo de la reserva de vuelos, en la que necesitaremos realizar las
siguientes inserciones (reservas):</p>
<pre class="brush:java;">try {
    stmt.executeUpdate("INSERT INTO RESERVAS(pasajero, origen, " +
        + "destino) VALUES('Paquito', 'Alicante', 'Madrid')");
    stmt.executeUpdate("INSERT INTO RESERVAS(pasajero, origen, " + 
        + "destino) VALUES('Paquito', 'Madrid', 'Amsterdam')");
    stmt.executeUpdate("INSERT INTO RESERVAS(pasajero, origen, " + 
        + "destino) VALUES('Paquito', 'Amsterdam', 'Osaka')");
} 
catch(SQLException e) {
    // &iquest;D&oacute;nde ha fallado? &iquest;Qu&eacute; hacemos ahora?
}
</pre>
<p>En este caso, vemos que si falla la reserva de uno de los tres
vuelos obtendremos una excepci&oacute;n, pero en ese caso,
&iquest;c&oacute;mo podremos saber d&oacute;nde se ha producido el
fallo y hasta qu&eacute; acci&oacute;n debemos deshacer? Con la
excepci&oacute;n lo &uacute;nico que sabemos es que algo ha fallado,
pero no sabremos d&oacute;nde ha sido, por lo que de esta forma no
podremos saber hasta qu&eacute; acci&oacute;n debemos deshacer.</p>
<p>Para hacer esto de una forma limpia asegurando la consistencia de
los datos, utilizaremos las operaciones de <em>commit</em> y <em>rollback</em>.</p>
<p>Cuando realicemos cambios en la base de datos, estos cambios se
har&aacute;n efectivos en ella de forma persistente cuando realicemos
la operaci&oacute;n <em>commit</em>. En el modo de operaci&oacute;n que
hemos visto hasta ahora, por defecto tenemos activado el modo <em>auto-commit</em>,
de forma que siempre que ejecutamos alguna sentencia se realiza <em>commit</em>
autom&aacute;ticamente. Sin embargo, en el caso de las transacciones
con m&uacute;ltiples sentencias, no nos interesar&aacute; hacer estos
cambios persistentes hasta haber comprobado que todos los cambios se
pueden hacer de forma correcta. Para ello desactivaremos este modo con:</p>
<pre class="brush:java;">con.setAutoCommit(false); 
</pre>
<p>Al desactivar este modo, una vez hayamos hecho las modificaciones de
forma correcta, deberemos hacerlas persistentes mediante la
operaci&oacute;n <em>commit</em> llamando de forma expl&iacute;cita a:</p>
<pre class="brush:java;">con.commit();
</pre>
<p>Si por el contrario hemos obtenido alg&uacute;n error, no queremos
que esas modificaciones se lleven a cabo finalmente en la BD, por lo
que podremos deshacerlas llamando a:</p>
<pre class="brush:java;">con.rollback();
</pre>
<p>Por lo tanto, la operaci&oacute;n <em>rollback</em> deshar&aacute;
todos los cambios que hayamos realizado para los que todav&iacute;a no
hubi&eacute;semos hecho <em>commit</em> para hacerlos persistentes,
permiti&eacute;ndonos de esta forma implementar estas transacciones de
forma at&oacute;mica.</p>
<p>Nuestro ejemplo de la reserva de vuelos deber&iacute;a hacerse de la
siguiente forma:</p>
<pre class="brush:java;">try {
    con.setAutoCommit(false);
    stmt.executeUpdate("INSERT INTO RESERVAS(pasajero, origen, " +
           + "destino) VALUES('Paquito', 'Alicante', 'Madrid')");
    stmt.executeUpdate("INSERT INTO RESERVAS(pasajero, origen, " +  
           + "destino) VALUES('Paquito', 'Madrid', 'Amsterdam')");
    stmt.executeUpdate("INSERT INTO RESERVAS(pasajero, origen, " +
           + "destino) VALUES('Paquito', 'Amsterdam', 'Osaka')");
    // Hemos podido reservar los tres vuelos correctamente
    con.commit();
} 
catch(SQLException e) {
    // Alguno de los tres ha fallado, deshacemos los cambios
    try {
        con.rollback();
    }
    catch(SQLException e) {};
}
</pre>
<p>Una caracter&iacute;stica relacionada con las transacciones es la
concurrencia en el acceso a la BD. Dicho de otra forma, qu&eacute;
sucede cuando varios usuarios se encuentran accediendo a la vez a los
mismos datos y pretenden modificarlos. Un ejemplo sencillo: tenemos una
tienda y dos usuarios est&aacute;n accediendo al mismo disco, del cual
s&oacute;lo queda una unidad. El primero de los usuarios consulta el
disponible, comprueba que existe una unidad y lo introduce en su cesta
de la compra. El otro usuario en ese preciso momento tambi&eacute;n
est&aacute; consultando el disponible, tambi&eacute;n le aparece una
unidad y tambi&eacute;n intenta introducirlo en su cesta de la compra.
Al segundo usuario el sistema no deber&iacute;a dejarle actualizar los
datos que est&aacute; manejando el primero.</p>
<p> La concurrencia es manejada por los distintos SGBD de manera
distinta. Para saber el nivel aislamiento entre diferentes accesos 
podemos utilizar el siguiente
m&eacute;todo de la clase <span class="codefrag">Connection:</span> 
</p>
<pre class="brush:java;">int con.getTransactionIsolation();
</pre>
<p>Este m&eacute;todo devolver&aacute; Connection.<span class="codefrag">TRANSACTION_NONE</span> si 
el SGBD no soporta transacciones. En caso de que si que las soporte, nos 
dir&aacute; el nivel de aislamiento, pudiendo ser &eacute;ste (ordenado de menor a mayor
aislamiento) Connection.<span class="codefrag">TRANSACTION_READ_UNCOMMITTED</span>, 
Connection.<span class="codefrag">TRANSACTION_READ_COMMITTED</span>, 
Connection.<span class="codefrag">TRANSACTION_REPETEABLE_READ</span>,
Connection.<span class="codefrag">TRANSACTION_SERIALIZABLE</span>.</p>
<p>Cuanto mayor sea el nivel de aislamiento m&aacute;s posibles casos de 
concurrencia se estar&aacute;n teniendo en cuenta y por lo tanto menos
problemas podr&aacute;n ocurrir, pero esto tambi&eacute;n producir&aacute; un mayor n&uacute;mero
de bloqueos en los accesos y por lo tanto una menor eficiencia. Un posible 
problema en las transacciones  es el interbloqueo. Un interbloqueo se 
produce en la siguiente situaci&oacute;n: una aplicaci&oacute;n tiene 
que modificar dos registros. Otra aplicaci&oacute;n modifica los mismos, 
pero en orden inverso. Se empiezan a ejecutar las dos aplicaciones a la vez 
y al haber modificado un registro no dejan que la otra lo modifique. Sin 
embargo, ninguna de las dos terminan porque est&aacute;n esperando que se 
desbloquee su registro. En caso de que esto ocurra, el SGBD deber&iacute;a detectar
la situaci&oacute;n y lanzar una excepci&oacute;n.
</p>
</div>




<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
