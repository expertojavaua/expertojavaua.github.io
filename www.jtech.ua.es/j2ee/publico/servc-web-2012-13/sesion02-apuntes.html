<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Creaci&oacute;n de Servicios Web SOAP</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servicios Web y SOA" src="images/baner_j2ee_der.gif" title="Servicios Web y SOA"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servicios Web</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servicios Web</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servicios Web">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 2</div>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion02-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Creaci&oacute;n de Servicios Web SOAP</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Los+servicios+Web+desde+la+vista+del+Servidor">Los servicios Web desde la vista del Servidor</a>
</li>
<li>
<a href="#El+modelo+de+programaci%C3%B3n+JAX-WS">El modelo de programaci&oacute;n JAX-WS</a>
</li>
<li>
<a href="#Implementaci%C3%B3n+del+servicio+JAX-WS+con+el+modelo+de+servlets">Implementaci&oacute;n del servicio JAX-WS con el modelo de servlets </a>
<ul class="minitoc">
<li>
<a href="#Anotaciones">Anotaciones</a>
</li>
<li>
<a href="#Estilo+y+codificaci%C3%B3n+del+servicio">Estilo y codificaci&oacute;n del servicio</a>
</li>
<li>
<a href="#Requerimientos+de+un+servicio+Web+JAX-WS">Requerimientos de un servicio Web JAX-WS</a>
</li>
</ul>
</li>
<li>
<a href="#Implementaci%C3%B3n+del+servicio+Web+con+el+modelo+EJB">Implementaci&oacute;n del servicio Web con el modelo EJB </a>
</li>
<li>
<a href="#Empaquetado+y+despliegue+de+un+servicio+Web">Empaquetado y despliegue de un servicio Web</a>
</li>
<li>
<a href="#Creaci%C3%B3n+de+un+servicio+Web+con+JDK+1.6">Creaci&oacute;n de un servicio Web con JDK 1.6</a>
</li>
<li>
<a href="#Creaci%C3%B3n+de+un+servicio+Web+JAX-WS+con+Maven">Creaci&oacute;n de un servicio Web JAX-WS con Maven</a>
</li>
<li>
<a href="#Creaci%C3%B3n+de+servicios+web+con+Netbeans">Creaci&oacute;n de servicios web con Netbeans</a>
</li>
<li>
<a href="#Creaci%C3%B3n+de+servicios+a+partir+de+EJBs+existentes">Creaci&oacute;n de servicios a partir de EJBs existentes</a>
</li>
<li>
<a href="#Creaci%C3%B3n+de+servicios+a+partir+del+WSDL">Creaci&oacute;n de servicios a partir del WSDL</a>
</li>
<li>
<a href="#Paso+de+datos+binarios">Paso de datos binarios</a>
</li>
<li>
<a href="#Servicios+web+con+estado">Servicios web con estado</a>
</li>
</ul>
</div>


<p>Vamos a crear nuestros propios Servicios Web, que ofrecer&aacute;n una serie 
  de m&eacute;todos a los que se podr&aacute; llamar mediante RPC desde cualquier 
  lugar de Internet mediante protocolos est&aacute;ndar (mensajes SOAP).</p>

<p>Deberemos por lo tanto ser capaces de interpretar en nuestras aplicaciones 
  los mensajes SOAP entrantes de petici&oacute;n para la invocaci&oacute;n de 
  un m&eacute;todo. Posteriormente, invocaremos el m&eacute;todo solicitado, y 
  con el resultado que nos devuelva deberemos construir un mensaje SOAP de respuesta 
  y devolv&eacute;rselo al cliente.</p>

<p>Si tuvi&eacute;semos que introducir nosotros el c&oacute;digo para interpretar 
  este mensaje de entrada, y generar manualmente el mensaje de respuesta, el desarrollo 
  de Servicios Web ser&iacute;a una tarea altamente costosa.</p>

<p>Es m&aacute;s, si se forzase al programador a componer el mensaje SOAP manualmente 
  cada vez que desarrolle un Servicio Web, es muy probable que cometa alg&uacute;n 
  error y no respete exactamente el est&aacute;ndar SOAP. Esto ser&iacute;a un 
  grave problema para la interoperabilidad de los Servicios Web, que es una de 
  las caracter&iacute;sticas que perseguimos con esta tecnolog&iacute;a.</p>

<p>Para evitar estos problemas, utilizaremos librer&iacute;as que nos permitan 
  leer o generar mensajes SOAP para la invocaci&oacute;n de m&eacute;todos remotos,
   como es el caso de la API JAX-WS. </p>

<p>Adem&aacute;s, para facilitar a&uacute;n m&aacute;s la tarea de desarrollar 
  Servicios Web, normalmente contaremos con herramientas que a partir de las clases 
  que implementan nuestro servicio generen autom&aacute;ticamente todo el c&oacute;digo 
  necesario para leer el mensaje SOAP de entrada, invocar el m&eacute;todo, escribir 
  el mensaje SOAP de salida, y devolverlo al cliente.</p>

<p>Por lo tanto, nosotros deberemos centrarnos &uacute;nicamente en la tarea de 
  programar la funcionalidad que implementan nuestros servicios, olvid&aacute;ndonos 
  del mecanismo de invocaci&oacute;n de &eacute;stos.</p>

<p>JAX-WS es una especificaci&oacute;n est&aacute;ndar de Sun Microsystems, pero 
  no todos los servidores de aplicaciones utilizan esta librer&iacute;a para gestionar 
  los Servicios Web. Por ejemplo, es el caso de Weblogic, que aunque est&aacute; basado en 
  JAX-WS, mantiene algunas extensiones propietarias sobre dicha API. Nos centraremos
  por lo tanto en el desarrollo de servicios con Netbeans y Glassfish, que incorpora 
  las &uacute;ltimas versiones de las librer&iacute;as est&aacute;ndar.</p>


<a name="N10024"></a><a name="Los+servicios+Web+desde+la+vista+del+Servidor"></a>
<h2 class="underlined_10">Los servicios Web desde la vista del Servidor</h2>
<div class="section">
<p>Como ya hemos visto, un documento WSDL define la interoperabilidad de los servicios Web e incluye
   la especificaci&oacute;n sobre requerimientos de transporte y formato de los datos a trav&eacute;s de la red. 
   En general, un WSDL no impone ning&uacute;n requerimiento sobre el modelo de programaci&oacute;n del cliente o del
   servidor. La especificaci&oacute;n de servicios Web para Java EE (JSR-109) define tres formas de implementar
   la l&oacute;gica de negocio de servicio Web: </p>
<ul>
  
<li>Como un Bean de Sesi&oacute;n sin estado: la implementaci&oacute;n del servicio Web (componente <strong>Port</strong>) se realiza creando un
      Bean de sesi&oacute;n sin estado, que implementa los m&eacute;todos del SEI (<em>Service Endpoint Interface</em>)
      tal y como se describe en la especificaci&oacute;n de EJB 3.0</li>
  
<li>Como una clase Java: en este caso se implementa el <em>Port</em> como un <em>Servlet</em> JAX-WS</li>
  
<li>Como un <em>Singleton Session Bean</em>: en este caso se crea un <em>singleton session bean</em> que
      implementa los m&eacute;todos de un SEI seg&uacute;n la especificaci&oacute;n de EJB 3.1
  </li>    

</ul>
<p>Un componente <strong>Port</strong> define la vista del servidor de un Servicio Web. Cada <em>Port</em>
   proporciona un servicio en una direcci&oacute;n f&iacute;sica particular definida por el atributo <em>address</em> de 
   la definicion <span class="codefrag">&lt;port&gt;</span> de un WSDL. Un componente Port "sirve" una petici&oacute;n de operaci&oacute;n
   definida en un <span class="codefrag">&lt;portType&gt;</span> de un WSDL. La implementaci&oacute;n del servicio (<em>Service Implementation Bean</em>)
   depende del contenedor del componente Port, pero en general es una clase Java que puede implementar los m&eacute;todos 
   definidos en el SEI (<em>Service Endpoint Interface</em>). El SEI es un mapeado java del <span class="codefrag">&lt;portType&gt;</span> y
   <span class="codefrag">&lt;binding&gt;</span> asociado a un <span class="codefrag">&lt;port&gt;</span> de un WSDL. Un servicio Web es un conjunto de <em>Ports</em>
    que difieren &uacute;nicamente en su direcci&oacute;n f&iacute;sica, y son mapeados en componentes Port separados, cada uno con su potencialmente
    &uacute;nico, pero probablemente compartido, Service Implementation Bean. La siguiente figura muestra la vista del
    servidor de un Servicio Web.   
</p>
<p>
<img alt="Vista del servidor de un servicio Web" content-width="7cm" src="imagenes/sesion2/port.png" width="439"></p>
<p>El ciclo de vida del Port est&aacute; completamente controlado por el contenedor, pero en general sigue el mismo ciclo de vida
   que el del propio contenedor. Un Port es creado e inicializado por el contenedor antes de que la primera llamada recibida 
   en la direcci&oacute;n del <span class="codefrag">&lt;port&gt;</span> del WSDL sea servida. Un Port es destruido por el contenedor cuando &eacute;ste
   considera que sea necesario hacerlo, como por ejemplo cuando el propio contenedor es <em>sutting down</em>. Una implementaci&oacute;n
   de un servicio Web JAX-WS reside en un contenedor Web, y por lo tanto puede desplegarse en un servidor Web o un servidor de aplicaciones, 
   una implementaci&oacute;n EJB, en cambio, reside en un contenedor EJB y s&oacute;lo podr&aacute; desplegarse en un servidor de aplicaciones.</p>
<p>Un componente Port asocia una direcci&oacute;n de puerto (<em>port address</em> de un WSDL) con la implementaci&oacute;n del servicio (<em>Service
   Implementation Bean</em>). En general, el componente Port "pospone" la definici&oacute;n de los requerimientos del contenedor del servicio a la
   fase de despliegue, indicando dichos requerimientos en el descriptor de despliegue del componente. Un contenedor proporciona un <em>listener</em>
   en la direcci&oacute;n del puerto (<em>port address</em> de un WSDL) y un mecanismo para "enviar" la petici&oacute;n a la implementaci&oacute;n del servicio Web.
   Un contenedor tambi&eacute;n proporciona servicios en tiempo de ejecuci&oacute;n, tales como restricciones de seguridad y mapeados de referencias l&oacute;gicas a
   referencias f&iacute;sicas de objetos distribuidos y recursos.</p>
<p>Un desarrollador declara un componente <strong>Port</strong> en un descriptor de despliegue de servicios Web. El descriptor de despliegue
   incluye el documento WSDL que describe el <em>PortType</em> y <em>binding</em> del servicio Web. Cuando se usa JAX-WS, no es necesario proporcionar
   dicho descriptor de despliegue. La mayor parte de la informaci&oacute;n del descriptor de despliegue se incluye en las anotaciones de la implementaci&oacute;n
   del servicio. Podr&iacute;amos utilizar el descriptor de despliegue para "sobreescribir" o mejorar la informaci&oacute;n proporcionada por las anotaciones de la
   implementaci&oacute;n del servicio.</p>
<p>La plataforma Java EE 6, soporta las siguientes implementaciones de servicios Web: como un componente Web JAX-WS en un contenedor de
   <em>Servlets</em>, y como un componente EJB de sesi&oacute;n <em>stateless</em> o <em>singleton</em>.</p>
<p>El empaquetado de un servicio Web en un m&oacute;dulo Java EE es espec&iacute;fico de la metodolog&iacute;a de implementaci&oacute;n, pero sigue los
    requerimientos para un fichero EJB-JAR o fichero WAR. Contiene los ficheros de clases java del SEI y los documentos WSDL del servicio Web.
    Adem&aacute;s contiene el descriptor XML de despliegue que define los <em>Ports</em> del servicio y su estructura.
 </p>
</div>


<a name="N100AD"></a><a name="El+modelo+de+programaci%C3%B3n+JAX-WS"></a>
<h2 class="underlined_10">El modelo de programaci&oacute;n JAX-WS</h2>
<div class="section">
<p>Para desarrollar una implementaci&oacute;n de un servicio web (<em>web service endpoint</em>) podemos
   optar por dos puntos de partida: una clase Java que implementa el servicio Web o un fichero
   WSDL. Cuando comenzamos por una <strong>clase java</strong>, utilizaremos herramientas para generar
   los artefactos necesarios, entre ellos el WSDL del servicio. Cuando nuestro punto de partida es
   un <strong>fichero WSDL</strong> (junto con los ficheros de esquema que describen los tipos
   de datos usados en el servicio), utilizaremos herramientas para generar el SEI (<em>Service
   Endpoint Interface</em>)
</p>
<div class="frame note">
<div class="label">Sobre JAX-WS y la implementaci&oacute;n del servicio</div>
<div class="content">
	JAX-WS impone la existencia de un <em>Service Implementation Bean</em> anotado con <em>javax.jws.WebService
	</em> en un componente Port. Como ya hemos indicado en el apartado anterior, la implementaci&oacute;n del servicio
	(<em>Service Implementation Bean</em>) va a depender del contenedor del componente Port, pero en general
	es una clase Java que puede implementar los m&eacute;todos definidos en el SEI (<em>Service Endpoint Interface</em>).
	En los apartados siguientes veremos que JAX-WS permite implementar un <em>Service Implementation Bean</em> 
	como una clase Java anotada (modelo de servlets), o como un EJB de sesi&oacute;n sin estado (modelo EJB).
</div>
</div>
<p>Si comenzamos por una clase java, tendremos la seguridad de que la clase que implementa el
   servicio tiene los tipos de datos java adecuados, pero el desarrollador tienen menos control
   sobre el esquema XML generado. Si comenzamos por el WSDL y esquemas, el desarrollador tiene un
   control total sobre qu&eacute; esquema se est&aacute; usando, pero menos control sobre el <em>endpoint</em> del
   servicio generado y de las clases que utiliza.</p>
<p>Nosotros vamos a explicar en primer lugar c&oacute;mo crear un servicio a partir de una clase java, y tambi&eacute;n veremos
c&oacute;mo utilizar Netbeans para crear un servicio a partir de un wsdl.
</p>
<p>Cuando nuestro punto de partida es una clase java, tenemos que seguir ciertas restricciones en la implementaci&oacute;n
   de nuestro servicio. Una implementaci&oacute;n v&aacute;lida de un servicio web es una clase java que
   cumple las siguientes restricciones: </p>
<ul>   
  
<li>La clase debe estar anotada con <span class="codefrag">javax.jws.Webservice</span> (o alternativamente con
      <span class="codefrag">javax.xml.ws.Provider</span>, si se desea trabajar directamente a nivel de mensajes
      XML)</li>
  
<li>Podemos anotar cualquiera de sus m&eacute;todos con <span class="codefrag">javax.jws.WebMethod</span>
  
</li>
  
<li>Todos sus m&eacute;todos pueden lanzar la excepci&oacute;n <em>java.rmi.RemoteException</em> adem&aacute;s de cualquier
      otra excepci&oacute;n propia del servicio</li>
  
<li>Los par&aacute;metros de sus m&eacute;todos y tipos de retorno deben ser compatible con JAXB (JAXB impone
      unas reglas para mapear tipos java con tipos de ficheros de esquema XML)</li>
  
<li>Ning&uacute;n par&aacute;metro y/o tipo de retorno pueden implementar la interfaz <em>java.rmi.Remote</em>
      ni directa ni indirectamente</li>

</ul>
<p>La clase java anotada con <span class="codefrag">@WebService</span> define un SEI de forma <strong>impl&iacute;cita</strong> por
   lo que no ser&aacute; necesario proporcionar dicha interfaz. Podemos especificar de forma expl&iacute;cita una interfaz 
   a&ntilde;adiendo el atributo <span class="codefrag">endpointInterface</span> a la
   anotaci&oacute;n <span class="codefrag">@WebService</span>. En ese caso, s&iacute; es necesario
   proporcionar la interfaz que defina los m&eacute;todos p&uacute;blicos disponibles en la clase que implementa el servicio.
</p>
<p>Una implementaci&oacute;n de un servicio Web que utiliza la anotaci&oacute;n <span class="codefrag">@WebService</span> no es necesario que especifique
   la ubicaci&oacute;n del WSDL. Si se utiliza el atributo <span class="codefrag">wsdlLocation</span> en la anotaci&oacute;n <span class="codefrag">@WebService</span>, 
   el fichero WSDL debe ser empaquetado junto con las clases java del servicio web.
   </p>
<p>A continuaci&oacute;n explicaremos con m&aacute;s detalle c&oacute;mo implementar el servicio utilizando el
    modelo de servlets (el servicio se ejecuta en un contenedor web) y ejb (el servicio se ejecuta
    en un contenedor EJB).</p>
</div>



<a name="N10125"></a><a name="Implementaci%C3%B3n+del+servicio+JAX-WS+con+el+modelo+de+servlets"></a>
<h2 class="underlined_10">Implementaci&oacute;n del servicio JAX-WS con el modelo de servlets </h2>
<div class="section">
<p>Un <em>Service Implementation Bean</em> que se ejecuta dentro de un contenedor Web debe seguir los siguientes
   requerimientos (algunos de los cuales ya los hemos indicado en el apartado anterior):</p>
<ul>
  
<li>La clase que implementa el servicio debe estar anotada con <span class="codefrag">javax.jws.WebService</span> (o alternativamente,
      con <span class="codefrag">javax.xml.ws.Provider</span>)</li>
  
<li>Si se implementa el servicio Web partiendo de c&oacute;digo java, la anotaci&oacute;n <span class="codefrag">javax.jws.WebService</span> NO es necesario especificar el SEI, la clase que
      implementa el servicio impl&iacute;citamente define un SEI. Los m&eacute;todos de negocio de la implementaci&oacute;n deben ser 
      <strong>p&uacute;blicos</strong>, y NO pueden ser <strong>final</strong> o <strong>static</strong>. Solamente los m&eacute;todos anotados con
        <span class="codefrag">@WebMethod</span>
      en la implementaci&oacute;n del servicio son expuestos al cliente.
     </li> 
  
<li>Si se implementa el servcicio Web a partir del WSDL, el SEI generado a partir del WSDL debe estar anotado con 
      <span class="codefrag">javax.jws.WebService</span>. La implementaci&oacute;n del servicio debe est&aacute;r tambi&eacute;n anotada con <span class="codefrag">javax.jws.WebService</span>.
      La implementaci&oacute;n del servicio puede implementar el SEI, aunque no es necesario. En este caso se deben implementar todos
      los m&eacute;todos indicados en el SEI. Los m&eacute;todos de negocio de la implementaci&oacute;n deben ser 
      <strong>p&uacute;blicos</strong>, y NO pueden ser <strong>final</strong> o <strong>static</strong>. Se puede implementar m&eacute;todos
      adicionales que no figuren en el SEI.
  </li> 
  
<li>La implementaci&oacute;n del servicio debe tener un constructor p&uacute;blico por defecto</li>  
  
<li>La implementaci&oacute;n del servicio no debe guardar el estado</li>
  
<li>La clase debe ser p&uacute;blica, no puede ser <em>final</em> ni <em>abstracta</em>
</li>
  
<li>La clase no debe implementar el m&eacute;todo <span class="codefrag">finalize()</span>
</li>   

</ul>
<p>Por ejemplo, podemos implementar nuestro servicio Web como:</p>
<pre class="brush:java;">package jaxwsHelloServer;

import javax.jws.WebService;
import javax.jws.WebMethod;

@WebService
public class Hello {
    private String message = new String("Hola, ");

    public void Hello() {}

    @WebMethod
    public String sayHello(String name) {
         return message + name + ".";
    }
}</pre>
<p>Con esto habremos implementado la funcionalidad del servicio como una clase 
  Java ordinaria, sin necesitar tener conocimientos de ninguna librer&iacute;a 
  adicional.</p>
<p>De forma opcional, podemos a&ntilde;adir al servicio un campo <span class="codefrag">context</span> en el que se inyectar&aacute; un objeto
<span class="codefrag">WebServiceContext</span> que nos dar&aacute; acceso al contexto del servicio:</p>
<pre class="brush:java;">...
@WebService
public class Hello {
    @Resource
    private WebServiceContext context;

    ...
}</pre>
<p>Dado que realmente el servicio es un componente web, a trav&eacute;s de este objeto podremos tener acceso a
componentes de la API de <em>servlets</em> como la petici&oacute;n HTTP (<span class="codefrag">HttpServletRequest</span>), la sesi&oacute;n
(<span class="codefrag">HttpSession</span>), etc.</p>
<a name="N10199"></a><a name="Anotaciones"></a>
<h3 class="underlined_5">Anotaciones</h3>
<p>Podemos especificar la forma en la que se crea el servicio mediante diferentes anotaciones. Las principales anotaciones disponibles son:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebService</span></td>
<td colspan="2" rowspan="1">Indica que la clase define un servicio web. Se pueden especificar como par&aacute;metros 
   los nombres del servicio (serviceName), del componente Port (portName), 
   del SEI del servicio (name), de su espacio de nombres (targetNamespace), y de la
   ubicaci&oacute;n del WSDL (wsdlLocation), que figurar&aacute;n en el documento WSDL del servicio:

<pre class="code">@WebService(name="ConversionPortType", 
    serviceName="ConversionService",
    portName="ConversionPort",
    targetNamespace="http://jtech.ua.es",
    wsdlLocation="resources/wsdl/")</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@SOAPBinding</span></td>
<td colspan="2" rowspan="1">Permite especificar el estilo y la codificaci&oacute;n de los mensajes SOAP utilizados para invocar el servicio. Por ejemplo:
<pre class="code">@SOAPBinding(style=SOAPBinding.Style.DOCUMENT,
    use=SOAPBinding.Use.LITERAL,
    parameterStyle=
      SOAPBinding.ParameterStyle.WRAPPED)</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebMethod</span></td>
<td colspan="2" rowspan="1">Indica que un determinado m&eacute;todo debe ser publicado como operaci&oacute;n del servicio. Si no se indica para ning&uacute;n m&eacute;todo, se considerar&aacute; que deben ser publicados todos los m&eacute;todos p&uacute;blicos. Si no, s&oacute;lo se publicar&aacute;n los m&eacute;todos indicados. Adem&aacute;s, de forma opcional se puede indicar como par&aacute;metro el nombre con el que queramos que aparezca la operaci&oacute;n en el documento WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
public int euro2ptas(double euros) {
   ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@Oneway</span></td>
<td colspan="2" rowspan="1">Indica que la llamada a la operaci&oacute;n no debe esperar ninguna respuesta. Esto s&oacute;lo lo podremos hacer con m&eacute;todos que devuelvan <span class="codefrag">void</span>. Por ejemplo:
<pre class="code">@Oneway()
@WebMethod()
public void publicarMensaje(String mensaje) {
   ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebParam</span></td>
<td colspan="2" rowspan="1">Permite indicar el nombre que recibir&aacute;n los par&aacute;metros en el fichero WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
public int euro2ptas(
  @WebParam(name="CantidadEuros",
            targetNamespace="http://jtech.ua.es")
  double euros) {
    ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebResult</span></td>
<td colspan="2" rowspan="1">Permite indicar el nombre que recibir&aacute; el mensaje de respuesta en el fichero WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
@WebResult(name="ResultadoPtas",
    targetNamespace="http://jtech.ua.es")
public int euro2ptas(double euros) {
    ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebFault</span></td>
<td colspan="2" rowspan="1">Se utiliza para anotar excepciones Java. Cuando utilizamos esta anotaci&oacute;n en una
excepci&oacute;n estamos indicando que cuando sea lanzada por una operaci&oacute;n del servicio web debe generar
un mensaje SOAP de respuesta con un <em>SOAP Fault</em> que nos indique el error producido. En el lado 
del cliente la clase con dicha excepci&oacute;n se habr&aacute; generado en el <em>stub</em> para el acceso al servicio,
y al recibir el mensaje SOAP con el error el <em>stub</em> lanzar&aacute; la excepci&oacute;n correspondiente. Es decir,
para el desarrollador ser&aacute; como si la excepci&oacute;n saltase directamente desde el servicio hasta el cliente.
<pre class="code">@WebFault
public class ConversionFaultException extends Exception {
    public ConversionFaultException(String msg) {
        super(msg);
    }
}</pre>

</td>

</tr>

</table>
<a name="N1023B"></a><a name="Estilo+y+codificaci%C3%B3n+del+servicio"></a>
<h3 class="underlined_5">Estilo y codificaci&oacute;n del servicio</h3>
<p>Hemos visto que mediante la anotaci&oacute;n <span class="codefrag">@SOAPBinding</span> podemos cambiar el estilo 
y la codificaci&oacute;n del servicio. Los posibles estilos son:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.Style.RPC</span>: Se utilizan mensajes SOAP orientados a RPC, en los que 
se codifican en XML las llamadas a m&eacute;todos remotos.</li>

<li>
<span class="codefrag">SOAPBinding.Style.DOCUMENT</span>: Se utilizan mensajes SOAP orientados al documento. 
Dado que en estos mensajes se puede incluir cualquier tipo de documento XML, tambi&eacute;n se pueden 
utilizar para invocar operaciones de servicios.</li>

</ul>
<p>Podemos especificar tambi&eacute;n la codificaci&oacute;n:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.Use.LITERAL</span>: Esta es la &uacute;nica codificaci&oacute;n aceptada en el WS-I 
Basic Profile (BP), que da soporte a los servicios de tipo <em>document/literal</em> y 
<em>RPC/literal</em>.</li>

<li>
<span class="codefrag">SOAPBinding.Use.ENCODED</span>: Se trata de una codificaci&oacute;n que permite representar 
una mayor variedad de estructuras de datos que la anterior, pero est&aacute; desaprobada por el 
BP por ser la causa de gran cantidad de incompatibilidades entre servicios. De hecho JAX-WS 
es incompatible con los servicios de este tipo. Esta codificaci&oacute;n se suele utilizar con 
servicios de tipo RPC, dando lugar al tipo <em>RPC/encoded</em>.</li>

</ul>
<p>En el caso de los servicios de tipo <em>document/literal</em>, tambi&eacute;n podemos especificar 
la forma en la que se representan los tipos de datos de los par&aacute;metros de las operaciones:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.ParameterStyle.BARE</span>: Los par&aacute;metros se pasan directamente.</li>

<li>
<span class="codefrag">SOAPBinding.ParameterStyle.WRAPPED</span>: Los par&aacute;metros se pasan envueltos en 
tipos de datos complejos.</li>

</ul>
<p>Por defecto los servicios ser&aacute;n del tipo <em>document/literal/wrapped</em>.</p>
<a name="N10287"></a><a name="Requerimientos+de+un+servicio+Web+JAX-WS"></a>
<h3 class="underlined_5">Requerimientos de un servicio Web JAX-WS</h3>
<p>
<strong>Tipos de datos compatibles</strong>
</p>
<p>Cuando trabajamos con JAX-WS, los tipos de datos que podremos utilizar 
  como tipo de los par&aacute;metros y de valor de retorno de los m&eacute;todos 
  de nuestro servicio ser&aacute;n los tipos soportados por JAXB.</p>
<p>Podremos utilizar cualquiera de los tipos b&aacute;sicos de Java:</p>
<pre class="brush:java;">boolean
byte
double
float
int
long
short
char</pre>
<p>Adem&aacute;s, tambi&eacute;n podremos utilizar cualquiera de los <em>wrappers</em> 
  de estos tipos b&aacute;sicos:</p>
<pre class="brush:java;">java.lang.Boolean
java.lang.Byte
java.lang.Double
java.lang.Float
java.lang.Integer
java.lang.Long
java.lang.Short
java.lang.Character</pre>
<p>Las siguientes clases de Java tambi&eacute;n son aceptadas como tipos v&aacute;lidos 
  por JAX-WS:</p>
<pre class="brush:java;">java.lang.String
java.math.BigDecimal
java.math.BigInteger
java.util.Calendar
java.util.Date
javax.xml.namespace.QName
java.net.URI</pre>
<p>Adem&aacute;s de estos datos, se permitir&aacute; el uso de colecciones cuyos elementos podr&aacute;n 
  ser de cualquiera de los tipos admitidos. Estas colecciones podr&aacute;n ser <em>arrays</em>, 
  tanto unidimensionales como multidimensionales, o clases del marco de colecciones de Java:</p>
<pre class="brush:java;">Listas: List 
ArrayList 
LinkedList 
Stack 
Vector 
Mapas: Map 
HashMap 
Hashtable 
Properties 
TreeMap 
Conjuntos: Set 
HashSet 
TreeSet 
</pre>
</div>


<a name="N102BC"></a><a name="Implementaci%C3%B3n+del+servicio+Web+con+el+modelo+EJB"></a>
<h2 class="underlined_10">Implementaci&oacute;n del servicio Web con el modelo EJB </h2>
<div class="section">
<p>Se puede utilizar un <em>Stateless Session Bean</em>, tal y como se define en la especificaci&oacute;n de 
   <em>Enterprise Java Beans</em>, para ser desplegado en un contenedor EJB. Tambi&eacute;n se puede utilizar
   un <em>Singleton Session Bean</em> tal y como se define en la especificaci&oacute;n EJB 3.1, para implementar
   un servicio Web JAX-WS para ser desplegado en un contenedor EJB.</p>
<p>Los requerimientos para crear una implementaci&oacute;n de un servicio como un EJB de sesi&oacute;n
   sin estado y <em>singleton</em>, son las mismas que hemos visto en el apartado anterior para el modelo de programaci&oacute;n
   con <em>servlets</em>.</p>
<p>Podemos anotar un <em>bean</em> de sesi&oacute;n sin estado con la anotaci&oacute;n <span class="codefrag">javax.ejb.Stateless</span>. En este caso, la clase
   del <em>bean</em> ya no debe implementar la interfaz <span class="codefrag">javax.ejb.SessionBean</span>.</p>
<p>Un EJB de sesi&oacute;n sin estado y <em>singleton</em> que implementen un servicio Web utilizando la API de JAX-WS
   deber&iacute;a utilizar <em>javax.xml.ws.WebServiceContext</em>, el cual puede inyectarse utilizando la anotaci&oacute;n
   <span class="codefrag">@Resource</span>, tal y como hemos visto en el ejemplo de la secci&oacute;n anterior.</p>
<p>En el caso de utilizar un <em>bean</em> de sesi&oacute;n <em>singleton</em> se utiliza la anotaci&oacute;n <span class="codefrag">javax.ejb.Singleton</span>.</p>
<p>Por ejemplo, podemos implementar nuestro servicio Web como un <em>Stateless Session Bean</em> de la siguiente forma:</p>
<pre class="brush:java;">package jaxwsHelloServer;

import javax.jws.WebService;
import javax.jws.WebMethod;
import javax.ejb.Stateless;

@WebService
@Stateless
public class Hello {
    private String message = new String("Hola, ");
    
    public void Hello() {}
    
    @WebMethod
    public String sayHello(String name) {
        return message + name + ".";
    }
}</pre>
</div>   




<a name="N1030C"></a><a name="Empaquetado+y+despliegue+de+un+servicio+Web"></a>
<h2 class="underlined_10">Empaquetado y despliegue de un servicio Web</h2>
<div class="section">
<p>Los componentes <strong>Port</strong> pueden empaquetarse en un fichero WAR o en un fichero EJB-JAR.
   Los componentes <em>Port</em> empaquetados en un fichero WAR deben usar una implementaci&oacute;n de un servicio
   con el modelo de programaci&oacute;n de servlets JAX-WS. Los componentes <em>Port</em> empaquetados en un fichero EJB-JAR deben utilizar un <em>stateless</em>
   o <em>singleton bean</em> para implementar el servicio web. </p>
<p>El desarrollador es responsable de empaquetar (bien incluyendo directamente, o referenciando), los siguientes elementos:</p>
<ul>
  
<li>el fichero WSDL (opcional si se utilizan anotaciones JAX-WS)</li>
  
<li>la clase SEI (opcional con JAX-WS)</li>
  
<li>la clase que implementa el servicio y sus clases dependientes</li>
  
<li>los artefactos portables generados por JAX-WS (clases java generadas cuando se implementa un servicio Web a partir de una clase
  java, para ayudar al <em>marshaling/unmarshaling</em> de las invocaciones y
      respuestas del servicio web, as&iacute; como de las excepciones espec&iacute;ficas del servicio devueltas por dicho servicio)</li>
  
<li>descriptor de despliegue en un m&oacute;dulo java EE (opcional si se usan anotaciones JAX-WS. Cualquier informaci&oacute;n contenida en este 
      fichero "sobreescribe" la correspondiente informaci&oacute;n especificada con anotaciones)</li>    

</ul>
<p>El fichero WSDL se suele almacenar en un directorio <span class="codefrag">wsdl</span>, para su publicaci&oacute;n durante el despliegue.
</p>
<p>El descriptor de despliegue es espec&iacute;fico del m&oacute;dulo que contenga el servicio web. En el caso del <strong>empaquetado EJB</strong>, el fichero
   descriptor de despliegue con la informaci&oacute;n del servicio web se localizar&iacute;a en <span class="codefrag">META-INF/webservices.xml</span>. El directorio
   <span class="codefrag">wsdl</span> estar&aacute; en <span class="codefrag">META-INF/wsdl</span>. Si utilizamos un <strong>war</strong> para empaquetar nuestro servicio web, 
   el descriptor de despliegue se localiza en <span class="codefrag">WEB-INF/webservices.xml</span>, y el directorio que contiene el fichero WSDL se
   localiza en <span class="codefrag">WEB-INF/wsdl</span>.</p>
<p>Adicionalmente, se puede empaquetar el fichero de <strong>cat&aacute;logo</strong> <span class="codefrag">jax-ws-catalog.xml</span> en el
   directorio <span class="codefrag">META-INF/jax-ws-catalog.xml</span>, en el caso de un m&oacute;dulo EJB, y <span class="codefrag">WEB-INF/jax-ws-catalog.xml</span>, en 
   el caso de un m&oacute;dulo web. El fichero de cat&aacute;logo se utiliza fundamentalmente para resolver las referencias a documentos de
   servicios web, espec&iacute;ficamente documentos WSDL y ficheros de esquema.</p>
<p>Un ejemplo del contenido del fichero <em>jax-ws-catalog.xml</em> es el siguiente:</p>
<pre class="brush:xml;">
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;catalog xmlns="urn:oasis:names:tc:entity:xmlns:xml:catalog" 
         prefer="system"&gt;
    &lt;system systemId="http://localhost:8080/holaMundo/hola?WSDL" 
            uri="wsdl/localhost_8080/holaMundo/hola.wsdl"/&gt;
    &lt;system systemId="http://localhost:8080/holaMundo/hola?xsd=1" 
            uri="wsdl/localhost_8080/holaMundo/hola.xsd_1.xsd"/&gt;
&lt;/catalog&gt;

</pre>
<p>
<strong>Despliegue del servicio Web</strong>
</p>
<p>JAX-WS 2.2.2 RI (Implementaci&oacute;n de referencia de JAX-WS. RI= <em>Reference Implementation</em>) soporta dos modelos
   de despliegue para publicar servicios web. Una posibilidad es utilizar el modelo definido por JSR-109 (<em>Web Services
   for Java EE</em>), que utiliza el fichero <em>webservices.xml</em> para definir el despliegue de los servicios. Otra
   posibilidad es utilizar el modelo de despliegue espec&iacute;fico de JAX-WS RI, que define la configuraci&oacute;n del despliegue
   en los ficheros <em>web.xml</em> y <em>sun-jaxws.xml</em>. Esta segunda opci&oacute;n es la que vamos a comentar aqu&iacute;.</p>
<p>Nosotros vamos a utilizar Glassfish 3.1 para realizar el despliegue. Glassfish incluye todas las librer&iacute;as y clases necesarias
   para desarrollar/desplegar servicios web en la plataforma Java EE, de forma que no necesitaremos incluir ning&uacute;n descriptor de 
   despliegue en nuestro empaquetado, ni siquiera el fichero <span class="codefrag">web.xml</span> en el caso de utilizar el modelo de servlets.
</p>
<p>En el caso de utilizar el modelo <em>servlets</em>, y por lo tanto empaquetar nuestras clases en un <em>war</em>, este tipo
   de despliegue (sin utilizar ning&uacute;n descriptor) NO es portable. Para un contenedor no Java EE, por ejemplo un Tomcat, el fichero
   war que contiene el servicio web no es diferente al <em>war</em> de una aplicaci&oacute;n <em>servlet/jsp</em>. Si queremos trabajar con
   servicios web, tenemos que elegir una implementaci&oacute;n de JAX-WS e incluir en el <em>war</em> las librer&iacute;as necesarias de JAX-WS.
</p>
<p>Otra cuesti&oacute;n con respecto al tipo de despliegue sin descriptores, es que la implementaci&oacute;n de nuestro servicio web no ser&iacute;a
   "descubierta" autom&aacute;ticamente por el contenedor (por ejemplo Tomcat). Para ello deber&iacute;amos incluir algunos descriptores de
   despliegue para "decirle" a la librer&iacute;a JAX-WS c&oacute;mo queremos que se desplieguen nuestros servicios web. Estos descriptores
   son espec&iacute;ficos de la librer&iacute;a que estemos utilizando. As&iacute;, por ejemplo, si decidimos desplegar nuestro servidor en un Tomcat,
   tendr&iacute;amos que a&ntilde;adir en el directorio WEB-INF los ficheros <span class="codefrag">sun-jaxws.xml</span> y <span class="codefrag">web.xml</span>. Ambos ficheros
   contendr&aacute;n informaci&oacute;n para realizar el "despliegue" de los servicios web.</p>
<p>
<strong>Descriptores de despliegue JAX-WS: <em>web.xml</em> y <em>sun-jaxws.xml</em></strong>
</p>
<p>En el fichero <span class="codefrag">web.xml</span> declaramos el <em>listener</em> JAX-WS <span class="codefrag">WSServletContextListener</span>, que
   inicializa y configura el <em>endpoint</em> (componente <em>port</em>) del servicio web, y el <em>servlet</em> JAXWS <span class="codefrag">WSServlet</span>, que es el
   que sirve las peticiones al servicio, utilizando la clase que implementa dicho servicio. Un ejemplo de contenido 
   de fichero <span class="codefrag">web.xml</span> podr&iacute;a ser &eacute;ste:</p>
<pre class="brush:xml;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
         http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;
           com.sun.xml.ws.transport.http.servlet.WSServletContextListener
        &lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;NewsService&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.sun.xml.ws.transport.http.servlet.WSServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;NewsService&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/NewsService&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;session-config&gt;
        &lt;session-timeout&gt;
            30
        &lt;/session-timeout&gt;
    &lt;/session-config&gt;
    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;
&lt;/web-app&gt;
 
</pre>
<p>El fichero <span class="codefrag">sun-jaxws.xml</span> contiene la definici&oacute;n de la implementaci&oacute;n del <em>endpoint</em> del servicio.
   Cada <em>endpoint</em> representa un <em>port</em> WSDL, y contiene toda la informaci&oacute;n sobre la clase que implementa el
   servicio, <em>url-pattern</em> del <em>servlet</em>, informaci&oacute;n de <em>binding</em>, ubicaci&oacute;n del fichero WSDL,
   y nombres "cualificados" (<em>qualified names</em>) del <em>port</em> y <em>service</em> del WSDL. 
   Si no especificamos la ubicaci&oacute;n del fichero WSDL, &eacute;ste ser&aacute; generado y publicado durante el despliegue.
   Por ejemplo, en el siguiente fichero <span class="codefrag">sun-jaxws.xml</span> indicamos que la implentaci&oacute;n de nuestro servicio viene dada por la clase
   <span class="codefrag">ws.news.NewsService</span> (dicha clase debe estar anotada conc <span class="codefrag">@WebService</span>).</p>
<pre class="brush:xml;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;endpoints version="2.0" xmlns="http://java.sun.com/xml/ns/jax-ws/ri/runtime"&gt;
  &lt;endpoint implementation="ws.news.NewsService" 
            name="NewsService" 
            url-pattern="/NewsService"/&gt;
&lt;/endpoints&gt;
 
</pre>
<p>
<strong>Responsabilidades del contenedor</strong>
</p>
<p>El contenedor en el que resida nuestro servicio Web debe proporcionar el <em>runtime</em> de JAX-WS, para soportar
   peticiones de invocaci&oacute;n sobre los componentes <em>port</em> desplegados en dicho contenedor. El soporte de ejecuci&oacute;n
   de JAX-WS se encargar&aacute; de convertir los mensajes SOAP de las llamadas entrantes al servicio en llamadas al API java 
   de JAX-WS, y viceversa (convertir la respuesta java en mensaje SOAP). El contenedor ser&aacute; el responsable de:</p>
<ul>
  
<li>"Escuchar" en un puerto determinado, o en la URI de la implementaci&oacute;n del servicio, esperando peticiones SOA/HTTP)</li>
  
<li>"Parsear" el mensaje de entrada, dependiendo del tipo de "enlazado" <em>binding</em> del servicio</li>
  
<li>"Mapear" el mensaje a la clase y m&eacute;todo correspondiente, de acuerdo con los datos de despliegue del servicio</li>
  
<li>Crear los objetos java adecuados para el sobre (<em>envelope</em>) SOAP de acuerdo a la especificaci&oacute;n JAX-WS</li>
  
<li>Invocar al <em>Service Implementation Bean</em> y al m&eacute;todo de instancia con los par&aacute;metros java adecuados</li>
  
<li>Capturar la respuesta de la invocaci&oacute;n si el estilo es petici&oacute;n-respuesta</li>
  
<li>Mapear los objetos de respuesta java al mensaje SOAP</li>
  
<li>Crear el <em>envelope</em> adecuado del mensaje para su transporte</li>
  
<li>Enviar el mensaje al cliente del servicio Web</li>

</ul>
<p>
<strong>Despliegue del servicio web</strong>
</p>
<p>La herramienta de despliegue comienza el proceso examinando el artefacto desplegado para determinar qu&eacute; m&oacute;dulos
   contienen servicios Web, para ello analiza las anotaciones de servicios web o los descriptores de despliegue contenidos
   en el m&oacute;dulo. A continuaci&oacute;n obtiene la informaci&oacute;n de enlazado (<em>binding</em>), despliega los componentes y 
   servicios web definidos en el m&oacute;dulo. Seguidamente publica los documentos WSDL que representan a los servicios web
   desplegados, configura al servidor e inicia la aplicaci&oacute;n.
 </p>
</div>


<a name="N10449"></a><a name="Creaci%C3%B3n+de+un+servicio+Web+con+JDK+1.6"></a>
<h2 class="underlined_10">Creaci&oacute;n de un servicio Web con JDK 1.6</h2>
<div class="section">
<p>Igual que en el caso de los clientes de servicios web, a partir de la versi&oacute;n 1.6
de JDK se incluyen herramientas para generar servicios web a partir de una clase java. Concretamente la 
herramienta que se utilizar&aacute; para generar el servicio es <span class="codefrag">wsgen</span>, que al 
igual que <span class="codefrag">wsimport</span> se podr&aacute; utilizar tanto en l&iacute;nea de comando como en 
forma de tarea de ant.</p>
<p>Lo primero que deberemos hacer es compilar la clase que implementa el servicio
 al igual que cualquier otra clase Java, con la herramienta <span class="codefrag">javac</span>. 
Una vez hecho esto, generaremos el servicio con <span class="codefrag">wsgen</span> a partir de la 
clase compilada. Utilizaremos <span class="codefrag">wsgen</span> de la siguiente forma:</p>
<pre class="brush:plain;">
wsgen -cp &lt;classpath&gt; -s &lt;src.dir&gt; -d &lt;dest.dir&gt; 
      &lt;nombre.clase.servicio&gt;</pre>
<p>La clase que implementa el servicio (<span class="codefrag">&lt;nombre.clase.servicio&gt;</span>) 
se especificar&aacute; mediante su nombre completo, es decir, incluyendo el nombre del 
paquete al que pertenece. Podemos proporcionar 
otros par&aacute;metros para indicar la forma en la que se deben generar las clases, 
como el directorio donde queremos que guarde los fuentes de las clases generadas 
(<span class="codefrag">&lt;src.dir&gt;</span>), el directorio donde guardar&aacute; estas clases compiladas 
(<span class="codefrag">&lt;dest.dir&gt;</span>), y el <span class="codefrag">classpath</span>, en el que deber&aacute; 
encontrarse la clase especificada.</p>
<p>En el caso concreto del servicio <span class="codefrag">Hello</span> definido anteriormente, 
podr&iacute;amos generar las clases necesarias (despu&eacute;s de haber compilado la clase 
<span class="codefrag">Hello</span>) de la siguiente forma:</p>
<pre class="brush:plain;">
wsgen -cp bin -s src -d bin 
      jaxwsHelloServer.Hello</pre>
<p>Con esto habremos creado las clases necesarias para publicar el servicio. Con JDK 1.6
no ser&aacute; necesario contar con un servidor de aplicaciones para publicar este servicio, 
sino que lo podremos publicar desde cualquier aplicaci&oacute;n Java. Podemos publicar
el servicio de la siguiente forma:</p>
<pre class="brush:java;">
package jaxwsHelloServer;

import javax.xml.ws.Endpoint;

public class Servicio {
  public static void main(String[] args) {
    Endpoint.publish(
      "http://localhost:8080/ServicioWeb/Hello",
       new Hello());
  }
}</pre>
<p>El m&eacute;todo <span class="codefrag">Endpoint.publish</span> utiliza por defecto un contenedor servidor HTTP "ligero" que
  viene incluido con Java SE 6 y adem&aacute;s nos permite desplegar nuestro servicio web sin tener que
  empaquetar ni desplegar nuestra aplicaci&oacute;n. Esto es particularmente &uacute;til y pr&aacute;ctico durante el desarrollo.
  De esta forma no es necesario tener en marcha Glassfish, Tomcat o cualquier otro servidor. De hecho, si 
  previamente tenemos en marcha una instancia de alg&uacute;n otro servidor utilizando el mismo puerto, al hacer la llamada a
  <span class="codefrag">Endpoint.publish</span> nos dar&aacute; un error inform&aacute;ndonos de que dicho puerto ya est&aacute; en uso.</p>
<p>Cuando ejecutemos la aplicaci&oacute;n, podremos acceder al WSDL del servicio a trav&eacute;s de 
cualquier navegador en la siguiente direcci&oacute;n:</p>
<pre class="brush:plain;">http://localhost:8080/ServicioWeb/Hello?WSDL</pre>
</div>


<a name="N104A8"></a><a name="Creaci%C3%B3n+de+un+servicio+Web+JAX-WS+con+Maven"></a>
<h2 class="underlined_10">Creaci&oacute;n de un servicio Web JAX-WS con Maven</h2>
<div class="section">
<p>Vamos a ilustrar c&oacute;mo, a partir de una clase java, y utilizando el modelo de programaci&oacute;n de <em>servlets</em>, 
  podemos construir, empaquetar y desplegar un servicio Web 
   JAX-WS con Maven. Utilizaremos para ello la clase <span class="codefrag">expertoJava.Hola</span> como
   clase que va a implementar nuestro servicio Web. 
</p>
<p>Comenzamos creando una aplicaci&oacute;n Web con Maven (similar a la que creamos para nuestro
   cliente Web del servicio en la sesi&oacute;n anterior)
</p>
<pre class="brush:plain;">
mvn archetype:generate -DgroupId=expertoJava 
                       -DartifactId=HolaMundo 
                       -Dversion=1.0-SNAPSHOT 
                       -DarchetypeArtifactId=webapp-javaee6
                       -DarchetypeGroupId=org.codehaus.mojo.archetypes
                       -DinteractiveMode=false
</pre>
<p>A&ntilde;adiremos en nuestro pom el plugin para desplegar nuestro proyecto en glassfish (<strong>maven-glassfish-plugin</strong>),
   utilizando la goal <em>glassfish:deploy</em>:</p>
<pre class="brush:xml;">
&lt;plugin&gt;
   &lt;groupId&gt;org.glassfish.maven.plugin&lt;/groupId&gt;
   &lt;artifactId&gt;maven-glassfish-plugin&lt;/artifactId&gt;
   &lt;version&gt;2.1&lt;/version&gt;
   &lt;configuration&gt;
      &lt;user&gt;admin&lt;/user&gt;
      &lt;passwordFile&gt;/opt/glassfish-3.1.2.2/glassfish/domains/domain1/master-password
      &lt;/passwordFile&gt;
      &lt;glassfishDirectory&gt;/opt/glassfish-3.1.2.2/glassfish&lt;/glassfishDirectory&gt;
      &lt;domain&gt;
         &lt;name&gt;domain1&lt;/name&gt;
         &lt;adminPort&gt;4848&lt;/adminPort&gt;
         &lt;httpPort&gt;8080&lt;/httpPort&gt;
      &lt;/domain&gt;
      &lt;components&gt;
         &lt;component&gt;
            &lt;name&gt;HolaMundo&lt;/name&gt;
            &lt;artifact&gt;target/HolaMundo-1.0-SNAPSHOT.war&lt;/artifact&gt;
         &lt;/component&gt;
      &lt;/components&gt;
   &lt;/configuration&gt;
&lt;/plugin&gt;
  
</pre>
<p>Para generar los artefactos necesarios en la parte del servidor del servicio web no es necesario que incluyamos
   ning&uacute;n <em>plugin</em> adicional en el pom de nuestro proyecto (plugin wsgen). Durante del despliegue se generar&aacute;n autom&aacute;ticamente
   los ficheros necesarios (entre ellos el SEI de nuestro servicio Web) para poder utilizar nuestro servicio Web.</p>
<div class="frame note">
<div class="label">Nombres de los artefactos generados por Maven</div>
<div class="content">
Por defecto, el nombre del artefacto generado por Maven est&aacute; formado por el artifactId de nuestro proyecto
seguido de la versi&oacute;n del mismo (por ejemplo, en nuestro ejemplo se genera el artefacto <em>HolaMundo-1.0-SNAPSHOT.war</em>).
Para utilizar cualquier otro nombre de nuestra elecci&oacute;n simplemente tendremos que indicarlo utilizando la
etiqueta &lt;finalName&gt;nombre-artefacto-que-queramos&lt;/finalName&gt;, dentro de la etiqueta 
&lt;build&gt;&lt;/build&gt; de nuestro <em>pom.xml</em>

</div>
</div>
<p>Ahora creamos nuestro servicio web como la clase <span class="codefrag">src/main/java/expertoJava/Hola.java</span> 
   anotada con <span class="codefrag">@Webservice</span>. El c&oacute;digo ser&aacute; el siguiente:
</p>
<pre class="brush:java;">
package expertoJava;

import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebService;

@WebService
public class Hola {

    @WebMethod(operationName = "hello")
    public String hello(@WebParam(name = "name") String txt) {
        return "Hola " + txt + " !";
    }
}
</pre>
<p>Como ya se ha comentado, NO es necesario configurar el despliegue utilizando <span class="codefrag">/src/main/webapp/WEB-INF/web.xml</span> 
   y <span class="codefrag">/src/main/webapp/WEB-INF/sun-jaxws.xml</span> porque vamos a desplegar nuestro servicio Web sobre Glassfish.
 </p>
<p>Ahora ya estamos en disposici&oacute;n de compilar y desplegar nuestro servicio web:</p>
<pre class="brush:plain;">
mvn clean package
</pre>
<p>Recordemos que el servidor de aplicaciones debe estar en marcha para poder desplegar nuestro servico web
con:</p>
<pre class="brush:plain;">
./asadmin start-domain --verbose   (desde /opt/glassfish-3.1.2.2/bin)
mvn glassfish:deploy  (desde el raiz de nuestro proyecto)</pre>
<p>Podemos ver el <em>wsdl</em> generado en:</p>
<pre class="brush:plain;">http://localhost:8080/HolaMundoRaizContexto/HolaService?wsdl</pre>
<p>Suponemos que la ra&iacute;z del contexto se ha definido como "HolaMundoRaizContexto" en el fichero 
   <em>src/main/webapp/WEB-INF/glassfish-web.xml</em>. Por defecto, si no especificamos el nombre del servicio
   en el atributo <em>serviceName</em> de la anotaci&oacute;n <em>@WebService</em>, &eacute;ste es el nombre de la clase, seguido
   del sufijo "Service".</p>
<p>Dicho <em>wsdl</em> se genera autom&aacute;ticamente al desplegar el servicio. Tambi&eacute;n se genera de forma autom&aacute;tica 
   c&oacute;digo para probar los servicios desplegados. Siguiendo con nuestro ejemplo, podremos probar nuestro servicio en la 
   direcci&oacute;n: </p>
<pre class="brush:plain;">http://localhost:8080/HolaMundoRaizContexto/HolaService?tester</pre>
</div>


<a name="N10529"></a><a name="Creaci%C3%B3n+de+servicios+web+con+Netbeans"></a>
<h2 class="underlined_10">Creaci&oacute;n de servicios web con Netbeans</h2>
<div class="section">
<p>Vamos a ver a continuaci&oacute;n c&oacute;mo crear servicios web paso a paso utilizando Netbeans.
Seguiremos un ejemplo del servicio web de conversi&oacute;n (de euros a ptas y viceversa) 
para ilustrar el procedimiento que utilizaremos en Netbeans para crear un servicio web. 
Seguiremos los siguiente pasos:</p>
<p>Lo primero que necesitamos es un contenedor en el que crear nuestros servicios. Este contenedor ser&aacute; normalmente
un proyecto web de Netbeans, aunque tambi&eacute;n podr&iacute;amos utilizar un m&oacute;dulo EJB. Para nuestro ejemplo guiado
vamos a crear un nuevo proyecto web llamado <span class="codefrag">ConversionWeb</span> al que a&ntilde;adiremos nuestro servicio.
</p>
<p>
<img alt="Creaci&oacute;n del proyecto ConversionWeb" content-width="10cm" src="imagenes/sesion2/nb-soap-conv-new.jpg" width="650"></p>
<p>Una vez tenemos el proyecto web en el que introducir el servicio, pinchamos sobre &eacute;l con el bot&oacute;n derecho
y seleccionamos <strong><em>New &gt;  Web Service ...</em></strong> para a&ntilde;adir un servicio web.</p>
<p>Introduciremos el nombre que le queremos dar al servicio (nombre de la clase que implementar&aacute; el servicio) y el paquete en el que 
estar&aacute;. Aqu&iacute; podemos crear un servicio web desde cero, o bien utilizar un EJB de sesi&oacute;n existente. Si utiliz&aacute;semos
esta segunda opci&oacute;n, los m&eacute;todos del EJB se ofrecer&iacute;an como operaciones del servicio web de forma autom&aacute;tica, 
sin necesidad de hacer nada m&aacute;s. Para nuestro ejemplo vamos a quedarnos con la opci&oacute;n por defecto, que es crear
el servicio web desde cero en una nueva clase Java plana.</p>
<p>
<img alt="Creaci&oacute;n del servicio Web ConversionSW" content-width="10cm" src="imagenes/sesion2/nb-soap-conv-newWS.jpg" width="550"></p>
<p>Una vez pulsemos el bot&oacute;n <em>Finish</em> se crear&aacute; el servicio. En la vista de c&oacute;digo podemos ver que se ha 
creado la clase <em>ConversionSW.java</em>.</p>
<p>
<img alt="Vista de c&oacute;digo del servicio Web creado" content-width="10cm" src="imagenes/sesion2/nb-soap-conv-newWS-2.jpg" width="550"></p>
<p>Ahora vamos a&ntilde;adir una operaci&oacute;n a nuestro servicio, pulsando con el bot&oacute;n derecho sobre el servicio creado y eligiendo la 
   opci&oacute;n "Add operation".</p>
<p>
<img alt="A&ntilde;adimos una operaci&oacute;n al servicio Web" content-width="8cm" src="imagenes/sesion2/nb-soap-conv-addOp.jpg" width="400"></p>
<p>Al a&ntilde;adir una operaci&oacute;n deberemos especificar su nombre, el tipo de datos devuelto, y sus par&aacute;metros. En
nuestro caso crearemos la funci&oacute;n <span class="codefrag">euro2ptas</span>, con un par&aacute;metro <span class="codefrag">euros</span> de tipo <span class="codefrag">double</span>,
y que devuelve un valor de tipo <span class="codefrag">int</span>.</p>
<p>
<img alt="Datos de la operaci&oacute;n euro2ptas" content-width="8cm" src="imagenes/sesion2/nb-soap-conv-addOp2.jpg" width="400"></p>
<p>Una vez a&ntilde;adida la operaci&oacute;n, en la vista de c&oacute;digo vemos el esqueleto de la implementaci&oacute;n de nuestro servicio. Deberemos introducir en el m&eacute;todo
<span class="codefrag">euro2ptas</span> el c&oacute;digo que realice la conversi&oacute;n de euros a pesetas.</p>
<p>
<img alt="Implementaci&oacute;n de la operaci&oacute;n euro2ptas" content-width="10cm" src="imagenes/sesion2/nb-soap-conv-newWS-3.jpg" width="550"></p>
<p>Con esto ya tenemos implementado el servicio. Ahora podemos desplegar nuestro servicio con la opci&oacute;n "Run", con el bot&oacute;n derecho sobre el nodo del proyecto.</p>
<p>
<img alt="Despliegue de la aplicaci&oacute;n ConversionSW" content-width="8cm" src="imagenes/sesion2/nb-soap-conv-run.jpg" width="496"></p>
<p>Podemos ver c&oacute;mo est&aacute; configurada por defecto la opci&oacute;n "Run" del men&uacute; contextual del proyecto (y tambi&eacute;n el resto de opciones de dicho
  men&uacute;), seleccionando
   <em>"Properties"</em> y a continuaci&oacute;n <em>Actions</em> en el panel de la izquierda, y la acci&oacute;n <em>"Run Project"</em> de la lista
   de acciones de la derecha. En la siguiente figura se muestra el comando maven que se ejecuta cuando seleccionamos la opci&oacute;n <em>"Run"</em>
   del men&uacute; contextual del proyecto.  </p>
<p>
<img alt="Acci&oacute;n asociada a la opci&oacute;n de men&uacute; contextual Run" content-width="8cm" src="imagenes/sesion2/conversion-ejb-5.png" width="500"></p>
<p>Una vez la aplicaci&oacute;n est&eacute; ejecut&aacute;ndose en el servidor, podremos probar el servicio pinchando sobre &eacute;l servicio Web
con el bot&oacute;n derecho y seleccionando la opci&oacute;n <strong><em>Test Web Service</em></strong>.</p>
<p>
<img alt="Invocaci&oacute;n de la prueba del servicio web" content-width="8cm" src="imagenes/sesion2/nb-soap-conv-test.jpg" width="435"></p>
<p>Se abrir&aacute; en el navegador una web desde la que podremos probar el servicio. En ella podremos observar un 
<strong>enlace al documento WSDL</strong> que define el servicio, el cual nos resultar&aacute; de utilidad cuando queramos crear un cliente
que acceda a &eacute;l, y la lista de operaciones que ofrece. Para cada operaci&oacute;n tendremos cuadros de texto para
introducir el valor de los par&aacute;metros de entrada que necesita, y un bot&oacute;n para invocarla. </p>
<p>
<img alt="Ejecuci&oacute;n de la prueba del servicio web" content-width="8cm" src="imagenes/sesion2/nbsw_9.gif" width="600"></p>
<p>Si probamos la operaci&oacute;n <em>euro2ptas</em> pasando como par&aacute;metro <em>18.95</em>, veremos el resultado de
invocar el servicio, y adem&aacute;s abajo en la misma p&aacute;gina se mostrar&aacute;n los mensajes SOAP utilizados para dicha
invocaci&oacute;n.</p>
<p>
<img alt="Resultado de la prueba del servicvio web" content-width="5cm" height="270" src="imagenes/sesion2/nbsw_10.gif" width="270"></p>
</div>


<a name="N105DC"></a><a name="Creaci%C3%B3n+de+servicios+a+partir+de+EJBs+existentes"></a>
<h2 class="underlined_10">Creaci&oacute;n de servicios a partir de EJBs existentes</h2>
<div class="section">
<p>Adem&aacute;s de poder crear servicios web desde cero, tambi&eacute;n podremos crearlos a partir de EJBs existentes. De esta forma
lo que estaremos haciendo es exportar las operaciones de los EJBs en forma de servicios web, para poder acceder a ellas
desde aplicaciones desarrolladas en otras plataformas o en cualquier otro lugar de la red.</p>
<p>Con Netbeans crear un servicio web a partir de un EJB es inmediato. Supongamos que tenemos un EJB en nuestra aplicaci&oacute;n
llamado <span class="codefrag">ConversionEJBBean</span>, que proporciona las operaciones <span class="codefrag">euros2ptas</span> y <span class="codefrag">ptas2euros</span>. Podremos
exportar dichas operaciones en forma de servicio web de la siguiente forma:</p>
<p>Crearemos un nuevo servicio web en nuestro proyecto, con <em>New-&gt;Web Service...</em>al igual que en el caso anterior. </p>
<p>Ahora, adem&aacute;s del nombre del servicio y el paquete en el que queremos crear sus clases, deberemos
especificar que cree el servicio web a partir de un EJB (<strong><em>Create Web Service from Existing 
Session Bean</em></strong>), y pulsamos el bot&oacute;n <em>Browse ...</em> para seleccionar el EJB a partir del
cual queramos crear el servicio.</p>
<p>
<img alt="Creaci&oacute;n de un servicio a partir de un EJB" content-width="8cm" height="321" src="imagenes/sesion2/nbejb_2.gif" width="380"></p>
<p>Seleccionaremos el EJB que queremos utilizar (en nuestro caso <span class="codefrag">ConversionEJBBean</span>), 
y pulsamos <em>OK</em> y a continuaci&oacute;n <em>Finish</em> para finalizar la creaci&oacute;n del servicio web.</p>
<p>
<img alt="Selecci&oacute;n del EJB para crear el servicio" content-width="5cm" height="218" src="imagenes/sesion2/nbejb_3.gif" width="229"></p>
<p>Con esto podremos acceder a las operaciones de nuestro EJB de sesi&oacute;n mediante un servicio web. A continuaci&oacute;n mostramos
   el c&oacute;digo de nuestro servicio Web, creado a partir del EJB existente:</p>
<pre class="brush:java;"> 
package jtech;

import javax.ejb.EJB;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebService;

@WebService(serviceName = "ConversionSW")
public class ConversionSW {
    @EJB
    private jtech.ConversionEJBBeanLocal ejbRef;

    @WebMethod(operationName = "euro2ptas")
    public int euro2ptas(@WebParam(name = "euros") double euros) {
        return ejbRef.euro2ptas(euros);
    }

    @WebMethod(operationName = "ptas2euros")
    public double ptas2euros(@WebParam(name = "ptas") int ptas) {
        return ejbRef.ptas2euros(ptas);
    }    
}   
</pre>
</div>



<a name="N10626"></a><a name="Creaci%C3%B3n+de+servicios+a+partir+del+WSDL"></a>
<h2 class="underlined_10">Creaci&oacute;n de servicios a partir del WSDL</h2>
<div class="section">
<p>Hemos visto como crear con Netbeans servicios web a partir de c&oacute;digo
Java que ya tenemos implementado. Esta es la forma m&aacute;s inmediata de 
crear servicios web, sin embargo, si lo que buscamos es una alta
interoperabilidad, no resulta la forma m&aacute;s adecuada de hacerlo. 
Podr&iacute;a darnos problemas sobre todo en el caso en que nuestras operaciones
intercambien tipos de datos complejos, ya que podr&iacute;amos tener problemas
al intentar recomponer dichos tipos desde clientes de diferentes
plataformas.</p>
<p>Lo fundamental en un servicio web SOAP es el <strong>contrato</strong> que existe entre
cliente y servicio, es decir, el documento WSDL. Por lo tanto, a la hora de
crear servicios web complejos es recomendable empezar definiendo dicho
contrato. De esta forma tendremos mayor control sobre los datos que
se serializan durante la invocaci&oacute;n del servicio, con lo que podremos
definir las estructuras de datos que consideremos m&aacute;s adecuadas para
el intercambio. Una vez definido el contrato (WSDL), generaremos a partir
de &eacute;l el esqueleto para la implementaci&oacute;n del servicio que cumpla con
dicho contrato.</p>
<p>
<strong>Creamos el WSDL y fichero de esquema</strong>
</p>
<p>En Netbeans podremos generar un servicio web a partir de un documento
WSDL de forma sencilla. Lo primero que deberemos hacer es escribir el
documento WSDL, y el esquema asociado que definir&aacute; nuestro servicio. 
Ya hemos visto c&oacute;mo hacer &eacute;sto en la sesi&oacute;n anterior. Recordemos que tenemos 
que pinchar con el bot&oacute;n derecho sobre nuestro proyecto y seleccionar
<em>New &gt; Other ...</em>. Nos aparecer&aacute; la ventana para crear un nuevo 
fichero, y dentro de ella seleccionaremos la categor&iacute;a <em>XML</em> y 
el tipo <em>XML Schema</em> (para el fichero de esquema), y <em>WSDL Document</em>, 
para el documento WSDL. Al continuar con el asistente, podremos
introducir los datos b&aacute;sicos del documento WSDL , como su nombre, espacio de
nombres, puertos, operaciones, mensajes, tipo de codificaci&oacute;n, nombre del
servicio, etc.</p>
<p>Una vez hayamos terminado de escribir el documento WSDL que actuar&aacute; como
contrato de nuestro servicio, deberemos crear nuestro servicio web. Para
crear un servicio web que se ajuste a dicho contrato pincharemos con el bot&oacute;n
derecho sobre nuestro proyecto y seleccionaremos <em>New &gt; Web Service from WSDL...</em>.
Tras rellenar todos los datos del asistente se generar&aacute;n una serie de clases
con el esqueleto de la implementaci&oacute;n de nuestro servicio y los tipos de datos
necesarios. Ahora deberemos rellenar el c&oacute;digo de cada operaci&oacute;n del servicio
para darle su funcionalidad, y con esto habremos terminado de implementar nuestro
servicio.</p>
</div>


<a name="N1064F"></a><a name="Paso+de+datos+binarios"></a>
<h2 class="underlined_10">Paso de datos binarios</h2>
<div class="section">
<p>Supongamos que queremos crear un servicio Web que proporcione informaci&oacute;n binaria, por ejemplo
   ficheros de im&aacute;genes en formato <em>jpg</em>. 
   Por defecto, la infraestructura de servicios de JAX-WS no puede informar a los clientes sobre c&oacute;mo tienen
   que interpretar los datos binarios. Es decir, si en un mensaje SOAP incluimos datos binarios, &eacute;stos tendr&aacute;n asociado el tipo 
   <em>base64Binary</em>, que ser&aacute; mapeado a un array de <em>bytes</em>, y por lo tanto, el cliente tiene que saber
   c&oacute;mo interpretar adecuadamente dichos datos.</p>
<p>Para poder enviar en nuestro mensaje SOAP un objeto <em>java.awt.Image</em>, por ejemplo, y que el cliente lo reciba como tal
   (y no como un array de bytes que posteriormente tenga que convertir al tipo <em>java.awt.Image</em>), b&aacute;sicamente lo que
   tendremos que hacer ser&aacute; editar el fichero de esquema generado para que devuelva datos binarios de tipo <em>image/jpeg</em>,
   y a continuaci&oacute;n modificaremos el fichero wsdl para que utilice el fichero de esquema con la nueva configuraci&oacute;n.</p>
<p>En el fichero de esquema (<em>.xsd</em>) tenemos que a&ntilde;adir el atributo <span class="codefrag">expectedContentTypes="mime_type"</span> al
   elemento que devuelve los datos binarios (especificado mediante el atributo 
   <span class="codefrag">type=xs:bas64Binary</span> o <span class="codefrag">type=xs:hexBinary</span>). Este atributo (<em>expectedContentTypes</em>) informa 
   al cliente de que debe mapear los datos binarios a un
   tipo Java (seg&uacute;n las reglas de mapeado de tipo MIME a tipos Java), en lugar de a un array de bytes. A continuaci&oacute;n mostramos
   una tabla que muestra el mapeado entre tipos MIME y typos Java.
</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
    
<th colspan="1" rowspan="1">MIME Type</th>
    <th colspan="1" rowspan="1">Java Type</th>
  
</tr>
  
<tr>
   
<td colspan="1" rowspan="1">image/gif</td>
   <td colspan="1" rowspan="1">java.awt.Image</td>
  
</tr>
  
<tr>
   
<td colspan="1" rowspan="1">image/jpeg</td>
   <td colspan="1" rowspan="1">java.awt.Image</td>
  
</tr>
  
<tr>
   
<td colspan="1" rowspan="1">text/plain</td>
   <td colspan="1" rowspan="1">java.lang.String</td>
  
</tr>  
  
<tr>
   
<td colspan="1" rowspan="1">text/xml or application/xml</td>
   <td colspan="1" rowspan="1">javax.xml.transform.Source</td>
  
</tr> 
  
<tr>
   
<td colspan="1" rowspan="1">*/*</td>
   <td colspan="1" rowspan="1">javax.activation.DataHandler</td>
  
</tr>     

</table>
<div class="frame note">
<div class="label">Sobre tipos Mime</div>
<div class="content">
MIME es un est&aacute;ndar que clasifica los recursos y provee informaci&oacute;n (a los programas) acerca de c&oacute;mo manejarlos. Esto permite 
la correcta manipulaci&oacute;n e interpretaci&oacute;n de diferentes tipos de archivos por parte de los programas (como navegadores). 
Por ejemplo, gracias a MIME, los navegadores pueden abrir correctamente un archivo ".txt" como un recurso de texto plano 
y no como un video u otro tipo.

Cuando un tipo MIME no es especificado para un recurso, el programa que lo maneje puede "suponerlo" a partir de la extensi&oacute;n 
del mismo (por ejemplo, un archivo con la extenci&oacute;n ".bmp" deber&iacute;a contener una imagen de mapa de bits). Pero esto puede no 
siempre dar buenos resultados ya que una sola extensi&oacute;n puede asociarse a m&aacute;s de un formato. Por su parte, los tipos MIME son 
&uacute;nicos. &Eacute;sta es la principal raz&oacute;n para utilizar los tipos MIME siempre que sea posible.
</div>
</div>
<p>As&iacute;, por ejemplo, el siguiente elemento:</p>
<pre class="brush:xml;">
&lt;element name="image" type="base64Binary"/&gt;
</pre>
<p>ser&aacute; mapeado a <strong>byte []</strong>
</p>
<p>mientras que el elemento:</p>
<pre class="brush:xml;">
&lt;element name="image" type="base64Binary" 
            xmime:expectedContentTypes="image/jpeg" 
            xmlns:xmime="http://www.w3.org/2005/05/xmlmime"/&gt;
</pre>
<p>ser&aacute; mapeado a <strong>java.awt.Image</strong>
</p>
<p>Vamos a ilustrar el uso de este atributo con un ejemplo. Supongamos que tenemos un servicio Web que
 proporciona fotos, en este caso, de flores de jard&iacute;n, en formato <em>jpeg</em>.
</p>
<p>Nuestro servicio Web, denominado <em>FlowerService</em> proporciona la operaci&oacute;n <em>getFlower</em>. Dicha 
   operaci&oacute;n tiene como entrada un <em>string</em> que representa el nombre de una flor, y como salida el fichero
   <em>jpg</em> con la foto de dicha flor, o bien una excepci&oacute;n en caso de no existir dicho fichero.</p>
<p>A continuaci&oacute;n mostramos un extracto del wsdl con los mensajes asociados a la operaci&oacute;n <em>getFlower</em>:</p>
<pre class="brush:xml;">
 &lt;!-- extra&iacute;do de FlowerService.wsdl --&gt;
  &lt;message name="getFlower"&gt;
     &lt;part name="parameters" element="tns:getFlower"/&gt;
  &lt;/message&gt;

  &lt;message name="getFlowerResponse"&gt;
     &lt;part name="parameters" element="tns:getFlowerResponse"/&gt;
  &lt;/message&gt;

  &lt;message name="IOException"&gt;
     &lt;part name="fault" element="tns:IOException"/&gt;
  &lt;/message&gt;
  
  &lt;portType name="FlowerService"&gt;
     &lt;operation name="getFlower"&gt;
        &lt;input message="tns:getFlower"/&gt;
        &lt;output message="tns:getFlowerResponse"/&gt;
        &lt;fault message="tns:IOException" name="IOException"/&gt;
     &lt;/operation&gt;
  &lt;/portType&gt; 
</pre>
<p>La definici&oacute;n de tipos correspondiente en el fichero de esquema <em>xsd</em> es la siguiente:</p>
<pre class="brush:xml;">
 &lt;!-- extracto de FlowerService.xsd --&gt;
 &lt;xs:element name="getFlower" type="tns:getFlower"/&gt; 
 &lt;xs:element name="getFlowerResponse" type="tns:getFlowerResponse"/&gt; 
 &lt;xs:element name="IOException" type="tns:IOException"/&gt; 
 
 &lt;xsd:complexType name="getFlower"&gt;
    &lt;xsd:sequence&gt;
       &lt;xsd:element name="name" type="xs:string" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;

 &lt;xsd:complexType name="getFlowerResponse"&gt;
    &lt;xsd:sequence&gt;
       &lt;xsd:element name="return" type="xs:base64Binary" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;

 &lt;xsd:complexType name="IOException"&gt;
    &lt;xsd:sequence&gt;
       &lt;xsd:element name="message" type="xs:string" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;
 
</pre>
<p>Si probamos el servicio web FlowerService mediante <em>Test Web Service</em>, veremos algo parecido a:</p>
<p>
<img alt="Paso de datos binarios como array de bytes" content-width="10cm" src="imagenes/sesion2/binary-flower-tester.png" width="550"></p>
<p>Nosotros queremos ver una imagen, y no una serie de s&iacute;mbolos. Sin embargo, ya que <em>java.awt.Img</em> no es un tipo de
   esquema v&aacute;lido, necesitamos configurar manualmente el fichero de esquema para devolver datos binarios con formato <em>image/jpeg</em>.
</p>
<p>Si el servicio web lo hemos creado en un proyecto web Maven, necesitaremos incluir alguna modificaci&oacute;n en el <em>pom</em> 
   del proyecto. Concretamente tendremos que a&ntilde;adir expl&iacute;citamente el <em>plugin</em> <strong><em>wsgen</em></strong> y poner la
   propiedad <strong>genWsdl</strong> a <strong>true</strong>. Dicha propiedad genera el fichero wsdl de nuestro servicio web
   en el directorio por defecto <em>${project.build.directory}/jaxws/wsgen/wsdl</em> (siendo <em>${project.build.directory}</em>
   el directorio <em>target</em> de nuestro proyecto). A continuaci&oacute;n mostramos las modificaciones a realizar en el fichero
   <em>pom.xml</em>.
</p>
<pre class="brush:xml;">
 &lt;!-- a&ntilde;adimos el plugin wsgen en nuestro pom.xml--&gt;
 &lt;!-- para generar el ficheros wsdl + xsd en target/jaxsw/wsgen/wsdl --&gt;
 &lt;plugin&gt;
   &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
   &lt;artifactId&gt;jaxws-maven-plugin&lt;/artifactId&gt;
   &lt;version&gt;1.10&lt;/version&gt;
   &lt;executions&gt;
      &lt;execution&gt;
         &lt;goals&gt;
            &lt;goal&gt;wsgen&lt;/goal&gt;
         &lt;/goals&gt;
         &lt;configuration&gt;
             &lt;sei&gt;jtech.floweralbumservice.FlowerService&lt;/sei&gt;
             &lt;genWsdl&gt;true&lt;/genWsdl&gt;
         &lt;/configuration&gt;
      &lt;/execution&gt;
   &lt;/executions&gt;
   &lt;dependencies&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;javax&lt;/groupId&gt;
         &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;
         &lt;version&gt;6.0&lt;/version&gt;
      &lt;/dependency&gt;
   &lt;/dependencies&gt;
&lt;/plugin&gt;
 
</pre>
<p>Si volvemos a "compilar" nuestra aplicaci&oacute;n, podemos ver que en el directorio <em>target/jaxws/wsgen/wsdl</em> se
   han generado los ficheros <em>wsdl</em> y <em>xsd</em> de nuestro servicio web. El siguiente paso es "copiar" dichos
   ficheros en el directorio <em>src/main/resources</em>. Cuando compilemos, por defecto todos los ficheros del directorio
   <em>src/main/resources</em> se copiar&aacute;n en el WAR generado en el directorio WEB-INF/classes. 
 </p>
<p> A continuaci&oacute;n vamos a 
   indicar de forma expl&iacute;cita al
   servidor de aplicaciones que queremos usar nuestra propia versi&oacute;n del fichero wsdl (que se encontrar&aacute; en el directorio
   WEB-INF/classes. Si no lo hacemos as&iacute;, el servidor
   de aplicaciones generar&aacute; su propio fichero wsdl. Para ello, lo que tenemos que hacer es indicar de forma
   expl&iacute;cita el atributo <strong>wsdlLocation</strong> de nuestro servicio web, "apuntando" al directorio en donde
   estar&aacute; el wsdl que queremos utilizar. 
 </p>
<pre class="brush:java;">
    //fichero FlowerService.java
    @WebService(serviceName="FlowerService", 
                 wsdlLocation = "WEB-INF/classes/FlowerService.wsdl")
    @Stateless
    public class FlowerService {    
    ...
    @WebMethod(operationName="getFlower")
    public Image getFlower(@WebParam(name="name") String name) throws IOException {
      ...
    }  
    ...
</pre>
<p>A continuaci&oacute;n mostramos la modificaci&oacute;n a realizar en el fichero <em>src/main/resources/FlowerService.xsd</em>:</p>
<pre class="brush:xml;">
 &lt;!-- extracto de FlowerService.xsd modificado con el atributo expectedContentTypes--&gt;

 &lt;xsd:complexType name="getFlowerResponse"&gt;
    &lt;xsd:sequence&gt;
       &lt;xsd:element name="return" type="xs:base64Binary" minOccurs="0"
                    xmime:expectedContentTypes="image/jpeg" 
                    xmlns:xmime="http://www.w3.org/2005/05/xmlmime"/&gt;
    &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;
 
</pre>
<p>Una vez realizadas las modificaciones anteriores, si volvemos a realizar un "test" sobre nuestro servicio Web, 
   veremos un resultado similar al siguiente:</p>
<p>
<img alt="Paso de datos binarios como image/jpeg" content-width="9cm" src="imagenes/sesion2/binary-flower-tester-2.png" width="500"></p>
</div>


<a name="N10786"></a><a name="Servicios+web+con+estado"></a>
<h2 class="underlined_10">Servicios web con estado</h2>
<div class="section">
<p>Una de las caracter&iacute;sticas que m&aacute;s se han echado en falta en los primeros a&ntilde;os de existencia de los 
servicios web es la capacidad de mantener un estado. Los servicios web eran servicios sin estado, en los que
cada llamada era independiente de las dem&aacute;s, y si quer&iacute;amos identificar de alguna forma al cliente que
estaba realizando la llamada deb&iacute;amos proporcionar como par&aacute;metro un identificador creado por nosotros
que nos indicase de qu&eacute; cliente se trataba. Esta carencia complicaba implementar elementos como por ejemplo
un carrito de la compra mediante servicios web, al que pudiesemos a&ntilde;adir productos en sucesivas llamadas.</p>
<p>Para suplir esta carencia se han ideado diferentes t&eacute;cnicas, como por ejemplo el acceder a sesiones HTTP
a trav&eacute;s del objeto <span class="codefrag">WebServiceContext</span>. Tambi&eacute;n encontramos otro enfoque consistente en aprovechar la
tecnolog&iacute;a <em>WS-ReliableMessaging</em> para implementar el estado. Cada canal de datos tiene un identificador
de sesi&oacute;n &uacute;nico, al que podemos acceder a trav&eacute;s de la propiedad <span class="codefrag">com.sun.xml.ws.sessionid</span> del 
objeto <span class="codefrag">WebServiceContext</span>, y que puede ser utilizado para identificar a cada cliente y de 
esta forma mantener su estado.</p>
<p>Sin embargo, a partir de JAX-WS 2.1 aparece la tan esperada posibilidad de crear servicios web con estado
(<em>stateful</em>). En este caso tendremos una instancia diferente de la clase del servicio para cada cliente.
De esta forma, dentro de la clase que implementa el servicio podremos definir variables de instancia (a diferencia de los servicios
<em>stateless</em>, en los que todos los campos deb&iacute;an ser est&aacute;ticos), y cada cliente
acceder&aacute; a sus datos propios (almacenados en los campos de la instancia concreta a la que est&eacute; accediendo).</p>
<p>Estos servicios con estado est&aacute;n basados en la tecnolog&iacute;a <em>WS-Addressing</em>. Esta
tecnolog&iacute;a permite identificar un <em>endpoint</em> de un servicio mediante XML, de forma independiente
al protocolo de transporte que se vaya a utilizar para acceder a &eacute;l. De esta forma se podr&aacute; especificar
no s&oacute;lo la direcci&oacute;n del servicio, sino tambi&eacute;n la instancia concreta a la que deseamos acceder de dicho
servicio.</p>
<p>Vamos a ver un ejemplo sencillo de servicio con estado. Para crear un servicio de este tipo deber&aacute; estar 
anotado con <span class="codefrag">@Addressing</span>, para poder identificar desde el cliente la instancia concreta del 
servicio a la que conectarse, y con <span class="codefrag">@Stateful</span> para marcarlo como servicio web con estado. Al
estar marcado de esta forma, el contenedor le inyectar&aacute; de forma autom&aacute;tica un objeto de tipo 
<span class="codefrag">StatefulWebServiceManager</span> en un campo <span class="codefrag">manager</span> que ser&aacute; p&uacute;blico y est&aacute;tico 
(o bien privado y accesible mediante <em>getters</em> y <em>setters</em>).</p>
<pre class="brush:java;">
@Stateful
@WebService
@Addressing
public class CuentaSW {

    private int id;
    private int saldo;

    public CuentaSW(int id) {
        this.id = id;
        this.saldo = 0;
    }

    public void ingresar(int cantidad) {
        saldo += cantidad;
    }

    public int saldo() {
        return saldo;
    }
    
    public void cerrar() {
        manager.unexport(this);
    }
    
    public static StatefulWebServiceManager&lt;CuentaSW&gt; manager;
}
</pre>
<p>Sabemos que cada cliente tendr&aacute; acceso a una instancia de este servicio. Pero, &iquest;cu&aacute;ndo se crea dicha instancia?
&iquest;y qui&eacute;n ser&aacute; el encargado de crearla? No puede hacerse autom&aacute;ticamente cuando desde el cliente llega una
petici&oacute;n, ya que no conocemos qu&eacute; par&aacute;metros hay que pasarle al constructor (por esa raz&oacute;n los servicios 
<em>stateless</em> deben tener un constructor vac&iacute;o, que es el que utiliza el contenedor para instanciarlos). 
Por lo tanto, estos servicios con estado deber&aacute;n ser instanciados desde otros servicios. Por ejemplo, si 
queremos acceder a nuestra cuenta podemos hacerlo a trav&eacute;s de un servicio <span class="codefrag">BancoSW</span> como el
siguiente:</p>
<pre class="brush:java;">@WebService
public class BancoSW {

    static Map&lt;Integer, CuentaSW&gt; cuentas = new HashMap();

    @WebMethod
    public synchronized W3CEndpointReference abrirCuenta(int id) {
        CuentaSW c = cuentas.get(id);
        if (c == null) {
            c = new CuentaSW(id);
            cuentas.put(id, c);
        }

        W3CEndpointReference endpoint = CuentaSW.manager.export(c);       
        return endpoint;
    }
}</pre>
<p>Lo &uacute;nico que tiene de especial este servicio es que como resultado nos devuelve un objeto 
<span class="codefrag">W3CEndpointReference</span>, es decir, una referencia a un <em>endpoint</em> codificada mediante
<em>WS-Addressing</em>. El <em>endpoint</em> al que har&aacute; referencia ser&aacute; a la instancia del servicio
<span class="codefrag">CuentaSW</span> correspondiente a la cuenta solicitada. De esta forma cada cliente podr&aacute; acceder a una
cuenta diferente, manteniendo cada una de ellas su estado por separado.</p>
<p>Podemos destacar tambi&eacute;n que la operaci&oacute;n <span class="codefrag">export</span> del <em>manager</em> de la cuenta es la
que genera la referencia al <em>endpoint</em>. Cuando queramos cerrar la sesi&oacute;n podemos utilizar 
<span class="codefrag">unexport</span> para que la instancia especificada del servicio deje de estar disponible como 
servicio web.</p>
<p>Vamos ahora a ver c&oacute;mo accederemos a este servicio desde el cliente. Para ello lo primero que deberemos
hacer es crear en nuestro proyecto cliente los <em>stubs</em> para acceder a los dos servicios 
creados anteriormente (al igual que hicimos en la sesi&oacute;n anterior). Una vez hecho esto podremos introducir
el c&oacute;digo del cliente como se muestra a continuaci&oacute;n:</p>
<pre class="brush:java;">BancoSWService bService = new BancoSWService();
CuentaSWService cService = new CuentaSWService();
BancoSW bPort = bService.getBancoSWPort();
                             
W3CEndpointReference endpoint = bPort.abrirCuenta(1);

CuentaSW c = cService.getPort(endpoint,CuentaSW.class);              

c.ingresar(10);
c.ingresar(5);
out.println("Saldo: " + c.saldo());
c.ingresar(20);
out.println("Nuevo saldo: " + c.saldo());
c.cerrar();</pre>
<p>Podemos observar que creamos los servicios <span class="codefrag">BancoSW</span> y <span class="codefrag">CuentaSW</span> igual que cualquier
otro servicio. El puerto del banco tambi&eacute;n se obtiene de la misma forma que anteriormente, y a partir de &eacute;l
podemos llamar a la operaci&oacute;n <span class="codefrag">abrirCuenta</span> para obtener el <em>endpoint</em> de la cuenta a la
que queremos acceder. Ahora es cuando viene la parte diferente, ya que el puerto de la cuenta deber&aacute; 
obtenerse para que acceda al <em>endpoint</em> concreto que nos ha suministrado el banco. Para ello debemos
utilizar una versi&oacute;n alternativa del m&eacute;todo <span class="codefrag">getPort</span> sobre el servicio <span class="codefrag">CuentaSWService</span>. En
esta versi&oacute;n deberemos suministar tanto el <em>endpoint</em> obtenido, como la clase que define el tipo de puerto
al que accederemos (<span class="codefrag">CuentaSW</span>). Esta versi&oacute;n de <span class="codefrag">getPort</span> s&oacute;lo est&aacute; disponible a partir de
JAX-WS 2.1, por lo que con versiones anteriores de la librer&iacute;a no podremos acceder a este tipo de 
servicios. </p>
</div>






<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Dept. Ciencia de la Computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
