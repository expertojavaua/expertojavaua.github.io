<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Acceso a datos</title>
<link type="text/css" href="skin/highlight/shCore.css" rel="stylesheet">
<link type="text/css" href="skin/highlight/shThemeEclipse.css" rel="stylesheet">
<script src="skin/highlight/shCore.js" type="text/javascript"></script><script src="skin/highlight/shAutoloader.js" type="text/javascript"></script>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://web.ua.es/especialistajava"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Experto Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Spring" src="images/baner_j2ee_der.gif" title="Spring"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li>
<a class="base-not-selected" href="index.html">Spring</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_1.1', 'skin/')" id="menu_1.1Title" class="menutitle">Spring</div>
<div id="menu_1.1" class="menuitemgroup">
<div class="menuitem">
<a href="index.html" title="Spring">Indice</a>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion02-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Acceso a datos</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#La+filosof%C3%ADa+del+acceso+a+datos+en+Spring">La filosof&iacute;a del acceso a datos en Spring</a>
</li>
<li>
<a href="#Uso+de+JDBC">Uso de JDBC</a>
<ul class="minitoc">
<li>
<a href="#JDBCTemplate">JDBCTemplate</a>
</li>
<li>
<a href="#Consultas+de+selecci%C3%B3n">Consultas de selecci&oacute;n</a>
</li>
<li>
<a href="#Consultas+de+actualizaci%C3%B3n">Consultas de actualizaci&oacute;n</a>
</li>
</ul>
</li>
<li>
<a href="#Uso+de+JPA">Uso de JPA</a>
<ul class="minitoc">
<li>
<a href="#Formas+de+acceder+a+la+%22EntityManagerFactory%22">Formas de acceder a la "EntityManagerFactory"</a>
</li>
<li>
<a href="#JpaTemplate">JpaTemplate</a>
</li>
</ul>
</li>
<li>
<a href="#Transaccionalidad+declarativa">Transaccionalidad declarativa</a>
<ul class="minitoc">
<li>
<a href="#El+%22Transaction+Manager%22">El "Transaction Manager"</a>
</li>
<li>
<a href="#La+anotaci%C3%B3n+%40Transactional">La anotaci&oacute;n @Transactional</a>
</li>
<li>
<a href="#Transaccionalidad+y+uso+directo+de+JDBC">Transaccionalidad y uso directo de JDBC</a>
</li>
</ul>
</li>
</ul>
</div>

<p>En este tema veremos las facilidades que proporciona Spring para implementar nuestros objetos de la capa de acceso a datos. Veremos que nos permite
simplificar el c&oacute;digo, reduciendo el c&oacute;digo repetitivo, y uniformizar el tratamiento independientemente de la
implementaci&oacute;n subyacente (JPA, JDBC, ...). Finalmente abordaremos la transaccionalidad, que es un aspecto &iacute;ntimamente ligado con el acceso a datos, aunque su gesti&oacute;n no suele estar localizada en el c&oacute;digo de los DAOs sino en la capa de negocio.</p>
 
<p>Debido al auge en los &uacute;ltimos a&ntilde;os del <em>big data</em> en la web, la "punta de lanza" de Spring en la capa de acceso a datos se ha movido m&aacute;s hacia la integraci&oacute;n en Spring de bases de datos no relacionales (NoSQL). El proyecto Spring que se ocupa de estos aspectos es Spring Data, que, no obstante, queda fuera del &aacute;mbito de estos apuntes.</p>

<a name="N10015"></a><a name="La+filosof%C3%ADa+del+acceso+a+datos+en+Spring"></a>
<h2 class="underlined_10">La filosof&iacute;a del acceso a datos en Spring</h2>
<div class="section">
<p>Spring proporciona b&aacute;sicamente dos ventajas a la hora de dar soporte a nuestros DAOs: </p>
<ul>
        
<li>Simplifica las operaciones de acceso a datos en APIs tediosos de utilizar como JDBC, proporcionando
    una capa de abstracci&oacute;n que reduce la necesidad de c&oacute;digo repetitivo. Para ello se usan los denominados <em>templates</em>,
que son clases que implementan este c&oacute;digo, permitiendo que nos concentremos en la parte "interesante".</li>
        
<li>Define una rica jerarqu&iacute;a de excepciones que modelan todos los problemas que nos podemos encontrar
    al operar con la base de datos, y que son independientes del API empleado.</li>
    
</ul>
<p>Un <strong>template</strong> de acceso a datos en Spring es una clase que encapsula los detalles m&aacute;s tediosos
   (como por ejemplo la necesidad de abrir y cerrar la conexi&oacute;n con la base de datos en JDBC), permitiendo
que nos ocupemos &uacute;nicamente de la parte de c&oacute;digo que hace realmente la tarea (inserci&oacute;n, consulta, ...)</p>
<p>Spring ofrece diversas <em>templates</em> entre las que elegir, dependiendo del API de persistencia a emplear.
Dada la heterogeneidad de los distintos APIs La implementaci&oacute;n del DAO variar&aacute; seg&uacute;n usemos un API u otro 
, aunque en todos ellos Spring reduce enormemente la cantidad de c&oacute;digo que debemos escribir, haci&eacute;ndolo m&aacute;s mantenible.</p>
<p>Por otro lado, en APIs de acceso a datos como JDBC hay dos problemas b&aacute;sicos con respecto a la <strong>gesti&oacute;n de excepciones</strong>:</p>
<ul>
            
<li>Hay muy pocas excepciones distintas definidas para acceso a datos. Como consecuencia, la m&aacute;s importante,
            <span class="codefrag">SQLException</span>, es una especie de "chica para todo". La misma excepci&oacute;n se usa
            para prop&oacute;sitos tan distintos como: "no hay conexi&oacute;n con la base de datos", "el SQL de la consulta
        est&aacute; mal formado" o "se ha producido una violaci&oacute;n de la integridad de los datos". Esto hace que
    para el desarrollador sea tedioso escribir c&oacute;digo que detecte adecuadamente el problema. Herramientas
como Hibernate tienen una jerarqu&iacute;a de excepciones mucho m&aacute;s completa, pero son excepciones propias del API, y
referenciarlas directamente va a introducir dependencias no deseadas en nuestro c&oacute;digo.</li>
        
<li>Las excepciones definidas en Java para acceso a datos son <em>comprobadas</em>. Esto implica que debemos
    poner <span class="codefrag">try/catch</span> o <span class="codefrag">throws</span> para gestionarlas, lo que inevitablemente llena
<em>todos</em> los m&eacute;todos de acceso a datos de bloques de gesti&oacute;n de excepciones. Est&aacute; bien obligar 
al desarrollador a responsabilizarse de los errores, pero  en acceso a datos esta gesti&oacute;n
se vuelve repetitiva y propensa a fallos, descuidos o a caer en "malas tentaciones" (&iquest;qui&eacute;n no ha escrito <em>nunca</em> un bloque <span class="codefrag">catch</span> vac&iacute;o?). 
Adem&aacute;s, muchos m&eacute;todos de los DAO
generalmente poco pueden hacer para recuperarse de la mayor&iacute;a de excepciones (por ejemplo, "violaci&oacute;n de la
integridad"), lo que lleva al desarrollador a poner tambi&eacute;n <span class="codefrag">throws</span> de manera repetitiva y tediosa.</li>
        
</ul>
<p>La soluci&oacute;n de Spring al primer problema es la definici&oacute;n de una completa jerarqu&iacute;a de excepciones de
acceso a datos. Cada problema tiene su excepci&oacute;n correspondiente, por ejemplo <span class="codefrag">DataAccessResourceFailureException</span>
 cuando no podemos conectar con la BD, <span class="codefrag">DataIntegrityViolationException</span> cuando se produce una violaci&oacute;n
de integridad en los datos, y as&iacute; con otras muchas. Un aspecto fundamental es que estas excepciones <em>son independientes
del API usado para acceder a los datos</em>, es decir, se generar&aacute; el mismo <span class="codefrag">DataIntegrityViolationException</span>
cuando queramos insertar un registro con clave primaria duplicada en JDBC que cuando queramos persistir un objeto 
con clave duplicada en JPA. La ra&iacute;z de esta jerarqu&iacute;a de excepciones es <span class="codefrag">DataAccessException</span>.</p>
<p>En cuanto a la necesidad de gestionar las excepciones, Spring opta por eliminarla haciendo que todas
las excepciones de acceso a datos sean <em>no comprobadas</em>. Esto libera al desarrollador de la carga de los <span class="codefrag">try-catch/throws</span>
repetitivos, aunque evidentemente no lo libera de su responsabilidad, ya que las excepciones tendr&aacute;n que gestionarse en alg&uacute;n nivel
superior.</p>
</div>

<a name="N10079"></a><a name="Uso+de+JDBC"></a>
<h2 class="underlined_10">Uso de JDBC</h2>
<div class="section">
<p>JDBC sigue siendo un API muy usado para el acceso a datos, aunque es tedioso y repetitivo. Vamos a ver c&oacute;mo
soluciona Spring algunos problemas de JDBC, manteniendo las ventajas de poder trabajar "a bajo nivel" si as&iacute; lo
deseamos. Probablemente las ventajas quedar&aacute;n m&aacute;s claras si primero vemos un ejemplo con JDBC "a secas" y luego vemos el mismo
c&oacute;digo usando las facilidades que nos da Spring. Por ejemplo, supongamos un m&eacute;todo que comprueba que
el login y el password de un usuario son correctos, busc&aacute;ndolo en la base de datos con JDBC:</p>
<pre class="brush:java;highlight:[1,8,9,10,11,12,13,14,15,16,17,18,19]">
private String SQL ="select * from usuarios where login=? and password=?";
    
public UsuarioTO login(String login, String password) throws DAOException {
    Connection con=null;
    try {
        con = ds.getConnection();	
           PreparedStatement ps = con.prepareStatement(SQL);
        ps.setString(1, login);
        ps.setString(2, password);
        ResultSet rs = ps.executeQuery();
        if (rs.next()) {
            UsuarioTO uto = new UsuarioTO();
            uto.setLogin(rs.getString("login"));
            uto.setPassword(rs.getString("password"));
            uto.setFechaNac(rs.getDate("fechaNac"));
            return uto;
        }
        else
            return null;
    } catch(SQLException sqle) {
        throw new DAOException(sqle);
    }
    finally {
        if (con!=null) {
            try {
                con.close();
            }
            catch(SQLException sqle2) {
                throw new DAOException(sqle2);                    
            }
        }
    }
}        
</pre>
<p>Se destacan las l&iacute;neas de c&oacute;digo que hacen realmente el trabajo de buscar el registro y devolver
la informaci&oacute;n. El resto es simplemente la infraestructura necesaria para poder hacer el trabajo y gestionar
los errores, y que, curiosamente <em>ocupa m&aacute;s l&iacute;neas que el c&oacute;digo "importante"</em>. Evidentemente la gesti&oacute;n de
errores se habr&iacute;a podido "simplificar" poniendo en la cabecera del m&eacute;todo un <span class="codefrag">throws SQLException</span>,
pero entonces ya estar&iacute;amos introduciendo dependencias del API JDBC en la capa de negocio.</p>
<p>Veamos c&oacute;mo nos puede ayudar Spring a simplificar nuestro c&oacute;digo, manteniendo la flexibilidad que nos da SQL. El
primer paso ser&aacute; elegir el <em>template</em> apropiado.</p>
<a name="N10097"></a><a name="JDBCTemplate"></a>
<h3 class="underlined_5">JDBCTemplate</h3>
<p>Como ya hemos dicho, los <em>templates</em> son clases que encapsulan el c&oacute;digo de gesti&oacute;n de
    los detalles "tediosos" del API de acceso a datos. En Spring, para JDBC tenemos varios templates disponibles, seg&uacute;n queramos
hacer consultas simples, con par&aacute;metros con nombre,... Vamos a usar aqu&iacute; <span class="codefrag">JdbcTemplate</span>,
que aprovecha las ventajas de Java 5 (autoboxing, gen&eacute;ricos, ...) para simplificar las operaciones. El equivalente
si no tenemos Java 5 ser&iacute;a <span class="codefrag">JdbcTemplate</span>, que tiene una sintaxis mucho m&aacute;s complicada.</p>
<p>Lo primero que necesitamos es instanciar el <em>template</em>. El constructor de <span class="codefrag">JdbcTemplate</span>
necesita un <span class="codefrag">DataSource</span> como par&aacute;metro. Como se vio en el tema anterior, los <span class="codefrag">DataSource</span>
se pueden definir en el fichero XML de los beans, gracias al espacio de nombres <span class="codefrag">jee</span>:</p>
<pre class="brush:xml;">
&lt;jee:jndi-lookup id="ds" jndi-name="jdbc/MiDataSource" resource-ref="true"/&gt;
</pre>
<p>Con lo que el <span class="codefrag">DataSource</span> se convierte en un bean de Spring llamado <span class="codefrag">ds</span>. La pr&aacute;ctica
habitual es inyectarlo en nuestro DAO y con &eacute;l inicializar el <em>template</em>, que guardaremos en el DAO:</p>
<pre class="brush:java;highlight:[8,12]">
import org.springframework.jdbc.core.simple.JbcTemplate;
import org.springframework.stereotype.Repository;
//Resto de imports...
...

@Repository("JDBC")
public class UsuariosDAOJDBC implements IUsuariosDAO {
    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    public void setDataSource(DataSource ds) {
        this.jdbcTemplate = new JdbcTemplate(ds);
    }

    ...
}    
</pre>
<p>Recordemos que la anotaci&oacute;n <span class="codefrag">@Repository</span> se usa para definir un DAO. Recordemos tambi&eacute;n que
<span class="codefrag">@Autowired</span> inyecta la dependencia busc&aacute;ndola por tipo. En este caso no hay ambig&uuml;edad, ya que
solo hemos definido un <span class="codefrag">DataSource</span>.</p>
<div class="frame note">
<div class="label">SimpleJdbcTemplate</div>
<div class="content">Antes de Spring 3, la funcionalidad m&aacute;s "simple" de JDBC en Spring la implementaba <span class="codefrag">SimpleJdbcTemplate</span>, mientras que el API de <span class="codefrag">JdbcTemplate</span> era m&aacute;s complicado y por tanto solo recomendable para operaciones m&aacute;s complejas que las que vamos a ver aqu&iacute;. A partir de la versi&oacute;n 3, <span class="codefrag">SimpleJdbcTemplate</span> est&aacute; <em>deprecated</em>.</div>
</div>
<a name="N100EF"></a><a name="Consultas+de+selecci%C3%B3n"></a>
<h3 class="underlined_5">Consultas de selecci&oacute;n</h3>
<p>Normalmente en un SELECT se van recorriendo registros y nuestro DAO los va transformando en objetos Java
que devolver&aacute; a la capa de negocio. En Spring, el trabajo de tomar los datos de un registro y empaquetarlos
en un objeto lo hace <span class="codefrag">RowMapper</span>. Este es un interface, por
lo que nuestro trabajo consistir&aacute; en escribir una clase que lo implemente. Realmente el &uacute;nico m&eacute;todo
estrictamente necesario es <span class="codefrag">mapRow</span>, que a partir de un registro debe devolver un objeto. En nuestro
caso podr&iacute;a ser algo como:</p>
<pre class="brush:java;">
 //esto podr&iacute;a tambi&eacute;n ser private y estar dentro del DAO
 //ya que solo lo necesitaremos dentro de &eacute;l
 public class UsuarioTOMapper implements RowMapper&lt;UsuarioTO&gt; {

     public UsuarioTO mapRow(ResultSet rs, int numRow) throws SQLException {
          UsuarioTO uto = new UsuarioTO();
          uto.setLogin(rs.getString("login"));
          uto.setPassword(rs.getString("password"));
          uto.setFechaNac(rs.getDate("fechaNac"));
          return uto;
     }
}
</pre>
<p>Ahora solo nos queda escribir en el DAO el c&oacute;digo que hace el SELECT:</p>
<pre class="brush:java;">
private static final String LOGIN_SQL = "select * " +
 "from usuarios where login=? and password=?";

public UsuarioTO login(String login, String password) {
    UsuarioTOMapper miMapper = new UsuarioTOMapper();
       
    return this.jdbcTemplate.queryForObject(LOGIN_SQL, miMapper,
                                              login, password);
}
</pre>
<p>Como se ve, no hay que gestionar la conexi&oacute;n con la base de datos, preocuparse del <span class="codefrag">Statement</span>
ni nada parecido. El <em>template</em> se ocupa de estos detalles. El m&eacute;todo <span class="codefrag">queryForObject</span> hace el SELECT y
devuelve un <span class="codefrag">UsuarioTO</span> ayudado del <em>mapper</em>
que hemos definido antes. Simplemente hay que pasarle el SQL a ejecutar y los valores de los par&aacute;metros.</p>
<p>Tampoco hay gesti&oacute;n de excepciones, porque Spring captura todas las <span class="codefrag">SQLException</span> de JDBC
y las transforma en excepciones no comprobadas. Por supuesto, eso no quiere decir que no podamos capturarlas en el DAO si as&iacute;
lo deseamos. De hecho, en el c&oacute;digo anterior hemos cometido en realidad un "descuido", ya que podr&iacute;a no haber ning&uacute;n
registro como resultado del SELECT. Para Spring esto es una excepci&oacute;n del tipo <span class="codefrag">EmptyResultDataAccessException</span>. Si queremos seguir la misma l&oacute;gica que en el ejemplo con JDBC, deber&iacute;amos devolver <span class="codefrag">null</span>
en este caso.</p>
<pre class="brush:java;">
private static final String LOGIN_SQL = "select * " + 
        "from usuarios where login=? and password=?";

public UsuarioTO login(String login, String password) {
   UsuarioTOMapper miMapper = new UsuarioTOMapper();
       
   try {
       return this.jdbcTemplate.queryForObject(LOGIN_SQL, miMapper, 
                                                login, password);
   }
   catch(EmptyResultDataAccessException erdae) {
       return null;
   }
}   
</pre>
<p>La amplia variedad de excepciones de acceso a datos convierte a Spring en un <em>framework</em> un poco "quisquilloso" en ciertos aspectos.
En un <span class="codefrag">queryForObject</span> Spring espera obtener <em>un registro y s&oacute;lo un registro</em>, de modo
que se lanza una excepci&oacute;n si no hay resultados, como hemos visto, pero tambi&eacute;n si hay m&aacute;s de uno: <span class="codefrag">IncorrectResultSizeDataAccessException</span>. Esto tiene su l&oacute;gica, ya que
<span class="codefrag">queryForObject</span> solo se debe usar cuando esperamos como m&aacute;ximo un registro. Si el SELECT pudiera devolver m&aacute;s de un resultado, en lugar de llamar a <span class="codefrag">queryForObject</span>,
emplear&iacute;amos <strong><span class="codefrag">query</span></strong>, que usa los mismos par&aacute;metros, pero devuelve una lista de objetos.</p>
<a name="N10148"></a><a name="Consultas+de+actualizaci%C3%B3n"></a>
<h3 class="underlined_5">Consultas de actualizaci&oacute;n</h3>
<p>Las actualizaciones se hacen con el m&eacute;todo <span class="codefrag">update</span> del <em>template</em>. Por ejemplo, aqu&iacute; tenemos
el c&oacute;digo que da de alta a un nuevo usuario:</p>
<pre class="brush:java;">
private static final String REGISTRAR_SQL =
        "insert into usuarios(login, password, fechaNac) values (?,?,?)";

public void registrar(UsuarioTO uto) {      
   this.jdbcTemplate.update(REGISTRAR_SQL, uto.getLogin(),
             uto.getPassword(), uto.getFechaNac());
}    
</pre>
</div>

<a name="N1015E"></a><a name="Uso+de+JPA"></a>
<h2 class="underlined_10">Uso de JPA</h2>
<div class="section">
<p>Veamos qu&eacute; soporte ofrece Spring al otro API de persistencia que hemos visto durante el curso: JPA. El caso
de JPA es muy distinto al de JDBC, ya que es de mucho m&aacute;s alto nivel y m&aacute;s conciso que este &uacute;ltimo. Por eso, aunque
Spring implementa un <em>template</em> para JPA, tambi&eacute;n se puede usar directamente el API sin escribir
mucho m&aacute;s c&oacute;digo. Adem&aacute;s otra decisi&oacute;n que debemos tomar es qui&eacute;n gestionar&aacute; los Entity Managers, si lo haremos "manualmente", al estilo Java SE, o bien a trav&eacute;s del servidor de aplicaciones. </p>
<a name="N1016A"></a><a name="Formas+de+acceder+a+la+%22EntityManagerFactory%22"></a>
<h3 class="underlined_5">Formas de acceder a la "EntityManagerFactory"</h3>
<p>Para poder trabajar con JPA lo primero que necesitamos es una <span class="codefrag">EntityManagerFactory</span> a trav&eacute;s de la que crear
    los <em>Entity Managers</em>.  Spring nos da tres posibilidades para acceder a ella: </p>
<ul>
    
<li>Como se hace en Java SE. Es decir, Entity Managers gestionados por la aplicaci&oacute;n. En este caso, la mayor parte de la configuraci&oacute;n se hace en el persistence.xml. Esta forma no se recomienda en general, solo para pruebas.</li>
    
<li>Usando el soporte del servidor de aplicaciones. Evidentemente esto no funcionar&aacute; en servidores que no tengan soporte
    JPA, como Tomcat, pero es la forma recomendada de trabajo en los que s&iacute; lo tienen. El acceso a la factor&iacute;a se hace con JNDI.</li>
    
<li>Usando un soporte propio de Spring. Esto funciona incluso en servidores sin soporte "nativo", como Tomcat. La configuraci&oacute;n se hace sobre todo en el fichero de configuraci&oacute;n de beans de Spring. El problema es que depende del servidor y tambi&eacute;n de la implementaci&oacute;n JPA que estemos usando, pero est&aacute; explicada con detalle en la documentaci&oacute;n de Spring para varios casos posibles (secci&oacute;n 7.8.4.5).</li>
    
</ul>
<p>Estas dos &uacute;ltimas posibilidades ser&iacute;an lo que en JPA se conoce como Entity Managers gestionados por el contenedor, con la diferencia de que una de ellas es una implementaci&oacute;n nativa y la otra proporcionada por Spring. En cualquier caso, en realidad como desarrolladores todo esto nos da casi igual: elijamos la opci&oacute;n que elijamos Spring va a gestionar  la  <span class="codefrag">EntityManagerFactory</span>  por nosotros. Esta se implementa como un bean de Spring, que podemos inyectar en nuestro c&oacute;digo usando la anotaci&oacute;n est&aacute;ndar de <span class="codefrag">@PersistenceUnit</span>. Tambi&eacute;n podemos inyectarlo con <span class="codefrag">@Autowired</span> o <span class="codefrag">@Resource</span>, como vimos en el tema anterior. Dicho bean debemos definirlo en el fichero XML de configuraci&oacute;n. Aqu&iacute; tenemos un ejemplo
    usando JPA gestionado por el contenedor pero en Tomcat (es decir, gestionado en realidad por Spring)</p>
<pre class="brush:xml;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/context
         http://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:component-scan base-package="es.ua.jtech"/&gt;

    &lt;jee:jndi-lookup id="miDS" jndi-name="jdbc/MiDataSource"
       resource-ref="true"/&gt;
    
    &lt;bean id="miEMF" class="org.springframework.orm.jpa.
    				LocalContainerEntityManagerFactoryBean"&gt;
      &lt;property name="dataSource" ref="miDS"/&gt;
      &lt;property name="jpaVendorAdapter"&gt;
         &lt;bean class="org.springframework.orm.jpa.vendor.
		          HibernateJpaVendorAdapter"&gt;
		&lt;property name="showSql" value="true"/&gt;
        	&lt;property name="generateDdl" value="true"/&gt;
        	&lt;property name="databasePlatform" 
        		    value="org.hibernate.dialect.HSQLDialect"/&gt;
        &lt;/bean&gt;		       	
      &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
    </pre>
<p>Como vemos el bean es una clase propia de Spring, de ah&iacute; que no podamos definirlo mediante anotaciones.El identificador del bean (miEMF) es arbitrario e irrelevante para nuestro ejemplo. Especificamos dos propiedades del bean: el datasource que se usar&aacute; para conectar con la BD (aqu&iacute; definido con JNDI) y la implementaci&oacute;n JPA que 
    estamos usando, en nuestro caso Hibernate. Finalmente, la etiqueta "component-scan" es necesaria para que Spring reconozca y procese las anotaciones <span class="codefrag">@PersistenceUnit</span> y <span class="codefrag">@PersistenceContext</span>.</p>
<div class="frame warning">
<div class="label">Cuidado con la implementaci&oacute;n JPA</div>
<div class="content">En nuestro caso la configuraci&oacute;n se simplifica porque usamos Hibernate, pero otras implementaciones JPA requieren <em>load time weaving</em>, una t&eacute;cnica que manipula el <em>bytecode</em> de las clases JPA en tiempo de ejecuci&oacute;n y que es necesaria para que funcione la gesti&oacute;n por el contenedor. Si us&aacute;ramos otra implementaci&oacute;n JPA para la que fuera necesario el <em>load time weaving</em> habr&iacute;a que configurarlo, configuraci&oacute;n que es adem&aacute;s dependiente del servidor web en que hagamos el despliegue. Consultad la documentaci&oacute;n de Spring para m&aacute;s informaci&oacute;n.</div>
</div>
<p>Con esto ya podemos inyectar el EntityManager o bien la factor&iacute;a de EntityManagers  en nuestro c&oacute;digo:</p>
<pre class="brush:java;highligh:[4,7]">
package es.ua.jtech.datos;

//faltan los import...
@Repository("JPA")
public class UsuariosDAOJPA implements IUsuariosDAO {

    @PersistenceContext
    EntityManager em;

    public UsuarioTO login(String login, String password) {
        UsuarioTO uto = em.find(UsuarioTO.class, login);
        if (uto!=null &amp;&amp; password.equals(uto.getPassword()))
            return uto;
        else
            return null;
    }
}
    </pre>
<a name="N101B9"></a><a name="JpaTemplate"></a>
<h3 class="underlined_5">JpaTemplate</h3>
<p>Esta clase facilita el trabajo con JPA, haci&eacute;ndolo m&aacute;s sencillo. No obstante, al ser JPA
un API relativamente conciso, no es de esperar que ahorremos mucho c&oacute;digo. De hecho, los propios dise&ntilde;adores de Spring recomiendan usar directamente el API JPA para aumentar la portabilidad del c&oacute;digo. No obstante, vamos a verlo brevemente.</p>
<p> Aqu&iacute; tenemos el esqueleto de una nueva implementaci&oacute;n de <span class="codefrag">IUsuariosDAO</span> usando
ahora <span class="codefrag">JpaTemplate</span> en lugar de <span class="codefrag">JdbcTemplate</span>:</p>
<pre class="brush:java;highlight:[11,13,14,15,16]">
package es.ua.jtech.spring.datos;

import es.ua.jtech.spring.dominio.UsuarioTO;
import javax.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.stereotype.Repository;

@Repository("JPATemplate")
public class UsuariosDAOJPATemplate implements IUsuariosDAO {
    private JpaTemplate template;
    
    @Autowired
    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.template = new JpaTemplate(emf);
    }

    //Falta la implementaci&oacute;n de este m&eacute;todo
    public UsuarioTO login(String login, String password) {
        ...
    }

    //Falta la implementaci&oacute;n de este m&eacute;todo
    public void registrar(UsuarioTO uto) {
        ...
    }    
</pre>
<p>Como se ve, para instanciar un <span class="codefrag">JpaTemplate</span> necesitamos un <span class="codefrag">EntityManagerFactory</span> (de
ah&iacute; el trabajo que nos hab&iacute;amos tomado en la secci&oacute;n anterior).
En este caso usamos la anotaci&oacute;n <span class="codefrag">@Autowired</span> para que Spring resuelva autom&aacute;ticamente
la dependencia y la inyecte a trav&eacute;s del <em>setter</em>. Tambi&eacute;n podr&iacute;amos haber usado <span class="codefrag">@PersistenceUnit</span>, que al ser est&aacute;ndar hace nuestro c&oacute;digo m&aacute;s portable. Una vez creado el Template, se
puede reutilizar en todos los m&eacute;todos ya que es <em>thread-safe</em>, al igual que en JDBC.</p>
<p>Ahora veamos c&oacute;mo implementar los m&eacute;todos del DAO. En lugar de ver sistem&aacute;ticamente el API de
<span class="codefrag">JpaTemplate</span>, nos limitaremos a mostrar un par de ejemplos. Primero, una consulta de selecci&oacute;n:</p>
<pre class="brush:java;">
private static String LOGIN_JPAQL = "SELECT u FROM UsuarioTO u
                                   WHERE u.login=?1 AND u.password=?2";
public UsuarioTO login(String login, String password) {
   List&lt;UsuarioTO&gt; lista;   
   lista = this.template.find(LOGIN_JPAQL, login, password);
   return (UsuarioTO) lista.get(0);
}    
</pre>
<p>Obs&eacute;rvese que en el ejemplo anterior <strong>no es necesario instanciar ni cerrar ning&uacute;n Entity Manager</strong>,
ya que la gesti&oacute;n la lleva a cabo el <em>template</em>. En cuanto al API de acceso a datos, como se ve, el m&eacute;todo <span class="codefrag">find</span> nos devuelve una lista de resultados y nos permite
pasar par&aacute;metros a JPAQL gracias a los <em>varargs</em> de Java 5. En el ejemplo anterior
hemos "forzado un poco" el API de <span class="codefrag">JpaTemplate</span> ya que <span class="codefrag">find</span>
devuelve siempre una lista y en nuestro caso est&aacute; claro que no va a haber m&aacute;s de un 
objeto como resultado. Se ha hecho as&iacute; para mantener el paralelismo con el ejemplo JDBC, aunque 
aqu&iacute; quiz&aacute; lo m&aacute;s natural ser&iacute;a buscar por clave primaria. Tampoco se han tratado adecuadamente
los errores, como que no haya ning&uacute;n resultado en la lista.</p>
<p>Otros m&eacute;todos de <span class="codefrag">JpaTemplate</span> nos permiten trabajar con par&aacute;metros con nombre
y con <em>named queries</em>.</p>
<p>Las actualizaciones de datos no ofrecen gran ventaja con respecto al API directo de JPA, salvo la gesti&oacute;n
autom&aacute;tica del Entity Manager, por ejemplo:</p>
<pre class="brush:java;">
public void registrar(UsuarioTO uto) {
   this.template.persist(uto);
}
</pre>
<div class="frame warning">
<div class="label">&iexcl;Cuidado con la transaccionalidad!</div>
<div class="content">Spring gestiona autom&aacute;ticamente los Entity Manager en funci&oacute;n de la transaccionalidad de los m&eacute;todos.
Si no declaramos ning&uacute;n tipo de transaccionalidad, como en el ejemplo anterior, podemos encontrarnos
con que al hacer un <span class="codefrag">persist</span> no se hace el <span class="codefrag">commit</span> y el cambio no tiene efecto.
En el &uacute;ltimo apartado del tema veremos c&oacute;mo especificar la transaccionalidad, pero repetimos que es importante
darse cuenta de que <em>si no especificamos transaccionalidad, la gesti&oacute;n autom&aacute;tica
de los entity manager no funcionar&aacute; adecuadamente</em>.</div>
</div>
<p>Una ventaja del uso de <em>templates</em> es la jerarqu&iacute;a de
excepciones de Spring. En caso de usar directamente el API JPA nos llegar&aacute;n las propias de la implementaci&oacute;n JPA que estemos
usando. Si queremos que Spring capture dichas excepciones y las transforme en excepciones
de Spring, debemos definir un bean de la clase <span class="codefrag">PersistenceExceptionTranslationPostProcessor</span>
en el XML de definici&oacute;n de beans:</p>
<pre class="brush:xml;">
&lt;bean class="org.springframework.dao. &lt;!--Esto deber&iacute;a estar en 1 sola l&iacute;nea--&gt;
                      annotation.PersistenceExceptionTranslationPostProcessor"/&gt;        
</pre>
<p>Como se ve, lo m&aacute;s complicado de la definici&oacute;n anterior &iexcl;es el nombre de la clase!</p>
</div>

<a name="N1023A"></a><a name="Transaccionalidad+declarativa"></a>
<h2 class="underlined_10">Transaccionalidad declarativa</h2>
<div class="section">
<p>Abordamos aqu&iacute; la transaccionalidad porque es un aspecto &iacute;ntimamente ligado al acceso a datos, aunque se suele
gestionar desde la capa de negocio en lugar de directamente en los DAOs. Vamos a ver qu&eacute; facilidades
nos da Spring para controlar la transaccionalidad de forma declarativa.</p>
<a name="N10243"></a><a name="El+%22Transaction+Manager%22"></a>
<h3 class="underlined_5">El "Transaction Manager"</h3>
<p>Lo primero es escoger la estrategia de gesti&oacute;n de transacciones: si estamos en un servidor
de aplicaciones podemos usar JTA, pero si no, tendremos que recurrir a la implementaci&oacute;n
nativa del API de acceso a datos que estemos usando. Spring implementa clases propias para trabajar 
con JTA o bien con transacciones JDBC o JPA. Estas clases gestionan las transacciones y se denominan "Transaction Managers". Necesitaremos
definir uno de ellos en el fichero XML de definici&oacute;n de beans.</p>
<p>Por ejemplo, en el caso de estar usando JDBC sin soporte JTA, como en Tomcat, necesitar&iacute;amos una implementaci&oacute;n de Transaction Manager
que referencia un DataSource.</p>
<pre class="brush:xml;highlight:[12,13,18,22,27]">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:jee="http://www.springframework.org/schema/jee"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jee
        http://www.springframework.org/schema/jee/spring-jee.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx 
        http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;
          
    
    &lt;!-- el DataSource que usar&aacute; el Transaction Manager --&gt;
    &lt;jee:jndi-lookup id="miDataSource" jndi-name="DStestSpring" resource-ref="true" /&gt;
    
    &lt;!-- Elegimos el tipo apropiado de "Transaction Manager" (JDBC) --&gt;
    &lt;bean id="miTxManager" 
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="miDataSource"/&gt;
    &lt;/bean&gt;
    
    &lt;!-- Decimos que para este Transaction Manager vamos a usar anotaciones --&gt;
    &lt;tx:annotation-driven transaction-manager="miTxManager"/&gt;
 &lt;/beans&gt;    
</pre>
<a name="N10256"></a><a name="La+anotaci%C3%B3n+%40Transactional"></a>
<h3 class="underlined_5">La anotaci&oacute;n @Transactional</h3>
<p>Para entender mejor el uso de esta anotaci&oacute;n, vamos a plantear un ejemplo. Supongamos que al registrar un nuevo usuario, adem&aacute;s de introducir sus datos en
    la tabla de usuarios, tambi&eacute;n lo debemos dar de alta en otra tabla para enviarle publicidad, pero si no es posible
este alta de publicidad por lo que sea (direcci&oacute;n de email no v&aacute;lida, digamos) hay que anular toda la operaci&oacute;n.
Supongamos que al detectar el error nuestro DAO lanzar&iacute;a un <span class="codefrag">DataAccessException</span>
que, recordemos, es la ra&iacute;z de la jerarqu&iacute;a de excepciones de acceso a datos en Spring.</p>
<p>Colocaremos <span class="codefrag">@Transactional</span> delante de los m&eacute;todos que queramos hacer transaccionales. Si
la colocamos delante de una clase, estamos diciendo que <strong>todos</strong> sus m&eacute;todos
deben ser transaccionales. En nuestro caso:</p>
<pre class="brush:java;highlight:[13,14,15,16,17]">
//Faltan los imports, etc.
...
@Service
public class GestorUsuarios {
  @Autowired
  @Qualifier("JPA")
  private IUsuariosDAO udao;
   
  public void setUdao(IUsuariosDAO udao) {
      this.udao = udao;
  }
  
  @Transactional
  public void registrar(UsuarioTO uto) {
      udao.registrar(uto);
      udao.altaPublicidad(uto);
  }
}
</pre>
<p>El comportamiento por defecto de <span class="codefrag">@Transactional</span> es <strong>realizar un <em>rollback</em>
si se ha lanzado alguna excepci&oacute;n no comprobada</strong>. Recordemos que, precisamente, 
<span class="codefrag">DataAccessException</span> era de ese tipo. Por tanto, se har&aacute; autom&aacute;ticamente un <em>rollback</em>
en caso de error.
</p>
<div class="frame warning">
<div class="label">&iexcl;Cuidado con los m&eacute;todos no p&uacute;blicos!</div>
<div class="content">Todos los m&eacute;todos que deseamos hacer transaccionales deben ser p&uacute;blicos, no es
posible usar <span class="codefrag">@Transactional</span> en m&eacute;todos <span class="codefrag">protected</span>
o <span class="codefrag">private</span>. La raz&oacute;n es que cuando hacemos un m&eacute;todo transaccional y lo llamamos
desde cualquier otra clase quien est&aacute; recibiendo la llamada en realidad es el gestor de transacciones.
El gestor comienza y acaba las transacciones y "entre medias" llama a nuestro m&eacute;todo de acceso a datos, pero eso no lo podr&aacute; hacer si este no es <span class="codefrag">public</span>.
Por la misma raz&oacute;n, la anotaci&oacute;n no funcionar&aacute; si el m&eacute;todo transaccional es llamado desde la misma clase que lo define, aunque
esto &uacute;ltimo se puede solucionar haciendo la configuraci&oacute;n adecuada.</div>
</div>
<p>
<span class="codefrag">@Transactional</span> tiene varias implicaciones por defecto (aunque son totalmente
configurables, como ahora veremos):</p>
<ul>

<li>La propagaci&oacute;n de la transacci&oacute;n es REQUIRED. Esto significa que se requiere una transacci&oacute;n abierta para que el m&eacute;todo se ejecute en ella. Si no hubiera ninguna, 
Spring autom&aacute;ticamente la crear&iacute;a. Esto funciona igual que los EJBs del JavaEE est&aacute;ndar.
<div class="frame note">
<div class="label">Transaccionalidad declarativa en JavaEE</div>
<div class="content">
En el bloque de Aplicaciones Enterprise se ver&aacute; con mucho m&aacute;s detalle todo el tema de la transaccionalidad declarativa, y los diferentes
tipos de gesti&oacute;n de la transacci&oacute;n t&iacute;picos en JavaEE. Por el momento nos limitaremos a casos relativamente simples.
</div>
</div>


</li>

<li>Cualquier excepci&oacute;n no comprobada dispara el <em>rollback</em> y cualquiera comprobada, no.</li>

<li>La transacci&oacute;n es de lectura/escritura (en algunos APIs de acceso a datos, por ejemplo, Hibernate, las
transacciones de "solo lectura" son mucho m&aacute;s eficientes).</li>

<li>El <em>timeout</em> para efectuar la operaci&oacute;n antes de que se haga <em>rollback</em>
es el que tenga por defecto el API usado (no todos soportan <em>timeout</em>).</li>

</ul>
<p>Todo este comportamiento se puede configurar a trav&eacute;s de los atributos de la anotaci&oacute;n, como se
muestra en la siguiente tabla:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>

<th colspan="1" rowspan="1">Propiedad</th> <th colspan="1" rowspan="1">Tipo</th> <th colspan="1" rowspan="1">Significado</th>

</tr>

<tr>

<td colspan="1" rowspan="1">propagation</td><td colspan="1" rowspan="1">enum: Propagation</td><td colspan="1" rowspan="1">nivel de propagaci&oacute;n (opcional)</td>

</tr>

<tr>

<td colspan="1" rowspan="1">isolation</td><td colspan="1" rowspan="1">enum: Isolation</td><td colspan="1" rowspan="1">nivel de aislamiento (opcional)</td>

</tr>

<tr>

<td colspan="1" rowspan="1">readOnly</td><td colspan="1" rowspan="1">boolean</td><td colspan="1" rowspan="1">solo de lectura vs. de lectura/escritura</td>

</tr>

<tr>

<td colspan="1" rowspan="1">timeOut</td><td colspan="1" rowspan="1">int (segundos)</td><td colspan="1" rowspan="1"></td>

</tr>

<tr>

<td colspan="1" rowspan="1">rollbackFor</td><td colspan="1" rowspan="1">array de objetos Throwable</td><td colspan="1" rowspan="1">clases de excepci&oacute;n que deben causar rollback</td>

</tr>

<tr>

<td colspan="1" rowspan="1">rollbackForClassName</td><td colspan="1" rowspan="1">array con nombres de objetos Throwable</td><td colspan="1" rowspan="1">nombres de clases de excepci&oacute;n que deben causar rollback </td>

</tr>

<tr>

<td colspan="1" rowspan="1">noRollbackFor</td><td colspan="1" rowspan="1">array de objetos Throwable</td><td colspan="1" rowspan="1">clases de excepci&oacute;n que no deben causar rollback</td>

</tr>

<tr>

<td colspan="1" rowspan="1">noRollbackForClassName</td><td colspan="1" rowspan="1">array con nombres de objetos Throwable</td><td colspan="1" rowspan="1">nombres de clases de excepci&oacute;n que no deben causar rollback</td>

</tr>

</table>
<p>Por ejemplo supongamos que al producirse un error en la llamada a <span class="codefrag">altaPublicidad()</span>
lo que se genera es una excepci&oacute;n propia de tipo <span class="codefrag">AltaPublicidadException</span>, que es comprobada
pero queremos que cause un <em>rollback</em>:</p>
<pre class="brush:java;highlight:[1]">
@Transactional(rollbackFor=AltaPublicidadException.class)
public void registrar(UsuarioTO uto) {
      udao.registrar(uto);
      udao.altaPublicidad(uto);
}
</pre>
<p>Finalmente, destacar que podemos poner transaccionalidad "global" a una clase
y en cada uno de los m&eacute;todos especificar atributos distintos:</p>
<pre class="brush:java;highlight:[6,16,21]">
//Faltan los imports, etc.
...
@Service
//Vale, el REQUIRED no har&iacute;a falta ponerlo porque es la opci&oacute;n
//por defecto, pero esto es solo un humilde ejemplo!
@Transactional(propagation=Propagation.REQUIRED)
public class GestorUsuarios {
  @Autowired
  @Qualifier("JPA")
  private IUsuariosDAO udao;
   
  public void setUdao(IUsuariosDAO udao) {
      this.udao = udao;
  }
  
  @Transactional(readOnly=true)
  public UsuarioTO login(String login, String password) {
      return udao.login(login, password);
  }
  
  @Transactional(rollbackFor=AltaPublicidadException.class)
  public void registrar(UsuarioTO uto) {
      udao.registrar(uto);
      udao.altaPublicidad(uto);
  }
  
  public void eliminarUsuario(UsuarioTO uto) {
       udao.eliminar(uto);
  }
}
    
</pre>
<p>N&oacute;tese que <span class="codefrag">eliminarUsuario</span> es tambi&eacute;n transaccional, heredando las propiedades
transaccionales de la clase.</p>
<a name="N10370"></a><a name="Transaccionalidad+y+uso+directo+de+JDBC"></a>
<h3 class="underlined_5">Transaccionalidad y uso directo de JDBC</h3>
<p>Si usamos el API JDBC directamente, sin ninguna de las facilidades que nos da Spring, se nos
va a plantear un problema con la transaccionalidad declarativa: si cada m&eacute;todo del DAO abre y cierra
una conexi&oacute;n con la BD (lo m&aacute;s habitual), va a ser imposible hacer un rollback de las operaciones que hagan distintos
m&eacute;todos, ya que la conexi&oacute;n ya se habr&aacute; cerrado. Para evitar este problema, Spring nos proporciona
la clase <span class="codefrag">DataSourceUtils</span>, que nos permite "liberar" la conexi&oacute;n desde nuestro punto de vista, 
pero mantenerla abierta autom&aacute;ticamente gracias a Spring, hasta que se cierre la transacci&oacute;n y no sea necesaria m&aacute;s.
Su uso es muy sencillo. Cada vez que queremos obtener una conexi&oacute;n hacemos:</p>
<pre class="brush:java;highlight:[6]">
//El DataSource se habr&iacute;a resuelto por inyecci&oacute;n de dependencias
@Autowired
private DataSource ds;
    
...
Connection con = DataSourceUtils.getConnection(ds);
</pre>
<p>Y cada vez que queremos liberarla:</p>
<pre class="brush:java;">
DataSourceUtils.releaseConnection(con, ds);    
</pre>
<p>N&oacute;tese que al liberar la conexi&oacute;n no se puede generar una SQLException, al contrario de lo que pasa cuando
cerramos con el <span class="codefrag">close</span> de JDBC, lo que al menos nos ahorra un <span class="codefrag">catch</span>.</p>
</div>

<p class="pageBreakAfter"> 
</p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2012-2013 Depto. Ciencia de la computaci&oacute;n e IA</div>
</div>
<script type="text/javascript">
     
         SyntaxHighlighter.defaults['toolbar'] = false;
         SyntaxHighlighter.autoloader(
  		     'java                   skin/highlight/shBrushJava.js',
  		     'xml xhtml xslt html    skin/highlight/shBrushXml.js',
  		     'js jscript javascript  skin/highlight/shBrushJScript.js',
  		     'groovy                 skin/highlight/shBrushGroovy.js',
  		     'bash shell             skin/highlight/shBrushBash.js',
  		     'php                    skin/highlight/shBrushPhp.js',
  		     'css                    skin/highlight/shBrushCss.js',
  		     'sql                    skin/highlight/shBrushSql.js',
  		     'objc                   skin/highlight/shBrushObjC.js',
  		     'cpp c                  skin/highlight/shBrushCpp.js',
  		     'text plain             skin/highlight/shBrushPlain.js'
         );
         SyntaxHighlighter.all();
     </script><a href="skin/highlight/shBrushJava.js"></a><a href="skin/highlight/shBrushXml.js"></a><a href="skin/highlight/shBrushJScript.js"></a><a href="skin/highlight/shBrushGroovy.js"></a><a href="skin/highlight/shBrushBash.js"></a><a href="skin/highlight/shBrushPhp.js"></a><a href="skin/highlight/shBrushCss.js"></a><a href="skin/highlight/shBrushSql.js"></a><a href="skin/highlight/shBrushObjC.js"></a><a href="skin/highlight/shBrushCpp.js"></a><a href="skin/highlight/shBrushPlain.js"></a>
</body>
</html>
